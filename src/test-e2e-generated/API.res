// SPDX-License-Identifier: MIT
// All API endpoints in API
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



module API = {
    type postAdminAbuseReportNotificationRecipientCreateRequest = {
      isactive: bool,
      name: string,
      @as("method") method_: string,
      userid: option<string>,
      systemwebhookid: option<string>,
    }

    let postAdminAbuseReportNotificationRecipientCreateRequestSchema = S.object(s => {
        isactive: s.field("isActive", S.bool),
        name: s.field("name", S.string->S.min(1)->S.max(255)),
        method_: s.field("method", S.string),
        userid: s.fieldOr("userId", S.nullableAsOption(S.string), None),
        systemwebhookid: s.fieldOr("systemWebhookId", S.nullableAsOption(S.string), None),
      })

    type postAdminAbuseReportNotificationRecipientCreateResponse = ComponentSchemas.Abusereportnotificationrecipient.t

    let postAdminAbuseReportNotificationRecipientCreateResponseSchema = ComponentSchemas.Abusereportnotificationrecipient.schema

    /**
     * admin/abuse-report/notification-recipient/create
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
     */
    let postAdminAbuseReportNotificationRecipientCreate = (~body: postAdminAbuseReportNotificationRecipientCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientCreateRequestSchema)

      fetch(
        ~url="/admin/abuse-report/notification-recipient/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAbuseReportNotificationRecipientDeleteRequest = {
      id: string,
    }

    let postAdminAbuseReportNotificationRecipientDeleteRequestSchema = S.object(s => {
        id: s.field("id", S.string),
      })

    type postAdminAbuseReportNotificationRecipientDeleteResponse = unit

    /**
     * admin/abuse-report/notification-recipient/delete
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
     */
    let postAdminAbuseReportNotificationRecipientDelete = (~body: postAdminAbuseReportNotificationRecipientDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientDeleteRequestSchema)

      fetch(
        ~url="/admin/abuse-report/notification-recipient/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminAbuseReportNotificationRecipientListRequest = {
      @as("method") method_: option<array<string>>,
    }

    let postAdminAbuseReportNotificationRecipientListRequestSchema = S.object(s => {
        method_: s.fieldOr("method", S.nullableAsOption(S.array(S.string)), None),
      })

    type postAdminAbuseReportNotificationRecipientListResponse = array<ComponentSchemas.Abusereportnotificationrecipient.t>

    let postAdminAbuseReportNotificationRecipientListResponseSchema = S.array(ComponentSchemas.Abusereportnotificationrecipient.schema)

    /**
     * admin/abuse-report/notification-recipient/list
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *read:admin:abuse-report:notification-recipient*
     */
    let postAdminAbuseReportNotificationRecipientList = (~body: postAdminAbuseReportNotificationRecipientListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientListRequestSchema)

      fetch(
        ~url="/admin/abuse-report/notification-recipient/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAbuseReportNotificationRecipientShowRequest = {
      id: string,
    }

    let postAdminAbuseReportNotificationRecipientShowRequestSchema = S.object(s => {
        id: s.field("id", S.string),
      })

    type postAdminAbuseReportNotificationRecipientShowResponse = ComponentSchemas.Abusereportnotificationrecipient.t

    let postAdminAbuseReportNotificationRecipientShowResponseSchema = ComponentSchemas.Abusereportnotificationrecipient.schema

    /**
     * admin/abuse-report/notification-recipient/show
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *read:admin:abuse-report:notification-recipient*
     */
    let postAdminAbuseReportNotificationRecipientShow = (~body: postAdminAbuseReportNotificationRecipientShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientShowRequestSchema)

      fetch(
        ~url="/admin/abuse-report/notification-recipient/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAbuseReportNotificationRecipientUpdateRequest = {
      id: string,
      isactive: bool,
      name: string,
      @as("method") method_: string,
      userid: option<string>,
      systemwebhookid: option<string>,
    }

    let postAdminAbuseReportNotificationRecipientUpdateRequestSchema = S.object(s => {
        id: s.field("id", S.string),
        isactive: s.field("isActive", S.bool),
        name: s.field("name", S.string->S.min(1)->S.max(255)),
        method_: s.field("method", S.string),
        userid: s.fieldOr("userId", S.nullableAsOption(S.string), None),
        systemwebhookid: s.fieldOr("systemWebhookId", S.nullableAsOption(S.string), None),
      })

    type postAdminAbuseReportNotificationRecipientUpdateResponse = ComponentSchemas.Abusereportnotificationrecipient.t

    let postAdminAbuseReportNotificationRecipientUpdateResponseSchema = ComponentSchemas.Abusereportnotificationrecipient.schema

    /**
     * admin/abuse-report/notification-recipient/update
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
     */
    let postAdminAbuseReportNotificationRecipientUpdate = (~body: postAdminAbuseReportNotificationRecipientUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientUpdateRequestSchema)

      fetch(
        ~url="/admin/abuse-report/notification-recipient/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAbuseUserReportsRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      state: option<JSON.t>,
      reporterorigin: option<string>,
      targetuserorigin: option<string>,
    }

    let postAdminAbuseUserReportsRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        state: s.fieldOr("state", S.nullableAsOption(S.json), None),
        reporterorigin: s.fieldOr("reporterOrigin", S.nullableAsOption(S.string), None),
        targetuserorigin: s.fieldOr("targetUserOrigin", S.nullableAsOption(S.string), None),
      })

    type postAdminAbuseUserReportsResponse = array<JSON.t>

    let postAdminAbuseUserReportsResponseSchema = S.array(S.json)

    /**
     * admin/abuse-user-reports
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:abuse-user-reports*
     */
    let postAdminAbuseUserReports = (~body: postAdminAbuseUserReportsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseUserReportsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseUserReportsRequestSchema)

      fetch(
        ~url="/admin/abuse-user-reports",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAbuseUserReportsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAccountsCreateRequest = {
      username: string,
      password: string,
      setuppassword: option<JSON.t>,
    }

    let postAdminAccountsCreateRequestSchema = S.object(s => {
        username: s.field("username", S.string->S.pattern(%re("/^\\w{1,20}$/"))),
        password: s.field("password", S.string->S.min(1)),
        setuppassword: s.fieldOr("setupPassword", S.nullableAsOption(S.json), None),
      })

    type postAdminAccountsCreateResponse = JSON.t

    let postAdminAccountsCreateResponseSchema = S.json

    /**
     * admin/accounts/create
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postAdminAccountsCreate = (~body: postAdminAccountsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAccountsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsCreateRequestSchema)

      fetch(
        ~url="/admin/accounts/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAccountsCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAccountsDeleteRequest = {
      userid: string,
    }

    let postAdminAccountsDeleteRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postAdminAccountsDeleteResponse = unit

    /**
     * admin/accounts/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:account*
     */
    let postAdminAccountsDelete = (~body: postAdminAccountsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAccountsDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsDeleteRequestSchema)

      fetch(
        ~url="/admin/accounts/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminAccountsFindByEmailRequest = {
      email: string,
    }

    let postAdminAccountsFindByEmailRequestSchema = S.object(s => {
        email: s.field("email", S.string),
      })

    type postAdminAccountsFindByEmailResponse = ComponentSchemas.Userdetailednotme.t

    let postAdminAccountsFindByEmailResponseSchema = ComponentSchemas.Userdetailednotme.schema

    /**
     * admin/accounts/find-by-email
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:account*
     */
    let postAdminAccountsFindByEmail = (~body: postAdminAccountsFindByEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAccountsFindByEmailResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsFindByEmailRequestSchema)

      fetch(
        ~url="/admin/accounts/find-by-email",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAccountsFindByEmailResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAdCreateRequest = {
      url: string,
      memo: string,
      place: string,
      priority: string,
      ratio: int,
      expiresat: int,
      startsat: int,
      imageurl: string,
      dayofweek: int,
      issensitive: option<bool>,
    }

    let postAdminAdCreateRequestSchema = S.object(s => {
        url: s.field("url", S.string->S.min(1)),
        memo: s.field("memo", S.string),
        place: s.field("place", S.string),
        priority: s.field("priority", S.string),
        ratio: s.field("ratio", S.int),
        expiresat: s.field("expiresAt", S.int),
        startsat: s.field("startsAt", S.int),
        imageurl: s.field("imageUrl", S.string->S.min(1)),
        dayofweek: s.field("dayOfWeek", S.int),
        issensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
      })

    type postAdminAdCreateResponse = ComponentSchemas.Ad.t

    let postAdminAdCreateResponseSchema = ComponentSchemas.Ad.schema

    /**
     * admin/ad/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:ad*
     */
    let postAdminAdCreate = (~body: postAdminAdCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAdCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdCreateRequestSchema)

      fetch(
        ~url="/admin/ad/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAdCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAdDeleteRequest = {
      id: string,
    }

    let postAdminAdDeleteRequestSchema = S.object(s => {
        id: s.field("id", S.string),
      })

    type postAdminAdDeleteResponse = unit

    /**
     * admin/ad/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:ad*
     */
    let postAdminAdDelete = (~body: postAdminAdDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAdDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdDeleteRequestSchema)

      fetch(
        ~url="/admin/ad/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminAdListRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      publishing: option<JSON.t>,
    }

    let postAdminAdListRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        publishing: s.fieldOr("publishing", S.nullableAsOption(S.json), None),
      })

    type postAdminAdListResponse = array<ComponentSchemas.Ad.t>

    let postAdminAdListResponseSchema = S.array(ComponentSchemas.Ad.schema)

    /**
     * admin/ad/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:ad*
     */
    let postAdminAdList = (~body: postAdminAdListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAdListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdListRequestSchema)

      fetch(
        ~url="/admin/ad/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAdListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAdUpdateRequest = {
      id: string,
      memo: option<string>,
      url: option<string>,
      imageurl: option<string>,
      place: option<string>,
      priority: option<string>,
      ratio: option<int>,
      expiresat: option<int>,
      startsat: option<int>,
      dayofweek: option<int>,
      issensitive: option<bool>,
    }

    let postAdminAdUpdateRequestSchema = S.object(s => {
        id: s.field("id", S.string),
        memo: s.fieldOr("memo", S.nullableAsOption(S.string), None),
        url: s.fieldOr("url", S.nullableAsOption(S.string->S.min(1)), None),
        imageurl: s.fieldOr("imageUrl", S.nullableAsOption(S.string->S.min(1)), None),
        place: s.fieldOr("place", S.nullableAsOption(S.string), None),
        priority: s.fieldOr("priority", S.nullableAsOption(S.string), None),
        ratio: s.fieldOr("ratio", S.nullableAsOption(S.int), None),
        expiresat: s.fieldOr("expiresAt", S.nullableAsOption(S.int), None),
        startsat: s.fieldOr("startsAt", S.nullableAsOption(S.int), None),
        dayofweek: s.fieldOr("dayOfWeek", S.nullableAsOption(S.int), None),
        issensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
      })

    type postAdminAdUpdateResponse = unit

    /**
     * admin/ad/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:ad*
     */
    let postAdminAdUpdate = (~body: postAdminAdUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAdUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdUpdateRequestSchema)

      fetch(
        ~url="/admin/ad/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminAnnouncementsCreateRequest = {
      title: string,
      text: string,
      imageurl: JSON.t,
      icon: option<string>,
      display: option<string>,
      forexistingusers: option<bool>,
      silence: option<bool>,
      needconfirmationtoread: option<bool>,
      userid: option<JSON.t>,
    }

    let postAdminAnnouncementsCreateRequestSchema = S.object(s => {
        title: s.field("title", S.string->S.min(1)),
        text: s.field("text", S.string->S.min(1)),
        imageurl: s.field("imageUrl", S.json),
        icon: s.fieldOr("icon", S.nullableAsOption(S.string), None),
        display: s.fieldOr("display", S.nullableAsOption(S.string), None),
        forexistingusers: s.fieldOr("forExistingUsers", S.nullableAsOption(S.bool), None),
        silence: s.fieldOr("silence", S.nullableAsOption(S.bool), None),
        needconfirmationtoread: s.fieldOr("needConfirmationToRead", S.nullableAsOption(S.bool), None),
        userid: s.fieldOr("userId", S.nullableAsOption(S.json), None),
      })

    type postAdminAnnouncementsCreateResponse = {
      id: string,
      createdat: string,
      updatedat: JSON.t,
      title: string,
      text: string,
      imageurl: JSON.t,
    }

    let postAdminAnnouncementsCreateResponseSchema = S.object(s => {
        id: s.field("id", S.string),
        createdat: s.field("createdAt", S.string),
        updatedat: s.field("updatedAt", S.json),
        title: s.field("title", S.string),
        text: s.field("text", S.string),
        imageurl: s.field("imageUrl", S.json),
      })

    /**
     * admin/announcements/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:announcements*
     */
    let postAdminAnnouncementsCreate = (~body: postAdminAnnouncementsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAnnouncementsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsCreateRequestSchema)

      fetch(
        ~url="/admin/announcements/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAnnouncementsCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAnnouncementsDeleteRequest = {
      id: string,
    }

    let postAdminAnnouncementsDeleteRequestSchema = S.object(s => {
        id: s.field("id", S.string),
      })

    type postAdminAnnouncementsDeleteResponse = unit

    /**
     * admin/announcements/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:announcements*
     */
    let postAdminAnnouncementsDelete = (~body: postAdminAnnouncementsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAnnouncementsDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsDeleteRequestSchema)

      fetch(
        ~url="/admin/announcements/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminAnnouncementsListRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      userid: option<JSON.t>,
      status: option<string>,
    }

    let postAdminAnnouncementsListRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        userid: s.fieldOr("userId", S.nullableAsOption(S.json), None),
        status: s.fieldOr("status", S.nullableAsOption(S.string), None),
      })

    type postAdminAnnouncementsListResponse = array<JSON.t>

    let postAdminAnnouncementsListResponseSchema = S.array(S.json)

    /**
     * admin/announcements/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:announcements*
     */
    let postAdminAnnouncementsList = (~body: postAdminAnnouncementsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAnnouncementsListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsListRequestSchema)

      fetch(
        ~url="/admin/announcements/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAnnouncementsListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAnnouncementsUpdateRequest = {
      id: string,
      title: option<string>,
      text: option<string>,
      imageurl: option<JSON.t>,
      icon: option<string>,
      display: option<string>,
      forexistingusers: option<bool>,
      silence: option<bool>,
      needconfirmationtoread: option<bool>,
      isactive: option<bool>,
    }

    let postAdminAnnouncementsUpdateRequestSchema = S.object(s => {
        id: s.field("id", S.string),
        title: s.fieldOr("title", S.nullableAsOption(S.string->S.min(1)), None),
        text: s.fieldOr("text", S.nullableAsOption(S.string->S.min(1)), None),
        imageurl: s.fieldOr("imageUrl", S.nullableAsOption(S.json), None),
        icon: s.fieldOr("icon", S.nullableAsOption(S.string), None),
        display: s.fieldOr("display", S.nullableAsOption(S.string), None),
        forexistingusers: s.fieldOr("forExistingUsers", S.nullableAsOption(S.bool), None),
        silence: s.fieldOr("silence", S.nullableAsOption(S.bool), None),
        needconfirmationtoread: s.fieldOr("needConfirmationToRead", S.nullableAsOption(S.bool), None),
        isactive: s.fieldOr("isActive", S.nullableAsOption(S.bool), None),
      })

    type postAdminAnnouncementsUpdateResponse = unit

    /**
     * admin/announcements/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:announcements*
     */
    let postAdminAnnouncementsUpdate = (~body: postAdminAnnouncementsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAnnouncementsUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsUpdateRequestSchema)

      fetch(
        ~url="/admin/announcements/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminAvatarDecorationsCreateRequest = {
      name: string,
      description: string,
      url: string,
      roleidsthatcanbeusedthisdecoration: option<array<string>>,
    }

    let postAdminAvatarDecorationsCreateRequestSchema = S.object(s => {
        name: s.field("name", S.string->S.min(1)),
        description: s.field("description", S.string),
        url: s.field("url", S.string->S.min(1)),
        roleidsthatcanbeusedthisdecoration: s.fieldOr("roleIdsThatCanBeUsedThisDecoration", S.nullableAsOption(S.array(S.string)), None),
      })

    type postAdminAvatarDecorationsCreateResponse = {
      id: string,
      createdat: string,
      updatedat: JSON.t,
      name: string,
      description: string,
      url: string,
      roleidsthatcanbeusedthisdecoration: array<string>,
    }

    let postAdminAvatarDecorationsCreateResponseSchema = S.object(s => {
        id: s.field("id", S.string),
        createdat: s.field("createdAt", S.string),
        updatedat: s.field("updatedAt", S.json),
        name: s.field("name", S.string),
        description: s.field("description", S.string),
        url: s.field("url", S.string),
        roleidsthatcanbeusedthisdecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.array(S.string)),
      })

    /**
     * admin/avatar-decorations/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:avatar-decorations*
     */
    let postAdminAvatarDecorationsCreate = (~body: postAdminAvatarDecorationsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAvatarDecorationsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsCreateRequestSchema)

      fetch(
        ~url="/admin/avatar-decorations/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAvatarDecorationsCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAvatarDecorationsDeleteRequest = {
      id: string,
    }

    let postAdminAvatarDecorationsDeleteRequestSchema = S.object(s => {
        id: s.field("id", S.string),
      })

    type postAdminAvatarDecorationsDeleteResponse = unit

    /**
     * admin/avatar-decorations/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:avatar-decorations*
     */
    let postAdminAvatarDecorationsDelete = (~body: postAdminAvatarDecorationsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAvatarDecorationsDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsDeleteRequestSchema)

      fetch(
        ~url="/admin/avatar-decorations/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminAvatarDecorationsListRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      userid: option<JSON.t>,
    }

    let postAdminAvatarDecorationsListRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        userid: s.fieldOr("userId", S.nullableAsOption(S.json), None),
      })

    type postAdminAvatarDecorationsListResponse = array<JSON.t>

    let postAdminAvatarDecorationsListResponseSchema = S.array(S.json)

    /**
     * admin/avatar-decorations/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:avatar-decorations*
     */
    let postAdminAvatarDecorationsList = (~body: postAdminAvatarDecorationsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAvatarDecorationsListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsListRequestSchema)

      fetch(
        ~url="/admin/avatar-decorations/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminAvatarDecorationsListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminAvatarDecorationsUpdateRequest = {
      id: string,
      name: option<string>,
      description: option<string>,
      url: option<string>,
      roleidsthatcanbeusedthisdecoration: option<array<string>>,
    }

    let postAdminAvatarDecorationsUpdateRequestSchema = S.object(s => {
        id: s.field("id", S.string),
        name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)), None),
        description: s.fieldOr("description", S.nullableAsOption(S.string), None),
        url: s.fieldOr("url", S.nullableAsOption(S.string->S.min(1)), None),
        roleidsthatcanbeusedthisdecoration: s.fieldOr("roleIdsThatCanBeUsedThisDecoration", S.nullableAsOption(S.array(S.string)), None),
      })

    type postAdminAvatarDecorationsUpdateResponse = unit

    /**
     * admin/avatar-decorations/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:avatar-decorations*
     */
    let postAdminAvatarDecorationsUpdate = (~body: postAdminAvatarDecorationsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAvatarDecorationsUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsUpdateRequestSchema)

      fetch(
        ~url="/admin/avatar-decorations/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminCaptchaCurrentResponse = {
      provider: string,
      hcaptcha: JSON.t,
      mcaptcha: JSON.t,
      recaptcha: JSON.t,
      turnstile: JSON.t,
    }

    let postAdminCaptchaCurrentResponseSchema = S.object(s => {
        provider: s.field("provider", S.string),
        hcaptcha: s.field("hcaptcha", S.json),
        mcaptcha: s.field("mcaptcha", S.json),
        recaptcha: s.field("recaptcha", S.json),
        turnstile: s.field("turnstile", S.json),
      })

    /**
     * admin/captcha/current
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:meta*
     */
    let postAdminCaptchaCurrent = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminCaptchaCurrentResponse> => {

      fetch(
        ~url="/admin/captcha/current",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminCaptchaCurrentResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminCaptchaSaveRequest = {
      provider: string,
      captcharesult: option<JSON.t>,
      sitekey: option<JSON.t>,
      secret: option<JSON.t>,
      instanceurl: option<JSON.t>,
    }

    let postAdminCaptchaSaveRequestSchema = S.object(s => {
        provider: s.field("provider", S.string),
        captcharesult: s.fieldOr("captchaResult", S.nullableAsOption(S.json), None),
        sitekey: s.fieldOr("sitekey", S.nullableAsOption(S.json), None),
        secret: s.fieldOr("secret", S.nullableAsOption(S.json), None),
        instanceurl: s.fieldOr("instanceUrl", S.nullableAsOption(S.json), None),
      })

    type postAdminCaptchaSaveResponse = unit

    /**
     * admin/captcha/save
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:meta*
     */
    let postAdminCaptchaSave = (~body: postAdminCaptchaSaveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminCaptchaSaveResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminCaptchaSaveRequestSchema)

      fetch(
        ~url="/admin/captcha/save",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminDeleteAccountRequest = {
      userid: string,
    }

    let postAdminDeleteAccountRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postAdminDeleteAccountResponse = unit

    /**
     * admin/delete-account
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:delete-account*
     */
    let postAdminDeleteAccount = (~body: postAdminDeleteAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDeleteAccountResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDeleteAccountRequestSchema)

      fetch(
        ~url="/admin/delete-account",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminDeleteAllFilesOfAUserRequest = {
      userid: string,
    }

    let postAdminDeleteAllFilesOfAUserRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postAdminDeleteAllFilesOfAUserResponse = unit

    /**
     * admin/delete-all-files-of-a-user
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:delete-all-files-of-a-user*
     */
    let postAdminDeleteAllFilesOfAUser = (~body: postAdminDeleteAllFilesOfAUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDeleteAllFilesOfAUserResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDeleteAllFilesOfAUserRequestSchema)

      fetch(
        ~url="/admin/delete-all-files-of-a-user",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminDriveCleanRemoteFilesResponse = unit

    /**
     * admin/drive/clean-remote-files
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:drive*
     */
    let postAdminDriveCleanRemoteFiles = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDriveCleanRemoteFilesResponse> => {

      fetch(
        ~url="/admin/drive/clean-remote-files",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminDriveCleanupResponse = unit

    /**
     * admin/drive/cleanup
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:drive*
     */
    let postAdminDriveCleanup = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDriveCleanupResponse> => {

      fetch(
        ~url="/admin/drive/cleanup",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminDriveFilesRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      userid: option<JSON.t>,
      @as("type") type_: option<JSON.t>,
      origin: option<string>,
      hostname: option<JSON.t>,
    }

    let postAdminDriveFilesRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        userid: s.fieldOr("userId", S.nullableAsOption(S.json), None),
        type_: s.fieldOr("type", S.nullableAsOption(S.json), None),
        origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
        hostname: s.fieldOr("hostname", S.nullableAsOption(S.json), None),
      })

    type postAdminDriveFilesResponse = array<ComponentSchemas.Drivefile.t>

    let postAdminDriveFilesResponseSchema = S.array(ComponentSchemas.Drivefile.schema)

    /**
     * admin/drive/files
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:drive*
     */
    let postAdminDriveFiles = (~body: postAdminDriveFilesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDriveFilesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveFilesRequestSchema)

      fetch(
        ~url="/admin/drive/files",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminDriveFilesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminDriveShowFileRequest = JSON.t

    let postAdminDriveShowFileRequestSchema = S.json

    type postAdminDriveShowFileResponse = {
      id: string,
      createdat: string,
      userid: JSON.t,
      userhost: JSON.t,
      md5: string,
      name: string,
      @as("type") type_: string,
      size: float,
      comment: JSON.t,
      blurhash: JSON.t,
      properties: JSON.t,
      storedinternal: JSON.t,
      url: JSON.t,
      thumbnailurl: JSON.t,
      webpublicurl: JSON.t,
      accesskey: JSON.t,
      thumbnailaccesskey: JSON.t,
      webpublicaccesskey: JSON.t,
      uri: JSON.t,
      src: JSON.t,
      folderid: JSON.t,
      issensitive: bool,
      islink: bool,
      maybesensitive: bool,
      maybeporn: bool,
      requestip: JSON.t,
      requestheaders: JSON.t,
    }

    let postAdminDriveShowFileResponseSchema = S.object(s => {
        id: s.field("id", S.string),
        createdat: s.field("createdAt", S.string),
        userid: s.field("userId", S.json),
        userhost: s.field("userHost", S.json),
        md5: s.field("md5", S.string),
        name: s.field("name", S.string),
        type_: s.field("type", S.string),
        size: s.field("size", S.float),
        comment: s.field("comment", S.json),
        blurhash: s.field("blurhash", S.json),
        properties: s.field("properties", S.json),
        storedinternal: s.field("storedInternal", S.json),
        url: s.field("url", S.json),
        thumbnailurl: s.field("thumbnailUrl", S.json),
        webpublicurl: s.field("webpublicUrl", S.json),
        accesskey: s.field("accessKey", S.json),
        thumbnailaccesskey: s.field("thumbnailAccessKey", S.json),
        webpublicaccesskey: s.field("webpublicAccessKey", S.json),
        uri: s.field("uri", S.json),
        src: s.field("src", S.json),
        folderid: s.field("folderId", S.json),
        issensitive: s.field("isSensitive", S.bool),
        islink: s.field("isLink", S.bool),
        maybesensitive: s.field("maybeSensitive", S.bool),
        maybeporn: s.field("maybePorn", S.bool),
        requestip: s.field("requestIp", S.json),
        requestheaders: s.field("requestHeaders", S.json),
      })

    /**
     * admin/drive/show-file
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:drive*
     */
    let postAdminDriveShowFile = (~body: postAdminDriveShowFileRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDriveShowFileResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveShowFileRequestSchema)

      fetch(
        ~url="/admin/drive/show-file",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminDriveShowFileResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminEmojiAddRequest = {
      name: string,
      fileid: string,
      category: option<JSON.t>,
      aliases: option<array<string>>,
      license: option<JSON.t>,
      issensitive: option<bool>,
      localonly: option<bool>,
      roleidsthatcanbeusedthisemojiasreaction: option<array<string>>,
    }

    let postAdminEmojiAddRequestSchema = S.object(s => {
        name: s.field("name", S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/"))),
        fileid: s.field("fileId", S.string),
        category: s.fieldOr("category", S.nullableAsOption(S.json), None),
        aliases: s.fieldOr("aliases", S.nullableAsOption(S.array(S.string)), None),
        license: s.fieldOr("license", S.nullableAsOption(S.json), None),
        issensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
        localonly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
        roleidsthatcanbeusedthisemojiasreaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
      })

    type postAdminEmojiAddResponse = ComponentSchemas.Emojidetailed.t

    let postAdminEmojiAddResponseSchema = ComponentSchemas.Emojidetailed.schema

    /**
     * admin/emoji/add
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
     */
    let postAdminEmojiAdd = (~body: postAdminEmojiAddRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiAddResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiAddRequestSchema)

      fetch(
        ~url="/admin/emoji/add",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminEmojiAddResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminEmojiAddAliasesBulkRequest = {
      ids: array<string>,
      aliases: array<string>,
    }

    let postAdminEmojiAddAliasesBulkRequestSchema = S.object(s => {
        ids: s.field("ids", S.array(S.string)),
        aliases: s.field("aliases", S.array(S.string)),
      })

    type postAdminEmojiAddAliasesBulkResponse = unit

    /**
     * admin/emoji/add-aliases-bulk
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
     */
    let postAdminEmojiAddAliasesBulk = (~body: postAdminEmojiAddAliasesBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiAddAliasesBulkResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiAddAliasesBulkRequestSchema)

      fetch(
        ~url="/admin/emoji/add-aliases-bulk",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminEmojiCopyRequest = {
      emojiid: string,
    }

    let postAdminEmojiCopyRequestSchema = S.object(s => {
        emojiid: s.field("emojiId", S.string),
      })

    type postAdminEmojiCopyResponse = {
      id: string,
    }

    let postAdminEmojiCopyResponseSchema = S.object(s => {
        id: s.field("id", S.string),
      })

    /**
     * admin/emoji/copy
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
     */
    let postAdminEmojiCopy = (~body: postAdminEmojiCopyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiCopyResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiCopyRequestSchema)

      fetch(
        ~url="/admin/emoji/copy",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminEmojiCopyResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminEmojiDeleteRequest = {
      id: string,
    }

    let postAdminEmojiDeleteRequestSchema = S.object(s => {
        id: s.field("id", S.string),
      })

    type postAdminEmojiDeleteResponse = unit

    /**
     * admin/emoji/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
     */
    let postAdminEmojiDelete = (~body: postAdminEmojiDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiDeleteRequestSchema)

      fetch(
        ~url="/admin/emoji/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminEmojiDeleteBulkRequest = {
      ids: array<string>,
    }

    let postAdminEmojiDeleteBulkRequestSchema = S.object(s => {
        ids: s.field("ids", S.array(S.string)),
      })

    type postAdminEmojiDeleteBulkResponse = unit

    /**
     * admin/emoji/delete-bulk
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
     */
    let postAdminEmojiDeleteBulk = (~body: postAdminEmojiDeleteBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiDeleteBulkResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiDeleteBulkRequestSchema)

      fetch(
        ~url="/admin/emoji/delete-bulk",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminEmojiImportZipRequest = {
      fileid: string,
    }

    let postAdminEmojiImportZipRequestSchema = S.object(s => {
        fileid: s.field("fileId", S.string),
      })

    type postAdminEmojiImportZipResponse = unit

    /**
     * admin/emoji/import-zip
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postAdminEmojiImportZip = (~body: postAdminEmojiImportZipRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiImportZipResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiImportZipRequestSchema)

      fetch(
        ~url="/admin/emoji/import-zip",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminEmojiListRequest = {
      query: option<JSON.t>,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postAdminEmojiListRequestSchema = S.object(s => {
        query: s.fieldOr("query", S.nullableAsOption(S.json), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postAdminEmojiListResponse = array<JSON.t>

    let postAdminEmojiListResponseSchema = S.array(S.json)

    /**
     * admin/emoji/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:emoji*
     */
    let postAdminEmojiList = (~body: postAdminEmojiListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiListRequestSchema)

      fetch(
        ~url="/admin/emoji/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminEmojiListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminEmojiListRemoteRequest = {
      query: option<JSON.t>,
      host: option<JSON.t>,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postAdminEmojiListRemoteRequestSchema = S.object(s => {
        query: s.fieldOr("query", S.nullableAsOption(S.json), None),
        host: s.fieldOr("host", S.nullableAsOption(S.json), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postAdminEmojiListRemoteResponse = array<JSON.t>

    let postAdminEmojiListRemoteResponseSchema = S.array(S.json)

    /**
     * admin/emoji/list-remote
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:emoji*
     */
    let postAdminEmojiListRemote = (~body: postAdminEmojiListRemoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiListRemoteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiListRemoteRequestSchema)

      fetch(
        ~url="/admin/emoji/list-remote",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminEmojiListRemoteResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminEmojiRemoveAliasesBulkRequest = {
      ids: array<string>,
      aliases: array<string>,
    }

    let postAdminEmojiRemoveAliasesBulkRequestSchema = S.object(s => {
        ids: s.field("ids", S.array(S.string)),
        aliases: s.field("aliases", S.array(S.string)),
      })

    type postAdminEmojiRemoveAliasesBulkResponse = unit

    /**
     * admin/emoji/remove-aliases-bulk
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
     */
    let postAdminEmojiRemoveAliasesBulk = (~body: postAdminEmojiRemoveAliasesBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiRemoveAliasesBulkResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiRemoveAliasesBulkRequestSchema)

      fetch(
        ~url="/admin/emoji/remove-aliases-bulk",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminEmojiSetAliasesBulkRequest = {
      ids: array<string>,
      aliases: array<string>,
    }

    let postAdminEmojiSetAliasesBulkRequestSchema = S.object(s => {
        ids: s.field("ids", S.array(S.string)),
        aliases: s.field("aliases", S.array(S.string)),
      })

    type postAdminEmojiSetAliasesBulkResponse = unit

    /**
     * admin/emoji/set-aliases-bulk
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
     */
    let postAdminEmojiSetAliasesBulk = (~body: postAdminEmojiSetAliasesBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiSetAliasesBulkResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiSetAliasesBulkRequestSchema)

      fetch(
        ~url="/admin/emoji/set-aliases-bulk",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminEmojiSetCategoryBulkRequest = {
      ids: array<string>,
      category: option<JSON.t>,
    }

    let postAdminEmojiSetCategoryBulkRequestSchema = S.object(s => {
        ids: s.field("ids", S.array(S.string)),
        category: s.fieldOr("category", S.nullableAsOption(S.json), None),
      })

    type postAdminEmojiSetCategoryBulkResponse = unit

    /**
     * admin/emoji/set-category-bulk
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
     */
    let postAdminEmojiSetCategoryBulk = (~body: postAdminEmojiSetCategoryBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiSetCategoryBulkResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiSetCategoryBulkRequestSchema)

      fetch(
        ~url="/admin/emoji/set-category-bulk",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminEmojiSetLicenseBulkRequest = {
      ids: array<string>,
      license: option<JSON.t>,
    }

    let postAdminEmojiSetLicenseBulkRequestSchema = S.object(s => {
        ids: s.field("ids", S.array(S.string)),
        license: s.fieldOr("license", S.nullableAsOption(S.json), None),
      })

    type postAdminEmojiSetLicenseBulkResponse = unit

    /**
     * admin/emoji/set-license-bulk
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
     */
    let postAdminEmojiSetLicenseBulk = (~body: postAdminEmojiSetLicenseBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiSetLicenseBulkResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiSetLicenseBulkRequestSchema)

      fetch(
        ~url="/admin/emoji/set-license-bulk",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminEmojiUpdateRequest = JSON.t

    let postAdminEmojiUpdateRequestSchema = S.json

    type postAdminEmojiUpdateResponse = unit

    /**
     * admin/emoji/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
     */
    let postAdminEmojiUpdate = (~body: postAdminEmojiUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiUpdateRequestSchema)

      fetch(
        ~url="/admin/emoji/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminFederationDeleteAllFilesRequest = {
      host: string,
    }

    let postAdminFederationDeleteAllFilesRequestSchema = S.object(s => {
        host: s.field("host", S.string),
      })

    type postAdminFederationDeleteAllFilesResponse = unit

    /**
     * admin/federation/delete-all-files
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:federation*
     */
    let postAdminFederationDeleteAllFiles = (~body: postAdminFederationDeleteAllFilesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminFederationDeleteAllFilesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationDeleteAllFilesRequestSchema)

      fetch(
        ~url="/admin/federation/delete-all-files",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminFederationRefreshRemoteInstanceMetadataRequest = {
      host: string,
    }

    let postAdminFederationRefreshRemoteInstanceMetadataRequestSchema = S.object(s => {
        host: s.field("host", S.string),
      })

    type postAdminFederationRefreshRemoteInstanceMetadataResponse = unit

    /**
     * admin/federation/refresh-remote-instance-metadata
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:federation*
     */
    let postAdminFederationRefreshRemoteInstanceMetadata = (~body: postAdminFederationRefreshRemoteInstanceMetadataRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminFederationRefreshRemoteInstanceMetadataResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationRefreshRemoteInstanceMetadataRequestSchema)

      fetch(
        ~url="/admin/federation/refresh-remote-instance-metadata",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminFederationRemoveAllFollowingRequest = {
      host: string,
    }

    let postAdminFederationRemoveAllFollowingRequestSchema = S.object(s => {
        host: s.field("host", S.string),
      })

    type postAdminFederationRemoveAllFollowingResponse = unit

    /**
     * admin/federation/remove-all-following
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:federation*
     */
    let postAdminFederationRemoveAllFollowing = (~body: postAdminFederationRemoveAllFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminFederationRemoveAllFollowingResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationRemoveAllFollowingRequestSchema)

      fetch(
        ~url="/admin/federation/remove-all-following",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminFederationUpdateInstanceRequest = {
      host: string,
      issuspended: option<bool>,
      moderationnote: option<string>,
    }

    let postAdminFederationUpdateInstanceRequestSchema = S.object(s => {
        host: s.field("host", S.string),
        issuspended: s.fieldOr("isSuspended", S.nullableAsOption(S.bool), None),
        moderationnote: s.fieldOr("moderationNote", S.nullableAsOption(S.string), None),
      })

    type postAdminFederationUpdateInstanceResponse = unit

    /**
     * admin/federation/update-instance
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:federation*
     */
    let postAdminFederationUpdateInstance = (~body: postAdminFederationUpdateInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminFederationUpdateInstanceResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationUpdateInstanceRequestSchema)

      fetch(
        ~url="/admin/federation/update-instance",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminForwardAbuseUserReportRequest = {
      reportid: string,
    }

    let postAdminForwardAbuseUserReportRequestSchema = S.object(s => {
        reportid: s.field("reportId", S.string),
      })

    type postAdminForwardAbuseUserReportResponse = unit

    /**
     * admin/forward-abuse-user-report
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:resolve-abuse-user-report*
     */
    let postAdminForwardAbuseUserReport = (~body: postAdminForwardAbuseUserReportRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminForwardAbuseUserReportResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminForwardAbuseUserReportRequestSchema)

      fetch(
        ~url="/admin/forward-abuse-user-report",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminGetIndexStatsResponse = array<JSON.t>

    let postAdminGetIndexStatsResponseSchema = S.array(S.json)

    /**
     * admin/get-index-stats
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:index-stats*
     */
    let postAdminGetIndexStats = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminGetIndexStatsResponse> => {

      fetch(
        ~url="/admin/get-index-stats",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminGetIndexStatsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminGetTableStatsResponse = JSON.t

    let postAdminGetTableStatsResponseSchema = S.json

    /**
     * admin/get-table-stats
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:table-stats*
     */
    let postAdminGetTableStats = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminGetTableStatsResponse> => {

      fetch(
        ~url="/admin/get-table-stats",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminGetTableStatsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminGetUserIpsRequest = {
      userid: string,
    }

    let postAdminGetUserIpsRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postAdminGetUserIpsResponse = array<JSON.t>

    let postAdminGetUserIpsResponseSchema = S.array(S.json)

    /**
     * admin/get-user-ips
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:user-ips*
     */
    let postAdminGetUserIps = (~body: postAdminGetUserIpsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminGetUserIpsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminGetUserIpsRequestSchema)

      fetch(
        ~url="/admin/get-user-ips",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminGetUserIpsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminInviteCreateRequest = {
      count: option<int>,
      expiresat: option<JSON.t>,
    }

    let postAdminInviteCreateRequestSchema = S.object(s => {
        count: s.fieldOr("count", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        expiresat: s.fieldOr("expiresAt", S.nullableAsOption(S.json), None),
      })

    type postAdminInviteCreateResponse = array<ComponentSchemas.Invitecode.t>

    let postAdminInviteCreateResponseSchema = S.array(ComponentSchemas.Invitecode.schema)

    /**
     * admin/invite/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:invite-codes*
     */
    let postAdminInviteCreate = (~body: postAdminInviteCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminInviteCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminInviteCreateRequestSchema)

      fetch(
        ~url="/admin/invite/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminInviteCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminInviteListRequest = {
      limit: option<int>,
      offset: option<int>,
      @as("type") type_: option<string>,
      sort: option<string>,
    }

    let postAdminInviteListRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
        type_: s.fieldOr("type", S.nullableAsOption(S.string), None),
        sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
      })

    type postAdminInviteListResponse = array<ComponentSchemas.Invitecode.t>

    let postAdminInviteListResponseSchema = S.array(ComponentSchemas.Invitecode.schema)

    /**
     * admin/invite/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:invite-codes*
     */
    let postAdminInviteList = (~body: postAdminInviteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminInviteListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminInviteListRequestSchema)

      fetch(
        ~url="/admin/invite/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminInviteListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminMetaResponse = {
      cacheremotefiles: bool,
      cacheremotesensitivefiles: bool,
      emailrequiredforsignup: bool,
      enablehcaptcha: bool,
      hcaptchasitekey: JSON.t,
      enablemcaptcha: bool,
      mcaptchasitekey: JSON.t,
      mcaptchainstanceurl: JSON.t,
      enablerecaptcha: bool,
      recaptchasitekey: JSON.t,
      enableturnstile: bool,
      turnstilesitekey: JSON.t,
      enabletestcaptcha: bool,
      googleanalyticsmeasurementid: JSON.t,
      swpublickey: JSON.t,
      mascotimageurl: JSON.t,
      bannerurl: JSON.t,
      servererrorimageurl: JSON.t,
      infoimageurl: JSON.t,
      notfoundimageurl: JSON.t,
      iconurl: JSON.t,
      app192iconurl: JSON.t,
      app512iconurl: JSON.t,
      enableemail: bool,
      enableserviceworker: bool,
      translatoravailable: bool,
      silencedhosts: option<array<string>>,
      mediasilencedhosts: array<string>,
      pinnedusers: array<string>,
      hiddentags: array<string>,
      blockedhosts: array<string>,
      sensitivewords: array<string>,
      prohibitedwords: array<string>,
      prohibitedwordsfornameofuser: array<string>,
      bannedemaildomains: option<array<string>>,
      preservedusernames: array<string>,
      hcaptchasecretkey: JSON.t,
      mcaptchasecretkey: JSON.t,
      recaptchasecretkey: JSON.t,
      turnstilesecretkey: JSON.t,
      sensitivemediadetection: string,
      sensitivemediadetectionsensitivity: string,
      setsensitiveflagautomatically: bool,
      enablesensitivemediadetectionforvideos: bool,
      proxyaccountid: string,
      email: JSON.t,
      smtpsecure: bool,
      smtphost: JSON.t,
      smtpport: JSON.t,
      smtpuser: JSON.t,
      smtppass: JSON.t,
      swprivatekey: JSON.t,
      useobjectstorage: bool,
      objectstoragebaseurl: JSON.t,
      objectstoragebucket: JSON.t,
      objectstorageprefix: JSON.t,
      objectstorageendpoint: JSON.t,
      objectstorageregion: JSON.t,
      objectstorageport: JSON.t,
      objectstorageaccesskey: JSON.t,
      objectstoragesecretkey: JSON.t,
      objectstorageusessl: bool,
      objectstorageuseproxy: bool,
      objectstoragesetpublicread: bool,
      enableiplogging: bool,
      enableactiveemailvalidation: bool,
      enableverifymailapi: bool,
      verifymailauthkey: JSON.t,
      enabletruemailapi: bool,
      truemailinstance: JSON.t,
      truemailauthkey: JSON.t,
      enablechartsforremoteuser: bool,
      enablechartsforfederatedinstances: bool,
      enablestatsforfederatedinstances: bool,
      enableservermachinestats: bool,
      enableidenticongeneration: bool,
      manifestjsonoverride: string,
      policies: JSON.t,
      enablefanouttimeline: bool,
      enablefanouttimelinedbfallback: bool,
      perlocaluserusertimelinecachemax: float,
      perremoteuserusertimelinecachemax: float,
      peruserhometimelinecachemax: float,
      peruserlisttimelinecachemax: float,
      enablereactionsbuffering: bool,
      notesperonead: float,
      backgroundimageurl: JSON.t,
      deeplauthkey: JSON.t,
      deeplispro: bool,
      defaultdarktheme: JSON.t,
      defaultlighttheme: JSON.t,
      clientoptions: JSON.t,
      description: JSON.t,
      disableregistration: bool,
      impressumurl: JSON.t,
      maintaineremail: JSON.t,
      maintainername: JSON.t,
      name: JSON.t,
      shortname: JSON.t,
      objectstorages3forcepathstyle: bool,
      privacypolicyurl: JSON.t,
      inquiryurl: JSON.t,
      repositoryurl: JSON.t,
      feedbackurl: JSON.t,
      summalyproxy: JSON.t,
      themecolor: JSON.t,
      tosurl: JSON.t,
      uri: string,
      version: string,
      urlpreviewenabled: bool,
      urlpreviewallowredirect: bool,
      urlpreviewtimeout: float,
      urlpreviewmaximumcontentlength: float,
      urlpreviewrequirecontentlength: bool,
      urlpreviewuseragent: JSON.t,
      urlpreviewsummaryproxyurl: JSON.t,
      federation: string,
      federationhosts: array<string>,
      deliversuspendedsoftware: array<JSON.t>,
      singleusermode: bool,
      ugcvisibilityforvisitor: string,
      proxyremotefiles: bool,
      signtoactivitypubget: bool,
      allowexternalapredirect: bool,
      enableremotenotescleaning: bool,
      remotenotescleaningexpirydaysforeachnotes: float,
      remotenotescleaningmaxprocessingdurationinminutes: float,
      showrolebadgesofremoteusers: bool,
    }

    let postAdminMetaResponseSchema = S.object(s => {
        cacheremotefiles: s.field("cacheRemoteFiles", S.bool),
        cacheremotesensitivefiles: s.field("cacheRemoteSensitiveFiles", S.bool),
        emailrequiredforsignup: s.field("emailRequiredForSignup", S.bool),
        enablehcaptcha: s.field("enableHcaptcha", S.bool),
        hcaptchasitekey: s.field("hcaptchaSiteKey", S.json),
        enablemcaptcha: s.field("enableMcaptcha", S.bool),
        mcaptchasitekey: s.field("mcaptchaSiteKey", S.json),
        mcaptchainstanceurl: s.field("mcaptchaInstanceUrl", S.json),
        enablerecaptcha: s.field("enableRecaptcha", S.bool),
        recaptchasitekey: s.field("recaptchaSiteKey", S.json),
        enableturnstile: s.field("enableTurnstile", S.bool),
        turnstilesitekey: s.field("turnstileSiteKey", S.json),
        enabletestcaptcha: s.field("enableTestcaptcha", S.bool),
        googleanalyticsmeasurementid: s.field("googleAnalyticsMeasurementId", S.json),
        swpublickey: s.field("swPublickey", S.json),
        mascotimageurl: s.field("mascotImageUrl", S.json),
        bannerurl: s.field("bannerUrl", S.json),
        servererrorimageurl: s.field("serverErrorImageUrl", S.json),
        infoimageurl: s.field("infoImageUrl", S.json),
        notfoundimageurl: s.field("notFoundImageUrl", S.json),
        iconurl: s.field("iconUrl", S.json),
        app192iconurl: s.field("app192IconUrl", S.json),
        app512iconurl: s.field("app512IconUrl", S.json),
        enableemail: s.field("enableEmail", S.bool),
        enableserviceworker: s.field("enableServiceWorker", S.bool),
        translatoravailable: s.field("translatorAvailable", S.bool),
        silencedhosts: s.fieldOr("silencedHosts", S.nullableAsOption(S.array(S.string)), None),
        mediasilencedhosts: s.field("mediaSilencedHosts", S.array(S.string)),
        pinnedusers: s.field("pinnedUsers", S.array(S.string)),
        hiddentags: s.field("hiddenTags", S.array(S.string)),
        blockedhosts: s.field("blockedHosts", S.array(S.string)),
        sensitivewords: s.field("sensitiveWords", S.array(S.string)),
        prohibitedwords: s.field("prohibitedWords", S.array(S.string)),
        prohibitedwordsfornameofuser: s.field("prohibitedWordsForNameOfUser", S.array(S.string)),
        bannedemaildomains: s.fieldOr("bannedEmailDomains", S.nullableAsOption(S.array(S.string)), None),
        preservedusernames: s.field("preservedUsernames", S.array(S.string)),
        hcaptchasecretkey: s.field("hcaptchaSecretKey", S.json),
        mcaptchasecretkey: s.field("mcaptchaSecretKey", S.json),
        recaptchasecretkey: s.field("recaptchaSecretKey", S.json),
        turnstilesecretkey: s.field("turnstileSecretKey", S.json),
        sensitivemediadetection: s.field("sensitiveMediaDetection", S.string),
        sensitivemediadetectionsensitivity: s.field("sensitiveMediaDetectionSensitivity", S.string),
        setsensitiveflagautomatically: s.field("setSensitiveFlagAutomatically", S.bool),
        enablesensitivemediadetectionforvideos: s.field("enableSensitiveMediaDetectionForVideos", S.bool),
        proxyaccountid: s.field("proxyAccountId", S.string),
        email: s.field("email", S.json),
        smtpsecure: s.field("smtpSecure", S.bool),
        smtphost: s.field("smtpHost", S.json),
        smtpport: s.field("smtpPort", S.json),
        smtpuser: s.field("smtpUser", S.json),
        smtppass: s.field("smtpPass", S.json),
        swprivatekey: s.field("swPrivateKey", S.json),
        useobjectstorage: s.field("useObjectStorage", S.bool),
        objectstoragebaseurl: s.field("objectStorageBaseUrl", S.json),
        objectstoragebucket: s.field("objectStorageBucket", S.json),
        objectstorageprefix: s.field("objectStoragePrefix", S.json),
        objectstorageendpoint: s.field("objectStorageEndpoint", S.json),
        objectstorageregion: s.field("objectStorageRegion", S.json),
        objectstorageport: s.field("objectStoragePort", S.json),
        objectstorageaccesskey: s.field("objectStorageAccessKey", S.json),
        objectstoragesecretkey: s.field("objectStorageSecretKey", S.json),
        objectstorageusessl: s.field("objectStorageUseSSL", S.bool),
        objectstorageuseproxy: s.field("objectStorageUseProxy", S.bool),
        objectstoragesetpublicread: s.field("objectStorageSetPublicRead", S.bool),
        enableiplogging: s.field("enableIpLogging", S.bool),
        enableactiveemailvalidation: s.field("enableActiveEmailValidation", S.bool),
        enableverifymailapi: s.field("enableVerifymailApi", S.bool),
        verifymailauthkey: s.field("verifymailAuthKey", S.json),
        enabletruemailapi: s.field("enableTruemailApi", S.bool),
        truemailinstance: s.field("truemailInstance", S.json),
        truemailauthkey: s.field("truemailAuthKey", S.json),
        enablechartsforremoteuser: s.field("enableChartsForRemoteUser", S.bool),
        enablechartsforfederatedinstances: s.field("enableChartsForFederatedInstances", S.bool),
        enablestatsforfederatedinstances: s.field("enableStatsForFederatedInstances", S.bool),
        enableservermachinestats: s.field("enableServerMachineStats", S.bool),
        enableidenticongeneration: s.field("enableIdenticonGeneration", S.bool),
        manifestjsonoverride: s.field("manifestJsonOverride", S.string),
        policies: s.field("policies", S.json),
        enablefanouttimeline: s.field("enableFanoutTimeline", S.bool),
        enablefanouttimelinedbfallback: s.field("enableFanoutTimelineDbFallback", S.bool),
        perlocaluserusertimelinecachemax: s.field("perLocalUserUserTimelineCacheMax", S.float),
        perremoteuserusertimelinecachemax: s.field("perRemoteUserUserTimelineCacheMax", S.float),
        peruserhometimelinecachemax: s.field("perUserHomeTimelineCacheMax", S.float),
        peruserlisttimelinecachemax: s.field("perUserListTimelineCacheMax", S.float),
        enablereactionsbuffering: s.field("enableReactionsBuffering", S.bool),
        notesperonead: s.field("notesPerOneAd", S.float),
        backgroundimageurl: s.field("backgroundImageUrl", S.json),
        deeplauthkey: s.field("deeplAuthKey", S.json),
        deeplispro: s.field("deeplIsPro", S.bool),
        defaultdarktheme: s.field("defaultDarkTheme", S.json),
        defaultlighttheme: s.field("defaultLightTheme", S.json),
        clientoptions: s.field("clientOptions", S.json),
        description: s.field("description", S.json),
        disableregistration: s.field("disableRegistration", S.bool),
        impressumurl: s.field("impressumUrl", S.json),
        maintaineremail: s.field("maintainerEmail", S.json),
        maintainername: s.field("maintainerName", S.json),
        name: s.field("name", S.json),
        shortname: s.field("shortName", S.json),
        objectstorages3forcepathstyle: s.field("objectStorageS3ForcePathStyle", S.bool),
        privacypolicyurl: s.field("privacyPolicyUrl", S.json),
        inquiryurl: s.field("inquiryUrl", S.json),
        repositoryurl: s.field("repositoryUrl", S.json),
        feedbackurl: s.field("feedbackUrl", S.json),
        summalyproxy: s.field("summalyProxy", S.json),
        themecolor: s.field("themeColor", S.json),
        tosurl: s.field("tosUrl", S.json),
        uri: s.field("uri", S.string),
        version: s.field("version", S.string),
        urlpreviewenabled: s.field("urlPreviewEnabled", S.bool),
        urlpreviewallowredirect: s.field("urlPreviewAllowRedirect", S.bool),
        urlpreviewtimeout: s.field("urlPreviewTimeout", S.float),
        urlpreviewmaximumcontentlength: s.field("urlPreviewMaximumContentLength", S.float),
        urlpreviewrequirecontentlength: s.field("urlPreviewRequireContentLength", S.bool),
        urlpreviewuseragent: s.field("urlPreviewUserAgent", S.json),
        urlpreviewsummaryproxyurl: s.field("urlPreviewSummaryProxyUrl", S.json),
        federation: s.field("federation", S.string),
        federationhosts: s.field("federationHosts", S.array(S.string)),
        deliversuspendedsoftware: s.field("deliverSuspendedSoftware", S.array(S.json)),
        singleusermode: s.field("singleUserMode", S.bool),
        ugcvisibilityforvisitor: s.field("ugcVisibilityForVisitor", S.string),
        proxyremotefiles: s.field("proxyRemoteFiles", S.bool),
        signtoactivitypubget: s.field("signToActivityPubGet", S.bool),
        allowexternalapredirect: s.field("allowExternalApRedirect", S.bool),
        enableremotenotescleaning: s.field("enableRemoteNotesCleaning", S.bool),
        remotenotescleaningexpirydaysforeachnotes: s.field("remoteNotesCleaningExpiryDaysForEachNotes", S.float),
        remotenotescleaningmaxprocessingdurationinminutes: s.field("remoteNotesCleaningMaxProcessingDurationInMinutes", S.float),
        showrolebadgesofremoteusers: s.field("showRoleBadgesOfRemoteUsers", S.bool),
      })

    /**
     * admin/meta
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:meta*
     */
    let postAdminMeta = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminMetaResponse> => {

      fetch(
        ~url="/admin/meta",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminMetaResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminPromoCreateRequest = {
      noteid: string,
      expiresat: int,
    }

    let postAdminPromoCreateRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
        expiresat: s.field("expiresAt", S.int),
      })

    type postAdminPromoCreateResponse = unit

    /**
     * admin/promo/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:promo*
     */
    let postAdminPromoCreate = (~body: postAdminPromoCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminPromoCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminPromoCreateRequestSchema)

      fetch(
        ~url="/admin/promo/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminQueueClearRequest = {
      queue: string,
      state: string,
    }

    let postAdminQueueClearRequestSchema = S.object(s => {
        queue: s.field("queue", S.string),
        state: s.field("state", S.string),
      })

    type postAdminQueueClearResponse = unit

    /**
     * admin/queue/clear
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:queue*
     */
    let postAdminQueueClear = (~body: postAdminQueueClearRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueClearResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueClearRequestSchema)

      fetch(
        ~url="/admin/queue/clear",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminQueueDeliverDelayedResponse = array<array<JSON.t>>

    let postAdminQueueDeliverDelayedResponseSchema = S.array(S.array(S.json))

    /**
     * admin/queue/deliver-delayed
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
     */
    let postAdminQueueDeliverDelayed = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueDeliverDelayedResponse> => {

      fetch(
        ~url="/admin/queue/deliver-delayed",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminQueueDeliverDelayedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminQueueInboxDelayedResponse = array<array<JSON.t>>

    let postAdminQueueInboxDelayedResponseSchema = S.array(S.array(S.json))

    /**
     * admin/queue/inbox-delayed
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
     */
    let postAdminQueueInboxDelayed = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueInboxDelayedResponse> => {

      fetch(
        ~url="/admin/queue/inbox-delayed",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminQueueInboxDelayedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminQueueJobsRequest = {
      queue: string,
      state: array<string>,
      search: option<string>,
    }

    let postAdminQueueJobsRequestSchema = S.object(s => {
        queue: s.field("queue", S.string),
        state: s.field("state", S.array(S.string)),
        search: s.fieldOr("search", S.nullableAsOption(S.string), None),
      })

    type postAdminQueueJobsResponse = array<ComponentSchemas.Queuejob.t>

    let postAdminQueueJobsResponseSchema = S.array(ComponentSchemas.Queuejob.schema)

    /**
     * admin/queue/jobs
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
     */
    let postAdminQueueJobs = (~body: postAdminQueueJobsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueJobsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueJobsRequestSchema)

      fetch(
        ~url="/admin/queue/jobs",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminQueueJobsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminQueuePromoteJobsRequest = {
      queue: string,
    }

    let postAdminQueuePromoteJobsRequestSchema = S.object(s => {
        queue: s.field("queue", S.string),
      })

    type postAdminQueuePromoteJobsResponse = unit

    /**
     * admin/queue/promote-jobs
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:queue*
     */
    let postAdminQueuePromoteJobs = (~body: postAdminQueuePromoteJobsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueuePromoteJobsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueuePromoteJobsRequestSchema)

      fetch(
        ~url="/admin/queue/promote-jobs",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminQueueQueueStatsRequest = {
      queue: string,
    }

    let postAdminQueueQueueStatsRequestSchema = S.object(s => {
        queue: s.field("queue", S.string),
      })

    type postAdminQueueQueueStatsResponse = {
      name: string,
      qualifiedname: string,
      counts: JSON.t,
      ispaused: bool,
      metrics: JSON.t,
      db: JSON.t,
    }

    let postAdminQueueQueueStatsResponseSchema = S.object(s => {
        name: s.field("name", S.string),
        qualifiedname: s.field("qualifiedName", S.string),
        counts: s.field("counts", S.json),
        ispaused: s.field("isPaused", S.bool),
        metrics: s.field("metrics", S.json),
        db: s.field("db", S.json),
      })

    /**
     * admin/queue/queue-stats
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
     */
    let postAdminQueueQueueStats = (~body: postAdminQueueQueueStatsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueQueueStatsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueQueueStatsRequestSchema)

      fetch(
        ~url="/admin/queue/queue-stats",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminQueueQueueStatsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminQueueQueuesResponse = array<JSON.t>

    let postAdminQueueQueuesResponseSchema = S.array(S.json)

    /**
     * admin/queue/queues
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
     */
    let postAdminQueueQueues = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueQueuesResponse> => {

      fetch(
        ~url="/admin/queue/queues",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminQueueQueuesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminQueueRemoveJobRequest = {
      queue: string,
      jobid: string,
    }

    let postAdminQueueRemoveJobRequestSchema = S.object(s => {
        queue: s.field("queue", S.string),
        jobid: s.field("jobId", S.string),
      })

    type postAdminQueueRemoveJobResponse = unit

    /**
     * admin/queue/remove-job
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:queue*
     */
    let postAdminQueueRemoveJob = (~body: postAdminQueueRemoveJobRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueRemoveJobResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueRemoveJobRequestSchema)

      fetch(
        ~url="/admin/queue/remove-job",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminQueueRetryJobRequest = {
      queue: string,
      jobid: string,
    }

    let postAdminQueueRetryJobRequestSchema = S.object(s => {
        queue: s.field("queue", S.string),
        jobid: s.field("jobId", S.string),
      })

    type postAdminQueueRetryJobResponse = unit

    /**
     * admin/queue/retry-job
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:queue*
     */
    let postAdminQueueRetryJob = (~body: postAdminQueueRetryJobRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueRetryJobResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueRetryJobRequestSchema)

      fetch(
        ~url="/admin/queue/retry-job",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminQueueShowJobRequest = {
      queue: string,
      jobid: string,
    }

    let postAdminQueueShowJobRequestSchema = S.object(s => {
        queue: s.field("queue", S.string),
        jobid: s.field("jobId", S.string),
      })

    type postAdminQueueShowJobResponse = ComponentSchemas.Queuejob.t

    let postAdminQueueShowJobResponseSchema = ComponentSchemas.Queuejob.schema

    /**
     * admin/queue/show-job
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
     */
    let postAdminQueueShowJob = (~body: postAdminQueueShowJobRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueShowJobResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueShowJobRequestSchema)

      fetch(
        ~url="/admin/queue/show-job",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminQueueShowJobResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminQueueShowJobLogsRequest = {
      queue: string,
      jobid: string,
    }

    let postAdminQueueShowJobLogsRequestSchema = S.object(s => {
        queue: s.field("queue", S.string),
        jobid: s.field("jobId", S.string),
      })

    type postAdminQueueShowJobLogsResponse = array<string>

    let postAdminQueueShowJobLogsResponseSchema = S.array(S.string)

    /**
     * admin/queue/show-job-logs
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
     */
    let postAdminQueueShowJobLogs = (~body: postAdminQueueShowJobLogsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueShowJobLogsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueShowJobLogsRequestSchema)

      fetch(
        ~url="/admin/queue/show-job-logs",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminQueueShowJobLogsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminQueueStatsResponse = {
      deliver: ComponentSchemas.Queuecount.t,
      inbox: ComponentSchemas.Queuecount.t,
      db: ComponentSchemas.Queuecount.t,
      objectstorage: ComponentSchemas.Queuecount.t,
    }

    let postAdminQueueStatsResponseSchema = S.object(s => {
        deliver: s.field("deliver", ComponentSchemas.Queuecount.schema),
        inbox: s.field("inbox", ComponentSchemas.Queuecount.schema),
        db: s.field("db", ComponentSchemas.Queuecount.schema),
        objectstorage: s.field("objectStorage", ComponentSchemas.Queuecount.schema),
      })

    /**
     * admin/queue/stats
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:emoji*
     */
    let postAdminQueueStats = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueStatsResponse> => {

      fetch(
        ~url="/admin/queue/stats",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminQueueStatsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminRelaysAddRequest = {
      inbox: string,
    }

    let postAdminRelaysAddRequestSchema = S.object(s => {
        inbox: s.field("inbox", S.string),
      })

    type postAdminRelaysAddResponse = {
      id: string,
      inbox: string,
      status: string,
    }

    let postAdminRelaysAddResponseSchema = S.object(s => {
        id: s.field("id", S.string),
        inbox: s.field("inbox", S.string),
        status: s.field("status", S.string),
      })

    /**
     * admin/relays/add
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:relays*
     */
    let postAdminRelaysAdd = (~body: postAdminRelaysAddRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRelaysAddResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRelaysAddRequestSchema)

      fetch(
        ~url="/admin/relays/add",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminRelaysAddResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminRelaysListResponse = array<JSON.t>

    let postAdminRelaysListResponseSchema = S.array(S.json)

    /**
     * admin/relays/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:relays*
     */
    let postAdminRelaysList = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRelaysListResponse> => {

      fetch(
        ~url="/admin/relays/list",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminRelaysListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminRelaysRemoveRequest = {
      inbox: string,
    }

    let postAdminRelaysRemoveRequestSchema = S.object(s => {
        inbox: s.field("inbox", S.string),
      })

    type postAdminRelaysRemoveResponse = unit

    /**
     * admin/relays/remove
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:relays*
     */
    let postAdminRelaysRemove = (~body: postAdminRelaysRemoveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRelaysRemoveResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRelaysRemoveRequestSchema)

      fetch(
        ~url="/admin/relays/remove",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminResetPasswordRequest = {
      userid: string,
    }

    let postAdminResetPasswordRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postAdminResetPasswordResponse = {
      password: string,
    }

    let postAdminResetPasswordResponseSchema = S.object(s => {
        password: s.field("password", S.string->S.min(8)->S.max(8)),
      })

    /**
     * admin/reset-password
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:reset-password*
     */
    let postAdminResetPassword = (~body: postAdminResetPasswordRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminResetPasswordResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminResetPasswordRequestSchema)

      fetch(
        ~url="/admin/reset-password",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminResetPasswordResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminResolveAbuseUserReportRequest = {
      reportid: string,
      resolvedas: option<JSON.t>,
    }

    let postAdminResolveAbuseUserReportRequestSchema = S.object(s => {
        reportid: s.field("reportId", S.string),
        resolvedas: s.fieldOr("resolvedAs", S.nullableAsOption(S.json), None),
      })

    type postAdminResolveAbuseUserReportResponse = unit

    /**
     * admin/resolve-abuse-user-report
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:resolve-abuse-user-report*
     */
    let postAdminResolveAbuseUserReport = (~body: postAdminResolveAbuseUserReportRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminResolveAbuseUserReportResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminResolveAbuseUserReportRequestSchema)

      fetch(
        ~url="/admin/resolve-abuse-user-report",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminRolesAssignRequest = {
      roleid: string,
      userid: string,
      expiresat: option<JSON.t>,
    }

    let postAdminRolesAssignRequestSchema = S.object(s => {
        roleid: s.field("roleId", S.string),
        userid: s.field("userId", S.string),
        expiresat: s.fieldOr("expiresAt", S.nullableAsOption(S.json), None),
      })

    type postAdminRolesAssignResponse = unit

    /**
     * admin/roles/assign
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
     */
    let postAdminRolesAssign = (~body: postAdminRolesAssignRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesAssignResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesAssignRequestSchema)

      fetch(
        ~url="/admin/roles/assign",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminRolesCreateRequest = {
      name: string,
      description: string,
      color: JSON.t,
      iconurl: JSON.t,
      target: string,
      condformula: JSON.t,
      ispublic: bool,
      ismoderator: bool,
      isadministrator: bool,
      isexplorable: option<bool>,
      asbadge: bool,
      preserveassignmentonmoveaccount: option<bool>,
      caneditmembersbymoderator: bool,
      displayorder: float,
      policies: JSON.t,
    }

    let postAdminRolesCreateRequestSchema = S.object(s => {
        name: s.field("name", S.string),
        description: s.field("description", S.string),
        color: s.field("color", S.json),
        iconurl: s.field("iconUrl", S.json),
        target: s.field("target", S.string),
        condformula: s.field("condFormula", S.json),
        ispublic: s.field("isPublic", S.bool),
        ismoderator: s.field("isModerator", S.bool),
        isadministrator: s.field("isAdministrator", S.bool),
        isexplorable: s.fieldOr("isExplorable", S.nullableAsOption(S.bool), None),
        asbadge: s.field("asBadge", S.bool),
        preserveassignmentonmoveaccount: s.fieldOr("preserveAssignmentOnMoveAccount", S.nullableAsOption(S.bool), None),
        caneditmembersbymoderator: s.field("canEditMembersByModerator", S.bool),
        displayorder: s.field("displayOrder", S.float),
        policies: s.field("policies", S.json),
      })

    type postAdminRolesCreateResponse = ComponentSchemas.Role.t

    let postAdminRolesCreateResponseSchema = ComponentSchemas.Role.schema

    /**
     * admin/roles/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
     */
    let postAdminRolesCreate = (~body: postAdminRolesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesCreateRequestSchema)

      fetch(
        ~url="/admin/roles/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminRolesCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminRolesDeleteRequest = {
      roleid: string,
    }

    let postAdminRolesDeleteRequestSchema = S.object(s => {
        roleid: s.field("roleId", S.string),
      })

    type postAdminRolesDeleteResponse = unit

    /**
     * admin/roles/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
     */
    let postAdminRolesDelete = (~body: postAdminRolesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesDeleteRequestSchema)

      fetch(
        ~url="/admin/roles/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminRolesListResponse = array<ComponentSchemas.Role.t>

    let postAdminRolesListResponseSchema = S.array(ComponentSchemas.Role.schema)

    /**
     * admin/roles/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:roles*
     */
    let postAdminRolesList = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesListResponse> => {

      fetch(
        ~url="/admin/roles/list",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminRolesListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminRolesShowRequest = {
      roleid: string,
    }

    let postAdminRolesShowRequestSchema = S.object(s => {
        roleid: s.field("roleId", S.string),
      })

    type postAdminRolesShowResponse = ComponentSchemas.Role.t

    let postAdminRolesShowResponseSchema = ComponentSchemas.Role.schema

    /**
     * admin/roles/show
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:roles*
     */
    let postAdminRolesShow = (~body: postAdminRolesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesShowRequestSchema)

      fetch(
        ~url="/admin/roles/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminRolesShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminRolesUnassignRequest = {
      roleid: string,
      userid: string,
    }

    let postAdminRolesUnassignRequestSchema = S.object(s => {
        roleid: s.field("roleId", S.string),
        userid: s.field("userId", S.string),
      })

    type postAdminRolesUnassignResponse = unit

    /**
     * admin/roles/unassign
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
     */
    let postAdminRolesUnassign = (~body: postAdminRolesUnassignRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesUnassignResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUnassignRequestSchema)

      fetch(
        ~url="/admin/roles/unassign",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminRolesUpdateRequest = {
      roleid: string,
      name: option<string>,
      description: option<string>,
      color: option<JSON.t>,
      iconurl: option<JSON.t>,
      target: option<string>,
      condformula: option<JSON.t>,
      ispublic: option<bool>,
      ismoderator: option<bool>,
      isadministrator: option<bool>,
      isexplorable: option<bool>,
      asbadge: option<bool>,
      preserveassignmentonmoveaccount: option<bool>,
      caneditmembersbymoderator: option<bool>,
      displayorder: option<float>,
      policies: option<JSON.t>,
    }

    let postAdminRolesUpdateRequestSchema = S.object(s => {
        roleid: s.field("roleId", S.string),
        name: s.fieldOr("name", S.nullableAsOption(S.string), None),
        description: s.fieldOr("description", S.nullableAsOption(S.string), None),
        color: s.fieldOr("color", S.nullableAsOption(S.json), None),
        iconurl: s.fieldOr("iconUrl", S.nullableAsOption(S.json), None),
        target: s.fieldOr("target", S.nullableAsOption(S.string), None),
        condformula: s.fieldOr("condFormula", S.nullableAsOption(S.json), None),
        ispublic: s.fieldOr("isPublic", S.nullableAsOption(S.bool), None),
        ismoderator: s.fieldOr("isModerator", S.nullableAsOption(S.bool), None),
        isadministrator: s.fieldOr("isAdministrator", S.nullableAsOption(S.bool), None),
        isexplorable: s.fieldOr("isExplorable", S.nullableAsOption(S.bool), None),
        asbadge: s.fieldOr("asBadge", S.nullableAsOption(S.bool), None),
        preserveassignmentonmoveaccount: s.fieldOr("preserveAssignmentOnMoveAccount", S.nullableAsOption(S.bool), None),
        caneditmembersbymoderator: s.fieldOr("canEditMembersByModerator", S.nullableAsOption(S.bool), None),
        displayorder: s.fieldOr("displayOrder", S.nullableAsOption(S.float), None),
        policies: s.fieldOr("policies", S.nullableAsOption(S.json), None),
      })

    type postAdminRolesUpdateResponse = unit

    /**
     * admin/roles/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
     */
    let postAdminRolesUpdate = (~body: postAdminRolesUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUpdateRequestSchema)

      fetch(
        ~url="/admin/roles/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminRolesUpdateDefaultPoliciesRequest = {
      policies: JSON.t,
    }

    let postAdminRolesUpdateDefaultPoliciesRequestSchema = S.object(s => {
        policies: s.field("policies", S.json),
      })

    type postAdminRolesUpdateDefaultPoliciesResponse = unit

    /**
     * admin/roles/update-default-policies
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
     */
    let postAdminRolesUpdateDefaultPolicies = (~body: postAdminRolesUpdateDefaultPoliciesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesUpdateDefaultPoliciesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUpdateDefaultPoliciesRequestSchema)

      fetch(
        ~url="/admin/roles/update-default-policies",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminRolesUsersRequest = {
      roleid: string,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postAdminRolesUsersRequestSchema = S.object(s => {
        roleid: s.field("roleId", S.string),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postAdminRolesUsersResponse = array<JSON.t>

    let postAdminRolesUsersResponseSchema = S.array(S.json)

    /**
     * admin/roles/users
     *
     * No description provided.
     *
     * **Credential required**: *No* / **Permission**: *read:admin:roles*
     */
    let postAdminRolesUsers = (~body: postAdminRolesUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesUsersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUsersRequestSchema)

      fetch(
        ~url="/admin/roles/users",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminRolesUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminSendEmailRequest = {
      @as("to") to_: string,
      subject: string,
      text: string,
    }

    let postAdminSendEmailRequestSchema = S.object(s => {
        to_: s.field("to", S.string),
        subject: s.field("subject", S.string),
        text: s.field("text", S.string),
      })

    type postAdminSendEmailResponse = unit

    /**
     * admin/send-email
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:send-email*
     */
    let postAdminSendEmail = (~body: postAdminSendEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSendEmailResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSendEmailRequestSchema)

      fetch(
        ~url="/admin/send-email",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminServerInfoResponse = {
      machine: string,
      os: string,
      node: string,
      psql: string,
      cpu: JSON.t,
      mem: JSON.t,
      fs: JSON.t,
      net: JSON.t,
    }

    let postAdminServerInfoResponseSchema = S.object(s => {
        machine: s.field("machine", S.string),
        os: s.field("os", S.string),
        node: s.field("node", S.string),
        psql: s.field("psql", S.string),
        cpu: s.field("cpu", S.json),
        mem: s.field("mem", S.json),
        fs: s.field("fs", S.json),
        net: s.field("net", S.json),
      })

    /**
     * admin/server-info
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:server-info*
     */
    let postAdminServerInfo = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminServerInfoResponse> => {

      fetch(
        ~url="/admin/server-info",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminServerInfoResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminShowModerationLogsRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      @as("type") type_: option<JSON.t>,
      userid: option<JSON.t>,
      search: option<JSON.t>,
    }

    let postAdminShowModerationLogsRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        type_: s.fieldOr("type", S.nullableAsOption(S.json), None),
        userid: s.fieldOr("userId", S.nullableAsOption(S.json), None),
        search: s.fieldOr("search", S.nullableAsOption(S.json), None),
      })

    type postAdminShowModerationLogsResponse = array<JSON.t>

    let postAdminShowModerationLogsResponseSchema = S.array(S.json)

    /**
     * admin/show-moderation-logs
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:show-moderation-log*
     */
    let postAdminShowModerationLogs = (~body: postAdminShowModerationLogsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminShowModerationLogsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowModerationLogsRequestSchema)

      fetch(
        ~url="/admin/show-moderation-logs",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminShowModerationLogsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminShowUserRequest = {
      userid: string,
    }

    let postAdminShowUserRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postAdminShowUserResponse = {
      email: JSON.t,
      emailverified: bool,
      followedmessage: JSON.t,
      autoacceptfollowed: bool,
      nocrawle: bool,
      preventailearning: bool,
      alwaysmarknsfw: bool,
      autosensitive: bool,
      carefulbot: bool,
      injectfeaturednote: bool,
      receiveannouncementemail: bool,
      mutedwords: array<array<string>>,
      mutedinstances: array<string>,
      notificationrecieveconfig: JSON.t,
      ismoderator: bool,
      issilenced: bool,
      issuspended: bool,
      ishibernated: bool,
      lastactivedate: JSON.t,
      moderationnote: string,
      signins: array<ComponentSchemas.Signin.t>,
      policies: ComponentSchemas.Rolepolicies.t,
      roles: array<ComponentSchemas.Role.t>,
      roleassigns: array<JSON.t>,
    }

    let postAdminShowUserResponseSchema = S.object(s => {
        email: s.field("email", S.json),
        emailverified: s.field("emailVerified", S.bool),
        followedmessage: s.field("followedMessage", S.json),
        autoacceptfollowed: s.field("autoAcceptFollowed", S.bool),
        nocrawle: s.field("noCrawle", S.bool),
        preventailearning: s.field("preventAiLearning", S.bool),
        alwaysmarknsfw: s.field("alwaysMarkNsfw", S.bool),
        autosensitive: s.field("autoSensitive", S.bool),
        carefulbot: s.field("carefulBot", S.bool),
        injectfeaturednote: s.field("injectFeaturedNote", S.bool),
        receiveannouncementemail: s.field("receiveAnnouncementEmail", S.bool),
        mutedwords: s.field("mutedWords", S.array(S.array(S.string))),
        mutedinstances: s.field("mutedInstances", S.array(S.string)),
        notificationrecieveconfig: s.field("notificationRecieveConfig", S.json),
        ismoderator: s.field("isModerator", S.bool),
        issilenced: s.field("isSilenced", S.bool),
        issuspended: s.field("isSuspended", S.bool),
        ishibernated: s.field("isHibernated", S.bool),
        lastactivedate: s.field("lastActiveDate", S.json),
        moderationnote: s.field("moderationNote", S.string),
        signins: s.field("signins", S.array(ComponentSchemas.Signin.schema)),
        policies: s.field("policies", ComponentSchemas.Rolepolicies.schema),
        roles: s.field("roles", S.array(ComponentSchemas.Role.schema)),
        roleassigns: s.field("roleAssigns", S.array(S.json)),
      })

    /**
     * admin/show-user
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:show-user*
     */
    let postAdminShowUser = (~body: postAdminShowUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminShowUserResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowUserRequestSchema)

      fetch(
        ~url="/admin/show-user",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminShowUserResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminShowUsersRequest = {
      limit: option<int>,
      offset: option<int>,
      sort: option<string>,
      state: option<string>,
      origin: option<string>,
      username: option<JSON.t>,
      hostname: option<JSON.t>,
    }

    let postAdminShowUsersRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
        sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
        state: s.fieldOr("state", S.nullableAsOption(S.string), None),
        origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
        username: s.fieldOr("username", S.nullableAsOption(S.json), None),
        hostname: s.fieldOr("hostname", S.nullableAsOption(S.json), None),
      })

    type postAdminShowUsersResponse = array<ComponentSchemas.Userdetailed.t>

    let postAdminShowUsersResponseSchema = S.array(ComponentSchemas.Userdetailed.schema)

    /**
     * admin/show-users
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:show-user*
     */
    let postAdminShowUsers = (~body: postAdminShowUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminShowUsersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowUsersRequestSchema)

      fetch(
        ~url="/admin/show-users",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminShowUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminSuspendUserRequest = {
      userid: string,
    }

    let postAdminSuspendUserRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postAdminSuspendUserResponse = unit

    /**
     * admin/suspend-user
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:suspend-user*
     */
    let postAdminSuspendUser = (~body: postAdminSuspendUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSuspendUserResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSuspendUserRequestSchema)

      fetch(
        ~url="/admin/suspend-user",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminSystemWebhookCreateRequest = {
      isactive: bool,
      name: string,
      on: array<string>,
      url: string,
      secret: option<string>,
    }

    let postAdminSystemWebhookCreateRequestSchema = S.object(s => {
        isactive: s.field("isActive", S.bool),
        name: s.field("name", S.string->S.min(1)->S.max(255)),
        on: s.field("on", S.array(S.string)),
        url: s.field("url", S.string->S.min(1)->S.max(1024)),
        secret: s.fieldOr("secret", S.nullableAsOption(S.string->S.max(1024)), None),
      })

    type postAdminSystemWebhookCreateResponse = ComponentSchemas.Systemwebhook.t

    let postAdminSystemWebhookCreateResponseSchema = ComponentSchemas.Systemwebhook.schema

    /**
     * admin/system-webhook/create
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
     */
    let postAdminSystemWebhookCreate = (~body: postAdminSystemWebhookCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookCreateRequestSchema)

      fetch(
        ~url="/admin/system-webhook/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminSystemWebhookCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminSystemWebhookDeleteRequest = {
      id: string,
    }

    let postAdminSystemWebhookDeleteRequestSchema = S.object(s => {
        id: s.field("id", S.string),
      })

    type postAdminSystemWebhookDeleteResponse = unit

    /**
     * admin/system-webhook/delete
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
     */
    let postAdminSystemWebhookDelete = (~body: postAdminSystemWebhookDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookDeleteRequestSchema)

      fetch(
        ~url="/admin/system-webhook/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminSystemWebhookListRequest = {
      isactive: option<bool>,
      on: option<array<string>>,
    }

    let postAdminSystemWebhookListRequestSchema = S.object(s => {
        isactive: s.fieldOr("isActive", S.nullableAsOption(S.bool), None),
        on: s.fieldOr("on", S.nullableAsOption(S.array(S.string)), None),
      })

    type postAdminSystemWebhookListResponse = array<ComponentSchemas.Systemwebhook.t>

    let postAdminSystemWebhookListResponseSchema = S.array(ComponentSchemas.Systemwebhook.schema)

    /**
     * admin/system-webhook/list
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
     */
    let postAdminSystemWebhookList = (~body: postAdminSystemWebhookListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookListRequestSchema)

      fetch(
        ~url="/admin/system-webhook/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminSystemWebhookListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminSystemWebhookShowRequest = {
      id: string,
    }

    let postAdminSystemWebhookShowRequestSchema = S.object(s => {
        id: s.field("id", S.string),
      })

    type postAdminSystemWebhookShowResponse = ComponentSchemas.Systemwebhook.t

    let postAdminSystemWebhookShowResponseSchema = ComponentSchemas.Systemwebhook.schema

    /**
     * admin/system-webhook/show
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
     */
    let postAdminSystemWebhookShow = (~body: postAdminSystemWebhookShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookShowRequestSchema)

      fetch(
        ~url="/admin/system-webhook/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminSystemWebhookShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminSystemWebhookTestRequest = {
      webhookid: string,
      @as("type") type_: string,
      override: option<JSON.t>,
    }

    let postAdminSystemWebhookTestRequestSchema = S.object(s => {
        webhookid: s.field("webhookId", S.string),
        type_: s.field("type", S.string),
        override: s.fieldOr("override", S.nullableAsOption(S.json), None),
      })

    type postAdminSystemWebhookTestResponse = unit

    /**
     * admin/system-webhook/test
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *read:admin:system-webhook*
     */
    let postAdminSystemWebhookTest = (~body: postAdminSystemWebhookTestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookTestResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookTestRequestSchema)

      fetch(
        ~url="/admin/system-webhook/test",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminSystemWebhookUpdateRequest = {
      id: string,
      isactive: bool,
      name: string,
      on: array<string>,
      url: string,
      secret: option<string>,
    }

    let postAdminSystemWebhookUpdateRequestSchema = S.object(s => {
        id: s.field("id", S.string),
        isactive: s.field("isActive", S.bool),
        name: s.field("name", S.string->S.min(1)->S.max(255)),
        on: s.field("on", S.array(S.string)),
        url: s.field("url", S.string->S.min(1)->S.max(1024)),
        secret: s.fieldOr("secret", S.nullableAsOption(S.string->S.max(1024)), None),
      })

    type postAdminSystemWebhookUpdateResponse = ComponentSchemas.Systemwebhook.t

    let postAdminSystemWebhookUpdateResponseSchema = ComponentSchemas.Systemwebhook.schema

    /**
     * admin/system-webhook/update
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
     */
    let postAdminSystemWebhookUpdate = (~body: postAdminSystemWebhookUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookUpdateRequestSchema)

      fetch(
        ~url="/admin/system-webhook/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminSystemWebhookUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminUnsetUserAvatarRequest = {
      userid: string,
    }

    let postAdminUnsetUserAvatarRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postAdminUnsetUserAvatarResponse = unit

    /**
     * admin/unset-user-avatar
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:unset-user-avatar*
     */
    let postAdminUnsetUserAvatar = (~body: postAdminUnsetUserAvatarRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUnsetUserAvatarResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUnsetUserAvatarRequestSchema)

      fetch(
        ~url="/admin/unset-user-avatar",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminUnsetUserBannerRequest = {
      userid: string,
    }

    let postAdminUnsetUserBannerRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postAdminUnsetUserBannerResponse = unit

    /**
     * admin/unset-user-banner
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:unset-user-banner*
     */
    let postAdminUnsetUserBanner = (~body: postAdminUnsetUserBannerRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUnsetUserBannerResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUnsetUserBannerRequestSchema)

      fetch(
        ~url="/admin/unset-user-banner",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminUnsuspendUserRequest = {
      userid: string,
    }

    let postAdminUnsuspendUserRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postAdminUnsuspendUserResponse = unit

    /**
     * admin/unsuspend-user
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:unsuspend-user*
     */
    let postAdminUnsuspendUser = (~body: postAdminUnsuspendUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUnsuspendUserResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUnsuspendUserRequestSchema)

      fetch(
        ~url="/admin/unsuspend-user",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminUpdateAbuseUserReportRequest = {
      reportid: string,
      moderationnote: option<string>,
    }

    let postAdminUpdateAbuseUserReportRequestSchema = S.object(s => {
        reportid: s.field("reportId", S.string),
        moderationnote: s.fieldOr("moderationNote", S.nullableAsOption(S.string), None),
      })

    type postAdminUpdateAbuseUserReportResponse = unit

    /**
     * admin/update-abuse-user-report
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:resolve-abuse-user-report*
     */
    let postAdminUpdateAbuseUserReport = (~body: postAdminUpdateAbuseUserReportRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUpdateAbuseUserReportResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateAbuseUserReportRequestSchema)

      fetch(
        ~url="/admin/update-abuse-user-report",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminUpdateMetaRequest = {
      disableregistration: option<JSON.t>,
      pinnedusers: option<JSON.t>,
      hiddentags: option<JSON.t>,
      blockedhosts: option<JSON.t>,
      sensitivewords: option<JSON.t>,
      prohibitedwords: option<JSON.t>,
      prohibitedwordsfornameofuser: option<JSON.t>,
      themecolor: option<JSON.t>,
      mascotimageurl: option<JSON.t>,
      bannerurl: option<JSON.t>,
      servererrorimageurl: option<JSON.t>,
      infoimageurl: option<JSON.t>,
      notfoundimageurl: option<JSON.t>,
      iconurl: option<JSON.t>,
      app192iconurl: option<JSON.t>,
      app512iconurl: option<JSON.t>,
      backgroundimageurl: option<JSON.t>,
      logoimageurl: option<JSON.t>,
      name: option<JSON.t>,
      shortname: option<JSON.t>,
      description: option<JSON.t>,
      defaultlighttheme: option<JSON.t>,
      defaultdarktheme: option<JSON.t>,
      clientoptions: option<JSON.t>,
      cacheremotefiles: option<bool>,
      cacheremotesensitivefiles: option<bool>,
      emailrequiredforsignup: option<bool>,
      enablehcaptcha: option<bool>,
      hcaptchasitekey: option<JSON.t>,
      hcaptchasecretkey: option<JSON.t>,
      enablemcaptcha: option<bool>,
      mcaptchasitekey: option<JSON.t>,
      mcaptchainstanceurl: option<JSON.t>,
      mcaptchasecretkey: option<JSON.t>,
      enablerecaptcha: option<bool>,
      recaptchasitekey: option<JSON.t>,
      recaptchasecretkey: option<JSON.t>,
      enableturnstile: option<bool>,
      turnstilesitekey: option<JSON.t>,
      turnstilesecretkey: option<JSON.t>,
      enabletestcaptcha: option<bool>,
      googleanalyticsmeasurementid: option<JSON.t>,
      sensitivemediadetection: option<string>,
      sensitivemediadetectionsensitivity: option<string>,
      setsensitiveflagautomatically: option<bool>,
      enablesensitivemediadetectionforvideos: option<bool>,
      maintainername: option<JSON.t>,
      maintaineremail: option<JSON.t>,
      langs: option<array<string>>,
      deeplauthkey: option<JSON.t>,
      deeplispro: option<bool>,
      enableemail: option<bool>,
      email: option<JSON.t>,
      smtpsecure: option<bool>,
      smtphost: option<JSON.t>,
      smtpport: option<JSON.t>,
      smtpuser: option<JSON.t>,
      smtppass: option<JSON.t>,
      enableserviceworker: option<bool>,
      swpublickey: option<JSON.t>,
      swprivatekey: option<JSON.t>,
      tosurl: option<JSON.t>,
      repositoryurl: option<JSON.t>,
      feedbackurl: option<JSON.t>,
      impressumurl: option<JSON.t>,
      privacypolicyurl: option<JSON.t>,
      inquiryurl: option<JSON.t>,
      useobjectstorage: option<bool>,
      objectstoragebaseurl: option<JSON.t>,
      objectstoragebucket: option<JSON.t>,
      objectstorageprefix: option<JSON.t>,
      objectstorageendpoint: option<JSON.t>,
      objectstorageregion: option<JSON.t>,
      objectstorageport: option<JSON.t>,
      objectstorageaccesskey: option<JSON.t>,
      objectstoragesecretkey: option<JSON.t>,
      objectstorageusessl: option<bool>,
      objectstorageuseproxy: option<bool>,
      objectstoragesetpublicread: option<bool>,
      objectstorages3forcepathstyle: option<bool>,
      enableiplogging: option<bool>,
      enableactiveemailvalidation: option<bool>,
      enableverifymailapi: option<bool>,
      verifymailauthkey: option<JSON.t>,
      enabletruemailapi: option<bool>,
      truemailinstance: option<JSON.t>,
      truemailauthkey: option<JSON.t>,
      enablechartsforremoteuser: option<bool>,
      enablechartsforfederatedinstances: option<bool>,
      enablestatsforfederatedinstances: option<bool>,
      enableservermachinestats: option<bool>,
      enableidenticongeneration: option<bool>,
      serverrules: option<array<string>>,
      bannedemaildomains: option<array<string>>,
      preservedusernames: option<array<string>>,
      manifestjsonoverride: option<string>,
      enablefanouttimeline: option<bool>,
      enablefanouttimelinedbfallback: option<bool>,
      perlocaluserusertimelinecachemax: option<int>,
      perremoteuserusertimelinecachemax: option<int>,
      peruserhometimelinecachemax: option<int>,
      peruserlisttimelinecachemax: option<int>,
      enablereactionsbuffering: option<bool>,
      notesperonead: option<int>,
      silencedhosts: option<JSON.t>,
      mediasilencedhosts: option<JSON.t>,
      summalyproxy: option<JSON.t>,
      urlpreviewenabled: option<bool>,
      urlpreviewallowredirect: option<bool>,
      urlpreviewtimeout: option<int>,
      urlpreviewmaximumcontentlength: option<int>,
      urlpreviewrequirecontentlength: option<bool>,
      urlpreviewuseragent: option<JSON.t>,
      urlpreviewsummaryproxyurl: option<JSON.t>,
      federation: option<string>,
      federationhosts: option<array<string>>,
      deliversuspendedsoftware: option<array<JSON.t>>,
      singleusermode: option<bool>,
      ugcvisibilityforvisitor: option<string>,
      proxyremotefiles: option<bool>,
      signtoactivitypubget: option<bool>,
      allowexternalapredirect: option<bool>,
      enableremotenotescleaning: option<bool>,
      remotenotescleaningexpirydaysforeachnotes: option<float>,
      remotenotescleaningmaxprocessingdurationinminutes: option<float>,
      showrolebadgesofremoteusers: option<bool>,
    }

    let postAdminUpdateMetaRequestSchema = S.object(s => {
        disableregistration: s.fieldOr("disableRegistration", S.nullableAsOption(S.json), None),
        pinnedusers: s.fieldOr("pinnedUsers", S.nullableAsOption(S.json), None),
        hiddentags: s.fieldOr("hiddenTags", S.nullableAsOption(S.json), None),
        blockedhosts: s.fieldOr("blockedHosts", S.nullableAsOption(S.json), None),
        sensitivewords: s.fieldOr("sensitiveWords", S.nullableAsOption(S.json), None),
        prohibitedwords: s.fieldOr("prohibitedWords", S.nullableAsOption(S.json), None),
        prohibitedwordsfornameofuser: s.fieldOr("prohibitedWordsForNameOfUser", S.nullableAsOption(S.json), None),
        themecolor: s.fieldOr("themeColor", S.nullableAsOption(S.json), None),
        mascotimageurl: s.fieldOr("mascotImageUrl", S.nullableAsOption(S.json), None),
        bannerurl: s.fieldOr("bannerUrl", S.nullableAsOption(S.json), None),
        servererrorimageurl: s.fieldOr("serverErrorImageUrl", S.nullableAsOption(S.json), None),
        infoimageurl: s.fieldOr("infoImageUrl", S.nullableAsOption(S.json), None),
        notfoundimageurl: s.fieldOr("notFoundImageUrl", S.nullableAsOption(S.json), None),
        iconurl: s.fieldOr("iconUrl", S.nullableAsOption(S.json), None),
        app192iconurl: s.fieldOr("app192IconUrl", S.nullableAsOption(S.json), None),
        app512iconurl: s.fieldOr("app512IconUrl", S.nullableAsOption(S.json), None),
        backgroundimageurl: s.fieldOr("backgroundImageUrl", S.nullableAsOption(S.json), None),
        logoimageurl: s.fieldOr("logoImageUrl", S.nullableAsOption(S.json), None),
        name: s.fieldOr("name", S.nullableAsOption(S.json), None),
        shortname: s.fieldOr("shortName", S.nullableAsOption(S.json), None),
        description: s.fieldOr("description", S.nullableAsOption(S.json), None),
        defaultlighttheme: s.fieldOr("defaultLightTheme", S.nullableAsOption(S.json), None),
        defaultdarktheme: s.fieldOr("defaultDarkTheme", S.nullableAsOption(S.json), None),
        clientoptions: s.fieldOr("clientOptions", S.nullableAsOption(S.json), None),
        cacheremotefiles: s.fieldOr("cacheRemoteFiles", S.nullableAsOption(S.bool), None),
        cacheremotesensitivefiles: s.fieldOr("cacheRemoteSensitiveFiles", S.nullableAsOption(S.bool), None),
        emailrequiredforsignup: s.fieldOr("emailRequiredForSignup", S.nullableAsOption(S.bool), None),
        enablehcaptcha: s.fieldOr("enableHcaptcha", S.nullableAsOption(S.bool), None),
        hcaptchasitekey: s.fieldOr("hcaptchaSiteKey", S.nullableAsOption(S.json), None),
        hcaptchasecretkey: s.fieldOr("hcaptchaSecretKey", S.nullableAsOption(S.json), None),
        enablemcaptcha: s.fieldOr("enableMcaptcha", S.nullableAsOption(S.bool), None),
        mcaptchasitekey: s.fieldOr("mcaptchaSiteKey", S.nullableAsOption(S.json), None),
        mcaptchainstanceurl: s.fieldOr("mcaptchaInstanceUrl", S.nullableAsOption(S.json), None),
        mcaptchasecretkey: s.fieldOr("mcaptchaSecretKey", S.nullableAsOption(S.json), None),
        enablerecaptcha: s.fieldOr("enableRecaptcha", S.nullableAsOption(S.bool), None),
        recaptchasitekey: s.fieldOr("recaptchaSiteKey", S.nullableAsOption(S.json), None),
        recaptchasecretkey: s.fieldOr("recaptchaSecretKey", S.nullableAsOption(S.json), None),
        enableturnstile: s.fieldOr("enableTurnstile", S.nullableAsOption(S.bool), None),
        turnstilesitekey: s.fieldOr("turnstileSiteKey", S.nullableAsOption(S.json), None),
        turnstilesecretkey: s.fieldOr("turnstileSecretKey", S.nullableAsOption(S.json), None),
        enabletestcaptcha: s.fieldOr("enableTestcaptcha", S.nullableAsOption(S.bool), None),
        googleanalyticsmeasurementid: s.fieldOr("googleAnalyticsMeasurementId", S.nullableAsOption(S.json), None),
        sensitivemediadetection: s.fieldOr("sensitiveMediaDetection", S.nullableAsOption(S.string), None),
        sensitivemediadetectionsensitivity: s.fieldOr("sensitiveMediaDetectionSensitivity", S.nullableAsOption(S.string), None),
        setsensitiveflagautomatically: s.fieldOr("setSensitiveFlagAutomatically", S.nullableAsOption(S.bool), None),
        enablesensitivemediadetectionforvideos: s.fieldOr("enableSensitiveMediaDetectionForVideos", S.nullableAsOption(S.bool), None),
        maintainername: s.fieldOr("maintainerName", S.nullableAsOption(S.json), None),
        maintaineremail: s.fieldOr("maintainerEmail", S.nullableAsOption(S.json), None),
        langs: s.fieldOr("langs", S.nullableAsOption(S.array(S.string)), None),
        deeplauthkey: s.fieldOr("deeplAuthKey", S.nullableAsOption(S.json), None),
        deeplispro: s.fieldOr("deeplIsPro", S.nullableAsOption(S.bool), None),
        enableemail: s.fieldOr("enableEmail", S.nullableAsOption(S.bool), None),
        email: s.fieldOr("email", S.nullableAsOption(S.json), None),
        smtpsecure: s.fieldOr("smtpSecure", S.nullableAsOption(S.bool), None),
        smtphost: s.fieldOr("smtpHost", S.nullableAsOption(S.json), None),
        smtpport: s.fieldOr("smtpPort", S.nullableAsOption(S.json), None),
        smtpuser: s.fieldOr("smtpUser", S.nullableAsOption(S.json), None),
        smtppass: s.fieldOr("smtpPass", S.nullableAsOption(S.json), None),
        enableserviceworker: s.fieldOr("enableServiceWorker", S.nullableAsOption(S.bool), None),
        swpublickey: s.fieldOr("swPublicKey", S.nullableAsOption(S.json), None),
        swprivatekey: s.fieldOr("swPrivateKey", S.nullableAsOption(S.json), None),
        tosurl: s.fieldOr("tosUrl", S.nullableAsOption(S.json), None),
        repositoryurl: s.fieldOr("repositoryUrl", S.nullableAsOption(S.json), None),
        feedbackurl: s.fieldOr("feedbackUrl", S.nullableAsOption(S.json), None),
        impressumurl: s.fieldOr("impressumUrl", S.nullableAsOption(S.json), None),
        privacypolicyurl: s.fieldOr("privacyPolicyUrl", S.nullableAsOption(S.json), None),
        inquiryurl: s.fieldOr("inquiryUrl", S.nullableAsOption(S.json), None),
        useobjectstorage: s.fieldOr("useObjectStorage", S.nullableAsOption(S.bool), None),
        objectstoragebaseurl: s.fieldOr("objectStorageBaseUrl", S.nullableAsOption(S.json), None),
        objectstoragebucket: s.fieldOr("objectStorageBucket", S.nullableAsOption(S.json), None),
        objectstorageprefix: s.fieldOr("objectStoragePrefix", S.nullableAsOption(S.json), None),
        objectstorageendpoint: s.fieldOr("objectStorageEndpoint", S.nullableAsOption(S.json), None),
        objectstorageregion: s.fieldOr("objectStorageRegion", S.nullableAsOption(S.json), None),
        objectstorageport: s.fieldOr("objectStoragePort", S.nullableAsOption(S.json), None),
        objectstorageaccesskey: s.fieldOr("objectStorageAccessKey", S.nullableAsOption(S.json), None),
        objectstoragesecretkey: s.fieldOr("objectStorageSecretKey", S.nullableAsOption(S.json), None),
        objectstorageusessl: s.fieldOr("objectStorageUseSSL", S.nullableAsOption(S.bool), None),
        objectstorageuseproxy: s.fieldOr("objectStorageUseProxy", S.nullableAsOption(S.bool), None),
        objectstoragesetpublicread: s.fieldOr("objectStorageSetPublicRead", S.nullableAsOption(S.bool), None),
        objectstorages3forcepathstyle: s.fieldOr("objectStorageS3ForcePathStyle", S.nullableAsOption(S.bool), None),
        enableiplogging: s.fieldOr("enableIpLogging", S.nullableAsOption(S.bool), None),
        enableactiveemailvalidation: s.fieldOr("enableActiveEmailValidation", S.nullableAsOption(S.bool), None),
        enableverifymailapi: s.fieldOr("enableVerifymailApi", S.nullableAsOption(S.bool), None),
        verifymailauthkey: s.fieldOr("verifymailAuthKey", S.nullableAsOption(S.json), None),
        enabletruemailapi: s.fieldOr("enableTruemailApi", S.nullableAsOption(S.bool), None),
        truemailinstance: s.fieldOr("truemailInstance", S.nullableAsOption(S.json), None),
        truemailauthkey: s.fieldOr("truemailAuthKey", S.nullableAsOption(S.json), None),
        enablechartsforremoteuser: s.fieldOr("enableChartsForRemoteUser", S.nullableAsOption(S.bool), None),
        enablechartsforfederatedinstances: s.fieldOr("enableChartsForFederatedInstances", S.nullableAsOption(S.bool), None),
        enablestatsforfederatedinstances: s.fieldOr("enableStatsForFederatedInstances", S.nullableAsOption(S.bool), None),
        enableservermachinestats: s.fieldOr("enableServerMachineStats", S.nullableAsOption(S.bool), None),
        enableidenticongeneration: s.fieldOr("enableIdenticonGeneration", S.nullableAsOption(S.bool), None),
        serverrules: s.fieldOr("serverRules", S.nullableAsOption(S.array(S.string)), None),
        bannedemaildomains: s.fieldOr("bannedEmailDomains", S.nullableAsOption(S.array(S.string)), None),
        preservedusernames: s.fieldOr("preservedUsernames", S.nullableAsOption(S.array(S.string)), None),
        manifestjsonoverride: s.fieldOr("manifestJsonOverride", S.nullableAsOption(S.string), None),
        enablefanouttimeline: s.fieldOr("enableFanoutTimeline", S.nullableAsOption(S.bool), None),
        enablefanouttimelinedbfallback: s.fieldOr("enableFanoutTimelineDbFallback", S.nullableAsOption(S.bool), None),
        perlocaluserusertimelinecachemax: s.fieldOr("perLocalUserUserTimelineCacheMax", S.nullableAsOption(S.int), None),
        perremoteuserusertimelinecachemax: s.fieldOr("perRemoteUserUserTimelineCacheMax", S.nullableAsOption(S.int), None),
        peruserhometimelinecachemax: s.fieldOr("perUserHomeTimelineCacheMax", S.nullableAsOption(S.int), None),
        peruserlisttimelinecachemax: s.fieldOr("perUserListTimelineCacheMax", S.nullableAsOption(S.int), None),
        enablereactionsbuffering: s.fieldOr("enableReactionsBuffering", S.nullableAsOption(S.bool), None),
        notesperonead: s.fieldOr("notesPerOneAd", S.nullableAsOption(S.int), None),
        silencedhosts: s.fieldOr("silencedHosts", S.nullableAsOption(S.json), None),
        mediasilencedhosts: s.fieldOr("mediaSilencedHosts", S.nullableAsOption(S.json), None),
        summalyproxy: s.fieldOr("summalyProxy", S.nullableAsOption(S.json), None),
        urlpreviewenabled: s.fieldOr("urlPreviewEnabled", S.nullableAsOption(S.bool), None),
        urlpreviewallowredirect: s.fieldOr("urlPreviewAllowRedirect", S.nullableAsOption(S.bool), None),
        urlpreviewtimeout: s.fieldOr("urlPreviewTimeout", S.nullableAsOption(S.int), None),
        urlpreviewmaximumcontentlength: s.fieldOr("urlPreviewMaximumContentLength", S.nullableAsOption(S.int), None),
        urlpreviewrequirecontentlength: s.fieldOr("urlPreviewRequireContentLength", S.nullableAsOption(S.bool), None),
        urlpreviewuseragent: s.fieldOr("urlPreviewUserAgent", S.nullableAsOption(S.json), None),
        urlpreviewsummaryproxyurl: s.fieldOr("urlPreviewSummaryProxyUrl", S.nullableAsOption(S.json), None),
        federation: s.fieldOr("federation", S.nullableAsOption(S.string), None),
        federationhosts: s.fieldOr("federationHosts", S.nullableAsOption(S.array(S.string)), None),
        deliversuspendedsoftware: s.fieldOr("deliverSuspendedSoftware", S.nullableAsOption(S.array(S.json)), None),
        singleusermode: s.fieldOr("singleUserMode", S.nullableAsOption(S.bool), None),
        ugcvisibilityforvisitor: s.fieldOr("ugcVisibilityForVisitor", S.nullableAsOption(S.string), None),
        proxyremotefiles: s.fieldOr("proxyRemoteFiles", S.nullableAsOption(S.bool), None),
        signtoactivitypubget: s.fieldOr("signToActivityPubGet", S.nullableAsOption(S.bool), None),
        allowexternalapredirect: s.fieldOr("allowExternalApRedirect", S.nullableAsOption(S.bool), None),
        enableremotenotescleaning: s.fieldOr("enableRemoteNotesCleaning", S.nullableAsOption(S.bool), None),
        remotenotescleaningexpirydaysforeachnotes: s.fieldOr("remoteNotesCleaningExpiryDaysForEachNotes", S.nullableAsOption(S.float), None),
        remotenotescleaningmaxprocessingdurationinminutes: s.fieldOr("remoteNotesCleaningMaxProcessingDurationInMinutes", S.nullableAsOption(S.float), None),
        showrolebadgesofremoteusers: s.fieldOr("showRoleBadgesOfRemoteUsers", S.nullableAsOption(S.bool), None),
      })

    type postAdminUpdateMetaResponse = unit

    /**
     * admin/update-meta
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:meta*
     */
    let postAdminUpdateMeta = (~body: postAdminUpdateMetaRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUpdateMetaResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateMetaRequestSchema)

      fetch(
        ~url="/admin/update-meta",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAdminUpdateProxyAccountRequest = {
      description: option<JSON.t>,
    }

    let postAdminUpdateProxyAccountRequestSchema = S.object(s => {
        description: s.fieldOr("description", S.nullableAsOption(S.json), None),
      })

    type postAdminUpdateProxyAccountResponse = ComponentSchemas.Userdetailed.t

    let postAdminUpdateProxyAccountResponseSchema = ComponentSchemas.Userdetailed.schema

    /**
     * admin/update-proxy-account
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:account*
     */
    let postAdminUpdateProxyAccount = (~body: postAdminUpdateProxyAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUpdateProxyAccountResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateProxyAccountRequestSchema)

      fetch(
        ~url="/admin/update-proxy-account",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAdminUpdateProxyAccountResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAdminUpdateUserNoteRequest = {
      userid: string,
      text: string,
    }

    let postAdminUpdateUserNoteRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        text: s.field("text", S.string),
      })

    type postAdminUpdateUserNoteResponse = unit

    /**
     * admin/update-user-note
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:admin:user-note*
     */
    let postAdminUpdateUserNote = (~body: postAdminUpdateUserNoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUpdateUserNoteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateUserNoteRequestSchema)

      fetch(
        ~url="/admin/update-user-note",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAnnouncementsRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      isactive: option<bool>,
    }

    let postAnnouncementsRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        isactive: s.fieldOr("isActive", S.nullableAsOption(S.bool), None),
      })

    type postAnnouncementsResponse = array<ComponentSchemas.Announcement.t>

    let postAnnouncementsResponseSchema = S.array(ComponentSchemas.Announcement.schema)

    /**
     * announcements
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postAnnouncements = (~body: postAnnouncementsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementsRequestSchema)

      fetch(
        ~url="/announcements",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAnnouncementsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAnnouncementsShowRequest = {
      announcementid: string,
    }

    let postAnnouncementsShowRequestSchema = S.object(s => {
        announcementid: s.field("announcementId", S.string),
      })

    type postAnnouncementsShowResponse = ComponentSchemas.Announcement.t

    let postAnnouncementsShowResponseSchema = ComponentSchemas.Announcement.schema

    /**
     * announcements/show
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postAnnouncementsShow = (~body: postAnnouncementsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementsShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementsShowRequestSchema)

      fetch(
        ~url="/announcements/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAnnouncementsShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAntennasCreateRequest = {
      name: string,
      src: string,
      userlistid: option<JSON.t>,
      keywords: array<array<string>>,
      excludekeywords: array<array<string>>,
      users: array<string>,
      casesensitive: bool,
      localonly: option<bool>,
      excludebots: option<bool>,
      withreplies: bool,
      withfile: bool,
      excludenotesinsensitivechannel: option<bool>,
    }

    let postAntennasCreateRequestSchema = S.object(s => {
        name: s.field("name", S.string->S.min(1)->S.max(100)),
        src: s.field("src", S.string),
        userlistid: s.fieldOr("userListId", S.nullableAsOption(S.json), None),
        keywords: s.field("keywords", S.array(S.array(S.string))),
        excludekeywords: s.field("excludeKeywords", S.array(S.array(S.string))),
        users: s.field("users", S.array(S.string)),
        casesensitive: s.field("caseSensitive", S.bool),
        localonly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
        excludebots: s.fieldOr("excludeBots", S.nullableAsOption(S.bool), None),
        withreplies: s.field("withReplies", S.bool),
        withfile: s.field("withFile", S.bool),
        excludenotesinsensitivechannel: s.fieldOr("excludeNotesInSensitiveChannel", S.nullableAsOption(S.bool), None),
      })

    type postAntennasCreateResponse = ComponentSchemas.Antenna.t

    let postAntennasCreateResponseSchema = ComponentSchemas.Antenna.schema

    /**
     * antennas/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postAntennasCreate = (~body: postAntennasCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasCreateRequestSchema)

      fetch(
        ~url="/antennas/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAntennasCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAntennasDeleteRequest = {
      antennaid: string,
    }

    let postAntennasDeleteRequestSchema = S.object(s => {
        antennaid: s.field("antennaId", S.string),
      })

    type postAntennasDeleteResponse = unit

    /**
     * antennas/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postAntennasDelete = (~body: postAntennasDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasDeleteRequestSchema)

      fetch(
        ~url="/antennas/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAntennasListResponse = array<ComponentSchemas.Antenna.t>

    let postAntennasListResponseSchema = S.array(ComponentSchemas.Antenna.schema)

    /**
     * antennas/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postAntennasList = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasListResponse> => {

      fetch(
        ~url="/antennas/list",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAntennasListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAntennasNotesRequest = {
      antennaid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postAntennasNotesRequestSchema = S.object(s => {
        antennaid: s.field("antennaId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postAntennasNotesResponse = array<ComponentSchemas.Note.t>

    let postAntennasNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * antennas/notes
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postAntennasNotes = (~body: postAntennasNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasNotesRequestSchema)

      fetch(
        ~url="/antennas/notes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAntennasNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAntennasShowRequest = {
      antennaid: string,
    }

    let postAntennasShowRequestSchema = S.object(s => {
        antennaid: s.field("antennaId", S.string),
      })

    type postAntennasShowResponse = ComponentSchemas.Antenna.t

    let postAntennasShowResponseSchema = ComponentSchemas.Antenna.schema

    /**
     * antennas/show
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postAntennasShow = (~body: postAntennasShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasShowRequestSchema)

      fetch(
        ~url="/antennas/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAntennasShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAntennasUpdateRequest = {
      antennaid: string,
      name: option<string>,
      src: option<string>,
      userlistid: option<JSON.t>,
      keywords: option<array<array<string>>>,
      excludekeywords: option<array<array<string>>>,
      users: option<array<string>>,
      casesensitive: option<bool>,
      localonly: option<bool>,
      excludebots: option<bool>,
      withreplies: option<bool>,
      withfile: option<bool>,
      excludenotesinsensitivechannel: option<bool>,
    }

    let postAntennasUpdateRequestSchema = S.object(s => {
        antennaid: s.field("antennaId", S.string),
        name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.max(100)), None),
        src: s.fieldOr("src", S.nullableAsOption(S.string), None),
        userlistid: s.fieldOr("userListId", S.nullableAsOption(S.json), None),
        keywords: s.fieldOr("keywords", S.nullableAsOption(S.array(S.array(S.string))), None),
        excludekeywords: s.fieldOr("excludeKeywords", S.nullableAsOption(S.array(S.array(S.string))), None),
        users: s.fieldOr("users", S.nullableAsOption(S.array(S.string)), None),
        casesensitive: s.fieldOr("caseSensitive", S.nullableAsOption(S.bool), None),
        localonly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
        excludebots: s.fieldOr("excludeBots", S.nullableAsOption(S.bool), None),
        withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
        withfile: s.fieldOr("withFile", S.nullableAsOption(S.bool), None),
        excludenotesinsensitivechannel: s.fieldOr("excludeNotesInSensitiveChannel", S.nullableAsOption(S.bool), None),
      })

    type postAntennasUpdateResponse = ComponentSchemas.Antenna.t

    let postAntennasUpdateResponseSchema = ComponentSchemas.Antenna.schema

    /**
     * antennas/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postAntennasUpdate = (~body: postAntennasUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasUpdateRequestSchema)

      fetch(
        ~url="/antennas/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAntennasUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postApGetRequest = {
      uri: string,
    }

    let postApGetRequestSchema = S.object(s => {
        uri: s.field("uri", S.string),
      })

    type postApGetResponse = JSON.t

    let postApGetResponseSchema = S.json

    /**
     * ap/get
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:federation*
     */
    let postApGet = (~body: postApGetRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postApGetResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postApGetRequestSchema)

      fetch(
        ~url="/ap/get",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postApGetResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postApShowRequest = {
      uri: string,
    }

    let postApShowRequestSchema = S.object(s => {
        uri: s.field("uri", S.string),
      })

    type postApShowResponse = JSON.t

    let postApShowResponseSchema = S.json

    /**
     * ap/show
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postApShow = (~body: postApShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postApShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postApShowRequestSchema)

      fetch(
        ~url="/ap/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postApShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAppCreateRequest = {
      name: string,
      description: string,
      permission: array<string>,
      callbackurl: option<JSON.t>,
    }

    let postAppCreateRequestSchema = S.object(s => {
        name: s.field("name", S.string),
        description: s.field("description", S.string),
        permission: s.field("permission", S.array(S.string)),
        callbackurl: s.fieldOr("callbackUrl", S.nullableAsOption(S.json), None),
      })

    type postAppCreateResponse = ComponentSchemas.App.t

    let postAppCreateResponseSchema = ComponentSchemas.App.schema

    /**
     * app/create
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postAppCreate = (~body: postAppCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAppCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAppCreateRequestSchema)

      fetch(
        ~url="/app/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAppCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAppShowRequest = {
      appid: string,
    }

    let postAppShowRequestSchema = S.object(s => {
        appid: s.field("appId", S.string),
      })

    type postAppShowResponse = ComponentSchemas.App.t

    let postAppShowResponseSchema = ComponentSchemas.App.schema

    /**
     * app/show
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postAppShow = (~body: postAppShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAppShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAppShowRequestSchema)

      fetch(
        ~url="/app/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAppShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAuthAcceptRequest = {
      token: string,
    }

    let postAuthAcceptRequestSchema = S.object(s => {
        token: s.field("token", S.string),
      })

    type postAuthAcceptResponse = unit

    /**
     * auth/accept
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postAuthAccept = (~body: postAuthAcceptRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAuthAcceptResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAuthAcceptRequestSchema)

      fetch(
        ~url="/auth/accept",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postAuthSessionGenerateRequest = {
      appsecret: string,
    }

    let postAuthSessionGenerateRequestSchema = S.object(s => {
        appsecret: s.field("appSecret", S.string),
      })

    type postAuthSessionGenerateResponse = {
      token: string,
      url: string,
    }

    let postAuthSessionGenerateResponseSchema = S.object(s => {
        token: s.field("token", S.string),
        url: s.field("url", S.string),
      })

    /**
     * auth/session/generate
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postAuthSessionGenerate = (~body: postAuthSessionGenerateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAuthSessionGenerateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAuthSessionGenerateRequestSchema)

      fetch(
        ~url="/auth/session/generate",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAuthSessionGenerateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAuthSessionShowRequest = {
      token: string,
    }

    let postAuthSessionShowRequestSchema = S.object(s => {
        token: s.field("token", S.string),
      })

    type postAuthSessionShowResponse = {
      id: string,
      app: ComponentSchemas.App.t,
      token: string,
    }

    let postAuthSessionShowResponseSchema = S.object(s => {
        id: s.field("id", S.string),
        app: s.field("app", ComponentSchemas.App.schema),
        token: s.field("token", S.string),
      })

    /**
     * auth/session/show
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postAuthSessionShow = (~body: postAuthSessionShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAuthSessionShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAuthSessionShowRequestSchema)

      fetch(
        ~url="/auth/session/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAuthSessionShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postAuthSessionUserkeyRequest = {
      appsecret: string,
      token: string,
    }

    let postAuthSessionUserkeyRequestSchema = S.object(s => {
        appsecret: s.field("appSecret", S.string),
        token: s.field("token", S.string),
      })

    type postAuthSessionUserkeyResponse = {
      accesstoken: string,
      user: ComponentSchemas.Userdetailednotme.t,
    }

    let postAuthSessionUserkeyResponseSchema = S.object(s => {
        accesstoken: s.field("accessToken", S.string),
        user: s.field("user", ComponentSchemas.Userdetailednotme.schema),
      })

    /**
     * auth/session/userkey
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postAuthSessionUserkey = (~body: postAuthSessionUserkeyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAuthSessionUserkeyResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postAuthSessionUserkeyRequestSchema)

      fetch(
        ~url="/auth/session/userkey",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postAuthSessionUserkeyResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postBlockingCreateRequest = {
      userid: string,
    }

    let postBlockingCreateRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postBlockingCreateResponse = ComponentSchemas.Userdetailednotme.t

    let postBlockingCreateResponseSchema = ComponentSchemas.Userdetailednotme.schema

    /**
     * blocking/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:blocks*
     */
    let postBlockingCreate = (~body: postBlockingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBlockingCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingCreateRequestSchema)

      fetch(
        ~url="/blocking/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postBlockingCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postBlockingDeleteRequest = {
      userid: string,
    }

    let postBlockingDeleteRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postBlockingDeleteResponse = ComponentSchemas.Userdetailednotme.t

    let postBlockingDeleteResponseSchema = ComponentSchemas.Userdetailednotme.schema

    /**
     * blocking/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:blocks*
     */
    let postBlockingDelete = (~body: postBlockingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBlockingDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingDeleteRequestSchema)

      fetch(
        ~url="/blocking/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postBlockingDeleteResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postBlockingListRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postBlockingListRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postBlockingListResponse = array<ComponentSchemas.Blocking.t>

    let postBlockingListResponseSchema = S.array(ComponentSchemas.Blocking.schema)

    /**
     * blocking/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:blocks*
     */
    let postBlockingList = (~body: postBlockingListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBlockingListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingListRequestSchema)

      fetch(
        ~url="/blocking/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postBlockingListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getBubbleGameRankingRequest = {
      gamemode: string,
    }

    let getBubbleGameRankingRequestSchema = S.object(s => {
        gamemode: s.field("gameMode", S.string),
      })

    type getBubbleGameRankingResponse = array<JSON.t>

    let getBubbleGameRankingResponseSchema = S.array(S.json)

    /**
     * bubble-game/ranking
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getBubbleGameRanking = (~body: getBubbleGameRankingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getBubbleGameRankingResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getBubbleGameRankingRequestSchema)

      fetch(
        ~url="/bubble-game/ranking",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getBubbleGameRankingResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postBubbleGameRankingRequest = {
      gamemode: string,
    }

    let postBubbleGameRankingRequestSchema = S.object(s => {
        gamemode: s.field("gameMode", S.string),
      })

    type postBubbleGameRankingResponse = array<JSON.t>

    let postBubbleGameRankingResponseSchema = S.array(S.json)

    /**
     * bubble-game/ranking
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postBubbleGameRanking = (~body: postBubbleGameRankingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBubbleGameRankingResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postBubbleGameRankingRequestSchema)

      fetch(
        ~url="/bubble-game/ranking",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postBubbleGameRankingResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postBubbleGameRegisterRequest = {
      score: int,
      seed: string,
      logs: array<array<float>>,
      gamemode: string,
      gameversion: int,
    }

    let postBubbleGameRegisterRequestSchema = S.object(s => {
        score: s.field("score", S.int->S.min(0)),
        seed: s.field("seed", S.string->S.min(1)->S.max(1024)),
        logs: s.field("logs", S.array(S.array(S.float))),
        gamemode: s.field("gameMode", S.string),
        gameversion: s.field("gameVersion", S.int),
      })

    type postBubbleGameRegisterResponse = unit

    /**
     * bubble-game/register
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postBubbleGameRegister = (~body: postBubbleGameRegisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBubbleGameRegisterResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postBubbleGameRegisterRequestSchema)

      fetch(
        ~url="/bubble-game/register",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChannelsCreateRequest = {
      name: string,
      description: option<JSON.t>,
      bannerid: option<JSON.t>,
      color: option<string>,
      issensitive: option<JSON.t>,
      allowrenotetoexternal: option<JSON.t>,
    }

    let postChannelsCreateRequestSchema = S.object(s => {
        name: s.field("name", S.string->S.min(1)->S.max(128)),
        description: s.fieldOr("description", S.nullableAsOption(S.json), None),
        bannerid: s.fieldOr("bannerId", S.nullableAsOption(S.json), None),
        color: s.fieldOr("color", S.nullableAsOption(S.string->S.min(1)->S.max(16)), None),
        issensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.json), None),
        allowrenotetoexternal: s.fieldOr("allowRenoteToExternal", S.nullableAsOption(S.json), None),
      })

    type postChannelsCreateResponse = ComponentSchemas.Channel.t

    let postChannelsCreateResponseSchema = ComponentSchemas.Channel.schema

    /**
     * channels/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:channels*
     */
    let postChannelsCreate = (~body: postChannelsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsCreateRequestSchema)

      fetch(
        ~url="/channels/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChannelsCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChannelsFavoriteRequest = {
      channelid: string,
    }

    let postChannelsFavoriteRequestSchema = S.object(s => {
        channelid: s.field("channelId", S.string),
      })

    type postChannelsFavoriteResponse = unit

    /**
     * channels/favorite
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:channels*
     */
    let postChannelsFavorite = (~body: postChannelsFavoriteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsFavoriteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsFavoriteRequestSchema)

      fetch(
        ~url="/channels/favorite",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChannelsFeaturedResponse = array<ComponentSchemas.Channel.t>

    let postChannelsFeaturedResponseSchema = S.array(ComponentSchemas.Channel.schema)

    /**
     * channels/featured
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChannelsFeatured = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsFeaturedResponse> => {

      fetch(
        ~url="/channels/featured",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChannelsFeaturedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChannelsFollowRequest = {
      channelid: string,
    }

    let postChannelsFollowRequestSchema = S.object(s => {
        channelid: s.field("channelId", S.string),
      })

    type postChannelsFollowResponse = unit

    /**
     * channels/follow
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:channels*
     */
    let postChannelsFollow = (~body: postChannelsFollowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsFollowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsFollowRequestSchema)

      fetch(
        ~url="/channels/follow",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChannelsFollowedRequest = {
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postChannelsFollowedRequestSchema = S.object(s => {
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postChannelsFollowedResponse = array<ComponentSchemas.Channel.t>

    let postChannelsFollowedResponseSchema = S.array(ComponentSchemas.Channel.schema)

    /**
     * channels/followed
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:channels*
     */
    let postChannelsFollowed = (~body: postChannelsFollowedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsFollowedResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsFollowedRequestSchema)

      fetch(
        ~url="/channels/followed",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChannelsFollowedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChannelsMuteCreateRequest = {
      channelid: string,
      expiresat: option<JSON.t>,
    }

    let postChannelsMuteCreateRequestSchema = S.object(s => {
        channelid: s.field("channelId", S.string),
        expiresat: s.fieldOr("expiresAt", S.nullableAsOption(S.json), None),
      })

    type postChannelsMuteCreateResponse = unit

    /**
     * channels/mute/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:channels*
     */
    let postChannelsMuteCreate = (~body: postChannelsMuteCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsMuteCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsMuteCreateRequestSchema)

      fetch(
        ~url="/channels/mute/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChannelsMuteDeleteRequest = {
      channelid: string,
    }

    let postChannelsMuteDeleteRequestSchema = S.object(s => {
        channelid: s.field("channelId", S.string),
      })

    type postChannelsMuteDeleteResponse = unit

    /**
     * channels/mute/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:channels*
     */
    let postChannelsMuteDelete = (~body: postChannelsMuteDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsMuteDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsMuteDeleteRequestSchema)

      fetch(
        ~url="/channels/mute/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChannelsMuteListResponse = array<ComponentSchemas.Channel.t>

    let postChannelsMuteListResponseSchema = S.array(ComponentSchemas.Channel.schema)

    /**
     * channels/mute/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:channels*
     */
    let postChannelsMuteList = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsMuteListResponse> => {

      fetch(
        ~url="/channels/mute/list",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChannelsMuteListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChannelsMyFavoritesResponse = array<ComponentSchemas.Channel.t>

    let postChannelsMyFavoritesResponseSchema = S.array(ComponentSchemas.Channel.schema)

    /**
     * channels/my-favorites
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:channels*
     */
    let postChannelsMyFavorites = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsMyFavoritesResponse> => {

      fetch(
        ~url="/channels/my-favorites",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChannelsMyFavoritesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChannelsOwnedRequest = {
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postChannelsOwnedRequestSchema = S.object(s => {
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postChannelsOwnedResponse = array<ComponentSchemas.Channel.t>

    let postChannelsOwnedResponseSchema = S.array(ComponentSchemas.Channel.schema)

    /**
     * channels/owned
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:channels*
     */
    let postChannelsOwned = (~body: postChannelsOwnedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsOwnedResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsOwnedRequestSchema)

      fetch(
        ~url="/channels/owned",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChannelsOwnedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChannelsSearchRequest = {
      query: string,
      @as("type") type_: option<string>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postChannelsSearchRequestSchema = S.object(s => {
        query: s.field("query", S.string),
        type_: s.fieldOr("type", S.nullableAsOption(S.string), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postChannelsSearchResponse = array<ComponentSchemas.Channel.t>

    let postChannelsSearchResponseSchema = S.array(ComponentSchemas.Channel.schema)

    /**
     * channels/search
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChannelsSearch = (~body: postChannelsSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsSearchResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsSearchRequestSchema)

      fetch(
        ~url="/channels/search",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChannelsSearchResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChannelsShowRequest = {
      channelid: string,
    }

    let postChannelsShowRequestSchema = S.object(s => {
        channelid: s.field("channelId", S.string),
      })

    type postChannelsShowResponse = ComponentSchemas.Channel.t

    let postChannelsShowResponseSchema = ComponentSchemas.Channel.schema

    /**
     * channels/show
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChannelsShow = (~body: postChannelsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsShowRequestSchema)

      fetch(
        ~url="/channels/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChannelsShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChannelsTimelineRequest = {
      channelid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      allowpartial: option<bool>,
    }

    let postChannelsTimelineRequestSchema = S.object(s => {
        channelid: s.field("channelId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
      })

    type postChannelsTimelineResponse = array<ComponentSchemas.Note.t>

    let postChannelsTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * channels/timeline
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChannelsTimeline = (~body: postChannelsTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsTimelineResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsTimelineRequestSchema)

      fetch(
        ~url="/channels/timeline",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChannelsTimelineResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChannelsUnfavoriteRequest = {
      channelid: string,
    }

    let postChannelsUnfavoriteRequestSchema = S.object(s => {
        channelid: s.field("channelId", S.string),
      })

    type postChannelsUnfavoriteResponse = unit

    /**
     * channels/unfavorite
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:channels*
     */
    let postChannelsUnfavorite = (~body: postChannelsUnfavoriteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsUnfavoriteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsUnfavoriteRequestSchema)

      fetch(
        ~url="/channels/unfavorite",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChannelsUnfollowRequest = {
      channelid: string,
    }

    let postChannelsUnfollowRequestSchema = S.object(s => {
        channelid: s.field("channelId", S.string),
      })

    type postChannelsUnfollowResponse = unit

    /**
     * channels/unfollow
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:channels*
     */
    let postChannelsUnfollow = (~body: postChannelsUnfollowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsUnfollowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsUnfollowRequestSchema)

      fetch(
        ~url="/channels/unfollow",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChannelsUpdateRequest = {
      channelid: string,
      name: option<string>,
      description: option<JSON.t>,
      bannerid: option<JSON.t>,
      isarchived: option<JSON.t>,
      pinnednoteids: option<array<string>>,
      color: option<string>,
      issensitive: option<JSON.t>,
      allowrenotetoexternal: option<JSON.t>,
    }

    let postChannelsUpdateRequestSchema = S.object(s => {
        channelid: s.field("channelId", S.string),
        name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.max(128)), None),
        description: s.fieldOr("description", S.nullableAsOption(S.json), None),
        bannerid: s.fieldOr("bannerId", S.nullableAsOption(S.json), None),
        isarchived: s.fieldOr("isArchived", S.nullableAsOption(S.json), None),
        pinnednoteids: s.fieldOr("pinnedNoteIds", S.nullableAsOption(S.array(S.string)), None),
        color: s.fieldOr("color", S.nullableAsOption(S.string->S.min(1)->S.max(16)), None),
        issensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.json), None),
        allowrenotetoexternal: s.fieldOr("allowRenoteToExternal", S.nullableAsOption(S.json), None),
      })

    type postChannelsUpdateResponse = ComponentSchemas.Channel.t

    let postChannelsUpdateResponseSchema = ComponentSchemas.Channel.schema

    /**
     * channels/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:channels*
     */
    let postChannelsUpdate = (~body: postChannelsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsUpdateRequestSchema)

      fetch(
        ~url="/channels/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChannelsUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsActiveUsersRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let getChartsActiveUsersRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type getChartsActiveUsersResponse = {
      readwrite: array<float>,
      read: array<float>,
      write: array<float>,
      registeredwithinweek: array<float>,
      registeredwithinmonth: array<float>,
      registeredwithinyear: array<float>,
      registeredoutsideweek: array<float>,
      registeredoutsidemonth: array<float>,
      registeredoutsideyear: array<float>,
    }

    let getChartsActiveUsersResponseSchema = S.object(s => {
        readwrite: s.field("readWrite", S.array(S.float)),
        read: s.field("read", S.array(S.float)),
        write: s.field("write", S.array(S.float)),
        registeredwithinweek: s.field("registeredWithinWeek", S.array(S.float)),
        registeredwithinmonth: s.field("registeredWithinMonth", S.array(S.float)),
        registeredwithinyear: s.field("registeredWithinYear", S.array(S.float)),
        registeredoutsideweek: s.field("registeredOutsideWeek", S.array(S.float)),
        registeredoutsidemonth: s.field("registeredOutsideMonth", S.array(S.float)),
        registeredoutsideyear: s.field("registeredOutsideYear", S.array(S.float)),
      })

    /**
     * charts/active-users
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsActiveUsers = (~body: getChartsActiveUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsActiveUsersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsActiveUsersRequestSchema)

      fetch(
        ~url="/charts/active-users",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsActiveUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsActiveUsersRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let postChartsActiveUsersRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type postChartsActiveUsersResponse = {
      readwrite: array<float>,
      read: array<float>,
      write: array<float>,
      registeredwithinweek: array<float>,
      registeredwithinmonth: array<float>,
      registeredwithinyear: array<float>,
      registeredoutsideweek: array<float>,
      registeredoutsidemonth: array<float>,
      registeredoutsideyear: array<float>,
    }

    let postChartsActiveUsersResponseSchema = S.object(s => {
        readwrite: s.field("readWrite", S.array(S.float)),
        read: s.field("read", S.array(S.float)),
        write: s.field("write", S.array(S.float)),
        registeredwithinweek: s.field("registeredWithinWeek", S.array(S.float)),
        registeredwithinmonth: s.field("registeredWithinMonth", S.array(S.float)),
        registeredwithinyear: s.field("registeredWithinYear", S.array(S.float)),
        registeredoutsideweek: s.field("registeredOutsideWeek", S.array(S.float)),
        registeredoutsidemonth: s.field("registeredOutsideMonth", S.array(S.float)),
        registeredoutsideyear: s.field("registeredOutsideYear", S.array(S.float)),
      })

    /**
     * charts/active-users
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsActiveUsers = (~body: postChartsActiveUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsActiveUsersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsActiveUsersRequestSchema)

      fetch(
        ~url="/charts/active-users",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsActiveUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsApRequestRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let getChartsApRequestRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type getChartsApRequestResponse = {
      deliverfailed: array<float>,
      deliversucceeded: array<float>,
      inboxreceived: array<float>,
    }

    let getChartsApRequestResponseSchema = S.object(s => {
        deliverfailed: s.field("deliverFailed", S.array(S.float)),
        deliversucceeded: s.field("deliverSucceeded", S.array(S.float)),
        inboxreceived: s.field("inboxReceived", S.array(S.float)),
      })

    /**
     * charts/ap-request
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsApRequest = (~body: getChartsApRequestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsApRequestResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsApRequestRequestSchema)

      fetch(
        ~url="/charts/ap-request",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsApRequestResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsApRequestRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let postChartsApRequestRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type postChartsApRequestResponse = {
      deliverfailed: array<float>,
      deliversucceeded: array<float>,
      inboxreceived: array<float>,
    }

    let postChartsApRequestResponseSchema = S.object(s => {
        deliverfailed: s.field("deliverFailed", S.array(S.float)),
        deliversucceeded: s.field("deliverSucceeded", S.array(S.float)),
        inboxreceived: s.field("inboxReceived", S.array(S.float)),
      })

    /**
     * charts/ap-request
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsApRequest = (~body: postChartsApRequestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsApRequestResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsApRequestRequestSchema)

      fetch(
        ~url="/charts/ap-request",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsApRequestResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsDriveRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let getChartsDriveRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type getChartsDriveResponse = {
      local: JSON.t,
      remote: JSON.t,
    }

    let getChartsDriveResponseSchema = S.object(s => {
        local: s.field("local", S.json),
        remote: s.field("remote", S.json),
      })

    /**
     * charts/drive
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsDrive = (~body: getChartsDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsDriveResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsDriveRequestSchema)

      fetch(
        ~url="/charts/drive",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsDriveResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsDriveRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let postChartsDriveRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type postChartsDriveResponse = {
      local: JSON.t,
      remote: JSON.t,
    }

    let postChartsDriveResponseSchema = S.object(s => {
        local: s.field("local", S.json),
        remote: s.field("remote", S.json),
      })

    /**
     * charts/drive
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsDrive = (~body: postChartsDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsDriveResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsDriveRequestSchema)

      fetch(
        ~url="/charts/drive",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsDriveResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsFederationRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let getChartsFederationRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type getChartsFederationResponse = {
      deliveredinstances: array<float>,
      inboxinstances: array<float>,
      stalled: array<float>,
      sub: array<float>,
      pub: array<float>,
      pubsub: array<float>,
      subactive: array<float>,
      pubactive: array<float>,
    }

    let getChartsFederationResponseSchema = S.object(s => {
        deliveredinstances: s.field("deliveredInstances", S.array(S.float)),
        inboxinstances: s.field("inboxInstances", S.array(S.float)),
        stalled: s.field("stalled", S.array(S.float)),
        sub: s.field("sub", S.array(S.float)),
        pub: s.field("pub", S.array(S.float)),
        pubsub: s.field("pubsub", S.array(S.float)),
        subactive: s.field("subActive", S.array(S.float)),
        pubactive: s.field("pubActive", S.array(S.float)),
      })

    /**
     * charts/federation
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsFederation = (~body: getChartsFederationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsFederationResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsFederationRequestSchema)

      fetch(
        ~url="/charts/federation",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsFederationResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsFederationRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let postChartsFederationRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type postChartsFederationResponse = {
      deliveredinstances: array<float>,
      inboxinstances: array<float>,
      stalled: array<float>,
      sub: array<float>,
      pub: array<float>,
      pubsub: array<float>,
      subactive: array<float>,
      pubactive: array<float>,
    }

    let postChartsFederationResponseSchema = S.object(s => {
        deliveredinstances: s.field("deliveredInstances", S.array(S.float)),
        inboxinstances: s.field("inboxInstances", S.array(S.float)),
        stalled: s.field("stalled", S.array(S.float)),
        sub: s.field("sub", S.array(S.float)),
        pub: s.field("pub", S.array(S.float)),
        pubsub: s.field("pubsub", S.array(S.float)),
        subactive: s.field("subActive", S.array(S.float)),
        pubactive: s.field("pubActive", S.array(S.float)),
      })

    /**
     * charts/federation
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsFederation = (~body: postChartsFederationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsFederationResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsFederationRequestSchema)

      fetch(
        ~url="/charts/federation",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsFederationResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsInstanceRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      host: string,
    }

    let getChartsInstanceRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        host: s.field("host", S.string),
      })

    type getChartsInstanceResponse = {
      requests: JSON.t,
      notes: JSON.t,
      users: JSON.t,
      following: JSON.t,
      followers: JSON.t,
      drive: JSON.t,
    }

    let getChartsInstanceResponseSchema = S.object(s => {
        requests: s.field("requests", S.json),
        notes: s.field("notes", S.json),
        users: s.field("users", S.json),
        following: s.field("following", S.json),
        followers: s.field("followers", S.json),
        drive: s.field("drive", S.json),
      })

    /**
     * charts/instance
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsInstance = (~body: getChartsInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsInstanceResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsInstanceRequestSchema)

      fetch(
        ~url="/charts/instance",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsInstanceResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsInstanceRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      host: string,
    }

    let postChartsInstanceRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        host: s.field("host", S.string),
      })

    type postChartsInstanceResponse = {
      requests: JSON.t,
      notes: JSON.t,
      users: JSON.t,
      following: JSON.t,
      followers: JSON.t,
      drive: JSON.t,
    }

    let postChartsInstanceResponseSchema = S.object(s => {
        requests: s.field("requests", S.json),
        notes: s.field("notes", S.json),
        users: s.field("users", S.json),
        following: s.field("following", S.json),
        followers: s.field("followers", S.json),
        drive: s.field("drive", S.json),
      })

    /**
     * charts/instance
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsInstance = (~body: postChartsInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsInstanceResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsInstanceRequestSchema)

      fetch(
        ~url="/charts/instance",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsInstanceResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsNotesRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let getChartsNotesRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type getChartsNotesResponse = {
      local: JSON.t,
      remote: JSON.t,
    }

    let getChartsNotesResponseSchema = S.object(s => {
        local: s.field("local", S.json),
        remote: s.field("remote", S.json),
      })

    /**
     * charts/notes
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsNotes = (~body: getChartsNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsNotesRequestSchema)

      fetch(
        ~url="/charts/notes",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsNotesRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let postChartsNotesRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type postChartsNotesResponse = {
      local: JSON.t,
      remote: JSON.t,
    }

    let postChartsNotesResponseSchema = S.object(s => {
        local: s.field("local", S.json),
        remote: s.field("remote", S.json),
      })

    /**
     * charts/notes
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsNotes = (~body: postChartsNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsNotesRequestSchema)

      fetch(
        ~url="/charts/notes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsUserDriveRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      userid: string,
    }

    let getChartsUserDriveRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        userid: s.field("userId", S.string),
      })

    type getChartsUserDriveResponse = {
      totalcount: array<float>,
      totalsize: array<float>,
      inccount: array<float>,
      incsize: array<float>,
      deccount: array<float>,
      decsize: array<float>,
    }

    let getChartsUserDriveResponseSchema = S.object(s => {
        totalcount: s.field("totalCount", S.array(S.float)),
        totalsize: s.field("totalSize", S.array(S.float)),
        inccount: s.field("incCount", S.array(S.float)),
        incsize: s.field("incSize", S.array(S.float)),
        deccount: s.field("decCount", S.array(S.float)),
        decsize: s.field("decSize", S.array(S.float)),
      })

    /**
     * charts/user/drive
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsUserDrive = (~body: getChartsUserDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUserDriveResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserDriveRequestSchema)

      fetch(
        ~url="/charts/user/drive",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsUserDriveResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsUserDriveRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      userid: string,
    }

    let postChartsUserDriveRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        userid: s.field("userId", S.string),
      })

    type postChartsUserDriveResponse = {
      totalcount: array<float>,
      totalsize: array<float>,
      inccount: array<float>,
      incsize: array<float>,
      deccount: array<float>,
      decsize: array<float>,
    }

    let postChartsUserDriveResponseSchema = S.object(s => {
        totalcount: s.field("totalCount", S.array(S.float)),
        totalsize: s.field("totalSize", S.array(S.float)),
        inccount: s.field("incCount", S.array(S.float)),
        incsize: s.field("incSize", S.array(S.float)),
        deccount: s.field("decCount", S.array(S.float)),
        decsize: s.field("decSize", S.array(S.float)),
      })

    /**
     * charts/user/drive
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsUserDrive = (~body: postChartsUserDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUserDriveResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserDriveRequestSchema)

      fetch(
        ~url="/charts/user/drive",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsUserDriveResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsUserFollowingRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      userid: string,
    }

    let getChartsUserFollowingRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        userid: s.field("userId", S.string),
      })

    type getChartsUserFollowingResponse = {
      local: JSON.t,
      remote: JSON.t,
    }

    let getChartsUserFollowingResponseSchema = S.object(s => {
        local: s.field("local", S.json),
        remote: s.field("remote", S.json),
      })

    /**
     * charts/user/following
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsUserFollowing = (~body: getChartsUserFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUserFollowingResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserFollowingRequestSchema)

      fetch(
        ~url="/charts/user/following",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsUserFollowingResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsUserFollowingRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      userid: string,
    }

    let postChartsUserFollowingRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        userid: s.field("userId", S.string),
      })

    type postChartsUserFollowingResponse = {
      local: JSON.t,
      remote: JSON.t,
    }

    let postChartsUserFollowingResponseSchema = S.object(s => {
        local: s.field("local", S.json),
        remote: s.field("remote", S.json),
      })

    /**
     * charts/user/following
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsUserFollowing = (~body: postChartsUserFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUserFollowingResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserFollowingRequestSchema)

      fetch(
        ~url="/charts/user/following",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsUserFollowingResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsUserNotesRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      userid: string,
    }

    let getChartsUserNotesRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        userid: s.field("userId", S.string),
      })

    type getChartsUserNotesResponse = {
      total: array<float>,
      inc: array<float>,
      dec: array<float>,
      diffs: JSON.t,
    }

    let getChartsUserNotesResponseSchema = S.object(s => {
        total: s.field("total", S.array(S.float)),
        inc: s.field("inc", S.array(S.float)),
        dec: s.field("dec", S.array(S.float)),
        diffs: s.field("diffs", S.json),
      })

    /**
     * charts/user/notes
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsUserNotes = (~body: getChartsUserNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUserNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserNotesRequestSchema)

      fetch(
        ~url="/charts/user/notes",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsUserNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsUserNotesRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      userid: string,
    }

    let postChartsUserNotesRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        userid: s.field("userId", S.string),
      })

    type postChartsUserNotesResponse = {
      total: array<float>,
      inc: array<float>,
      dec: array<float>,
      diffs: JSON.t,
    }

    let postChartsUserNotesResponseSchema = S.object(s => {
        total: s.field("total", S.array(S.float)),
        inc: s.field("inc", S.array(S.float)),
        dec: s.field("dec", S.array(S.float)),
        diffs: s.field("diffs", S.json),
      })

    /**
     * charts/user/notes
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsUserNotes = (~body: postChartsUserNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUserNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserNotesRequestSchema)

      fetch(
        ~url="/charts/user/notes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsUserNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsUserPvRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      userid: string,
    }

    let getChartsUserPvRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        userid: s.field("userId", S.string),
      })

    type getChartsUserPvResponse = {
      upv: JSON.t,
      pv: JSON.t,
    }

    let getChartsUserPvResponseSchema = S.object(s => {
        upv: s.field("upv", S.json),
        pv: s.field("pv", S.json),
      })

    /**
     * charts/user/pv
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsUserPv = (~body: getChartsUserPvRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUserPvResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserPvRequestSchema)

      fetch(
        ~url="/charts/user/pv",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsUserPvResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsUserPvRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      userid: string,
    }

    let postChartsUserPvRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        userid: s.field("userId", S.string),
      })

    type postChartsUserPvResponse = {
      upv: JSON.t,
      pv: JSON.t,
    }

    let postChartsUserPvResponseSchema = S.object(s => {
        upv: s.field("upv", S.json),
        pv: s.field("pv", S.json),
      })

    /**
     * charts/user/pv
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsUserPv = (~body: postChartsUserPvRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUserPvResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserPvRequestSchema)

      fetch(
        ~url="/charts/user/pv",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsUserPvResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsUserReactionsRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      userid: string,
    }

    let getChartsUserReactionsRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        userid: s.field("userId", S.string),
      })

    type getChartsUserReactionsResponse = {
      local: JSON.t,
      remote: JSON.t,
    }

    let getChartsUserReactionsResponseSchema = S.object(s => {
        local: s.field("local", S.json),
        remote: s.field("remote", S.json),
      })

    /**
     * charts/user/reactions
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsUserReactions = (~body: getChartsUserReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUserReactionsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserReactionsRequestSchema)

      fetch(
        ~url="/charts/user/reactions",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsUserReactionsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsUserReactionsRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
      userid: string,
    }

    let postChartsUserReactionsRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
        userid: s.field("userId", S.string),
      })

    type postChartsUserReactionsResponse = {
      local: JSON.t,
      remote: JSON.t,
    }

    let postChartsUserReactionsResponseSchema = S.object(s => {
        local: s.field("local", S.json),
        remote: s.field("remote", S.json),
      })

    /**
     * charts/user/reactions
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsUserReactions = (~body: postChartsUserReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUserReactionsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserReactionsRequestSchema)

      fetch(
        ~url="/charts/user/reactions",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsUserReactionsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getChartsUsersRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let getChartsUsersRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type getChartsUsersResponse = {
      local: JSON.t,
      remote: JSON.t,
    }

    let getChartsUsersResponseSchema = S.object(s => {
        local: s.field("local", S.json),
        remote: s.field("remote", S.json),
      })

    /**
     * charts/users
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getChartsUsers = (~body: getChartsUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUsersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUsersRequestSchema)

      fetch(
        ~url="/charts/users",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getChartsUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChartsUsersRequest = {
      span: string,
      limit: option<int>,
      offset: option<JSON.t>,
    }

    let postChartsUsersRequestSchema = S.object(s => {
        span: s.field("span", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
      })

    type postChartsUsersResponse = {
      local: JSON.t,
      remote: JSON.t,
    }

    let postChartsUsersResponseSchema = S.object(s => {
        local: s.field("local", S.json),
        remote: s.field("remote", S.json),
      })

    /**
     * charts/users
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postChartsUsers = (~body: postChartsUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUsersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUsersRequestSchema)

      fetch(
        ~url="/charts/users",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChartsUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatHistoryRequest = {
      limit: option<int>,
      room: option<bool>,
    }

    let postChatHistoryRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        room: s.fieldOr("room", S.nullableAsOption(S.bool), None),
      })

    type postChatHistoryResponse = array<ComponentSchemas.Chatmessage.t>

    let postChatHistoryResponseSchema = S.array(ComponentSchemas.Chatmessage.schema)

    /**
     * chat/history
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:chat*
     */
    let postChatHistory = (~body: postChatHistoryRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatHistoryResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatHistoryRequestSchema)

      fetch(
        ~url="/chat/history",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatHistoryResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatMessagesCreateToRoomRequest = {
      text: option<JSON.t>,
      fileid: option<string>,
      toroomid: string,
    }

    let postChatMessagesCreateToRoomRequestSchema = S.object(s => {
        text: s.fieldOr("text", S.nullableAsOption(S.json), None),
        fileid: s.fieldOr("fileId", S.nullableAsOption(S.string), None),
        toroomid: s.field("toRoomId", S.string),
      })

    type postChatMessagesCreateToRoomResponse = ComponentSchemas.Chatmessageliteforroom.t

    let postChatMessagesCreateToRoomResponseSchema = ComponentSchemas.Chatmessageliteforroom.schema

    /**
     * chat/messages/create-to-room
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatMessagesCreateToRoom = (~body: postChatMessagesCreateToRoomRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesCreateToRoomResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesCreateToRoomRequestSchema)

      fetch(
        ~url="/chat/messages/create-to-room",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatMessagesCreateToRoomResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatMessagesCreateToUserRequest = {
      text: option<JSON.t>,
      fileid: option<string>,
      touserid: string,
    }

    let postChatMessagesCreateToUserRequestSchema = S.object(s => {
        text: s.fieldOr("text", S.nullableAsOption(S.json), None),
        fileid: s.fieldOr("fileId", S.nullableAsOption(S.string), None),
        touserid: s.field("toUserId", S.string),
      })

    type postChatMessagesCreateToUserResponse = ComponentSchemas.Chatmessagelitefor1on1.t

    let postChatMessagesCreateToUserResponseSchema = ComponentSchemas.Chatmessagelitefor1on1.schema

    /**
     * chat/messages/create-to-user
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatMessagesCreateToUser = (~body: postChatMessagesCreateToUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesCreateToUserResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesCreateToUserRequestSchema)

      fetch(
        ~url="/chat/messages/create-to-user",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatMessagesCreateToUserResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatMessagesDeleteRequest = {
      messageid: string,
    }

    let postChatMessagesDeleteRequestSchema = S.object(s => {
        messageid: s.field("messageId", S.string),
      })

    type postChatMessagesDeleteResponse = unit

    /**
     * chat/messages/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatMessagesDelete = (~body: postChatMessagesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesDeleteRequestSchema)

      fetch(
        ~url="/chat/messages/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChatMessagesReactRequest = {
      messageid: string,
      reaction: string,
    }

    let postChatMessagesReactRequestSchema = S.object(s => {
        messageid: s.field("messageId", S.string),
        reaction: s.field("reaction", S.string),
      })

    type postChatMessagesReactResponse = unit

    /**
     * chat/messages/react
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatMessagesReact = (~body: postChatMessagesReactRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesReactResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesReactRequestSchema)

      fetch(
        ~url="/chat/messages/react",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChatMessagesRoomTimelineRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      roomid: string,
    }

    let postChatMessagesRoomTimelineRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        roomid: s.field("roomId", S.string),
      })

    type postChatMessagesRoomTimelineResponse = array<ComponentSchemas.Chatmessageliteforroom.t>

    let postChatMessagesRoomTimelineResponseSchema = S.array(ComponentSchemas.Chatmessageliteforroom.schema)

    /**
     * chat/messages/room-timeline
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:chat*
     */
    let postChatMessagesRoomTimeline = (~body: postChatMessagesRoomTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesRoomTimelineResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesRoomTimelineRequestSchema)

      fetch(
        ~url="/chat/messages/room-timeline",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatMessagesRoomTimelineResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatMessagesSearchRequest = {
      query: string,
      limit: option<int>,
      userid: option<JSON.t>,
      roomid: option<JSON.t>,
    }

    let postChatMessagesSearchRequestSchema = S.object(s => {
        query: s.field("query", S.string->S.min(1)->S.max(256)),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        userid: s.fieldOr("userId", S.nullableAsOption(S.json), None),
        roomid: s.fieldOr("roomId", S.nullableAsOption(S.json), None),
      })

    type postChatMessagesSearchResponse = array<ComponentSchemas.Chatmessage.t>

    let postChatMessagesSearchResponseSchema = S.array(ComponentSchemas.Chatmessage.schema)

    /**
     * chat/messages/search
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:chat*
     */
    let postChatMessagesSearch = (~body: postChatMessagesSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesSearchResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesSearchRequestSchema)

      fetch(
        ~url="/chat/messages/search",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatMessagesSearchResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatMessagesShowRequest = {
      messageid: string,
    }

    let postChatMessagesShowRequestSchema = S.object(s => {
        messageid: s.field("messageId", S.string),
      })

    type postChatMessagesShowResponse = ComponentSchemas.Chatmessage.t

    let postChatMessagesShowResponseSchema = ComponentSchemas.Chatmessage.schema

    /**
     * chat/messages/show
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:chat*
     */
    let postChatMessagesShow = (~body: postChatMessagesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesShowRequestSchema)

      fetch(
        ~url="/chat/messages/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatMessagesShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatMessagesUnreactRequest = {
      messageid: string,
      reaction: string,
    }

    let postChatMessagesUnreactRequestSchema = S.object(s => {
        messageid: s.field("messageId", S.string),
        reaction: s.field("reaction", S.string),
      })

    type postChatMessagesUnreactResponse = unit

    /**
     * chat/messages/unreact
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatMessagesUnreact = (~body: postChatMessagesUnreactRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesUnreactResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesUnreactRequestSchema)

      fetch(
        ~url="/chat/messages/unreact",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChatMessagesUserTimelineRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      userid: string,
    }

    let postChatMessagesUserTimelineRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        userid: s.field("userId", S.string),
      })

    type postChatMessagesUserTimelineResponse = array<ComponentSchemas.Chatmessagelitefor1on1.t>

    let postChatMessagesUserTimelineResponseSchema = S.array(ComponentSchemas.Chatmessagelitefor1on1.schema)

    /**
     * chat/messages/user-timeline
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:chat*
     */
    let postChatMessagesUserTimeline = (~body: postChatMessagesUserTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesUserTimelineResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesUserTimelineRequestSchema)

      fetch(
        ~url="/chat/messages/user-timeline",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatMessagesUserTimelineResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatReadAllResponse = unit

    /**
     * chat/read-all
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatReadAll = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatReadAllResponse> => {

      fetch(
        ~url="/chat/read-all",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChatRoomsCreateRequest = {
      name: string,
      description: option<string>,
    }

    let postChatRoomsCreateRequestSchema = S.object(s => {
        name: s.field("name", S.string->S.max(256)),
        description: s.fieldOr("description", S.nullableAsOption(S.string->S.max(1024)), None),
      })

    type postChatRoomsCreateResponse = ComponentSchemas.Chatroom.t

    let postChatRoomsCreateResponseSchema = ComponentSchemas.Chatroom.schema

    /**
     * chat/rooms/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatRoomsCreate = (~body: postChatRoomsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsCreateRequestSchema)

      fetch(
        ~url="/chat/rooms/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatRoomsCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatRoomsDeleteRequest = {
      roomid: string,
    }

    let postChatRoomsDeleteRequestSchema = S.object(s => {
        roomid: s.field("roomId", S.string),
      })

    type postChatRoomsDeleteResponse = unit

    /**
     * chat/rooms/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatRoomsDelete = (~body: postChatRoomsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsDeleteRequestSchema)

      fetch(
        ~url="/chat/rooms/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChatRoomsInvitationsCreateRequest = {
      roomid: string,
      userid: string,
    }

    let postChatRoomsInvitationsCreateRequestSchema = S.object(s => {
        roomid: s.field("roomId", S.string),
        userid: s.field("userId", S.string),
      })

    type postChatRoomsInvitationsCreateResponse = ComponentSchemas.Chatroominvitation.t

    let postChatRoomsInvitationsCreateResponseSchema = ComponentSchemas.Chatroominvitation.schema

    /**
     * chat/rooms/invitations/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatRoomsInvitationsCreate = (~body: postChatRoomsInvitationsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsInvitationsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsCreateRequestSchema)

      fetch(
        ~url="/chat/rooms/invitations/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatRoomsInvitationsCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatRoomsInvitationsIgnoreRequest = {
      roomid: string,
    }

    let postChatRoomsInvitationsIgnoreRequestSchema = S.object(s => {
        roomid: s.field("roomId", S.string),
      })

    type postChatRoomsInvitationsIgnoreResponse = unit

    /**
     * chat/rooms/invitations/ignore
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatRoomsInvitationsIgnore = (~body: postChatRoomsInvitationsIgnoreRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsInvitationsIgnoreResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsIgnoreRequestSchema)

      fetch(
        ~url="/chat/rooms/invitations/ignore",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChatRoomsInvitationsInboxRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postChatRoomsInvitationsInboxRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postChatRoomsInvitationsInboxResponse = array<ComponentSchemas.Chatroominvitation.t>

    let postChatRoomsInvitationsInboxResponseSchema = S.array(ComponentSchemas.Chatroominvitation.schema)

    /**
     * chat/rooms/invitations/inbox
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:chat*
     */
    let postChatRoomsInvitationsInbox = (~body: postChatRoomsInvitationsInboxRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsInvitationsInboxResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsInboxRequestSchema)

      fetch(
        ~url="/chat/rooms/invitations/inbox",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatRoomsInvitationsInboxResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatRoomsInvitationsOutboxRequest = {
      roomid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postChatRoomsInvitationsOutboxRequestSchema = S.object(s => {
        roomid: s.field("roomId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postChatRoomsInvitationsOutboxResponse = array<ComponentSchemas.Chatroominvitation.t>

    let postChatRoomsInvitationsOutboxResponseSchema = S.array(ComponentSchemas.Chatroominvitation.schema)

    /**
     * chat/rooms/invitations/outbox
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:chat*
     */
    let postChatRoomsInvitationsOutbox = (~body: postChatRoomsInvitationsOutboxRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsInvitationsOutboxResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsOutboxRequestSchema)

      fetch(
        ~url="/chat/rooms/invitations/outbox",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatRoomsInvitationsOutboxResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatRoomsJoinRequest = {
      roomid: string,
    }

    let postChatRoomsJoinRequestSchema = S.object(s => {
        roomid: s.field("roomId", S.string),
      })

    type postChatRoomsJoinResponse = unit

    /**
     * chat/rooms/join
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatRoomsJoin = (~body: postChatRoomsJoinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsJoinResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsJoinRequestSchema)

      fetch(
        ~url="/chat/rooms/join",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChatRoomsJoiningRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postChatRoomsJoiningRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postChatRoomsJoiningResponse = array<ComponentSchemas.Chatroommembership.t>

    let postChatRoomsJoiningResponseSchema = S.array(ComponentSchemas.Chatroommembership.schema)

    /**
     * chat/rooms/joining
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:chat*
     */
    let postChatRoomsJoining = (~body: postChatRoomsJoiningRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsJoiningResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsJoiningRequestSchema)

      fetch(
        ~url="/chat/rooms/joining",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatRoomsJoiningResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatRoomsLeaveRequest = {
      roomid: string,
    }

    let postChatRoomsLeaveRequestSchema = S.object(s => {
        roomid: s.field("roomId", S.string),
      })

    type postChatRoomsLeaveResponse = unit

    /**
     * chat/rooms/leave
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatRoomsLeave = (~body: postChatRoomsLeaveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsLeaveResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsLeaveRequestSchema)

      fetch(
        ~url="/chat/rooms/leave",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChatRoomsMembersRequest = {
      roomid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postChatRoomsMembersRequestSchema = S.object(s => {
        roomid: s.field("roomId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postChatRoomsMembersResponse = array<ComponentSchemas.Chatroommembership.t>

    let postChatRoomsMembersResponseSchema = S.array(ComponentSchemas.Chatroommembership.schema)

    /**
     * chat/rooms/members
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatRoomsMembers = (~body: postChatRoomsMembersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsMembersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsMembersRequestSchema)

      fetch(
        ~url="/chat/rooms/members",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatRoomsMembersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatRoomsMuteRequest = {
      roomid: string,
      mute: bool,
    }

    let postChatRoomsMuteRequestSchema = S.object(s => {
        roomid: s.field("roomId", S.string),
        mute: s.field("mute", S.bool),
      })

    type postChatRoomsMuteResponse = unit

    /**
     * chat/rooms/mute
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatRoomsMute = (~body: postChatRoomsMuteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsMuteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsMuteRequestSchema)

      fetch(
        ~url="/chat/rooms/mute",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postChatRoomsOwnedRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postChatRoomsOwnedRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postChatRoomsOwnedResponse = array<ComponentSchemas.Chatroom.t>

    let postChatRoomsOwnedResponseSchema = S.array(ComponentSchemas.Chatroom.schema)

    /**
     * chat/rooms/owned
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:chat*
     */
    let postChatRoomsOwned = (~body: postChatRoomsOwnedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsOwnedResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsOwnedRequestSchema)

      fetch(
        ~url="/chat/rooms/owned",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatRoomsOwnedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatRoomsShowRequest = {
      roomid: string,
    }

    let postChatRoomsShowRequestSchema = S.object(s => {
        roomid: s.field("roomId", S.string),
      })

    type postChatRoomsShowResponse = ComponentSchemas.Chatroom.t

    let postChatRoomsShowResponseSchema = ComponentSchemas.Chatroom.schema

    /**
     * chat/rooms/show
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:chat*
     */
    let postChatRoomsShow = (~body: postChatRoomsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsShowRequestSchema)

      fetch(
        ~url="/chat/rooms/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatRoomsShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postChatRoomsUpdateRequest = {
      roomid: string,
      name: option<string>,
      description: option<string>,
    }

    let postChatRoomsUpdateRequestSchema = S.object(s => {
        roomid: s.field("roomId", S.string),
        name: s.fieldOr("name", S.nullableAsOption(S.string->S.max(256)), None),
        description: s.fieldOr("description", S.nullableAsOption(S.string->S.max(1024)), None),
      })

    type postChatRoomsUpdateResponse = ComponentSchemas.Chatroom.t

    let postChatRoomsUpdateResponseSchema = ComponentSchemas.Chatroom.schema

    /**
     * chat/rooms/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:chat*
     */
    let postChatRoomsUpdate = (~body: postChatRoomsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsUpdateRequestSchema)

      fetch(
        ~url="/chat/rooms/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postChatRoomsUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postClipsAddNoteRequest = {
      clipid: string,
      noteid: string,
    }

    let postClipsAddNoteRequestSchema = S.object(s => {
        clipid: s.field("clipId", S.string),
        noteid: s.field("noteId", S.string),
      })

    type postClipsAddNoteResponse = unit

    /**
     * clips/add-note
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postClipsAddNote = (~body: postClipsAddNoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsAddNoteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsAddNoteRequestSchema)

      fetch(
        ~url="/clips/add-note",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postClipsCreateRequest = {
      name: string,
      ispublic: option<bool>,
      description: option<JSON.t>,
    }

    let postClipsCreateRequestSchema = S.object(s => {
        name: s.field("name", S.string->S.min(1)->S.max(100)),
        ispublic: s.fieldOr("isPublic", S.nullableAsOption(S.bool), None),
        description: s.fieldOr("description", S.nullableAsOption(S.json), None),
      })

    type postClipsCreateResponse = ComponentSchemas.Clip.t

    let postClipsCreateResponseSchema = ComponentSchemas.Clip.schema

    /**
     * clips/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postClipsCreate = (~body: postClipsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsCreateRequestSchema)

      fetch(
        ~url="/clips/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postClipsCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postClipsDeleteRequest = {
      clipid: string,
    }

    let postClipsDeleteRequestSchema = S.object(s => {
        clipid: s.field("clipId", S.string),
      })

    type postClipsDeleteResponse = unit

    /**
     * clips/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postClipsDelete = (~body: postClipsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsDeleteRequestSchema)

      fetch(
        ~url="/clips/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postClipsFavoriteRequest = {
      clipid: string,
    }

    let postClipsFavoriteRequestSchema = S.object(s => {
        clipid: s.field("clipId", S.string),
      })

    type postClipsFavoriteResponse = unit

    /**
     * clips/favorite
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:clip-favorite*
     */
    let postClipsFavorite = (~body: postClipsFavoriteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsFavoriteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsFavoriteRequestSchema)

      fetch(
        ~url="/clips/favorite",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postClipsListRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postClipsListRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postClipsListResponse = array<ComponentSchemas.Clip.t>

    let postClipsListResponseSchema = S.array(ComponentSchemas.Clip.schema)

    /**
     * clips/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postClipsList = (~body: postClipsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsListRequestSchema)

      fetch(
        ~url="/clips/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postClipsListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postClipsMyFavoritesResponse = array<ComponentSchemas.Clip.t>

    let postClipsMyFavoritesResponseSchema = S.array(ComponentSchemas.Clip.schema)

    /**
     * clips/my-favorites
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:clip-favorite*
     */
    let postClipsMyFavorites = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsMyFavoritesResponse> => {

      fetch(
        ~url="/clips/my-favorites",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postClipsMyFavoritesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postClipsNotesRequest = {
      clipid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      search: option<JSON.t>,
    }

    let postClipsNotesRequestSchema = S.object(s => {
        clipid: s.field("clipId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        search: s.fieldOr("search", S.nullableAsOption(S.json), None),
      })

    type postClipsNotesResponse = array<ComponentSchemas.Note.t>

    let postClipsNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * clips/notes
     *
     * No description provided.
     *
     * **Credential required**: *No* / **Permission**: *read:account*
     */
    let postClipsNotes = (~body: postClipsNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsNotesRequestSchema)

      fetch(
        ~url="/clips/notes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postClipsNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postClipsRemoveNoteRequest = {
      clipid: string,
      noteid: string,
    }

    let postClipsRemoveNoteRequestSchema = S.object(s => {
        clipid: s.field("clipId", S.string),
        noteid: s.field("noteId", S.string),
      })

    type postClipsRemoveNoteResponse = unit

    /**
     * clips/remove-note
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postClipsRemoveNote = (~body: postClipsRemoveNoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsRemoveNoteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsRemoveNoteRequestSchema)

      fetch(
        ~url="/clips/remove-note",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postClipsShowRequest = {
      clipid: string,
    }

    let postClipsShowRequestSchema = S.object(s => {
        clipid: s.field("clipId", S.string),
      })

    type postClipsShowResponse = ComponentSchemas.Clip.t

    let postClipsShowResponseSchema = ComponentSchemas.Clip.schema

    /**
     * clips/show
     *
     * No description provided.
     *
     * **Credential required**: *No* / **Permission**: *read:account*
     */
    let postClipsShow = (~body: postClipsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsShowRequestSchema)

      fetch(
        ~url="/clips/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postClipsShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postClipsUnfavoriteRequest = {
      clipid: string,
    }

    let postClipsUnfavoriteRequestSchema = S.object(s => {
        clipid: s.field("clipId", S.string),
      })

    type postClipsUnfavoriteResponse = unit

    /**
     * clips/unfavorite
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:clip-favorite*
     */
    let postClipsUnfavorite = (~body: postClipsUnfavoriteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsUnfavoriteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsUnfavoriteRequestSchema)

      fetch(
        ~url="/clips/unfavorite",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postClipsUpdateRequest = {
      clipid: string,
      name: option<string>,
      ispublic: option<bool>,
      description: option<JSON.t>,
    }

    let postClipsUpdateRequestSchema = S.object(s => {
        clipid: s.field("clipId", S.string),
        name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.max(100)), None),
        ispublic: s.fieldOr("isPublic", S.nullableAsOption(S.bool), None),
        description: s.fieldOr("description", S.nullableAsOption(S.json), None),
      })

    type postClipsUpdateResponse = ComponentSchemas.Clip.t

    let postClipsUpdateResponseSchema = ComponentSchemas.Clip.schema

    /**
     * clips/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postClipsUpdate = (~body: postClipsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsUpdateRequestSchema)

      fetch(
        ~url="/clips/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postClipsUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveResponse = {
      capacity: float,
      usage: float,
    }

    let postDriveResponseSchema = S.object(s => {
        capacity: s.field("capacity", S.float),
        usage: s.field("usage", S.float),
      })

    /**
     * drive
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDrive = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveResponse> => {

      fetch(
        ~url="/drive",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFilesRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      folderid: option<JSON.t>,
      @as("type") type_: option<JSON.t>,
      sort: option<JSON.t>,
    }

    let postDriveFilesRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        folderid: s.fieldOr("folderId", S.nullableAsOption(S.json), None),
        type_: s.fieldOr("type", S.nullableAsOption(S.json), None),
        sort: s.fieldOr("sort", S.nullableAsOption(S.json), None),
      })

    type postDriveFilesResponse = array<ComponentSchemas.Drivefile.t>

    let postDriveFilesResponseSchema = S.array(ComponentSchemas.Drivefile.schema)

    /**
     * drive/files
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDriveFiles = (~body: postDriveFilesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesRequestSchema)

      fetch(
        ~url="/drive/files",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFilesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFilesAttachedChatMessagesRequest = {
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
      fileid: string,
    }

    let postDriveFilesAttachedChatMessagesRequestSchema = S.object(s => {
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        fileid: s.field("fileId", S.string),
      })

    type postDriveFilesAttachedChatMessagesResponse = array<ComponentSchemas.Chatmessage.t>

    let postDriveFilesAttachedChatMessagesResponseSchema = S.array(ComponentSchemas.Chatmessage.schema)

    /**
     * drive/files/attached-chat-messages
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDriveFilesAttachedChatMessages = (~body: postDriveFilesAttachedChatMessagesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesAttachedChatMessagesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesAttachedChatMessagesRequestSchema)

      fetch(
        ~url="/drive/files/attached-chat-messages",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFilesAttachedChatMessagesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFilesAttachedNotesRequest = {
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
      fileid: string,
    }

    let postDriveFilesAttachedNotesRequestSchema = S.object(s => {
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        fileid: s.field("fileId", S.string),
      })

    type postDriveFilesAttachedNotesResponse = array<ComponentSchemas.Note.t>

    let postDriveFilesAttachedNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * drive/files/attached-notes
     *
     * Find the notes to which the given file is attached.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDriveFilesAttachedNotes = (~body: postDriveFilesAttachedNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesAttachedNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesAttachedNotesRequestSchema)

      fetch(
        ~url="/drive/files/attached-notes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFilesAttachedNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFilesCheckExistenceRequest = {
      md5: string,
    }

    let postDriveFilesCheckExistenceRequestSchema = S.object(s => {
        md5: s.field("md5", S.string),
      })

    type postDriveFilesCheckExistenceResponse = bool

    let postDriveFilesCheckExistenceResponseSchema = S.bool

    /**
     * drive/files/check-existence
     *
     * Check if a given file exists.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDriveFilesCheckExistence = (~body: postDriveFilesCheckExistenceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesCheckExistenceResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesCheckExistenceRequestSchema)

      fetch(
        ~url="/drive/files/check-existence",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFilesCheckExistenceResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFilesCreateRequest = {
      folderid: option<JSON.t>,
      name: option<JSON.t>,
      comment: option<JSON.t>,
      issensitive: option<bool>,
      force: option<bool>,
      file: string,
    }

    let postDriveFilesCreateRequestSchema = S.object(s => {
        folderid: s.fieldOr("folderId", S.nullableAsOption(S.json), None),
        name: s.fieldOr("name", S.nullableAsOption(S.json), None),
        comment: s.fieldOr("comment", S.nullableAsOption(S.json), None),
        issensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
        force: s.fieldOr("force", S.nullableAsOption(S.bool), None),
        file: s.field("file", S.string),
      })

    type postDriveFilesCreateResponse = ComponentSchemas.Drivefile.t

    let postDriveFilesCreateResponseSchema = ComponentSchemas.Drivefile.schema

    /**
     * drive/files/create
     *
     * Upload a new drive file.
     *
     * **Credential required**: *Yes* / **Permission**: *write:drive*
     */
    let postDriveFilesCreate = (~body: postDriveFilesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesCreateRequestSchema)

      fetch(
        ~url="/drive/files/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFilesCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFilesDeleteRequest = {
      fileid: string,
    }

    let postDriveFilesDeleteRequestSchema = S.object(s => {
        fileid: s.field("fileId", S.string),
      })

    type postDriveFilesDeleteResponse = unit

    /**
     * drive/files/delete
     *
     * Delete an existing drive file.
     *
     * **Credential required**: *Yes* / **Permission**: *write:drive*
     */
    let postDriveFilesDelete = (~body: postDriveFilesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesDeleteRequestSchema)

      fetch(
        ~url="/drive/files/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postDriveFilesFindRequest = {
      name: string,
      folderid: option<JSON.t>,
    }

    let postDriveFilesFindRequestSchema = S.object(s => {
        name: s.field("name", S.string),
        folderid: s.fieldOr("folderId", S.nullableAsOption(S.json), None),
      })

    type postDriveFilesFindResponse = array<ComponentSchemas.Drivefile.t>

    let postDriveFilesFindResponseSchema = S.array(ComponentSchemas.Drivefile.schema)

    /**
     * drive/files/find
     *
     * Search for a drive file by the given parameters.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDriveFilesFind = (~body: postDriveFilesFindRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesFindResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesFindRequestSchema)

      fetch(
        ~url="/drive/files/find",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFilesFindResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFilesFindByHashRequest = {
      md5: string,
    }

    let postDriveFilesFindByHashRequestSchema = S.object(s => {
        md5: s.field("md5", S.string),
      })

    type postDriveFilesFindByHashResponse = array<ComponentSchemas.Drivefile.t>

    let postDriveFilesFindByHashResponseSchema = S.array(ComponentSchemas.Drivefile.schema)

    /**
     * drive/files/find-by-hash
     *
     * Search for a drive file by a hash of the contents.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDriveFilesFindByHash = (~body: postDriveFilesFindByHashRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesFindByHashResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesFindByHashRequestSchema)

      fetch(
        ~url="/drive/files/find-by-hash",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFilesFindByHashResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFilesMoveBulkRequest = {
      fileids: array<string>,
      folderid: option<JSON.t>,
    }

    let postDriveFilesMoveBulkRequestSchema = S.object(s => {
        fileids: s.field("fileIds", S.array(S.string)),
        folderid: s.fieldOr("folderId", S.nullableAsOption(S.json), None),
      })

    type postDriveFilesMoveBulkResponse = unit

    /**
     * drive/files/move-bulk
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:drive*
     */
    let postDriveFilesMoveBulk = (~body: postDriveFilesMoveBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesMoveBulkResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesMoveBulkRequestSchema)

      fetch(
        ~url="/drive/files/move-bulk",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postDriveFilesShowRequest = JSON.t

    let postDriveFilesShowRequestSchema = S.json

    type postDriveFilesShowResponse = ComponentSchemas.Drivefile.t

    let postDriveFilesShowResponseSchema = ComponentSchemas.Drivefile.schema

    /**
     * drive/files/show
     *
     * Show the properties of a drive file.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDriveFilesShow = (~body: postDriveFilesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesShowRequestSchema)

      fetch(
        ~url="/drive/files/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFilesShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFilesUpdateRequest = {
      fileid: string,
      folderid: option<JSON.t>,
      name: option<string>,
      issensitive: option<bool>,
      comment: option<JSON.t>,
    }

    let postDriveFilesUpdateRequestSchema = S.object(s => {
        fileid: s.field("fileId", S.string),
        folderid: s.fieldOr("folderId", S.nullableAsOption(S.json), None),
        name: s.fieldOr("name", S.nullableAsOption(S.string), None),
        issensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
        comment: s.fieldOr("comment", S.nullableAsOption(S.json), None),
      })

    type postDriveFilesUpdateResponse = ComponentSchemas.Drivefile.t

    let postDriveFilesUpdateResponseSchema = ComponentSchemas.Drivefile.schema

    /**
     * drive/files/update
     *
     * Update the properties of a drive file.
     *
     * **Credential required**: *Yes* / **Permission**: *write:drive*
     */
    let postDriveFilesUpdate = (~body: postDriveFilesUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesUpdateRequestSchema)

      fetch(
        ~url="/drive/files/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFilesUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFilesUploadFromUrlRequest = {
      url: string,
      folderid: option<JSON.t>,
      issensitive: option<bool>,
      comment: option<JSON.t>,
      marker: option<JSON.t>,
      force: option<bool>,
    }

    let postDriveFilesUploadFromUrlRequestSchema = S.object(s => {
        url: s.field("url", S.string),
        folderid: s.fieldOr("folderId", S.nullableAsOption(S.json), None),
        issensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
        comment: s.fieldOr("comment", S.nullableAsOption(S.json), None),
        marker: s.fieldOr("marker", S.nullableAsOption(S.json), None),
        force: s.fieldOr("force", S.nullableAsOption(S.bool), None),
      })

    type postDriveFilesUploadFromUrlResponse = unit

    /**
     * drive/files/upload-from-url
     *
     * Request the server to download a new drive file from the specified URL.
     *
     * **Credential required**: *Yes* / **Permission**: *write:drive*
     */
    let postDriveFilesUploadFromUrl = (~body: postDriveFilesUploadFromUrlRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFilesUploadFromUrlResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesUploadFromUrlRequestSchema)

      fetch(
        ~url="/drive/files/upload-from-url",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postDriveFoldersRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      folderid: option<JSON.t>,
    }

    let postDriveFoldersRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        folderid: s.fieldOr("folderId", S.nullableAsOption(S.json), None),
      })

    type postDriveFoldersResponse = array<ComponentSchemas.Drivefolder.t>

    let postDriveFoldersResponseSchema = S.array(ComponentSchemas.Drivefolder.schema)

    /**
     * drive/folders
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDriveFolders = (~body: postDriveFoldersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFoldersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersRequestSchema)

      fetch(
        ~url="/drive/folders",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFoldersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFoldersCreateRequest = {
      name: option<string>,
      parentid: option<JSON.t>,
    }

    let postDriveFoldersCreateRequestSchema = S.object(s => {
        name: s.fieldOr("name", S.nullableAsOption(S.string->S.max(200)), None),
        parentid: s.fieldOr("parentId", S.nullableAsOption(S.json), None),
      })

    type postDriveFoldersCreateResponse = ComponentSchemas.Drivefolder.t

    let postDriveFoldersCreateResponseSchema = ComponentSchemas.Drivefolder.schema

    /**
     * drive/folders/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:drive*
     */
    let postDriveFoldersCreate = (~body: postDriveFoldersCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFoldersCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersCreateRequestSchema)

      fetch(
        ~url="/drive/folders/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFoldersCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFoldersDeleteRequest = {
      folderid: string,
    }

    let postDriveFoldersDeleteRequestSchema = S.object(s => {
        folderid: s.field("folderId", S.string),
      })

    type postDriveFoldersDeleteResponse = unit

    /**
     * drive/folders/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:drive*
     */
    let postDriveFoldersDelete = (~body: postDriveFoldersDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFoldersDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersDeleteRequestSchema)

      fetch(
        ~url="/drive/folders/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postDriveFoldersFindRequest = {
      name: string,
      parentid: option<JSON.t>,
    }

    let postDriveFoldersFindRequestSchema = S.object(s => {
        name: s.field("name", S.string),
        parentid: s.fieldOr("parentId", S.nullableAsOption(S.json), None),
      })

    type postDriveFoldersFindResponse = array<ComponentSchemas.Drivefolder.t>

    let postDriveFoldersFindResponseSchema = S.array(ComponentSchemas.Drivefolder.schema)

    /**
     * drive/folders/find
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDriveFoldersFind = (~body: postDriveFoldersFindRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFoldersFindResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersFindRequestSchema)

      fetch(
        ~url="/drive/folders/find",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFoldersFindResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFoldersShowRequest = {
      folderid: string,
    }

    let postDriveFoldersShowRequestSchema = S.object(s => {
        folderid: s.field("folderId", S.string),
      })

    type postDriveFoldersShowResponse = ComponentSchemas.Drivefolder.t

    let postDriveFoldersShowResponseSchema = ComponentSchemas.Drivefolder.schema

    /**
     * drive/folders/show
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDriveFoldersShow = (~body: postDriveFoldersShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFoldersShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersShowRequestSchema)

      fetch(
        ~url="/drive/folders/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFoldersShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveFoldersUpdateRequest = {
      folderid: string,
      name: option<string>,
      parentid: option<JSON.t>,
    }

    let postDriveFoldersUpdateRequestSchema = S.object(s => {
        folderid: s.field("folderId", S.string),
        name: s.fieldOr("name", S.nullableAsOption(S.string->S.max(200)), None),
        parentid: s.fieldOr("parentId", S.nullableAsOption(S.json), None),
      })

    type postDriveFoldersUpdateResponse = ComponentSchemas.Drivefolder.t

    let postDriveFoldersUpdateResponseSchema = ComponentSchemas.Drivefolder.schema

    /**
     * drive/folders/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:drive*
     */
    let postDriveFoldersUpdate = (~body: postDriveFoldersUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveFoldersUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersUpdateRequestSchema)

      fetch(
        ~url="/drive/folders/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveFoldersUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postDriveStreamRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      @as("type") type_: option<string>,
    }

    let postDriveStreamRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        type_: s.fieldOr("type", S.nullableAsOption(S.string->S.pattern(%re("/^[a-zA-Z\\/\\-*]+$/"))), None),
      })

    type postDriveStreamResponse = array<ComponentSchemas.Drivefile.t>

    let postDriveStreamResponseSchema = S.array(ComponentSchemas.Drivefile.schema)

    /**
     * drive/stream
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:drive*
     */
    let postDriveStream = (~body: postDriveStreamRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postDriveStreamResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveStreamRequestSchema)

      fetch(
        ~url="/drive/stream",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postDriveStreamResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postEmailAddressAvailableRequest = {
      emailaddress: string,
    }

    let postEmailAddressAvailableRequestSchema = S.object(s => {
        emailaddress: s.field("emailAddress", S.string),
      })

    type postEmailAddressAvailableResponse = {
      available: bool,
      reason: JSON.t,
    }

    let postEmailAddressAvailableResponseSchema = S.object(s => {
        available: s.field("available", S.bool),
        reason: s.field("reason", S.json),
      })

    /**
     * email-address/available
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postEmailAddressAvailable = (~body: postEmailAddressAvailableRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEmailAddressAvailableResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postEmailAddressAvailableRequestSchema)

      fetch(
        ~url="/email-address/available",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postEmailAddressAvailableResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getEmojiRequest = {
      name: string,
    }

    let getEmojiRequestSchema = S.object(s => {
        name: s.field("name", S.string),
      })

    type getEmojiResponse = ComponentSchemas.Emojidetailed.t

    let getEmojiResponseSchema = ComponentSchemas.Emojidetailed.schema

    /**
     * emoji
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getEmoji = (~body: getEmojiRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getEmojiResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getEmojiRequestSchema)

      fetch(
        ~url="/emoji",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getEmojiResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postEmojiRequest = {
      name: string,
    }

    let postEmojiRequestSchema = S.object(s => {
        name: s.field("name", S.string),
      })

    type postEmojiResponse = ComponentSchemas.Emojidetailed.t

    let postEmojiResponseSchema = ComponentSchemas.Emojidetailed.schema

    /**
     * emoji
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postEmoji = (~body: postEmojiRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEmojiResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postEmojiRequestSchema)

      fetch(
        ~url="/emoji",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postEmojiResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getEmojisResponse = {
      emojis: array<ComponentSchemas.Emojisimple.t>,
    }

    let getEmojisResponseSchema = S.object(s => {
        emojis: s.field("emojis", S.array(ComponentSchemas.Emojisimple.schema)),
      })

    /**
     * emojis
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getEmojis = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getEmojisResponse> => {

      fetch(
        ~url="/emojis",
        ~method_="GET",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getEmojisResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postEmojisResponse = {
      emojis: array<ComponentSchemas.Emojisimple.t>,
    }

    let postEmojisResponseSchema = S.object(s => {
        emojis: s.field("emojis", S.array(ComponentSchemas.Emojisimple.schema)),
      })

    /**
     * emojis
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postEmojis = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEmojisResponse> => {

      fetch(
        ~url="/emojis",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postEmojisResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postEndpointRequest = {
      endpoint: string,
    }

    let postEndpointRequestSchema = S.object(s => {
        endpoint: s.field("endpoint", S.string),
      })

    type postEndpointResponse = JSON.t

    let postEndpointResponseSchema = S.json

    /**
     * endpoint
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postEndpoint = (~body: postEndpointRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEndpointResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postEndpointRequestSchema)

      fetch(
        ~url="/endpoint",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postEndpointResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postEndpointsResponse = array<string>

    let postEndpointsResponseSchema = S.array(S.string)

    /**
     * endpoints
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postEndpoints = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEndpointsResponse> => {

      fetch(
        ~url="/endpoints",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postEndpointsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postExportCustomEmojisResponse = unit

    /**
     * export-custom-emojis
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postExportCustomEmojis = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postExportCustomEmojisResponse> => {

      fetch(
        ~url="/export-custom-emojis",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postFederationFollowersRequest = {
      host: string,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postFederationFollowersRequestSchema = S.object(s => {
        host: s.field("host", S.string),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postFederationFollowersResponse = array<ComponentSchemas.Following.t>

    let postFederationFollowersResponseSchema = S.array(ComponentSchemas.Following.schema)

    /**
     * federation/followers
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postFederationFollowers = (~body: postFederationFollowersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationFollowersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationFollowersRequestSchema)

      fetch(
        ~url="/federation/followers",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFederationFollowersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFederationFollowingRequest = {
      host: string,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postFederationFollowingRequestSchema = S.object(s => {
        host: s.field("host", S.string),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postFederationFollowingResponse = array<ComponentSchemas.Following.t>

    let postFederationFollowingResponseSchema = S.array(ComponentSchemas.Following.schema)

    /**
     * federation/following
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postFederationFollowing = (~body: postFederationFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationFollowingResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationFollowingRequestSchema)

      fetch(
        ~url="/federation/following",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFederationFollowingResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getFederationInstancesRequest = {
      host: option<JSON.t>,
      blocked: option<JSON.t>,
      notresponding: option<JSON.t>,
      suspended: option<JSON.t>,
      silenced: option<JSON.t>,
      federating: option<JSON.t>,
      subscribing: option<JSON.t>,
      publishing: option<JSON.t>,
      limit: option<int>,
      offset: option<int>,
      sort: option<JSON.t>,
    }

    let getFederationInstancesRequestSchema = S.object(s => {
        host: s.fieldOr("host", S.nullableAsOption(S.json), None),
        blocked: s.fieldOr("blocked", S.nullableAsOption(S.json), None),
        notresponding: s.fieldOr("notResponding", S.nullableAsOption(S.json), None),
        suspended: s.fieldOr("suspended", S.nullableAsOption(S.json), None),
        silenced: s.fieldOr("silenced", S.nullableAsOption(S.json), None),
        federating: s.fieldOr("federating", S.nullableAsOption(S.json), None),
        subscribing: s.fieldOr("subscribing", S.nullableAsOption(S.json), None),
        publishing: s.fieldOr("publishing", S.nullableAsOption(S.json), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
        sort: s.fieldOr("sort", S.nullableAsOption(S.json), None),
      })

    type getFederationInstancesResponse = array<ComponentSchemas.Federationinstance.t>

    let getFederationInstancesResponseSchema = S.array(ComponentSchemas.Federationinstance.schema)

    /**
     * federation/instances
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getFederationInstances = (~body: getFederationInstancesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getFederationInstancesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getFederationInstancesRequestSchema)

      fetch(
        ~url="/federation/instances",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getFederationInstancesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFederationInstancesRequest = {
      host: option<JSON.t>,
      blocked: option<JSON.t>,
      notresponding: option<JSON.t>,
      suspended: option<JSON.t>,
      silenced: option<JSON.t>,
      federating: option<JSON.t>,
      subscribing: option<JSON.t>,
      publishing: option<JSON.t>,
      limit: option<int>,
      offset: option<int>,
      sort: option<JSON.t>,
    }

    let postFederationInstancesRequestSchema = S.object(s => {
        host: s.fieldOr("host", S.nullableAsOption(S.json), None),
        blocked: s.fieldOr("blocked", S.nullableAsOption(S.json), None),
        notresponding: s.fieldOr("notResponding", S.nullableAsOption(S.json), None),
        suspended: s.fieldOr("suspended", S.nullableAsOption(S.json), None),
        silenced: s.fieldOr("silenced", S.nullableAsOption(S.json), None),
        federating: s.fieldOr("federating", S.nullableAsOption(S.json), None),
        subscribing: s.fieldOr("subscribing", S.nullableAsOption(S.json), None),
        publishing: s.fieldOr("publishing", S.nullableAsOption(S.json), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
        sort: s.fieldOr("sort", S.nullableAsOption(S.json), None),
      })

    type postFederationInstancesResponse = array<ComponentSchemas.Federationinstance.t>

    let postFederationInstancesResponseSchema = S.array(ComponentSchemas.Federationinstance.schema)

    /**
     * federation/instances
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postFederationInstances = (~body: postFederationInstancesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationInstancesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationInstancesRequestSchema)

      fetch(
        ~url="/federation/instances",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFederationInstancesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFederationShowInstanceRequest = {
      host: string,
    }

    let postFederationShowInstanceRequestSchema = S.object(s => {
        host: s.field("host", S.string),
      })

    type postFederationShowInstanceResponse = JSON.t

    let postFederationShowInstanceResponseSchema = S.json

    /**
     * federation/show-instance
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postFederationShowInstance = (~body: postFederationShowInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationShowInstanceResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationShowInstanceRequestSchema)

      fetch(
        ~url="/federation/show-instance",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFederationShowInstanceResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getFederationStatsRequest = {
      limit: option<int>,
    }

    let getFederationStatsRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type getFederationStatsResponse = {
      topsubinstances: array<ComponentSchemas.Federationinstance.t>,
      otherfollowerscount: float,
      toppubinstances: array<ComponentSchemas.Federationinstance.t>,
      otherfollowingcount: float,
    }

    let getFederationStatsResponseSchema = S.object(s => {
        topsubinstances: s.field("topSubInstances", S.array(ComponentSchemas.Federationinstance.schema)),
        otherfollowerscount: s.field("otherFollowersCount", S.float),
        toppubinstances: s.field("topPubInstances", S.array(ComponentSchemas.Federationinstance.schema)),
        otherfollowingcount: s.field("otherFollowingCount", S.float),
      })

    /**
     * federation/stats
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getFederationStats = (~body: getFederationStatsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getFederationStatsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getFederationStatsRequestSchema)

      fetch(
        ~url="/federation/stats",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getFederationStatsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFederationStatsRequest = {
      limit: option<int>,
    }

    let postFederationStatsRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postFederationStatsResponse = {
      topsubinstances: array<ComponentSchemas.Federationinstance.t>,
      otherfollowerscount: float,
      toppubinstances: array<ComponentSchemas.Federationinstance.t>,
      otherfollowingcount: float,
    }

    let postFederationStatsResponseSchema = S.object(s => {
        topsubinstances: s.field("topSubInstances", S.array(ComponentSchemas.Federationinstance.schema)),
        otherfollowerscount: s.field("otherFollowersCount", S.float),
        toppubinstances: s.field("topPubInstances", S.array(ComponentSchemas.Federationinstance.schema)),
        otherfollowingcount: s.field("otherFollowingCount", S.float),
      })

    /**
     * federation/stats
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postFederationStats = (~body: postFederationStatsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationStatsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationStatsRequestSchema)

      fetch(
        ~url="/federation/stats",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFederationStatsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFederationUpdateRemoteUserRequest = {
      userid: string,
    }

    let postFederationUpdateRemoteUserRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postFederationUpdateRemoteUserResponse = unit

    /**
     * federation/update-remote-user
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postFederationUpdateRemoteUser = (~body: postFederationUpdateRemoteUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationUpdateRemoteUserResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationUpdateRemoteUserRequestSchema)

      fetch(
        ~url="/federation/update-remote-user",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postFederationUsersRequest = {
      host: string,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postFederationUsersRequestSchema = S.object(s => {
        host: s.field("host", S.string),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postFederationUsersResponse = array<ComponentSchemas.Userdetailednotme.t>

    let postFederationUsersResponseSchema = S.array(ComponentSchemas.Userdetailednotme.schema)

    /**
     * federation/users
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postFederationUsers = (~body: postFederationUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationUsersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationUsersRequestSchema)

      fetch(
        ~url="/federation/users",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFederationUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFetchExternalResourcesRequest = {
      url: string,
      hash: string,
    }

    let postFetchExternalResourcesRequestSchema = S.object(s => {
        url: s.field("url", S.string),
        hash: s.field("hash", S.string),
      })

    type postFetchExternalResourcesResponse = {
      @as("type") type_: string,
      data: string,
    }

    let postFetchExternalResourcesResponseSchema = S.object(s => {
        type_: s.field("type", S.string),
        data: s.field("data", S.string),
      })

    /**
     * fetch-external-resources
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postFetchExternalResources = (~body: postFetchExternalResourcesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFetchExternalResourcesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFetchExternalResourcesRequestSchema)

      fetch(
        ~url="/fetch-external-resources",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFetchExternalResourcesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getFetchRssRequest = {
      url: string,
    }

    let getFetchRssRequestSchema = S.object(s => {
        url: s.field("url", S.string),
      })

    type getFetchRssResponse = {
      image: option<JSON.t>,
      paginationlinks: option<JSON.t>,
      link: option<string>,
      title: option<string>,
      items: array<JSON.t>,
      feedurl: option<string>,
      description: option<string>,
      itunes: option<JSON.t>,
    }

    let getFetchRssResponseSchema = S.object(s => {
        image: s.fieldOr("image", S.nullableAsOption(S.json), None),
        paginationlinks: s.fieldOr("paginationLinks", S.nullableAsOption(S.json), None),
        link: s.fieldOr("link", S.nullableAsOption(S.string), None),
        title: s.fieldOr("title", S.nullableAsOption(S.string), None),
        items: s.field("items", S.array(S.json)),
        feedurl: s.fieldOr("feedUrl", S.nullableAsOption(S.string), None),
        description: s.fieldOr("description", S.nullableAsOption(S.string), None),
        itunes: s.fieldOr("itunes", S.nullableAsOption(S.json), None),
      })

    /**
     * fetch-rss
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getFetchRss = (~body: getFetchRssRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getFetchRssResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getFetchRssRequestSchema)

      fetch(
        ~url="/fetch-rss",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getFetchRssResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFetchRssRequest = {
      url: string,
    }

    let postFetchRssRequestSchema = S.object(s => {
        url: s.field("url", S.string),
      })

    type postFetchRssResponse = {
      image: option<JSON.t>,
      paginationlinks: option<JSON.t>,
      link: option<string>,
      title: option<string>,
      items: array<JSON.t>,
      feedurl: option<string>,
      description: option<string>,
      itunes: option<JSON.t>,
    }

    let postFetchRssResponseSchema = S.object(s => {
        image: s.fieldOr("image", S.nullableAsOption(S.json), None),
        paginationlinks: s.fieldOr("paginationLinks", S.nullableAsOption(S.json), None),
        link: s.fieldOr("link", S.nullableAsOption(S.string), None),
        title: s.fieldOr("title", S.nullableAsOption(S.string), None),
        items: s.field("items", S.array(S.json)),
        feedurl: s.fieldOr("feedUrl", S.nullableAsOption(S.string), None),
        description: s.fieldOr("description", S.nullableAsOption(S.string), None),
        itunes: s.fieldOr("itunes", S.nullableAsOption(S.json), None),
      })

    /**
     * fetch-rss
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postFetchRss = (~body: postFetchRssRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFetchRssResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFetchRssRequestSchema)

      fetch(
        ~url="/fetch-rss",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFetchRssResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFlashCreateRequest = {
      title: string,
      summary: string,
      script: string,
      permissions: array<string>,
      visibility: option<string>,
    }

    let postFlashCreateRequestSchema = S.object(s => {
        title: s.field("title", S.string),
        summary: s.field("summary", S.string),
        script: s.field("script", S.string),
        permissions: s.field("permissions", S.array(S.string)),
        visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
      })

    type postFlashCreateResponse = ComponentSchemas.Flash.t

    let postFlashCreateResponseSchema = ComponentSchemas.Flash.schema

    /**
     * flash/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:flash*
     */
    let postFlashCreate = (~body: postFlashCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashCreateRequestSchema)

      fetch(
        ~url="/flash/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFlashCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFlashDeleteRequest = {
      flashid: string,
    }

    let postFlashDeleteRequestSchema = S.object(s => {
        flashid: s.field("flashId", S.string),
      })

    type postFlashDeleteResponse = unit

    /**
     * flash/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:flash*
     */
    let postFlashDelete = (~body: postFlashDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashDeleteRequestSchema)

      fetch(
        ~url="/flash/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postFlashFeaturedRequest = {
      offset: option<int>,
      limit: option<int>,
    }

    let postFlashFeaturedRequestSchema = S.object(s => {
        offset: s.fieldOr("offset", S.nullableAsOption(S.int->S.min(0)), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postFlashFeaturedResponse = array<ComponentSchemas.Flash.t>

    let postFlashFeaturedResponseSchema = S.array(ComponentSchemas.Flash.schema)

    /**
     * flash/featured
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postFlashFeatured = (~body: postFlashFeaturedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashFeaturedResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashFeaturedRequestSchema)

      fetch(
        ~url="/flash/featured",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFlashFeaturedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFlashLikeRequest = {
      flashid: string,
    }

    let postFlashLikeRequestSchema = S.object(s => {
        flashid: s.field("flashId", S.string),
      })

    type postFlashLikeResponse = unit

    /**
     * flash/like
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:flash-likes*
     */
    let postFlashLike = (~body: postFlashLikeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashLikeResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashLikeRequestSchema)

      fetch(
        ~url="/flash/like",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postFlashMyRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postFlashMyRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postFlashMyResponse = array<ComponentSchemas.Flash.t>

    let postFlashMyResponseSchema = S.array(ComponentSchemas.Flash.schema)

    /**
     * flash/my
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:flash*
     */
    let postFlashMy = (~body: postFlashMyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashMyResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashMyRequestSchema)

      fetch(
        ~url="/flash/my",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFlashMyResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFlashMyLikesRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      search: option<JSON.t>,
    }

    let postFlashMyLikesRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        search: s.fieldOr("search", S.nullableAsOption(S.json), None),
      })

    type postFlashMyLikesResponse = array<JSON.t>

    let postFlashMyLikesResponseSchema = S.array(S.json)

    /**
     * flash/my-likes
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:flash-likes*
     */
    let postFlashMyLikes = (~body: postFlashMyLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashMyLikesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashMyLikesRequestSchema)

      fetch(
        ~url="/flash/my-likes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFlashMyLikesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFlashSearchRequest = {
      query: string,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postFlashSearchRequestSchema = S.object(s => {
        query: s.field("query", S.string->S.min(1)->S.max(100)),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postFlashSearchResponse = array<ComponentSchemas.Flash.t>

    let postFlashSearchResponseSchema = S.array(ComponentSchemas.Flash.schema)

    /**
     * flash/search
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postFlashSearch = (~body: postFlashSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashSearchResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashSearchRequestSchema)

      fetch(
        ~url="/flash/search",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFlashSearchResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFlashShowRequest = {
      flashid: string,
    }

    let postFlashShowRequestSchema = S.object(s => {
        flashid: s.field("flashId", S.string),
      })

    type postFlashShowResponse = ComponentSchemas.Flash.t

    let postFlashShowResponseSchema = ComponentSchemas.Flash.schema

    /**
     * flash/show
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postFlashShow = (~body: postFlashShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashShowRequestSchema)

      fetch(
        ~url="/flash/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFlashShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFlashUnlikeRequest = {
      flashid: string,
    }

    let postFlashUnlikeRequestSchema = S.object(s => {
        flashid: s.field("flashId", S.string),
      })

    type postFlashUnlikeResponse = unit

    /**
     * flash/unlike
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:flash-likes*
     */
    let postFlashUnlike = (~body: postFlashUnlikeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashUnlikeResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashUnlikeRequestSchema)

      fetch(
        ~url="/flash/unlike",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postFlashUpdateRequest = {
      flashid: string,
      title: option<string>,
      summary: option<string>,
      script: option<string>,
      permissions: option<array<string>>,
      visibility: option<string>,
    }

    let postFlashUpdateRequestSchema = S.object(s => {
        flashid: s.field("flashId", S.string),
        title: s.fieldOr("title", S.nullableAsOption(S.string), None),
        summary: s.fieldOr("summary", S.nullableAsOption(S.string), None),
        script: s.fieldOr("script", S.nullableAsOption(S.string), None),
        permissions: s.fieldOr("permissions", S.nullableAsOption(S.array(S.string)), None),
        visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
      })

    type postFlashUpdateResponse = unit

    /**
     * flash/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:flash*
     */
    let postFlashUpdate = (~body: postFlashUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashUpdateRequestSchema)

      fetch(
        ~url="/flash/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postFollowingCreateRequest = {
      userid: string,
      withreplies: option<bool>,
    }

    let postFollowingCreateRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
      })

    type postFollowingCreateResponse = ComponentSchemas.Userlite.t

    let postFollowingCreateResponseSchema = ComponentSchemas.Userlite.schema

    /**
     * following/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:following*
     */
    let postFollowingCreate = (~body: postFollowingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingCreateRequestSchema)

      fetch(
        ~url="/following/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFollowingCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFollowingDeleteRequest = {
      userid: string,
    }

    let postFollowingDeleteRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postFollowingDeleteResponse = ComponentSchemas.Userlite.t

    let postFollowingDeleteResponseSchema = ComponentSchemas.Userlite.schema

    /**
     * following/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:following*
     */
    let postFollowingDelete = (~body: postFollowingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingDeleteRequestSchema)

      fetch(
        ~url="/following/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFollowingDeleteResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFollowingInvalidateRequest = {
      userid: string,
    }

    let postFollowingInvalidateRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postFollowingInvalidateResponse = ComponentSchemas.Userlite.t

    let postFollowingInvalidateResponseSchema = ComponentSchemas.Userlite.schema

    /**
     * following/invalidate
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:following*
     */
    let postFollowingInvalidate = (~body: postFollowingInvalidateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingInvalidateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingInvalidateRequestSchema)

      fetch(
        ~url="/following/invalidate",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFollowingInvalidateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFollowingRequestsAcceptRequest = {
      userid: string,
    }

    let postFollowingRequestsAcceptRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postFollowingRequestsAcceptResponse = unit

    /**
     * following/requests/accept
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:following*
     */
    let postFollowingRequestsAccept = (~body: postFollowingRequestsAcceptRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingRequestsAcceptResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsAcceptRequestSchema)

      fetch(
        ~url="/following/requests/accept",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postFollowingRequestsCancelRequest = {
      userid: string,
    }

    let postFollowingRequestsCancelRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postFollowingRequestsCancelResponse = ComponentSchemas.Userlite.t

    let postFollowingRequestsCancelResponseSchema = ComponentSchemas.Userlite.schema

    /**
     * following/requests/cancel
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:following*
     */
    let postFollowingRequestsCancel = (~body: postFollowingRequestsCancelRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingRequestsCancelResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsCancelRequestSchema)

      fetch(
        ~url="/following/requests/cancel",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFollowingRequestsCancelResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFollowingRequestsListRequest = {
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postFollowingRequestsListRequestSchema = S.object(s => {
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postFollowingRequestsListResponse = array<JSON.t>

    let postFollowingRequestsListResponseSchema = S.array(S.json)

    /**
     * following/requests/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:following*
     */
    let postFollowingRequestsList = (~body: postFollowingRequestsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingRequestsListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsListRequestSchema)

      fetch(
        ~url="/following/requests/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFollowingRequestsListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFollowingRequestsRejectRequest = {
      userid: string,
    }

    let postFollowingRequestsRejectRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postFollowingRequestsRejectResponse = unit

    /**
     * following/requests/reject
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:following*
     */
    let postFollowingRequestsReject = (~body: postFollowingRequestsRejectRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingRequestsRejectResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsRejectRequestSchema)

      fetch(
        ~url="/following/requests/reject",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postFollowingRequestsSentRequest = {
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postFollowingRequestsSentRequestSchema = S.object(s => {
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postFollowingRequestsSentResponse = array<JSON.t>

    let postFollowingRequestsSentResponseSchema = S.array(S.json)

    /**
     * following/requests/sent
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:following*
     */
    let postFollowingRequestsSent = (~body: postFollowingRequestsSentRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingRequestsSentResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsSentRequestSchema)

      fetch(
        ~url="/following/requests/sent",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFollowingRequestsSentResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFollowingUpdateRequest = {
      userid: string,
      notify: option<string>,
      withreplies: option<bool>,
    }

    let postFollowingUpdateRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        notify: s.fieldOr("notify", S.nullableAsOption(S.string), None),
        withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
      })

    type postFollowingUpdateResponse = ComponentSchemas.Userlite.t

    let postFollowingUpdateResponseSchema = ComponentSchemas.Userlite.schema

    /**
     * following/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:following*
     */
    let postFollowingUpdate = (~body: postFollowingUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingUpdateRequestSchema)

      fetch(
        ~url="/following/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postFollowingUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postFollowingUpdateAllRequest = {
      notify: option<string>,
      withreplies: option<bool>,
    }

    let postFollowingUpdateAllRequestSchema = S.object(s => {
        notify: s.fieldOr("notify", S.nullableAsOption(S.string), None),
        withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
      })

    type postFollowingUpdateAllResponse = unit

    /**
     * following/update-all
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:following*
     */
    let postFollowingUpdateAll = (~body: postFollowingUpdateAllRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingUpdateAllResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingUpdateAllRequestSchema)

      fetch(
        ~url="/following/update-all",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postGalleryFeaturedRequest = {
      limit: option<int>,
      untilid: option<string>,
    }

    let postGalleryFeaturedRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
      })

    type postGalleryFeaturedResponse = array<ComponentSchemas.Gallerypost.t>

    let postGalleryFeaturedResponseSchema = S.array(ComponentSchemas.Gallerypost.schema)

    /**
     * gallery/featured
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postGalleryFeatured = (~body: postGalleryFeaturedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGalleryFeaturedResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postGalleryFeaturedRequestSchema)

      fetch(
        ~url="/gallery/featured",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postGalleryFeaturedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postGalleryPopularResponse = array<ComponentSchemas.Gallerypost.t>

    let postGalleryPopularResponseSchema = S.array(ComponentSchemas.Gallerypost.schema)

    /**
     * gallery/popular
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postGalleryPopular = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGalleryPopularResponse> => {

      fetch(
        ~url="/gallery/popular",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postGalleryPopularResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postGalleryPostsRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postGalleryPostsRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postGalleryPostsResponse = array<ComponentSchemas.Gallerypost.t>

    let postGalleryPostsResponseSchema = S.array(ComponentSchemas.Gallerypost.schema)

    /**
     * gallery/posts
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postGalleryPosts = (~body: postGalleryPostsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGalleryPostsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postGalleryPostsRequestSchema)

      fetch(
        ~url="/gallery/posts",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postGalleryPostsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postGalleryPostsCreateRequest = {
      title: string,
      description: option<JSON.t>,
      fileids: array<string>,
      issensitive: option<bool>,
    }

    let postGalleryPostsCreateRequestSchema = S.object(s => {
        title: s.field("title", S.string->S.min(1)),
        description: s.fieldOr("description", S.nullableAsOption(S.json), None),
        fileids: s.field("fileIds", S.array(S.string)),
        issensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
      })

    type postGalleryPostsCreateResponse = ComponentSchemas.Gallerypost.t

    let postGalleryPostsCreateResponseSchema = ComponentSchemas.Gallerypost.schema

    /**
     * gallery/posts/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:gallery*
     */
    let postGalleryPostsCreate = (~body: postGalleryPostsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGalleryPostsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postGalleryPostsCreateRequestSchema)

      fetch(
        ~url="/gallery/posts/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postGalleryPostsCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postGalleryPostsDeleteRequest = {
      postid: string,
    }

    let postGalleryPostsDeleteRequestSchema = S.object(s => {
        postid: s.field("postId", S.string),
      })

    type postGalleryPostsDeleteResponse = unit

    /**
     * gallery/posts/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:gallery*
     */
    let postGalleryPostsDelete = (~body: postGalleryPostsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGalleryPostsDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postGalleryPostsDeleteRequestSchema)

      fetch(
        ~url="/gallery/posts/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postGalleryPostsLikeRequest = {
      postid: string,
    }

    let postGalleryPostsLikeRequestSchema = S.object(s => {
        postid: s.field("postId", S.string),
      })

    type postGalleryPostsLikeResponse = unit

    /**
     * gallery/posts/like
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:gallery-likes*
     */
    let postGalleryPostsLike = (~body: postGalleryPostsLikeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGalleryPostsLikeResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postGalleryPostsLikeRequestSchema)

      fetch(
        ~url="/gallery/posts/like",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postGalleryPostsShowRequest = {
      postid: string,
    }

    let postGalleryPostsShowRequestSchema = S.object(s => {
        postid: s.field("postId", S.string),
      })

    type postGalleryPostsShowResponse = ComponentSchemas.Gallerypost.t

    let postGalleryPostsShowResponseSchema = ComponentSchemas.Gallerypost.schema

    /**
     * gallery/posts/show
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postGalleryPostsShow = (~body: postGalleryPostsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGalleryPostsShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postGalleryPostsShowRequestSchema)

      fetch(
        ~url="/gallery/posts/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postGalleryPostsShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postGalleryPostsUnlikeRequest = {
      postid: string,
    }

    let postGalleryPostsUnlikeRequestSchema = S.object(s => {
        postid: s.field("postId", S.string),
      })

    type postGalleryPostsUnlikeResponse = unit

    /**
     * gallery/posts/unlike
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:gallery-likes*
     */
    let postGalleryPostsUnlike = (~body: postGalleryPostsUnlikeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGalleryPostsUnlikeResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postGalleryPostsUnlikeRequestSchema)

      fetch(
        ~url="/gallery/posts/unlike",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postGalleryPostsUpdateRequest = {
      postid: string,
      title: option<string>,
      description: option<JSON.t>,
      fileids: option<array<string>>,
      issensitive: option<bool>,
    }

    let postGalleryPostsUpdateRequestSchema = S.object(s => {
        postid: s.field("postId", S.string),
        title: s.fieldOr("title", S.nullableAsOption(S.string->S.min(1)), None),
        description: s.fieldOr("description", S.nullableAsOption(S.json), None),
        fileids: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
        issensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
      })

    type postGalleryPostsUpdateResponse = ComponentSchemas.Gallerypost.t

    let postGalleryPostsUpdateResponseSchema = ComponentSchemas.Gallerypost.schema

    /**
     * gallery/posts/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:gallery*
     */
    let postGalleryPostsUpdate = (~body: postGalleryPostsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGalleryPostsUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postGalleryPostsUpdateRequestSchema)

      fetch(
        ~url="/gallery/posts/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postGalleryPostsUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postGetAvatarDecorationsResponse = array<JSON.t>

    let postGetAvatarDecorationsResponseSchema = S.array(S.json)

    /**
     * get-avatar-decorations
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postGetAvatarDecorations = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGetAvatarDecorationsResponse> => {

      fetch(
        ~url="/get-avatar-decorations",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postGetAvatarDecorationsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getGetOnlineUsersCountResponse = {
      count: float,
    }

    let getGetOnlineUsersCountResponseSchema = S.object(s => {
        count: s.field("count", S.float),
      })

    /**
     * get-online-users-count
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getGetOnlineUsersCount = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getGetOnlineUsersCountResponse> => {

      fetch(
        ~url="/get-online-users-count",
        ~method_="GET",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getGetOnlineUsersCountResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postGetOnlineUsersCountResponse = {
      count: float,
    }

    let postGetOnlineUsersCountResponseSchema = S.object(s => {
        count: s.field("count", S.float),
      })

    /**
     * get-online-users-count
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postGetOnlineUsersCount = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGetOnlineUsersCountResponse> => {

      fetch(
        ~url="/get-online-users-count",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postGetOnlineUsersCountResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postHashtagsListRequest = {
      limit: option<int>,
      attachedtouseronly: option<bool>,
      attachedtolocaluseronly: option<bool>,
      attachedtoremoteuseronly: option<bool>,
      sort: string,
    }

    let postHashtagsListRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        attachedtouseronly: s.fieldOr("attachedToUserOnly", S.nullableAsOption(S.bool), None),
        attachedtolocaluseronly: s.fieldOr("attachedToLocalUserOnly", S.nullableAsOption(S.bool), None),
        attachedtoremoteuseronly: s.fieldOr("attachedToRemoteUserOnly", S.nullableAsOption(S.bool), None),
        sort: s.field("sort", S.string),
      })

    type postHashtagsListResponse = array<ComponentSchemas.Hashtag.t>

    let postHashtagsListResponseSchema = S.array(ComponentSchemas.Hashtag.schema)

    /**
     * hashtags/list
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postHashtagsList = (~body: postHashtagsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postHashtagsListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsListRequestSchema)

      fetch(
        ~url="/hashtags/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postHashtagsListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postHashtagsSearchRequest = {
      limit: option<int>,
      query: string,
      offset: option<int>,
    }

    let postHashtagsSearchRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        query: s.field("query", S.string),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
      })

    type postHashtagsSearchResponse = array<string>

    let postHashtagsSearchResponseSchema = S.array(S.string)

    /**
     * hashtags/search
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postHashtagsSearch = (~body: postHashtagsSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postHashtagsSearchResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsSearchRequestSchema)

      fetch(
        ~url="/hashtags/search",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postHashtagsSearchResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postHashtagsShowRequest = {
      tag: string,
    }

    let postHashtagsShowRequestSchema = S.object(s => {
        tag: s.field("tag", S.string),
      })

    type postHashtagsShowResponse = ComponentSchemas.Hashtag.t

    let postHashtagsShowResponseSchema = ComponentSchemas.Hashtag.schema

    /**
     * hashtags/show
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postHashtagsShow = (~body: postHashtagsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postHashtagsShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsShowRequestSchema)

      fetch(
        ~url="/hashtags/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postHashtagsShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getHashtagsTrendResponse = array<JSON.t>

    let getHashtagsTrendResponseSchema = S.array(S.json)

    /**
     * hashtags/trend
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getHashtagsTrend = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getHashtagsTrendResponse> => {

      fetch(
        ~url="/hashtags/trend",
        ~method_="GET",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getHashtagsTrendResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postHashtagsTrendResponse = array<JSON.t>

    let postHashtagsTrendResponseSchema = S.array(S.json)

    /**
     * hashtags/trend
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postHashtagsTrend = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postHashtagsTrendResponse> => {

      fetch(
        ~url="/hashtags/trend",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postHashtagsTrendResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postHashtagsUsersRequest = {
      tag: string,
      limit: option<int>,
      sort: string,
      state: option<string>,
      origin: option<string>,
    }

    let postHashtagsUsersRequestSchema = S.object(s => {
        tag: s.field("tag", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sort: s.field("sort", S.string),
        state: s.fieldOr("state", S.nullableAsOption(S.string), None),
        origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
      })

    type postHashtagsUsersResponse = array<ComponentSchemas.Userdetailed.t>

    let postHashtagsUsersResponseSchema = S.array(ComponentSchemas.Userdetailed.schema)

    /**
     * hashtags/users
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postHashtagsUsers = (~body: postHashtagsUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postHashtagsUsersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsUsersRequestSchema)

      fetch(
        ~url="/hashtags/users",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postHashtagsUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIResponse = ComponentSchemas.Medetailed.t

    let postIResponseSchema = ComponentSchemas.Medetailed.schema

    /**
     * i
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postI = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIResponse> => {

      fetch(
        ~url="/i",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postI2faDoneRequest = {
      token: string,
    }

    let postI2faDoneRequestSchema = S.object(s => {
        token: s.field("token", S.string),
      })

    type postI2faDoneResponse = {
      backupcodes: array<string>,
    }

    let postI2faDoneResponseSchema = S.object(s => {
        backupcodes: s.field("backupCodes", S.array(S.string)),
      })

    /**
     * i/2fa/done
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postI2faDone = (~body: postI2faDoneRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faDoneResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faDoneRequestSchema)

      fetch(
        ~url="/i/2fa/done",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postI2faDoneResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postI2faKeyDoneRequest = {
      password: string,
      token: option<JSON.t>,
      name: string,
      credential: JSON.t,
    }

    let postI2faKeyDoneRequestSchema = S.object(s => {
        password: s.field("password", S.string),
        token: s.fieldOr("token", S.nullableAsOption(S.json), None),
        name: s.field("name", S.string->S.min(1)->S.max(30)),
        credential: s.field("credential", S.json),
      })

    type postI2faKeyDoneResponse = {
      id: string,
      name: string,
    }

    let postI2faKeyDoneResponseSchema = S.object(s => {
        id: s.field("id", S.string),
        name: s.field("name", S.string),
      })

    /**
     * i/2fa/key-done
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postI2faKeyDone = (~body: postI2faKeyDoneRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faKeyDoneResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faKeyDoneRequestSchema)

      fetch(
        ~url="/i/2fa/key-done",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postI2faKeyDoneResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postI2faPasswordLessRequest = {
      value: bool,
    }

    let postI2faPasswordLessRequestSchema = S.object(s => {
        value: s.field("value", S.bool),
      })

    type postI2faPasswordLessResponse = unit

    /**
     * i/2fa/password-less
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postI2faPasswordLess = (~body: postI2faPasswordLessRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faPasswordLessResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faPasswordLessRequestSchema)

      fetch(
        ~url="/i/2fa/password-less",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postI2faRegisterRequest = {
      password: string,
      token: option<JSON.t>,
    }

    let postI2faRegisterRequestSchema = S.object(s => {
        password: s.field("password", S.string),
        token: s.fieldOr("token", S.nullableAsOption(S.json), None),
      })

    type postI2faRegisterResponse = {
      qr: string,
      url: string,
      secret: string,
      label: string,
      issuer: string,
    }

    let postI2faRegisterResponseSchema = S.object(s => {
        qr: s.field("qr", S.string),
        url: s.field("url", S.string),
        secret: s.field("secret", S.string),
        label: s.field("label", S.string),
        issuer: s.field("issuer", S.string),
      })

    /**
     * i/2fa/register
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postI2faRegister = (~body: postI2faRegisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faRegisterResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faRegisterRequestSchema)

      fetch(
        ~url="/i/2fa/register",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postI2faRegisterResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postI2faRegisterKeyRequest = {
      password: string,
      token: option<JSON.t>,
    }

    let postI2faRegisterKeyRequestSchema = S.object(s => {
        password: s.field("password", S.string),
        token: s.fieldOr("token", S.nullableAsOption(S.json), None),
      })

    type postI2faRegisterKeyResponse = {
      rp: JSON.t,
      user: JSON.t,
      challenge: string,
      pubkeycredparams: array<JSON.t>,
      timeout: JSON.t,
      excludecredentials: JSON.t,
      authenticatorselection: JSON.t,
      attestation: JSON.t,
      extensions: JSON.t,
    }

    let postI2faRegisterKeyResponseSchema = S.object(s => {
        rp: s.field("rp", S.json),
        user: s.field("user", S.json),
        challenge: s.field("challenge", S.string),
        pubkeycredparams: s.field("pubKeyCredParams", S.array(S.json)),
        timeout: s.field("timeout", S.json),
        excludecredentials: s.field("excludeCredentials", S.json),
        authenticatorselection: s.field("authenticatorSelection", S.json),
        attestation: s.field("attestation", S.json),
        extensions: s.field("extensions", S.json),
      })

    /**
     * i/2fa/register-key
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postI2faRegisterKey = (~body: postI2faRegisterKeyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faRegisterKeyResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faRegisterKeyRequestSchema)

      fetch(
        ~url="/i/2fa/register-key",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postI2faRegisterKeyResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postI2faRemoveKeyRequest = {
      password: string,
      token: option<JSON.t>,
      credentialid: string,
    }

    let postI2faRemoveKeyRequestSchema = S.object(s => {
        password: s.field("password", S.string),
        token: s.fieldOr("token", S.nullableAsOption(S.json), None),
        credentialid: s.field("credentialId", S.string),
      })

    type postI2faRemoveKeyResponse = unit

    /**
     * i/2fa/remove-key
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postI2faRemoveKey = (~body: postI2faRemoveKeyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faRemoveKeyResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faRemoveKeyRequestSchema)

      fetch(
        ~url="/i/2fa/remove-key",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postI2faUnregisterRequest = {
      password: string,
      token: option<JSON.t>,
    }

    let postI2faUnregisterRequestSchema = S.object(s => {
        password: s.field("password", S.string),
        token: s.fieldOr("token", S.nullableAsOption(S.json), None),
      })

    type postI2faUnregisterResponse = unit

    /**
     * i/2fa/unregister
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postI2faUnregister = (~body: postI2faUnregisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faUnregisterResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faUnregisterRequestSchema)

      fetch(
        ~url="/i/2fa/unregister",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postI2faUpdateKeyRequest = {
      name: string,
      credentialid: string,
    }

    let postI2faUpdateKeyRequestSchema = S.object(s => {
        name: s.field("name", S.string->S.min(1)->S.max(30)),
        credentialid: s.field("credentialId", S.string),
      })

    type postI2faUpdateKeyResponse = unit

    /**
     * i/2fa/update-key
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postI2faUpdateKey = (~body: postI2faUpdateKeyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faUpdateKeyResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faUpdateKeyRequestSchema)

      fetch(
        ~url="/i/2fa/update-key",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIAppsRequest = {
      sort: option<string>,
    }

    let postIAppsRequestSchema = S.object(s => {
        sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
      })

    type postIAppsResponse = array<JSON.t>

    let postIAppsResponseSchema = S.array(S.json)

    /**
     * i/apps
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIApps = (~body: postIAppsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIAppsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIAppsRequestSchema)

      fetch(
        ~url="/i/apps",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIAppsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIAuthorizedAppsRequest = {
      limit: option<int>,
      offset: option<int>,
      sort: option<string>,
    }

    let postIAuthorizedAppsRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
        sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
      })

    type postIAuthorizedAppsResponse = array<JSON.t>

    let postIAuthorizedAppsResponseSchema = S.array(S.json)

    /**
     * i/authorized-apps
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIAuthorizedApps = (~body: postIAuthorizedAppsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIAuthorizedAppsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIAuthorizedAppsRequestSchema)

      fetch(
        ~url="/i/authorized-apps",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIAuthorizedAppsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIChangePasswordRequest = {
      currentpassword: string,
      newpassword: string,
      token: option<JSON.t>,
    }

    let postIChangePasswordRequestSchema = S.object(s => {
        currentpassword: s.field("currentPassword", S.string),
        newpassword: s.field("newPassword", S.string->S.min(1)),
        token: s.fieldOr("token", S.nullableAsOption(S.json), None),
      })

    type postIChangePasswordResponse = unit

    /**
     * i/change-password
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIChangePassword = (~body: postIChangePasswordRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIChangePasswordResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIChangePasswordRequestSchema)

      fetch(
        ~url="/i/change-password",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIClaimAchievementRequest = {
      name: string,
    }

    let postIClaimAchievementRequestSchema = S.object(s => {
        name: s.field("name", S.string),
      })

    type postIClaimAchievementResponse = unit

    /**
     * i/claim-achievement
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postIClaimAchievement = (~body: postIClaimAchievementRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIClaimAchievementResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIClaimAchievementRequestSchema)

      fetch(
        ~url="/i/claim-achievement",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIDeleteAccountRequest = {
      password: string,
      token: option<JSON.t>,
    }

    let postIDeleteAccountRequestSchema = S.object(s => {
        password: s.field("password", S.string),
        token: s.fieldOr("token", S.nullableAsOption(S.json), None),
      })

    type postIDeleteAccountResponse = unit

    /**
     * i/delete-account
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIDeleteAccount = (~body: postIDeleteAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIDeleteAccountResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIDeleteAccountRequestSchema)

      fetch(
        ~url="/i/delete-account",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIExportAntennasResponse = unit

    /**
     * i/export-antennas
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIExportAntennas = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportAntennasResponse> => {

      fetch(
        ~url="/i/export-antennas",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIExportBlockingResponse = unit

    /**
     * i/export-blocking
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIExportBlocking = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportBlockingResponse> => {

      fetch(
        ~url="/i/export-blocking",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIExportClipsResponse = unit

    /**
     * i/export-clips
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIExportClips = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportClipsResponse> => {

      fetch(
        ~url="/i/export-clips",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIExportFavoritesResponse = unit

    /**
     * i/export-favorites
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIExportFavorites = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportFavoritesResponse> => {

      fetch(
        ~url="/i/export-favorites",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIExportFollowingRequest = {
      excludemuting: option<bool>,
      excludeinactive: option<bool>,
    }

    let postIExportFollowingRequestSchema = S.object(s => {
        excludemuting: s.fieldOr("excludeMuting", S.nullableAsOption(S.bool), None),
        excludeinactive: s.fieldOr("excludeInactive", S.nullableAsOption(S.bool), None),
      })

    type postIExportFollowingResponse = unit

    /**
     * i/export-following
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIExportFollowing = (~body: postIExportFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportFollowingResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIExportFollowingRequestSchema)

      fetch(
        ~url="/i/export-following",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIExportMuteResponse = unit

    /**
     * i/export-mute
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIExportMute = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportMuteResponse> => {

      fetch(
        ~url="/i/export-mute",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIExportNotesResponse = unit

    /**
     * i/export-notes
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIExportNotes = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportNotesResponse> => {

      fetch(
        ~url="/i/export-notes",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIExportUserListsResponse = unit

    /**
     * i/export-user-lists
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIExportUserLists = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportUserListsResponse> => {

      fetch(
        ~url="/i/export-user-lists",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIFavoritesRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postIFavoritesRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postIFavoritesResponse = array<ComponentSchemas.Notefavorite.t>

    let postIFavoritesResponseSchema = S.array(ComponentSchemas.Notefavorite.schema)

    /**
     * i/favorites
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:favorites*
     */
    let postIFavorites = (~body: postIFavoritesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIFavoritesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIFavoritesRequestSchema)

      fetch(
        ~url="/i/favorites",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIFavoritesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIGalleryLikesRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postIGalleryLikesRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postIGalleryLikesResponse = array<JSON.t>

    let postIGalleryLikesResponseSchema = S.array(S.json)

    /**
     * i/gallery/likes
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:gallery-likes*
     */
    let postIGalleryLikes = (~body: postIGalleryLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIGalleryLikesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIGalleryLikesRequestSchema)

      fetch(
        ~url="/i/gallery/likes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIGalleryLikesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIGalleryPostsRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postIGalleryPostsRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postIGalleryPostsResponse = array<ComponentSchemas.Gallerypost.t>

    let postIGalleryPostsResponseSchema = S.array(ComponentSchemas.Gallerypost.schema)

    /**
     * i/gallery/posts
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:gallery*
     */
    let postIGalleryPosts = (~body: postIGalleryPostsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIGalleryPostsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIGalleryPostsRequestSchema)

      fetch(
        ~url="/i/gallery/posts",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIGalleryPostsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIImportAntennasRequest = {
      fileid: string,
    }

    let postIImportAntennasRequestSchema = S.object(s => {
        fileid: s.field("fileId", S.string),
      })

    type postIImportAntennasResponse = unit

    /**
     * i/import-antennas
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIImportAntennas = (~body: postIImportAntennasRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIImportAntennasResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportAntennasRequestSchema)

      fetch(
        ~url="/i/import-antennas",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIImportBlockingRequest = {
      fileid: string,
    }

    let postIImportBlockingRequestSchema = S.object(s => {
        fileid: s.field("fileId", S.string),
      })

    type postIImportBlockingResponse = unit

    /**
     * i/import-blocking
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIImportBlocking = (~body: postIImportBlockingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIImportBlockingResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportBlockingRequestSchema)

      fetch(
        ~url="/i/import-blocking",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIImportFollowingRequest = {
      fileid: string,
      withreplies: option<bool>,
    }

    let postIImportFollowingRequestSchema = S.object(s => {
        fileid: s.field("fileId", S.string),
        withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
      })

    type postIImportFollowingResponse = unit

    /**
     * i/import-following
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIImportFollowing = (~body: postIImportFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIImportFollowingResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportFollowingRequestSchema)

      fetch(
        ~url="/i/import-following",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIImportMutingRequest = {
      fileid: string,
    }

    let postIImportMutingRequestSchema = S.object(s => {
        fileid: s.field("fileId", S.string),
      })

    type postIImportMutingResponse = unit

    /**
     * i/import-muting
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIImportMuting = (~body: postIImportMutingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIImportMutingResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportMutingRequestSchema)

      fetch(
        ~url="/i/import-muting",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIImportUserListsRequest = {
      fileid: string,
    }

    let postIImportUserListsRequestSchema = S.object(s => {
        fileid: s.field("fileId", S.string),
      })

    type postIImportUserListsResponse = unit

    /**
     * i/import-user-lists
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIImportUserLists = (~body: postIImportUserListsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIImportUserListsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportUserListsRequestSchema)

      fetch(
        ~url="/i/import-user-lists",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIMoveRequest = {
      movetoaccount: string,
    }

    let postIMoveRequestSchema = S.object(s => {
        movetoaccount: s.field("moveToAccount", S.string),
      })

    type postIMoveResponse = JSON.t

    let postIMoveResponseSchema = S.json

    /**
     * i/move
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIMove = (~body: postIMoveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIMoveResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIMoveRequestSchema)

      fetch(
        ~url="/i/move",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIMoveResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postINotificationsRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      markasread: option<bool>,
      includetypes: option<array<string>>,
      excludetypes: option<array<string>>,
    }

    let postINotificationsRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        markasread: s.fieldOr("markAsRead", S.nullableAsOption(S.bool), None),
        includetypes: s.fieldOr("includeTypes", S.nullableAsOption(S.array(S.string)), None),
        excludetypes: s.fieldOr("excludeTypes", S.nullableAsOption(S.array(S.string)), None),
      })

    type postINotificationsResponse = array<ComponentSchemas.Notification.t>

    let postINotificationsResponseSchema = S.array(ComponentSchemas.Notification.schema)

    /**
     * i/notifications
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:notifications*
     */
    let postINotifications = (~body: postINotificationsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postINotificationsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postINotificationsRequestSchema)

      fetch(
        ~url="/i/notifications",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postINotificationsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postINotificationsGroupedRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      markasread: option<bool>,
      includetypes: option<array<string>>,
      excludetypes: option<array<string>>,
    }

    let postINotificationsGroupedRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        markasread: s.fieldOr("markAsRead", S.nullableAsOption(S.bool), None),
        includetypes: s.fieldOr("includeTypes", S.nullableAsOption(S.array(S.string)), None),
        excludetypes: s.fieldOr("excludeTypes", S.nullableAsOption(S.array(S.string)), None),
      })

    type postINotificationsGroupedResponse = array<ComponentSchemas.Notification.t>

    let postINotificationsGroupedResponseSchema = S.array(ComponentSchemas.Notification.schema)

    /**
     * i/notifications-grouped
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:notifications*
     */
    let postINotificationsGrouped = (~body: postINotificationsGroupedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postINotificationsGroupedResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postINotificationsGroupedRequestSchema)

      fetch(
        ~url="/i/notifications-grouped",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postINotificationsGroupedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIPageLikesRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postIPageLikesRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postIPageLikesResponse = array<JSON.t>

    let postIPageLikesResponseSchema = S.array(S.json)

    /**
     * i/page-likes
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:page-likes*
     */
    let postIPageLikes = (~body: postIPageLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIPageLikesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPageLikesRequestSchema)

      fetch(
        ~url="/i/page-likes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIPageLikesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIPagesRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postIPagesRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postIPagesResponse = array<ComponentSchemas.Page.t>

    let postIPagesResponseSchema = S.array(ComponentSchemas.Page.schema)

    /**
     * i/pages
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:pages*
     */
    let postIPages = (~body: postIPagesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIPagesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPagesRequestSchema)

      fetch(
        ~url="/i/pages",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIPagesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIPinRequest = {
      noteid: string,
    }

    let postIPinRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postIPinResponse = ComponentSchemas.Medetailed.t

    let postIPinResponseSchema = ComponentSchemas.Medetailed.schema

    /**
     * i/pin
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postIPin = (~body: postIPinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIPinResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPinRequestSchema)

      fetch(
        ~url="/i/pin",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIPinResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIReadAnnouncementRequest = {
      announcementid: string,
    }

    let postIReadAnnouncementRequestSchema = S.object(s => {
        announcementid: s.field("announcementId", S.string),
      })

    type postIReadAnnouncementResponse = unit

    /**
     * i/read-announcement
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postIReadAnnouncement = (~body: postIReadAnnouncementRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIReadAnnouncementResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIReadAnnouncementRequestSchema)

      fetch(
        ~url="/i/read-announcement",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIRegenerateTokenRequest = {
      password: string,
    }

    let postIRegenerateTokenRequestSchema = S.object(s => {
        password: s.field("password", S.string),
      })

    type postIRegenerateTokenResponse = unit

    /**
     * i/regenerate-token
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIRegenerateToken = (~body: postIRegenerateTokenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegenerateTokenResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegenerateTokenRequestSchema)

      fetch(
        ~url="/i/regenerate-token",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIRegistryGetRequest = {
      key: string,
      scope: array<string>,
      domain: option<JSON.t>,
    }

    let postIRegistryGetRequestSchema = S.object(s => {
        key: s.field("key", S.string),
        scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
        domain: s.fieldOr("domain", S.nullableAsOption(S.json), None),
      })

    type postIRegistryGetResponse = JSON.t

    let postIRegistryGetResponseSchema = S.json

    /**
     * i/registry/get
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postIRegistryGet = (~body: postIRegistryGetRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryGetResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryGetRequestSchema)

      fetch(
        ~url="/i/registry/get",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIRegistryGetResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIRegistryGetAllRequest = {
      scope: array<string>,
      domain: option<JSON.t>,
    }

    let postIRegistryGetAllRequestSchema = S.object(s => {
        scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
        domain: s.fieldOr("domain", S.nullableAsOption(S.json), None),
      })

    type postIRegistryGetAllResponse = JSON.t

    let postIRegistryGetAllResponseSchema = S.json

    /**
     * i/registry/get-all
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postIRegistryGetAll = (~body: postIRegistryGetAllRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryGetAllResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryGetAllRequestSchema)

      fetch(
        ~url="/i/registry/get-all",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIRegistryGetAllResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIRegistryGetDetailRequest = {
      key: string,
      scope: array<string>,
      domain: option<JSON.t>,
    }

    let postIRegistryGetDetailRequestSchema = S.object(s => {
        key: s.field("key", S.string),
        scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
        domain: s.fieldOr("domain", S.nullableAsOption(S.json), None),
      })

    type postIRegistryGetDetailResponse = {
      updatedat: string,
      value: JSON.t,
    }

    let postIRegistryGetDetailResponseSchema = S.object(s => {
        updatedat: s.field("updatedAt", S.string),
        value: s.field("value", S.json),
      })

    /**
     * i/registry/get-detail
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postIRegistryGetDetail = (~body: postIRegistryGetDetailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryGetDetailResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryGetDetailRequestSchema)

      fetch(
        ~url="/i/registry/get-detail",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIRegistryGetDetailResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIRegistryKeysRequest = {
      scope: array<string>,
      domain: option<JSON.t>,
    }

    let postIRegistryKeysRequestSchema = S.object(s => {
        scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
        domain: s.fieldOr("domain", S.nullableAsOption(S.json), None),
      })

    type postIRegistryKeysResponse = array<string>

    let postIRegistryKeysResponseSchema = S.array(S.string)

    /**
     * i/registry/keys
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postIRegistryKeys = (~body: postIRegistryKeysRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryKeysResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryKeysRequestSchema)

      fetch(
        ~url="/i/registry/keys",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIRegistryKeysResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIRegistryKeysWithTypeRequest = {
      scope: array<string>,
      domain: option<JSON.t>,
    }

    let postIRegistryKeysWithTypeRequestSchema = S.object(s => {
        scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
        domain: s.fieldOr("domain", S.nullableAsOption(S.json), None),
      })

    type postIRegistryKeysWithTypeResponse = JSON.t

    let postIRegistryKeysWithTypeResponseSchema = S.json

    /**
     * i/registry/keys-with-type
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postIRegistryKeysWithType = (~body: postIRegistryKeysWithTypeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryKeysWithTypeResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryKeysWithTypeRequestSchema)

      fetch(
        ~url="/i/registry/keys-with-type",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIRegistryKeysWithTypeResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIRegistryRemoveRequest = {
      key: string,
      scope: array<string>,
      domain: option<JSON.t>,
    }

    let postIRegistryRemoveRequestSchema = S.object(s => {
        key: s.field("key", S.string),
        scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
        domain: s.fieldOr("domain", S.nullableAsOption(S.json), None),
      })

    type postIRegistryRemoveResponse = unit

    /**
     * i/registry/remove
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postIRegistryRemove = (~body: postIRegistryRemoveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryRemoveResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryRemoveRequestSchema)

      fetch(
        ~url="/i/registry/remove",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIRegistryScopesWithDomainResponse = array<JSON.t>

    let postIRegistryScopesWithDomainResponseSchema = S.array(S.json)

    /**
     * i/registry/scopes-with-domain
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIRegistryScopesWithDomain = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryScopesWithDomainResponse> => {

      fetch(
        ~url="/i/registry/scopes-with-domain",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIRegistryScopesWithDomainResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIRegistrySetRequest = {
      key: string,
      value: JSON.t,
      scope: array<string>,
      domain: option<JSON.t>,
    }

    let postIRegistrySetRequestSchema = S.object(s => {
        key: s.field("key", S.string->S.min(1)),
        value: s.field("value", S.json),
        scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
        domain: s.fieldOr("domain", S.nullableAsOption(S.json), None),
      })

    type postIRegistrySetResponse = unit

    /**
     * i/registry/set
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postIRegistrySet = (~body: postIRegistrySetRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistrySetResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistrySetRequestSchema)

      fetch(
        ~url="/i/registry/set",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIRevokeTokenRequest = JSON.t

    let postIRevokeTokenRequestSchema = S.json

    type postIRevokeTokenResponse = unit

    /**
     * i/revoke-token
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIRevokeToken = (~body: postIRevokeTokenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRevokeTokenResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRevokeTokenRequestSchema)

      fetch(
        ~url="/i/revoke-token",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postISigninHistoryRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postISigninHistoryRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postISigninHistoryResponse = array<ComponentSchemas.Signin.t>

    let postISigninHistoryResponseSchema = S.array(ComponentSchemas.Signin.schema)

    /**
     * i/signin-history
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postISigninHistory = (~body: postISigninHistoryRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postISigninHistoryResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postISigninHistoryRequestSchema)

      fetch(
        ~url="/i/signin-history",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postISigninHistoryResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIUnpinRequest = {
      noteid: string,
    }

    let postIUnpinRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postIUnpinResponse = ComponentSchemas.Medetailed.t

    let postIUnpinResponseSchema = ComponentSchemas.Medetailed.schema

    /**
     * i/unpin
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postIUnpin = (~body: postIUnpinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIUnpinResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUnpinRequestSchema)

      fetch(
        ~url="/i/unpin",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIUnpinResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIUpdateRequest = {
      name: option<JSON.t>,
      description: option<JSON.t>,
      followedmessage: option<JSON.t>,
      location: option<JSON.t>,
      birthday: option<JSON.t>,
      lang: option<JSON.t>,
      avatarid: option<JSON.t>,
      avatardecorations: option<array<JSON.t>>,
      bannerid: option<JSON.t>,
      fields: option<array<JSON.t>>,
      islocked: option<bool>,
      isexplorable: option<bool>,
      hideonlinestatus: option<bool>,
      publicreactions: option<bool>,
      carefulbot: option<bool>,
      autoacceptfollowed: option<bool>,
      nocrawle: option<bool>,
      preventailearning: option<bool>,
      requiresignintoviewcontents: option<bool>,
      makenotesfollowersonlybefore: option<JSON.t>,
      makenoteshiddenbefore: option<JSON.t>,
      isbot: option<bool>,
      iscat: option<bool>,
      injectfeaturednote: option<bool>,
      receiveannouncementemail: option<bool>,
      alwaysmarknsfw: option<bool>,
      autosensitive: option<bool>,
      followingvisibility: option<string>,
      followersvisibility: option<string>,
      chatscope: option<string>,
      pinnedpageid: option<JSON.t>,
      mutedwords: option<array<array<string>>>,
      hardmutedwords: option<array<array<string>>>,
      mutedinstances: option<array<string>>,
      notificationrecieveconfig: option<JSON.t>,
      emailnotificationtypes: option<array<string>>,
      alsoknownas: option<array<string>>,
    }

    let postIUpdateRequestSchema = S.object(s => {
        name: s.fieldOr("name", S.nullableAsOption(S.json), None),
        description: s.fieldOr("description", S.nullableAsOption(S.json), None),
        followedmessage: s.fieldOr("followedMessage", S.nullableAsOption(S.json), None),
        location: s.fieldOr("location", S.nullableAsOption(S.json), None),
        birthday: s.fieldOr("birthday", S.nullableAsOption(S.json), None),
        lang: s.fieldOr("lang", S.nullableAsOption(S.json), None),
        avatarid: s.fieldOr("avatarId", S.nullableAsOption(S.json), None),
        avatardecorations: s.fieldOr("avatarDecorations", S.nullableAsOption(S.array(S.json)), None),
        bannerid: s.fieldOr("bannerId", S.nullableAsOption(S.json), None),
        fields: s.fieldOr("fields", S.nullableAsOption(S.array(S.json)), None),
        islocked: s.fieldOr("isLocked", S.nullableAsOption(S.bool), None),
        isexplorable: s.fieldOr("isExplorable", S.nullableAsOption(S.bool), None),
        hideonlinestatus: s.fieldOr("hideOnlineStatus", S.nullableAsOption(S.bool), None),
        publicreactions: s.fieldOr("publicReactions", S.nullableAsOption(S.bool), None),
        carefulbot: s.fieldOr("carefulBot", S.nullableAsOption(S.bool), None),
        autoacceptfollowed: s.fieldOr("autoAcceptFollowed", S.nullableAsOption(S.bool), None),
        nocrawle: s.fieldOr("noCrawle", S.nullableAsOption(S.bool), None),
        preventailearning: s.fieldOr("preventAiLearning", S.nullableAsOption(S.bool), None),
        requiresignintoviewcontents: s.fieldOr("requireSigninToViewContents", S.nullableAsOption(S.bool), None),
        makenotesfollowersonlybefore: s.fieldOr("makeNotesFollowersOnlyBefore", S.nullableAsOption(S.json), None),
        makenoteshiddenbefore: s.fieldOr("makeNotesHiddenBefore", S.nullableAsOption(S.json), None),
        isbot: s.fieldOr("isBot", S.nullableAsOption(S.bool), None),
        iscat: s.fieldOr("isCat", S.nullableAsOption(S.bool), None),
        injectfeaturednote: s.fieldOr("injectFeaturedNote", S.nullableAsOption(S.bool), None),
        receiveannouncementemail: s.fieldOr("receiveAnnouncementEmail", S.nullableAsOption(S.bool), None),
        alwaysmarknsfw: s.fieldOr("alwaysMarkNsfw", S.nullableAsOption(S.bool), None),
        autosensitive: s.fieldOr("autoSensitive", S.nullableAsOption(S.bool), None),
        followingvisibility: s.fieldOr("followingVisibility", S.nullableAsOption(S.string), None),
        followersvisibility: s.fieldOr("followersVisibility", S.nullableAsOption(S.string), None),
        chatscope: s.fieldOr("chatScope", S.nullableAsOption(S.string), None),
        pinnedpageid: s.fieldOr("pinnedPageId", S.nullableAsOption(S.json), None),
        mutedwords: s.fieldOr("mutedWords", S.nullableAsOption(S.array(S.array(S.string))), None),
        hardmutedwords: s.fieldOr("hardMutedWords", S.nullableAsOption(S.array(S.array(S.string))), None),
        mutedinstances: s.fieldOr("mutedInstances", S.nullableAsOption(S.array(S.string)), None),
        notificationrecieveconfig: s.fieldOr("notificationRecieveConfig", S.nullableAsOption(S.json), None),
        emailnotificationtypes: s.fieldOr("emailNotificationTypes", S.nullableAsOption(S.array(S.string)), None),
        alsoknownas: s.fieldOr("alsoKnownAs", S.nullableAsOption(S.array(S.string)), None),
      })

    type postIUpdateResponse = ComponentSchemas.Medetailed.t

    let postIUpdateResponseSchema = ComponentSchemas.Medetailed.schema

    /**
     * i/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postIUpdate = (~body: postIUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateRequestSchema)

      fetch(
        ~url="/i/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIUpdateEmailRequest = {
      password: string,
      email: option<JSON.t>,
      token: option<JSON.t>,
    }

    let postIUpdateEmailRequestSchema = S.object(s => {
        password: s.field("password", S.string),
        email: s.fieldOr("email", S.nullableAsOption(S.json), None),
        token: s.fieldOr("token", S.nullableAsOption(S.json), None),
      })

    type postIUpdateEmailResponse = ComponentSchemas.Medetailed.t

    let postIUpdateEmailResponseSchema = ComponentSchemas.Medetailed.schema

    /**
     * i/update-email
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postIUpdateEmail = (~body: postIUpdateEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIUpdateEmailResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateEmailRequestSchema)

      fetch(
        ~url="/i/update-email",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIUpdateEmailResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIWebhooksCreateRequest = {
      name: string,
      url: string,
      secret: option<string>,
      on: array<string>,
    }

    let postIWebhooksCreateRequestSchema = S.object(s => {
        name: s.field("name", S.string->S.min(1)->S.max(100)),
        url: s.field("url", S.string->S.min(1)->S.max(1024)),
        secret: s.fieldOr("secret", S.nullableAsOption(S.string->S.max(1024)), None),
        on: s.field("on", S.array(S.string)),
      })

    type postIWebhooksCreateResponse = {
      id: string,
      userid: string,
      name: string,
      on: array<string>,
      url: string,
      secret: string,
      active: bool,
      latestsentat: JSON.t,
      lateststatus: JSON.t,
    }

    let postIWebhooksCreateResponseSchema = S.object(s => {
        id: s.field("id", S.string),
        userid: s.field("userId", S.string),
        name: s.field("name", S.string),
        on: s.field("on", S.array(S.string)),
        url: s.field("url", S.string),
        secret: s.field("secret", S.string),
        active: s.field("active", S.bool),
        latestsentat: s.field("latestSentAt", S.json),
        lateststatus: s.field("latestStatus", S.json),
      })

    /**
     * i/webhooks/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postIWebhooksCreate = (~body: postIWebhooksCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksCreateRequestSchema)

      fetch(
        ~url="/i/webhooks/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIWebhooksCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIWebhooksDeleteRequest = {
      webhookid: string,
    }

    let postIWebhooksDeleteRequestSchema = S.object(s => {
        webhookid: s.field("webhookId", S.string),
      })

    type postIWebhooksDeleteResponse = unit

    /**
     * i/webhooks/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postIWebhooksDelete = (~body: postIWebhooksDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksDeleteRequestSchema)

      fetch(
        ~url="/i/webhooks/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIWebhooksListResponse = array<ComponentSchemas.Userwebhook.t>

    let postIWebhooksListResponseSchema = S.array(ComponentSchemas.Userwebhook.schema)

    /**
     * i/webhooks/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postIWebhooksList = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksListResponse> => {

      fetch(
        ~url="/i/webhooks/list",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIWebhooksListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIWebhooksShowRequest = {
      webhookid: string,
    }

    let postIWebhooksShowRequestSchema = S.object(s => {
        webhookid: s.field("webhookId", S.string),
      })

    type postIWebhooksShowResponse = ComponentSchemas.Userwebhook.t

    let postIWebhooksShowResponseSchema = ComponentSchemas.Userwebhook.schema

    /**
     * i/webhooks/show
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postIWebhooksShow = (~body: postIWebhooksShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksShowRequestSchema)

      fetch(
        ~url="/i/webhooks/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postIWebhooksShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postIWebhooksTestRequest = {
      webhookid: string,
      @as("type") type_: string,
      override: option<JSON.t>,
    }

    let postIWebhooksTestRequestSchema = S.object(s => {
        webhookid: s.field("webhookId", S.string),
        type_: s.field("type", S.string),
        override: s.fieldOr("override", S.nullableAsOption(S.json), None),
      })

    type postIWebhooksTestResponse = unit

    /**
     * i/webhooks/test
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postIWebhooksTest = (~body: postIWebhooksTestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksTestResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksTestRequestSchema)

      fetch(
        ~url="/i/webhooks/test",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postIWebhooksUpdateRequest = {
      webhookid: string,
      name: option<string>,
      url: option<string>,
      secret: option<JSON.t>,
      on: option<array<string>>,
      active: option<bool>,
    }

    let postIWebhooksUpdateRequestSchema = S.object(s => {
        webhookid: s.field("webhookId", S.string),
        name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.max(100)), None),
        url: s.fieldOr("url", S.nullableAsOption(S.string->S.min(1)->S.max(1024)), None),
        secret: s.fieldOr("secret", S.nullableAsOption(S.json), None),
        on: s.fieldOr("on", S.nullableAsOption(S.array(S.string)), None),
        active: s.fieldOr("active", S.nullableAsOption(S.bool), None),
      })

    type postIWebhooksUpdateResponse = unit

    /**
     * i/webhooks/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postIWebhooksUpdate = (~body: postIWebhooksUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksUpdateRequestSchema)

      fetch(
        ~url="/i/webhooks/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postInviteCreateResponse = ComponentSchemas.Invitecode.t

    let postInviteCreateResponseSchema = ComponentSchemas.Invitecode.schema

    /**
     * invite/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:invite-codes*
     */
    let postInviteCreate = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteCreateResponse> => {

      fetch(
        ~url="/invite/create",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postInviteCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postInviteDeleteRequest = {
      inviteid: string,
    }

    let postInviteDeleteRequestSchema = S.object(s => {
        inviteid: s.field("inviteId", S.string),
      })

    type postInviteDeleteResponse = unit

    /**
     * invite/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:invite-codes*
     */
    let postInviteDelete = (~body: postInviteDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postInviteDeleteRequestSchema)

      fetch(
        ~url="/invite/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postInviteLimitResponse = {
      remaining: JSON.t,
    }

    let postInviteLimitResponseSchema = S.object(s => {
        remaining: s.field("remaining", S.json),
      })

    /**
     * invite/limit
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:invite-codes*
     */
    let postInviteLimit = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteLimitResponse> => {

      fetch(
        ~url="/invite/limit",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postInviteLimitResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postInviteListRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postInviteListRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postInviteListResponse = array<ComponentSchemas.Invitecode.t>

    let postInviteListResponseSchema = S.array(ComponentSchemas.Invitecode.schema)

    /**
     * invite/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:invite-codes*
     */
    let postInviteList = (~body: postInviteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postInviteListRequestSchema)

      fetch(
        ~url="/invite/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postInviteListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postMetaRequest = {
      detail: option<bool>,
    }

    let postMetaRequestSchema = S.object(s => {
        detail: s.fieldOr("detail", S.nullableAsOption(S.bool), None),
      })

    type postMetaResponse = JSON.t

    let postMetaResponseSchema = S.json

    /**
     * meta
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postMeta = (~body: postMetaRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMetaResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postMetaRequestSchema)

      fetch(
        ~url="/meta",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postMetaResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postMiauthGenTokenRequest = {
      session: JSON.t,
      name: option<JSON.t>,
      description: option<JSON.t>,
      iconurl: option<JSON.t>,
      permission: array<string>,
    }

    let postMiauthGenTokenRequestSchema = S.object(s => {
        session: s.field("session", S.json),
        name: s.fieldOr("name", S.nullableAsOption(S.json), None),
        description: s.fieldOr("description", S.nullableAsOption(S.json), None),
        iconurl: s.fieldOr("iconUrl", S.nullableAsOption(S.json), None),
        permission: s.field("permission", S.array(S.string)),
      })

    type postMiauthGenTokenResponse = {
      token: string,
    }

    let postMiauthGenTokenResponseSchema = S.object(s => {
        token: s.field("token", S.string),
      })

    /**
     * miauth/gen-token
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postMiauthGenToken = (~body: postMiauthGenTokenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMiauthGenTokenResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postMiauthGenTokenRequestSchema)

      fetch(
        ~url="/miauth/gen-token",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postMiauthGenTokenResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postMuteCreateRequest = {
      userid: string,
      expiresat: option<JSON.t>,
    }

    let postMuteCreateRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        expiresat: s.fieldOr("expiresAt", S.nullableAsOption(S.json), None),
      })

    type postMuteCreateResponse = unit

    /**
     * mute/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:mutes*
     */
    let postMuteCreate = (~body: postMuteCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMuteCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postMuteCreateRequestSchema)

      fetch(
        ~url="/mute/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postMuteDeleteRequest = {
      userid: string,
    }

    let postMuteDeleteRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postMuteDeleteResponse = unit

    /**
     * mute/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:mutes*
     */
    let postMuteDelete = (~body: postMuteDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMuteDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postMuteDeleteRequestSchema)

      fetch(
        ~url="/mute/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postMuteListRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postMuteListRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postMuteListResponse = array<ComponentSchemas.Muting.t>

    let postMuteListResponseSchema = S.array(ComponentSchemas.Muting.schema)

    /**
     * mute/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:mutes*
     */
    let postMuteList = (~body: postMuteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMuteListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postMuteListRequestSchema)

      fetch(
        ~url="/mute/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postMuteListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postMyAppsRequest = {
      limit: option<int>,
      offset: option<int>,
    }

    let postMyAppsRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
      })

    type postMyAppsResponse = array<ComponentSchemas.App.t>

    let postMyAppsResponseSchema = S.array(ComponentSchemas.App.schema)

    /**
     * my/apps
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postMyApps = (~body: postMyAppsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMyAppsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postMyAppsRequestSchema)

      fetch(
        ~url="/my/apps",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postMyAppsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesRequest = {
      local: option<bool>,
      reply: option<bool>,
      renote: option<bool>,
      withfiles: option<bool>,
      poll: option<bool>,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postNotesRequestSchema = S.object(s => {
        local: s.fieldOr("local", S.nullableAsOption(S.bool), None),
        reply: s.fieldOr("reply", S.nullableAsOption(S.bool), None),
        renote: s.fieldOr("renote", S.nullableAsOption(S.bool), None),
        withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
        poll: s.fieldOr("poll", S.nullableAsOption(S.bool), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postNotesResponse = array<ComponentSchemas.Note.t>

    let postNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotes = (~body: postNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRequestSchema)

      fetch(
        ~url="/notes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesChildrenRequest = {
      noteid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postNotesChildrenRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postNotesChildrenResponse = array<ComponentSchemas.Note.t>

    let postNotesChildrenResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/children
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesChildren = (~body: postNotesChildrenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesChildrenResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesChildrenRequestSchema)

      fetch(
        ~url="/notes/children",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesChildrenResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesClipsRequest = {
      noteid: string,
    }

    let postNotesClipsRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postNotesClipsResponse = array<ComponentSchemas.Clip.t>

    let postNotesClipsResponseSchema = S.array(ComponentSchemas.Clip.schema)

    /**
     * notes/clips
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesClips = (~body: postNotesClipsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesClipsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesClipsRequestSchema)

      fetch(
        ~url="/notes/clips",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesClipsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesConversationRequest = {
      noteid: string,
      limit: option<int>,
      offset: option<int>,
    }

    let postNotesConversationRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
      })

    type postNotesConversationResponse = array<ComponentSchemas.Note.t>

    let postNotesConversationResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/conversation
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesConversation = (~body: postNotesConversationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesConversationResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesConversationRequestSchema)

      fetch(
        ~url="/notes/conversation",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesConversationResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesCreateRequest = {
      visibility: option<string>,
      visibleuserids: option<array<string>>,
      cw: option<JSON.t>,
      localonly: option<bool>,
      reactionacceptance: option<JSON.t>,
      noextractmentions: option<bool>,
      noextracthashtags: option<bool>,
      noextractemojis: option<bool>,
      replyid: option<JSON.t>,
      renoteid: option<JSON.t>,
      channelid: option<JSON.t>,
      text: option<JSON.t>,
      fileids: option<array<string>>,
      mediaids: option<array<string>>,
      poll: option<JSON.t>,
    }

    let postNotesCreateRequestSchema = S.object(s => {
        visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
        visibleuserids: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
        cw: s.fieldOr("cw", S.nullableAsOption(S.json), None),
        localonly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
        reactionacceptance: s.fieldOr("reactionAcceptance", S.nullableAsOption(S.json), None),
        noextractmentions: s.fieldOr("noExtractMentions", S.nullableAsOption(S.bool), None),
        noextracthashtags: s.fieldOr("noExtractHashtags", S.nullableAsOption(S.bool), None),
        noextractemojis: s.fieldOr("noExtractEmojis", S.nullableAsOption(S.bool), None),
        replyid: s.fieldOr("replyId", S.nullableAsOption(S.json), None),
        renoteid: s.fieldOr("renoteId", S.nullableAsOption(S.json), None),
        channelid: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
        text: s.fieldOr("text", S.nullableAsOption(S.json), None),
        fileids: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
        mediaids: s.fieldOr("mediaIds", S.nullableAsOption(S.array(S.string)), None),
        poll: s.fieldOr("poll", S.nullableAsOption(S.json), None),
      })

    type postNotesCreateResponse = {
      creatednote: ComponentSchemas.Note.t,
    }

    let postNotesCreateResponseSchema = S.object(s => {
        creatednote: s.field("createdNote", ComponentSchemas.Note.schema),
      })

    /**
     * notes/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:notes*
     */
    let postNotesCreate = (~body: postNotesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesCreateRequestSchema)

      fetch(
        ~url="/notes/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesDeleteRequest = {
      noteid: string,
    }

    let postNotesDeleteRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postNotesDeleteResponse = unit

    /**
     * notes/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:notes*
     */
    let postNotesDelete = (~body: postNotesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDeleteRequestSchema)

      fetch(
        ~url="/notes/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    /** The number of drafts */
    type postNotesDraftsCountResponse = float

    // The number of drafts
    let postNotesDraftsCountResponseSchema = S.float

    /**
     * notes/drafts/count
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postNotesDraftsCount = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDraftsCountResponse> => {

      fetch(
        ~url="/notes/drafts/count",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesDraftsCountResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesDraftsCreateRequest = {
      visibility: option<string>,
      visibleuserids: option<array<string>>,
      cw: option<JSON.t>,
      hashtag: option<JSON.t>,
      localonly: option<bool>,
      reactionacceptance: option<JSON.t>,
      replyid: option<JSON.t>,
      renoteid: option<JSON.t>,
      channelid: option<JSON.t>,
      text: option<JSON.t>,
      fileids: option<array<string>>,
      poll: option<JSON.t>,
      scheduledat: option<JSON.t>,
      isactuallyscheduled: option<bool>,
    }

    let postNotesDraftsCreateRequestSchema = S.object(s => {
        visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
        visibleuserids: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
        cw: s.fieldOr("cw", S.nullableAsOption(S.json), None),
        hashtag: s.fieldOr("hashtag", S.nullableAsOption(S.json), None),
        localonly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
        reactionacceptance: s.fieldOr("reactionAcceptance", S.nullableAsOption(S.json), None),
        replyid: s.fieldOr("replyId", S.nullableAsOption(S.json), None),
        renoteid: s.fieldOr("renoteId", S.nullableAsOption(S.json), None),
        channelid: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
        text: s.fieldOr("text", S.nullableAsOption(S.json), None),
        fileids: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
        poll: s.fieldOr("poll", S.nullableAsOption(S.json), None),
        scheduledat: s.fieldOr("scheduledAt", S.nullableAsOption(S.json), None),
        isactuallyscheduled: s.fieldOr("isActuallyScheduled", S.nullableAsOption(S.bool), None),
      })

    type postNotesDraftsCreateResponse = {
      createddraft: ComponentSchemas.Notedraft.t,
    }

    let postNotesDraftsCreateResponseSchema = S.object(s => {
        createddraft: s.field("createdDraft", ComponentSchemas.Notedraft.schema),
      })

    /**
     * notes/drafts/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postNotesDraftsCreate = (~body: postNotesDraftsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDraftsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDraftsCreateRequestSchema)

      fetch(
        ~url="/notes/drafts/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesDraftsCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesDraftsDeleteRequest = {
      draftid: string,
    }

    let postNotesDraftsDeleteRequestSchema = S.object(s => {
        draftid: s.field("draftId", S.string),
      })

    type postNotesDraftsDeleteResponse = unit

    /**
     * notes/drafts/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postNotesDraftsDelete = (~body: postNotesDraftsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDraftsDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDraftsDeleteRequestSchema)

      fetch(
        ~url="/notes/drafts/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postNotesDraftsListRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      scheduled: option<JSON.t>,
    }

    let postNotesDraftsListRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        scheduled: s.fieldOr("scheduled", S.nullableAsOption(S.json), None),
      })

    type postNotesDraftsListResponse = array<ComponentSchemas.Notedraft.t>

    let postNotesDraftsListResponseSchema = S.array(ComponentSchemas.Notedraft.schema)

    /**
     * notes/drafts/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postNotesDraftsList = (~body: postNotesDraftsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDraftsListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDraftsListRequestSchema)

      fetch(
        ~url="/notes/drafts/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesDraftsListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesDraftsUpdateRequest = {
      draftid: string,
      visibility: option<string>,
      visibleuserids: option<array<string>>,
      cw: option<JSON.t>,
      hashtag: option<JSON.t>,
      localonly: option<bool>,
      reactionacceptance: option<JSON.t>,
      replyid: option<JSON.t>,
      renoteid: option<JSON.t>,
      channelid: option<JSON.t>,
      text: option<JSON.t>,
      fileids: option<array<string>>,
      poll: option<JSON.t>,
      scheduledat: option<JSON.t>,
      isactuallyscheduled: option<bool>,
    }

    let postNotesDraftsUpdateRequestSchema = S.object(s => {
        draftid: s.field("draftId", S.string),
        visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
        visibleuserids: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
        cw: s.fieldOr("cw", S.nullableAsOption(S.json), None),
        hashtag: s.fieldOr("hashtag", S.nullableAsOption(S.json), None),
        localonly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
        reactionacceptance: s.fieldOr("reactionAcceptance", S.nullableAsOption(S.json), None),
        replyid: s.fieldOr("replyId", S.nullableAsOption(S.json), None),
        renoteid: s.fieldOr("renoteId", S.nullableAsOption(S.json), None),
        channelid: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
        text: s.fieldOr("text", S.nullableAsOption(S.json), None),
        fileids: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
        poll: s.fieldOr("poll", S.nullableAsOption(S.json), None),
        scheduledat: s.fieldOr("scheduledAt", S.nullableAsOption(S.json), None),
        isactuallyscheduled: s.fieldOr("isActuallyScheduled", S.nullableAsOption(S.bool), None),
      })

    type postNotesDraftsUpdateResponse = {
      updateddraft: ComponentSchemas.Notedraft.t,
    }

    let postNotesDraftsUpdateResponseSchema = S.object(s => {
        updateddraft: s.field("updatedDraft", ComponentSchemas.Notedraft.schema),
      })

    /**
     * notes/drafts/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postNotesDraftsUpdate = (~body: postNotesDraftsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDraftsUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDraftsUpdateRequestSchema)

      fetch(
        ~url="/notes/drafts/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesDraftsUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesFavoritesCreateRequest = {
      noteid: string,
    }

    let postNotesFavoritesCreateRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postNotesFavoritesCreateResponse = unit

    /**
     * notes/favorites/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:favorites*
     */
    let postNotesFavoritesCreate = (~body: postNotesFavoritesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesFavoritesCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFavoritesCreateRequestSchema)

      fetch(
        ~url="/notes/favorites/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postNotesFavoritesDeleteRequest = {
      noteid: string,
    }

    let postNotesFavoritesDeleteRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postNotesFavoritesDeleteResponse = unit

    /**
     * notes/favorites/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:favorites*
     */
    let postNotesFavoritesDelete = (~body: postNotesFavoritesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesFavoritesDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFavoritesDeleteRequestSchema)

      fetch(
        ~url="/notes/favorites/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type getNotesFeaturedRequest = {
      limit: option<int>,
      untilid: option<string>,
      channelid: option<JSON.t>,
    }

    let getNotesFeaturedRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        channelid: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
      })

    type getNotesFeaturedResponse = array<ComponentSchemas.Note.t>

    let getNotesFeaturedResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/featured
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getNotesFeatured = (~body: getNotesFeaturedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getNotesFeaturedResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getNotesFeaturedRequestSchema)

      fetch(
        ~url="/notes/featured",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getNotesFeaturedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesFeaturedRequest = {
      limit: option<int>,
      untilid: option<string>,
      channelid: option<JSON.t>,
    }

    let postNotesFeaturedRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        channelid: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
      })

    type postNotesFeaturedResponse = array<ComponentSchemas.Note.t>

    let postNotesFeaturedResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/featured
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesFeatured = (~body: postNotesFeaturedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesFeaturedResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFeaturedRequestSchema)

      fetch(
        ~url="/notes/featured",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesFeaturedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesGlobalTimelineRequest = {
      withfiles: option<bool>,
      withrenotes: option<bool>,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postNotesGlobalTimelineRequestSchema = S.object(s => {
        withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
        withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postNotesGlobalTimelineResponse = array<ComponentSchemas.Note.t>

    let postNotesGlobalTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/global-timeline
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesGlobalTimeline = (~body: postNotesGlobalTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesGlobalTimelineResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesGlobalTimelineRequestSchema)

      fetch(
        ~url="/notes/global-timeline",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesGlobalTimelineResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesHybridTimelineRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      allowpartial: option<bool>,
      includemyrenotes: option<bool>,
      includerenotedmynotes: option<bool>,
      includelocalrenotes: option<bool>,
      withfiles: option<bool>,
      withrenotes: option<bool>,
      withreplies: option<bool>,
    }

    let postNotesHybridTimelineRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
        includemyrenotes: s.fieldOr("includeMyRenotes", S.nullableAsOption(S.bool), None),
        includerenotedmynotes: s.fieldOr("includeRenotedMyNotes", S.nullableAsOption(S.bool), None),
        includelocalrenotes: s.fieldOr("includeLocalRenotes", S.nullableAsOption(S.bool), None),
        withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
        withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
        withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
      })

    type postNotesHybridTimelineResponse = array<ComponentSchemas.Note.t>

    let postNotesHybridTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/hybrid-timeline
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postNotesHybridTimeline = (~body: postNotesHybridTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesHybridTimelineResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesHybridTimelineRequestSchema)

      fetch(
        ~url="/notes/hybrid-timeline",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesHybridTimelineResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesLocalTimelineRequest = {
      withfiles: option<bool>,
      withrenotes: option<bool>,
      withreplies: option<bool>,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      allowpartial: option<bool>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postNotesLocalTimelineRequestSchema = S.object(s => {
        withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
        withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
        withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postNotesLocalTimelineResponse = array<ComponentSchemas.Note.t>

    let postNotesLocalTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/local-timeline
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesLocalTimeline = (~body: postNotesLocalTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesLocalTimelineResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesLocalTimelineRequestSchema)

      fetch(
        ~url="/notes/local-timeline",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesLocalTimelineResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesMentionsRequest = {
      following: option<bool>,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      visibility: option<string>,
    }

    let postNotesMentionsRequestSchema = S.object(s => {
        following: s.fieldOr("following", S.nullableAsOption(S.bool), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
      })

    type postNotesMentionsResponse = array<ComponentSchemas.Note.t>

    let postNotesMentionsResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/mentions
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postNotesMentions = (~body: postNotesMentionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesMentionsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesMentionsRequestSchema)

      fetch(
        ~url="/notes/mentions",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesMentionsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesPollsRecommendationRequest = {
      limit: option<int>,
      offset: option<int>,
      excludechannels: option<bool>,
    }

    let postNotesPollsRecommendationRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
        excludechannels: s.fieldOr("excludeChannels", S.nullableAsOption(S.bool), None),
      })

    type postNotesPollsRecommendationResponse = array<ComponentSchemas.Note.t>

    let postNotesPollsRecommendationResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/polls/recommendation
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postNotesPollsRecommendation = (~body: postNotesPollsRecommendationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesPollsRecommendationResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesPollsRecommendationRequestSchema)

      fetch(
        ~url="/notes/polls/recommendation",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesPollsRecommendationResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesPollsVoteRequest = {
      noteid: string,
      choice: int,
    }

    let postNotesPollsVoteRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
        choice: s.field("choice", S.int),
      })

    type postNotesPollsVoteResponse = unit

    /**
     * notes/polls/vote
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:votes*
     */
    let postNotesPollsVote = (~body: postNotesPollsVoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesPollsVoteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesPollsVoteRequestSchema)

      fetch(
        ~url="/notes/polls/vote",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type getNotesReactionsRequest = {
      noteid: string,
      @as("type") type_: option<JSON.t>,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let getNotesReactionsRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
        type_: s.fieldOr("type", S.nullableAsOption(S.json), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type getNotesReactionsResponse = array<ComponentSchemas.Notereaction.t>

    let getNotesReactionsResponseSchema = S.array(ComponentSchemas.Notereaction.schema)

    /**
     * notes/reactions
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getNotesReactions = (~body: getNotesReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getNotesReactionsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getNotesReactionsRequestSchema)

      fetch(
        ~url="/notes/reactions",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getNotesReactionsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesReactionsRequest = {
      noteid: string,
      @as("type") type_: option<JSON.t>,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postNotesReactionsRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
        type_: s.fieldOr("type", S.nullableAsOption(S.json), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postNotesReactionsResponse = array<ComponentSchemas.Notereaction.t>

    let postNotesReactionsResponseSchema = S.array(ComponentSchemas.Notereaction.schema)

    /**
     * notes/reactions
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesReactions = (~body: postNotesReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesReactionsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesReactionsRequestSchema)

      fetch(
        ~url="/notes/reactions",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesReactionsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesReactionsCreateRequest = {
      noteid: string,
      reaction: string,
    }

    let postNotesReactionsCreateRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
        reaction: s.field("reaction", S.string),
      })

    type postNotesReactionsCreateResponse = unit

    /**
     * notes/reactions/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:reactions*
     */
    let postNotesReactionsCreate = (~body: postNotesReactionsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesReactionsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesReactionsCreateRequestSchema)

      fetch(
        ~url="/notes/reactions/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postNotesReactionsDeleteRequest = {
      noteid: string,
    }

    let postNotesReactionsDeleteRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postNotesReactionsDeleteResponse = unit

    /**
     * notes/reactions/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:reactions*
     */
    let postNotesReactionsDelete = (~body: postNotesReactionsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesReactionsDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesReactionsDeleteRequestSchema)

      fetch(
        ~url="/notes/reactions/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postNotesRenotesRequest = {
      noteid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postNotesRenotesRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postNotesRenotesResponse = array<ComponentSchemas.Note.t>

    let postNotesRenotesResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/renotes
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesRenotes = (~body: postNotesRenotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesRenotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRenotesRequestSchema)

      fetch(
        ~url="/notes/renotes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesRenotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesRepliesRequest = {
      noteid: string,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postNotesRepliesRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postNotesRepliesResponse = array<ComponentSchemas.Note.t>

    let postNotesRepliesResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/replies
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesReplies = (~body: postNotesRepliesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesRepliesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRepliesRequestSchema)

      fetch(
        ~url="/notes/replies",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesRepliesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesSearchRequest = {
      query: string,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
      offset: option<int>,
      host: option<string>,
      userid: option<JSON.t>,
      channelid: option<JSON.t>,
    }

    let postNotesSearchRequestSchema = S.object(s => {
        query: s.field("query", S.string),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
        host: s.fieldOr("host", S.nullableAsOption(S.string), None),
        userid: s.fieldOr("userId", S.nullableAsOption(S.json), None),
        channelid: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
      })

    type postNotesSearchResponse = array<ComponentSchemas.Note.t>

    let postNotesSearchResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/search
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesSearch = (~body: postNotesSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesSearchResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesSearchRequestSchema)

      fetch(
        ~url="/notes/search",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesSearchResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesSearchByTagRequest = JSON.t

    let postNotesSearchByTagRequestSchema = S.json

    type postNotesSearchByTagResponse = array<ComponentSchemas.Note.t>

    let postNotesSearchByTagResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/search-by-tag
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesSearchByTag = (~body: postNotesSearchByTagRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesSearchByTagResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesSearchByTagRequestSchema)

      fetch(
        ~url="/notes/search-by-tag",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesSearchByTagResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesShowRequest = {
      noteid: string,
    }

    let postNotesShowRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postNotesShowResponse = ComponentSchemas.Note.t

    let postNotesShowResponseSchema = ComponentSchemas.Note.schema

    /**
     * notes/show
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesShow = (~body: postNotesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesShowRequestSchema)

      fetch(
        ~url="/notes/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesShowPartialBulkRequest = {
      noteids: array<string>,
    }

    let postNotesShowPartialBulkRequestSchema = S.object(s => {
        noteids: s.field("noteIds", S.array(S.string)),
      })

    type postNotesShowPartialBulkResponse = array<JSON.t>

    let postNotesShowPartialBulkResponseSchema = S.array(S.json)

    /**
     * notes/show-partial-bulk
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postNotesShowPartialBulk = (~body: postNotesShowPartialBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesShowPartialBulkResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesShowPartialBulkRequestSchema)

      fetch(
        ~url="/notes/show-partial-bulk",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesShowPartialBulkResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesStateRequest = {
      noteid: string,
    }

    let postNotesStateRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postNotesStateResponse = {
      isfavorited: bool,
      ismutedthread: bool,
    }

    let postNotesStateResponseSchema = S.object(s => {
        isfavorited: s.field("isFavorited", S.bool),
        ismutedthread: s.field("isMutedThread", S.bool),
      })

    /**
     * notes/state
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postNotesState = (~body: postNotesStateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesStateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesStateRequestSchema)

      fetch(
        ~url="/notes/state",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesStateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesThreadMutingCreateRequest = {
      noteid: string,
    }

    let postNotesThreadMutingCreateRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postNotesThreadMutingCreateResponse = unit

    /**
     * notes/thread-muting/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postNotesThreadMutingCreate = (~body: postNotesThreadMutingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesThreadMutingCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesThreadMutingCreateRequestSchema)

      fetch(
        ~url="/notes/thread-muting/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postNotesThreadMutingDeleteRequest = {
      noteid: string,
    }

    let postNotesThreadMutingDeleteRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postNotesThreadMutingDeleteResponse = unit

    /**
     * notes/thread-muting/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postNotesThreadMutingDelete = (~body: postNotesThreadMutingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesThreadMutingDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesThreadMutingDeleteRequestSchema)

      fetch(
        ~url="/notes/thread-muting/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postNotesTimelineRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      allowpartial: option<bool>,
      includemyrenotes: option<bool>,
      includerenotedmynotes: option<bool>,
      includelocalrenotes: option<bool>,
      withfiles: option<bool>,
      withrenotes: option<bool>,
    }

    let postNotesTimelineRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
        includemyrenotes: s.fieldOr("includeMyRenotes", S.nullableAsOption(S.bool), None),
        includerenotedmynotes: s.fieldOr("includeRenotedMyNotes", S.nullableAsOption(S.bool), None),
        includelocalrenotes: s.fieldOr("includeLocalRenotes", S.nullableAsOption(S.bool), None),
        withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
        withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
      })

    type postNotesTimelineResponse = array<ComponentSchemas.Note.t>

    let postNotesTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/timeline
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postNotesTimeline = (~body: postNotesTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesTimelineResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesTimelineRequestSchema)

      fetch(
        ~url="/notes/timeline",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesTimelineResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesTranslateRequest = {
      noteid: string,
      targetlang: string,
    }

    let postNotesTranslateRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
        targetlang: s.field("targetLang", S.string),
      })

    type postNotesTranslateResponse = {
      sourcelang: string,
      text: string,
    }

    let postNotesTranslateResponseSchema = S.object(s => {
        sourcelang: s.field("sourceLang", S.string),
        text: s.field("text", S.string),
      })

    /**
     * notes/translate
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postNotesTranslate = (~body: postNotesTranslateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesTranslateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesTranslateRequestSchema)

      fetch(
        ~url="/notes/translate",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesTranslateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotesUnrenoteRequest = {
      noteid: string,
    }

    let postNotesUnrenoteRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postNotesUnrenoteResponse = unit

    /**
     * notes/unrenote
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:notes*
     */
    let postNotesUnrenote = (~body: postNotesUnrenoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesUnrenoteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesUnrenoteRequestSchema)

      fetch(
        ~url="/notes/unrenote",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postNotesUserListTimelineRequest = {
      listid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      allowpartial: option<bool>,
      includemyrenotes: option<bool>,
      includerenotedmynotes: option<bool>,
      includelocalrenotes: option<bool>,
      withrenotes: option<bool>,
      withfiles: option<bool>,
    }

    let postNotesUserListTimelineRequestSchema = S.object(s => {
        listid: s.field("listId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
        includemyrenotes: s.fieldOr("includeMyRenotes", S.nullableAsOption(S.bool), None),
        includerenotedmynotes: s.fieldOr("includeRenotedMyNotes", S.nullableAsOption(S.bool), None),
        includelocalrenotes: s.fieldOr("includeLocalRenotes", S.nullableAsOption(S.bool), None),
        withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
        withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
      })

    type postNotesUserListTimelineResponse = array<ComponentSchemas.Note.t>

    let postNotesUserListTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * notes/user-list-timeline
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postNotesUserListTimeline = (~body: postNotesUserListTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesUserListTimelineResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesUserListTimelineRequestSchema)

      fetch(
        ~url="/notes/user-list-timeline",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postNotesUserListTimelineResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postNotificationsCreateRequest = {
      body: string,
      header: option<JSON.t>,
      icon: option<JSON.t>,
    }

    let postNotificationsCreateRequestSchema = S.object(s => {
        body: s.field("body", S.string),
        header: s.fieldOr("header", S.nullableAsOption(S.json), None),
        icon: s.fieldOr("icon", S.nullableAsOption(S.json), None),
      })

    type postNotificationsCreateResponse = unit

    /**
     * notifications/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:notifications*
     */
    let postNotificationsCreate = (~body: postNotificationsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotificationsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotificationsCreateRequestSchema)

      fetch(
        ~url="/notifications/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postNotificationsFlushResponse = unit

    /**
     * notifications/flush
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:notifications*
     */
    let postNotificationsFlush = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotificationsFlushResponse> => {

      fetch(
        ~url="/notifications/flush",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postNotificationsMarkAllAsReadResponse = unit

    /**
     * notifications/mark-all-as-read
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:notifications*
     */
    let postNotificationsMarkAllAsRead = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotificationsMarkAllAsReadResponse> => {

      fetch(
        ~url="/notifications/mark-all-as-read",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postNotificationsTestNotificationResponse = unit

    /**
     * notifications/test-notification
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:notifications*
     */
    let postNotificationsTestNotification = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotificationsTestNotificationResponse> => {

      fetch(
        ~url="/notifications/test-notification",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postPagePushRequest = {
      pageid: string,
      event: string,
      var: option<JSON.t>,
    }

    let postPagePushRequestSchema = S.object(s => {
        pageid: s.field("pageId", S.string),
        event: s.field("event", S.string),
        var: s.fieldOr("var", S.nullableAsOption(S.json), None),
      })

    type postPagePushResponse = unit

    /**
     * page-push
     *
     * No description provided.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postPagePush = (~body: postPagePushRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagePushResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagePushRequestSchema)

      fetch(
        ~url="/page-push",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postPagesCreateRequest = {
      title: string,
      name: string,
      summary: option<JSON.t>,
      content: array<JSON.t>,
      variables: array<JSON.t>,
      script: string,
      eyecatchingimageid: option<JSON.t>,
      font: option<string>,
      aligncenter: option<bool>,
      hidetitlewhenpinned: option<bool>,
    }

    let postPagesCreateRequestSchema = S.object(s => {
        title: s.field("title", S.string),
        name: s.field("name", S.string->S.min(1)->S.pattern(%re("/^[^\\s:\\/?#\\[\\]@!$&'()*+,;=\\\\%\\x00-\\x20]{1,256}$/"))),
        summary: s.fieldOr("summary", S.nullableAsOption(S.json), None),
        content: s.field("content", S.array(S.json)),
        variables: s.field("variables", S.array(S.json)),
        script: s.field("script", S.string),
        eyecatchingimageid: s.fieldOr("eyeCatchingImageId", S.nullableAsOption(S.json), None),
        font: s.fieldOr("font", S.nullableAsOption(S.string), None),
        aligncenter: s.fieldOr("alignCenter", S.nullableAsOption(S.bool), None),
        hidetitlewhenpinned: s.fieldOr("hideTitleWhenPinned", S.nullableAsOption(S.bool), None),
      })

    type postPagesCreateResponse = ComponentSchemas.Page.t

    let postPagesCreateResponseSchema = ComponentSchemas.Page.schema

    /**
     * pages/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:pages*
     */
    let postPagesCreate = (~body: postPagesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesCreateRequestSchema)

      fetch(
        ~url="/pages/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postPagesCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postPagesDeleteRequest = {
      pageid: string,
    }

    let postPagesDeleteRequestSchema = S.object(s => {
        pageid: s.field("pageId", S.string),
      })

    type postPagesDeleteResponse = unit

    /**
     * pages/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:pages*
     */
    let postPagesDelete = (~body: postPagesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesDeleteRequestSchema)

      fetch(
        ~url="/pages/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postPagesFeaturedResponse = array<ComponentSchemas.Page.t>

    let postPagesFeaturedResponseSchema = S.array(ComponentSchemas.Page.schema)

    /**
     * pages/featured
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postPagesFeatured = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesFeaturedResponse> => {

      fetch(
        ~url="/pages/featured",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postPagesFeaturedResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postPagesLikeRequest = {
      pageid: string,
    }

    let postPagesLikeRequestSchema = S.object(s => {
        pageid: s.field("pageId", S.string),
      })

    type postPagesLikeResponse = unit

    /**
     * pages/like
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:page-likes*
     */
    let postPagesLike = (~body: postPagesLikeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesLikeResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesLikeRequestSchema)

      fetch(
        ~url="/pages/like",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postPagesShowRequest = JSON.t

    let postPagesShowRequestSchema = S.json

    type postPagesShowResponse = ComponentSchemas.Page.t

    let postPagesShowResponseSchema = ComponentSchemas.Page.schema

    /**
     * pages/show
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postPagesShow = (~body: postPagesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesShowRequestSchema)

      fetch(
        ~url="/pages/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postPagesShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postPagesUnlikeRequest = {
      pageid: string,
    }

    let postPagesUnlikeRequestSchema = S.object(s => {
        pageid: s.field("pageId", S.string),
      })

    type postPagesUnlikeResponse = unit

    /**
     * pages/unlike
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:page-likes*
     */
    let postPagesUnlike = (~body: postPagesUnlikeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesUnlikeResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesUnlikeRequestSchema)

      fetch(
        ~url="/pages/unlike",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postPagesUpdateRequest = {
      pageid: string,
      title: option<string>,
      name: option<string>,
      summary: option<JSON.t>,
      content: option<array<JSON.t>>,
      variables: option<array<JSON.t>>,
      script: option<string>,
      eyecatchingimageid: option<JSON.t>,
      font: option<string>,
      aligncenter: option<bool>,
      hidetitlewhenpinned: option<bool>,
    }

    let postPagesUpdateRequestSchema = S.object(s => {
        pageid: s.field("pageId", S.string),
        title: s.fieldOr("title", S.nullableAsOption(S.string), None),
        name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.pattern(%re("/^[^\\s:\\/?#\\[\\]@!$&'()*+,;=\\\\%\\x00-\\x20]{1,256}$/"))), None),
        summary: s.fieldOr("summary", S.nullableAsOption(S.json), None),
        content: s.fieldOr("content", S.nullableAsOption(S.array(S.json)), None),
        variables: s.fieldOr("variables", S.nullableAsOption(S.array(S.json)), None),
        script: s.fieldOr("script", S.nullableAsOption(S.string), None),
        eyecatchingimageid: s.fieldOr("eyeCatchingImageId", S.nullableAsOption(S.json), None),
        font: s.fieldOr("font", S.nullableAsOption(S.string), None),
        aligncenter: s.fieldOr("alignCenter", S.nullableAsOption(S.bool), None),
        hidetitlewhenpinned: s.fieldOr("hideTitleWhenPinned", S.nullableAsOption(S.bool), None),
      })

    type postPagesUpdateResponse = unit

    /**
     * pages/update
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:pages*
     */
    let postPagesUpdate = (~body: postPagesUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesUpdateRequestSchema)

      fetch(
        ~url="/pages/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postPingResponse = {
      pong: float,
    }

    let postPingResponseSchema = S.object(s => {
        pong: s.field("pong", S.float),
      })

    /**
     * ping
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postPing = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPingResponse> => {

      fetch(
        ~url="/ping",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postPingResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postPinnedUsersResponse = array<ComponentSchemas.Userdetailed.t>

    let postPinnedUsersResponseSchema = S.array(ComponentSchemas.Userdetailed.schema)

    /**
     * pinned-users
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postPinnedUsers = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPinnedUsersResponse> => {

      fetch(
        ~url="/pinned-users",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postPinnedUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postPromoReadRequest = {
      noteid: string,
    }

    let postPromoReadRequestSchema = S.object(s => {
        noteid: s.field("noteId", S.string),
      })

    type postPromoReadResponse = unit

    /**
     * promo/read
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postPromoRead = (~body: postPromoReadRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPromoReadResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postPromoReadRequestSchema)

      fetch(
        ~url="/promo/read",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postRenoteMuteCreateRequest = {
      userid: string,
    }

    let postRenoteMuteCreateRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postRenoteMuteCreateResponse = unit

    /**
     * renote-mute/create
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:mutes*
     */
    let postRenoteMuteCreate = (~body: postRenoteMuteCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRenoteMuteCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postRenoteMuteCreateRequestSchema)

      fetch(
        ~url="/renote-mute/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postRenoteMuteDeleteRequest = {
      userid: string,
    }

    let postRenoteMuteDeleteRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postRenoteMuteDeleteResponse = unit

    /**
     * renote-mute/delete
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:mutes*
     */
    let postRenoteMuteDelete = (~body: postRenoteMuteDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRenoteMuteDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postRenoteMuteDeleteRequestSchema)

      fetch(
        ~url="/renote-mute/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postRenoteMuteListRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postRenoteMuteListRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postRenoteMuteListResponse = array<ComponentSchemas.Renotemuting.t>

    let postRenoteMuteListResponseSchema = S.array(ComponentSchemas.Renotemuting.schema)

    /**
     * renote-mute/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:mutes*
     */
    let postRenoteMuteList = (~body: postRenoteMuteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRenoteMuteListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postRenoteMuteListRequestSchema)

      fetch(
        ~url="/renote-mute/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postRenoteMuteListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postRequestResetPasswordRequest = {
      username: string,
      email: string,
    }

    let postRequestResetPasswordRequestSchema = S.object(s => {
        username: s.field("username", S.string),
        email: s.field("email", S.string),
      })

    type postRequestResetPasswordResponse = unit

    /**
     * request-reset-password
     *
     * Request a users password to be reset.
     *
     * **Credential required**: *No*
     */
    let postRequestResetPassword = (~body: postRequestResetPasswordRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRequestResetPasswordResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postRequestResetPasswordRequestSchema)

      fetch(
        ~url="/request-reset-password",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postResetDbResponse = unit

    /**
     * reset-db
     *
     * Only available when running with <code>NODE_ENV=testing</code>. Reset the database and flush Redis.
     *
     * **Credential required**: *No*
     */
    let postResetDb = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postResetDbResponse> => {

      fetch(
        ~url="/reset-db",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postResetPasswordRequest = {
      token: string,
      password: string,
    }

    let postResetPasswordRequestSchema = S.object(s => {
        token: s.field("token", S.string),
        password: s.field("password", S.string),
      })

    type postResetPasswordResponse = unit

    /**
     * reset-password
     *
     * Complete the password reset that was previously requested.
     *
     * **Credential required**: *No*
     */
    let postResetPassword = (~body: postResetPasswordRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postResetPasswordResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postResetPasswordRequestSchema)

      fetch(
        ~url="/reset-password",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type getRetentionResponse = array<JSON.t>

    let getRetentionResponseSchema = S.array(S.json)

    /**
     * retention
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getRetention = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getRetentionResponse> => {

      fetch(
        ~url="/retention",
        ~method_="GET",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getRetentionResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postRetentionResponse = array<JSON.t>

    let postRetentionResponseSchema = S.array(S.json)

    /**
     * retention
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postRetention = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRetentionResponse> => {

      fetch(
        ~url="/retention",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postRetentionResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postReversiCancelMatchRequest = {
      userid: option<JSON.t>,
    }

    let postReversiCancelMatchRequestSchema = S.object(s => {
        userid: s.fieldOr("userId", S.nullableAsOption(S.json), None),
      })

    type postReversiCancelMatchResponse = unit

    /**
     * reversi/cancel-match
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postReversiCancelMatch = (~body: postReversiCancelMatchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiCancelMatchResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiCancelMatchRequestSchema)

      fetch(
        ~url="/reversi/cancel-match",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postReversiGamesRequest = {
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      my: option<bool>,
    }

    let postReversiGamesRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        my: s.fieldOr("my", S.nullableAsOption(S.bool), None),
      })

    type postReversiGamesResponse = array<ComponentSchemas.Reversigamelite.t>

    let postReversiGamesResponseSchema = S.array(ComponentSchemas.Reversigamelite.schema)

    /**
     * reversi/games
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postReversiGames = (~body: postReversiGamesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiGamesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiGamesRequestSchema)

      fetch(
        ~url="/reversi/games",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postReversiGamesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postReversiInvitationsResponse = array<ComponentSchemas.Userlite.t>

    let postReversiInvitationsResponseSchema = S.array(ComponentSchemas.Userlite.schema)

    /**
     * reversi/invitations
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postReversiInvitations = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiInvitationsResponse> => {

      fetch(
        ~url="/reversi/invitations",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postReversiInvitationsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postReversiMatchRequest = {
      userid: option<JSON.t>,
      noirregularrules: option<bool>,
      multiple: option<bool>,
    }

    let postReversiMatchRequestSchema = S.object(s => {
        userid: s.fieldOr("userId", S.nullableAsOption(S.json), None),
        noirregularrules: s.fieldOr("noIrregularRules", S.nullableAsOption(S.bool), None),
        multiple: s.fieldOr("multiple", S.nullableAsOption(S.bool), None),
      })

    type postReversiMatchResponse = ComponentSchemas.Reversigamedetailed.t

    let postReversiMatchResponseSchema = ComponentSchemas.Reversigamedetailed.schema

    /**
     * reversi/match
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postReversiMatch = (~body: postReversiMatchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiMatchResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiMatchRequestSchema)

      fetch(
        ~url="/reversi/match",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postReversiMatchResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postReversiShowGameRequest = {
      gameid: string,
    }

    let postReversiShowGameRequestSchema = S.object(s => {
        gameid: s.field("gameId", S.string),
      })

    type postReversiShowGameResponse = ComponentSchemas.Reversigamedetailed.t

    let postReversiShowGameResponseSchema = ComponentSchemas.Reversigamedetailed.schema

    /**
     * reversi/show-game
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postReversiShowGame = (~body: postReversiShowGameRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiShowGameResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiShowGameRequestSchema)

      fetch(
        ~url="/reversi/show-game",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postReversiShowGameResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postReversiSurrenderRequest = {
      gameid: string,
    }

    let postReversiSurrenderRequestSchema = S.object(s => {
        gameid: s.field("gameId", S.string),
      })

    type postReversiSurrenderResponse = unit

    /**
     * reversi/surrender
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postReversiSurrender = (~body: postReversiSurrenderRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiSurrenderResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiSurrenderRequestSchema)

      fetch(
        ~url="/reversi/surrender",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postReversiVerifyRequest = {
      gameid: string,
      crc32: string,
    }

    let postReversiVerifyRequestSchema = S.object(s => {
        gameid: s.field("gameId", S.string),
        crc32: s.field("crc32", S.string),
      })

    type postReversiVerifyResponse = {
      desynced: bool,
      game: option<JSON.t>,
    }

    let postReversiVerifyResponseSchema = S.object(s => {
        desynced: s.field("desynced", S.bool),
        game: s.fieldOr("game", S.nullableAsOption(S.json), None),
      })

    /**
     * reversi/verify
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postReversiVerify = (~body: postReversiVerifyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiVerifyResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiVerifyRequestSchema)

      fetch(
        ~url="/reversi/verify",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postReversiVerifyResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postRolesListResponse = array<ComponentSchemas.Role.t>

    let postRolesListResponseSchema = S.array(ComponentSchemas.Role.schema)

    /**
     * roles/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postRolesList = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRolesListResponse> => {

      fetch(
        ~url="/roles/list",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postRolesListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postRolesNotesRequest = {
      roleid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postRolesNotesRequestSchema = S.object(s => {
        roleid: s.field("roleId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postRolesNotesResponse = array<ComponentSchemas.Note.t>

    let postRolesNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * roles/notes
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postRolesNotes = (~body: postRolesNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRolesNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postRolesNotesRequestSchema)

      fetch(
        ~url="/roles/notes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postRolesNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postRolesShowRequest = {
      roleid: string,
    }

    let postRolesShowRequestSchema = S.object(s => {
        roleid: s.field("roleId", S.string),
      })

    type postRolesShowResponse = ComponentSchemas.Role.t

    let postRolesShowResponseSchema = ComponentSchemas.Role.schema

    /**
     * roles/show
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postRolesShow = (~body: postRolesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRolesShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postRolesShowRequestSchema)

      fetch(
        ~url="/roles/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postRolesShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postRolesUsersRequest = {
      roleid: string,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
    }

    let postRolesUsersRequestSchema = S.object(s => {
        roleid: s.field("roleId", S.string),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postRolesUsersResponse = array<JSON.t>

    let postRolesUsersResponseSchema = S.array(S.json)

    /**
     * roles/users
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postRolesUsers = (~body: postRolesUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRolesUsersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postRolesUsersRequestSchema)

      fetch(
        ~url="/roles/users",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postRolesUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getServerInfoResponse = {
      machine: string,
      cpu: JSON.t,
      mem: JSON.t,
      fs: JSON.t,
    }

    let getServerInfoResponseSchema = S.object(s => {
        machine: s.field("machine", S.string),
        cpu: s.field("cpu", S.json),
        mem: s.field("mem", S.json),
        fs: s.field("fs", S.json),
      })

    /**
     * server-info
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getServerInfo = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getServerInfoResponse> => {

      fetch(
        ~url="/server-info",
        ~method_="GET",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getServerInfoResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postServerInfoResponse = {
      machine: string,
      cpu: JSON.t,
      mem: JSON.t,
      fs: JSON.t,
    }

    let postServerInfoResponseSchema = S.object(s => {
        machine: s.field("machine", S.string),
        cpu: s.field("cpu", S.json),
        mem: s.field("mem", S.json),
        fs: s.field("fs", S.json),
      })

    /**
     * server-info
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postServerInfo = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postServerInfoResponse> => {

      fetch(
        ~url="/server-info",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postServerInfoResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postStatsResponse = {
      notescount: float,
      originalnotescount: float,
      userscount: float,
      originaluserscount: float,
      instances: float,
      driveusagelocal: float,
      driveusageremote: float,
    }

    let postStatsResponseSchema = S.object(s => {
        notescount: s.field("notesCount", S.float),
        originalnotescount: s.field("originalNotesCount", S.float),
        userscount: s.field("usersCount", S.float),
        originaluserscount: s.field("originalUsersCount", S.float),
        instances: s.field("instances", S.float),
        driveusagelocal: s.field("driveUsageLocal", S.float),
        driveusageremote: s.field("driveUsageRemote", S.float),
      })

    /**
     * stats
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postStats = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postStatsResponse> => {

      fetch(
        ~url="/stats",
        ~method_="POST",
         ~body=None
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postStatsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postSwRegisterRequest = {
      endpoint: string,
      auth: string,
      publickey: string,
      sendreadmessage: option<bool>,
    }

    let postSwRegisterRequestSchema = S.object(s => {
        endpoint: s.field("endpoint", S.string),
        auth: s.field("auth", S.string),
        publickey: s.field("publickey", S.string),
        sendreadmessage: s.fieldOr("sendReadMessage", S.nullableAsOption(S.bool), None),
      })

    type postSwRegisterResponse = {
      state: option<string>,
      key: JSON.t,
      userid: string,
      endpoint: string,
      sendreadmessage: bool,
    }

    let postSwRegisterResponseSchema = S.object(s => {
        state: s.fieldOr("state", S.nullableAsOption(S.string), None),
        key: s.field("key", S.json),
        userid: s.field("userId", S.string),
        endpoint: s.field("endpoint", S.string),
        sendreadmessage: s.field("sendReadMessage", S.bool),
      })

    /**
     * sw/register
     *
     * Register to receive push notifications.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postSwRegister = (~body: postSwRegisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postSwRegisterResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwRegisterRequestSchema)

      fetch(
        ~url="/sw/register",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postSwRegisterResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postSwShowRegistrationRequest = {
      endpoint: string,
    }

    let postSwShowRegistrationRequestSchema = S.object(s => {
        endpoint: s.field("endpoint", S.string),
      })

    type postSwShowRegistrationResponse = JSON.t

    let postSwShowRegistrationResponseSchema = S.json

    /**
     * sw/show-registration
     *
     * Check push notification registration exists.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postSwShowRegistration = (~body: postSwShowRegistrationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postSwShowRegistrationResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwShowRegistrationRequestSchema)

      fetch(
        ~url="/sw/show-registration",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postSwShowRegistrationResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postSwUnregisterRequest = {
      endpoint: string,
    }

    let postSwUnregisterRequestSchema = S.object(s => {
        endpoint: s.field("endpoint", S.string),
      })

    type postSwUnregisterResponse = unit

    /**
     * sw/unregister
     *
     * Unregister from receiving push notifications.
     *
     * **Credential required**: *No*
     */
    let postSwUnregister = (~body: postSwUnregisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postSwUnregisterResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwUnregisterRequestSchema)

      fetch(
        ~url="/sw/unregister",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postSwUpdateRegistrationRequest = {
      endpoint: string,
      sendreadmessage: option<bool>,
    }

    let postSwUpdateRegistrationRequestSchema = S.object(s => {
        endpoint: s.field("endpoint", S.string),
        sendreadmessage: s.fieldOr("sendReadMessage", S.nullableAsOption(S.bool), None),
      })

    type postSwUpdateRegistrationResponse = {
      userid: string,
      endpoint: string,
      sendreadmessage: bool,
    }

    let postSwUpdateRegistrationResponseSchema = S.object(s => {
        userid: s.field("userId", S.string),
        endpoint: s.field("endpoint", S.string),
        sendreadmessage: s.field("sendReadMessage", S.bool),
      })

    /**
     * sw/update-registration
     *
     * Update push notification registration.
     *
     * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
     * **Credential required**: *Yes*
     */
    let postSwUpdateRegistration = (~body: postSwUpdateRegistrationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postSwUpdateRegistrationResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwUpdateRegistrationRequestSchema)

      fetch(
        ~url="/sw/update-registration",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postSwUpdateRegistrationResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postTestRequest = {
      required: bool,
      string: option<string>,
      default: option<string>,
      nullabledefault: option<JSON.t>,
      id: option<string>,
    }

    let postTestRequestSchema = S.object(s => {
        required: s.field("required", S.bool),
        string: s.fieldOr("string", S.nullableAsOption(S.string), None),
        default: s.fieldOr("default", S.nullableAsOption(S.string), None),
        nullabledefault: s.fieldOr("nullableDefault", S.nullableAsOption(S.json), None),
        id: s.fieldOr("id", S.nullableAsOption(S.string), None),
      })

    type postTestResponse = {
      id: option<string>,
      required: bool,
      string: option<string>,
      default: option<string>,
      nullabledefault: option<JSON.t>,
    }

    let postTestResponseSchema = S.object(s => {
        id: s.fieldOr("id", S.nullableAsOption(S.string), None),
        required: s.field("required", S.bool),
        string: s.fieldOr("string", S.nullableAsOption(S.string), None),
        default: s.fieldOr("default", S.nullableAsOption(S.string), None),
        nullabledefault: s.fieldOr("nullableDefault", S.nullableAsOption(S.json), None),
      })

    /**
     * test
     *
     * Endpoint for testing input validation.
     *
     * **Credential required**: *No*
     */
    let postTest = (~body: postTestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postTestResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postTestRequestSchema)

      fetch(
        ~url="/test",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postTestResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsernameAvailableRequest = {
      username: string,
    }

    let postUsernameAvailableRequestSchema = S.object(s => {
        username: s.field("username", S.string->S.pattern(%re("/^\\w{1,20}$/"))),
      })

    type postUsernameAvailableResponse = {
      available: bool,
    }

    let postUsernameAvailableResponseSchema = S.object(s => {
        available: s.field("available", S.bool),
      })

    /**
     * username/available
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postUsernameAvailable = (~body: postUsernameAvailableRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsernameAvailableResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsernameAvailableRequestSchema)

      fetch(
        ~url="/username/available",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsernameAvailableResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersRequest = {
      limit: option<int>,
      offset: option<int>,
      sort: option<string>,
      state: option<string>,
      origin: option<string>,
      hostname: option<JSON.t>,
    }

    let postUsersRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
        sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
        state: s.fieldOr("state", S.nullableAsOption(S.string), None),
        origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
        hostname: s.fieldOr("hostname", S.nullableAsOption(S.json), None),
      })

    type postUsersResponse = array<ComponentSchemas.Userdetailed.t>

    let postUsersResponseSchema = S.array(ComponentSchemas.Userdetailed.schema)

    /**
     * users
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postUsers = (~body: postUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersRequestSchema)

      fetch(
        ~url="/users",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersAchievementsRequest = {
      userid: string,
    }

    let postUsersAchievementsRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
      })

    type postUsersAchievementsResponse = array<ComponentSchemas.Achievement.t>

    let postUsersAchievementsResponseSchema = S.array(ComponentSchemas.Achievement.schema)

    /**
     * users/achievements
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postUsersAchievements = (~body: postUsersAchievementsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersAchievementsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersAchievementsRequestSchema)

      fetch(
        ~url="/users/achievements",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersAchievementsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersClipsRequest = {
      userid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postUsersClipsRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postUsersClipsResponse = array<ComponentSchemas.Clip.t>

    let postUsersClipsResponseSchema = S.array(ComponentSchemas.Clip.schema)

    /**
     * users/clips
     *
     * Show all clips this user owns.
     *
     * **Credential required**: *No*
     */
    let postUsersClips = (~body: postUsersClipsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersClipsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersClipsRequestSchema)

      fetch(
        ~url="/users/clips",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersClipsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type getUsersFeaturedNotesRequest = {
      limit: option<int>,
      untilid: option<string>,
      userid: string,
    }

    let getUsersFeaturedNotesRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        userid: s.field("userId", S.string),
      })

    type getUsersFeaturedNotesResponse = array<ComponentSchemas.Note.t>

    let getUsersFeaturedNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * users/featured-notes
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let getUsersFeaturedNotes = (~body: getUsersFeaturedNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getUsersFeaturedNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(getUsersFeaturedNotesRequestSchema)

      fetch(
        ~url="/users/featured-notes",
        ~method_="GET",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(getUsersFeaturedNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersFeaturedNotesRequest = {
      limit: option<int>,
      untilid: option<string>,
      userid: string,
    }

    let postUsersFeaturedNotesRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        userid: s.field("userId", S.string),
      })

    type postUsersFeaturedNotesResponse = array<ComponentSchemas.Note.t>

    let postUsersFeaturedNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * users/featured-notes
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postUsersFeaturedNotes = (~body: postUsersFeaturedNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFeaturedNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFeaturedNotesRequestSchema)

      fetch(
        ~url="/users/featured-notes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersFeaturedNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersFlashsRequest = {
      userid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postUsersFlashsRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postUsersFlashsResponse = array<ComponentSchemas.Flash.t>

    let postUsersFlashsResponseSchema = S.array(ComponentSchemas.Flash.schema)

    /**
     * users/flashs
     *
     * Show all flashs this user created.
     *
     * **Credential required**: *No*
     */
    let postUsersFlashs = (~body: postUsersFlashsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFlashsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFlashsRequestSchema)

      fetch(
        ~url="/users/flashs",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersFlashsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersFollowersRequest = JSON.t

    let postUsersFollowersRequestSchema = S.json

    type postUsersFollowersResponse = array<ComponentSchemas.Following.t>

    let postUsersFollowersResponseSchema = S.array(ComponentSchemas.Following.schema)

    /**
     * users/followers
     *
     * Show everyone that follows this user.
     *
     * **Credential required**: *No*
     */
    let postUsersFollowers = (~body: postUsersFollowersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFollowersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFollowersRequestSchema)

      fetch(
        ~url="/users/followers",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersFollowersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersFollowingRequest = JSON.t

    let postUsersFollowingRequestSchema = S.json

    type postUsersFollowingResponse = array<ComponentSchemas.Following.t>

    let postUsersFollowingResponseSchema = S.array(ComponentSchemas.Following.schema)

    /**
     * users/following
     *
     * Show everyone that this user is following.
     *
     * **Credential required**: *No*
     */
    let postUsersFollowing = (~body: postUsersFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFollowingResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFollowingRequestSchema)

      fetch(
        ~url="/users/following",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersFollowingResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersGalleryPostsRequest = {
      userid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postUsersGalleryPostsRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postUsersGalleryPostsResponse = array<ComponentSchemas.Gallerypost.t>

    let postUsersGalleryPostsResponseSchema = S.array(ComponentSchemas.Gallerypost.schema)

    /**
     * users/gallery/posts
     *
     * Show all gallery posts by the given user.
     *
     * **Credential required**: *No*
     */
    let postUsersGalleryPosts = (~body: postUsersGalleryPostsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGalleryPostsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGalleryPostsRequestSchema)

      fetch(
        ~url="/users/gallery/posts",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersGalleryPostsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersGetFrequentlyRepliedUsersRequest = {
      userid: string,
      limit: option<int>,
    }

    let postUsersGetFrequentlyRepliedUsersRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
      })

    type postUsersGetFrequentlyRepliedUsersResponse = array<JSON.t>

    let postUsersGetFrequentlyRepliedUsersResponseSchema = S.array(S.json)

    /**
     * users/get-frequently-replied-users
     *
     * Get a list of other users that the specified user frequently replies to.
     *
     * **Credential required**: *No*
     */
    let postUsersGetFrequentlyRepliedUsers = (~body: postUsersGetFrequentlyRepliedUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGetFrequentlyRepliedUsersResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGetFrequentlyRepliedUsersRequestSchema)

      fetch(
        ~url="/users/get-frequently-replied-users",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersGetFrequentlyRepliedUsersResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersListsCreateRequest = {
      name: string,
    }

    let postUsersListsCreateRequestSchema = S.object(s => {
        name: s.field("name", S.string->S.min(1)->S.max(100)),
      })

    type postUsersListsCreateResponse = ComponentSchemas.Userlist.t

    let postUsersListsCreateResponseSchema = ComponentSchemas.Userlist.schema

    /**
     * users/lists/create
     *
     * Create a new list of users.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postUsersListsCreate = (~body: postUsersListsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsCreateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsCreateRequestSchema)

      fetch(
        ~url="/users/lists/create",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersListsCreateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersListsCreateFromPublicRequest = {
      name: string,
      listid: string,
    }

    let postUsersListsCreateFromPublicRequestSchema = S.object(s => {
        name: s.field("name", S.string->S.min(1)->S.max(100)),
        listid: s.field("listId", S.string),
      })

    type postUsersListsCreateFromPublicResponse = ComponentSchemas.Userlist.t

    let postUsersListsCreateFromPublicResponseSchema = ComponentSchemas.Userlist.schema

    /**
     * users/lists/create-from-public
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postUsersListsCreateFromPublic = (~body: postUsersListsCreateFromPublicRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsCreateFromPublicResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsCreateFromPublicRequestSchema)

      fetch(
        ~url="/users/lists/create-from-public",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersListsCreateFromPublicResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersListsDeleteRequest = {
      listid: string,
    }

    let postUsersListsDeleteRequestSchema = S.object(s => {
        listid: s.field("listId", S.string),
      })

    type postUsersListsDeleteResponse = unit

    /**
     * users/lists/delete
     *
     * Delete an existing list of users.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postUsersListsDelete = (~body: postUsersListsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsDeleteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsDeleteRequestSchema)

      fetch(
        ~url="/users/lists/delete",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postUsersListsFavoriteRequest = {
      listid: string,
    }

    let postUsersListsFavoriteRequestSchema = S.object(s => {
        listid: s.field("listId", S.string),
      })

    type postUsersListsFavoriteResponse = unit

    /**
     * users/lists/favorite
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postUsersListsFavorite = (~body: postUsersListsFavoriteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsFavoriteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsFavoriteRequestSchema)

      fetch(
        ~url="/users/lists/favorite",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postUsersListsGetMembershipsRequest = {
      listid: string,
      forpublic: option<bool>,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postUsersListsGetMembershipsRequestSchema = S.object(s => {
        listid: s.field("listId", S.string),
        forpublic: s.fieldOr("forPublic", S.nullableAsOption(S.bool), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postUsersListsGetMembershipsResponse = array<JSON.t>

    let postUsersListsGetMembershipsResponseSchema = S.array(S.json)

    /**
     * users/lists/get-memberships
     *
     * No description provided.
     *
     * **Credential required**: *No* / **Permission**: *read:account*
     */
    let postUsersListsGetMemberships = (~body: postUsersListsGetMembershipsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsGetMembershipsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsGetMembershipsRequestSchema)

      fetch(
        ~url="/users/lists/get-memberships",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersListsGetMembershipsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersListsListRequest = {
      userid: option<string>,
    }

    let postUsersListsListRequestSchema = S.object(s => {
        userid: s.fieldOr("userId", S.nullableAsOption(S.string), None),
      })

    type postUsersListsListResponse = array<ComponentSchemas.Userlist.t>

    let postUsersListsListResponseSchema = S.array(ComponentSchemas.Userlist.schema)

    /**
     * users/lists/list
     *
     * Show all lists that the authenticated user has created.
     *
     * **Credential required**: *No* / **Permission**: *read:account*
     */
    let postUsersListsList = (~body: postUsersListsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsListRequestSchema)

      fetch(
        ~url="/users/lists/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersListsListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersListsPullRequest = {
      listid: string,
      userid: string,
    }

    let postUsersListsPullRequestSchema = S.object(s => {
        listid: s.field("listId", S.string),
        userid: s.field("userId", S.string),
      })

    type postUsersListsPullResponse = unit

    /**
     * users/lists/pull
     *
     * Remove a user from a list.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postUsersListsPull = (~body: postUsersListsPullRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsPullResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsPullRequestSchema)

      fetch(
        ~url="/users/lists/pull",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postUsersListsPushRequest = {
      listid: string,
      userid: string,
    }

    let postUsersListsPushRequestSchema = S.object(s => {
        listid: s.field("listId", S.string),
        userid: s.field("userId", S.string),
      })

    type postUsersListsPushResponse = unit

    /**
     * users/lists/push
     *
     * Add a user to an existing list.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postUsersListsPush = (~body: postUsersListsPushRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsPushResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsPushRequestSchema)

      fetch(
        ~url="/users/lists/push",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postUsersListsShowRequest = {
      listid: string,
      forpublic: option<bool>,
    }

    let postUsersListsShowRequestSchema = S.object(s => {
        listid: s.field("listId", S.string),
        forpublic: s.fieldOr("forPublic", S.nullableAsOption(S.bool), None),
      })

    type postUsersListsShowResponse = JSON.t

    let postUsersListsShowResponseSchema = S.json

    /**
     * users/lists/show
     *
     * Show the properties of a list.
     *
     * **Credential required**: *No* / **Permission**: *read:account*
     */
    let postUsersListsShow = (~body: postUsersListsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsShowRequestSchema)

      fetch(
        ~url="/users/lists/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersListsShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersListsUnfavoriteRequest = {
      listid: string,
    }

    let postUsersListsUnfavoriteRequestSchema = S.object(s => {
        listid: s.field("listId", S.string),
      })

    type postUsersListsUnfavoriteResponse = unit

    /**
     * users/lists/unfavorite
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postUsersListsUnfavorite = (~body: postUsersListsUnfavoriteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsUnfavoriteResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsUnfavoriteRequestSchema)

      fetch(
        ~url="/users/lists/unfavorite",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postUsersListsUpdateRequest = {
      listid: string,
      name: option<string>,
      ispublic: option<bool>,
    }

    let postUsersListsUpdateRequestSchema = S.object(s => {
        listid: s.field("listId", S.string),
        name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.max(100)), None),
        ispublic: s.fieldOr("isPublic", S.nullableAsOption(S.bool), None),
      })

    type postUsersListsUpdateResponse = ComponentSchemas.Userlist.t

    let postUsersListsUpdateResponseSchema = ComponentSchemas.Userlist.schema

    /**
     * users/lists/update
     *
     * Update the properties of a list.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postUsersListsUpdate = (~body: postUsersListsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsUpdateResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsUpdateRequestSchema)

      fetch(
        ~url="/users/lists/update",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersListsUpdateResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersListsUpdateMembershipRequest = {
      listid: string,
      userid: string,
      withreplies: option<bool>,
    }

    let postUsersListsUpdateMembershipRequestSchema = S.object(s => {
        listid: s.field("listId", S.string),
        userid: s.field("userId", S.string),
        withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
      })

    type postUsersListsUpdateMembershipResponse = unit

    /**
     * users/lists/update-membership
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postUsersListsUpdateMembership = (~body: postUsersListsUpdateMembershipRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsUpdateMembershipResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsUpdateMembershipRequestSchema)

      fetch(
        ~url="/users/lists/update-membership",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postUsersNotesRequest = {
      userid: string,
      withreplies: option<bool>,
      withrenotes: option<bool>,
      withchannelnotes: option<bool>,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      allowpartial: option<bool>,
      withfiles: option<bool>,
    }

    let postUsersNotesRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
        withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
        withchannelnotes: s.fieldOr("withChannelNotes", S.nullableAsOption(S.bool), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
        withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
      })

    type postUsersNotesResponse = array<ComponentSchemas.Note.t>

    let postUsersNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

    /**
     * users/notes
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postUsersNotes = (~body: postUsersNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersNotesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersNotesRequestSchema)

      fetch(
        ~url="/users/notes",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersNotesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersPagesRequest = {
      userid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postUsersPagesRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postUsersPagesResponse = array<ComponentSchemas.Page.t>

    let postUsersPagesResponseSchema = S.array(ComponentSchemas.Page.schema)

    /**
     * users/pages
     *
     * Show all pages this user created.
     *
     * **Credential required**: *No*
     */
    let postUsersPages = (~body: postUsersPagesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersPagesResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersPagesRequestSchema)

      fetch(
        ~url="/users/pages",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersPagesResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersReactionsRequest = {
      userid: string,
      limit: option<int>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
    }

    let postUsersReactionsRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
      })

    type postUsersReactionsResponse = array<ComponentSchemas.Notereactionwithnote.t>

    let postUsersReactionsResponseSchema = S.array(ComponentSchemas.Notereactionwithnote.schema)

    /**
     * users/reactions
     *
     * Show all reactions this user made.
     *
     * **Credential required**: *No*
     */
    let postUsersReactions = (~body: postUsersReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersReactionsResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersReactionsRequestSchema)

      fetch(
        ~url="/users/reactions",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersReactionsResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersRecommendationRequest = {
      limit: option<int>,
      offset: option<int>,
    }

    let postUsersRecommendationRequestSchema = S.object(s => {
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
      })

    type postUsersRecommendationResponse = array<ComponentSchemas.Userdetailed.t>

    let postUsersRecommendationResponseSchema = S.array(ComponentSchemas.Userdetailed.schema)

    /**
     * users/recommendation
     *
     * Show users that the authenticated user might be interested to follow.
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postUsersRecommendation = (~body: postUsersRecommendationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersRecommendationResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersRecommendationRequestSchema)

      fetch(
        ~url="/users/recommendation",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersRecommendationResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersRelationRequest = {
      userid: array<string>,
    }

    let postUsersRelationRequestSchema = S.object(s => {
        userid: s.field("userId", S.array(S.string)),
      })

    type postUsersRelationResponse = JSON.t

    let postUsersRelationResponseSchema = S.json

    /**
     * users/relation
     *
     * Show the different kinds of relations between the authenticated user and the specified user(s).
     *
     * **Credential required**: *Yes* / **Permission**: *read:account*
     */
    let postUsersRelation = (~body: postUsersRelationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersRelationResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersRelationRequestSchema)

      fetch(
        ~url="/users/relation",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersRelationResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersReportAbuseRequest = {
      userid: string,
      comment: string,
    }

    let postUsersReportAbuseRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        comment: s.field("comment", S.string->S.min(1)->S.max(2048)),
      })

    type postUsersReportAbuseResponse = unit

    /**
     * users/report-abuse
     *
     * File a report.
     *
     * **Credential required**: *Yes* / **Permission**: *write:report-abuse*
     */
    let postUsersReportAbuse = (~body: postUsersReportAbuseRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersReportAbuseResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersReportAbuseRequestSchema)

      fetch(
        ~url="/users/report-abuse",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postUsersSearchRequest = {
      query: string,
      offset: option<int>,
      limit: option<int>,
      origin: option<string>,
      detail: option<bool>,
    }

    let postUsersSearchRequestSchema = S.object(s => {
        query: s.field("query", S.string),
        offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
        detail: s.fieldOr("detail", S.nullableAsOption(S.bool), None),
      })

    type postUsersSearchResponse = array<ComponentSchemas.User.t>

    let postUsersSearchResponseSchema = S.array(ComponentSchemas.User.schema)

    /**
     * users/search
     *
     * Search for users.
     *
     * **Credential required**: *No*
     */
    let postUsersSearch = (~body: postUsersSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersSearchResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersSearchRequestSchema)

      fetch(
        ~url="/users/search",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersSearchResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersSearchByUsernameAndHostRequest = JSON.t

    let postUsersSearchByUsernameAndHostRequestSchema = S.json

    type postUsersSearchByUsernameAndHostResponse = array<ComponentSchemas.User.t>

    let postUsersSearchByUsernameAndHostResponseSchema = S.array(ComponentSchemas.User.schema)

    /**
     * users/search-by-username-and-host
     *
     * Search for a user by username and/or host.
     *
     * **Credential required**: *No*
     */
    let postUsersSearchByUsernameAndHost = (~body: postUsersSearchByUsernameAndHostRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersSearchByUsernameAndHostResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersSearchByUsernameAndHostRequestSchema)

      fetch(
        ~url="/users/search-by-username-and-host",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersSearchByUsernameAndHostResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersShowRequest = JSON.t

    let postUsersShowRequestSchema = S.json

    type postUsersShowResponse = array<ComponentSchemas.Userdetailed.t>

    let postUsersShowResponseSchema = S.array(ComponentSchemas.Userdetailed.schema)

    /**
     * users/show
     *
     * Show the properties of a user.
     *
     * **Credential required**: *No*
     */
    let postUsersShow = (~body: postUsersShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersShowResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersShowRequestSchema)

      fetch(
        ~url="/users/show",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postUsersShowResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postUsersUpdateMemoRequest = {
      userid: string,
      memo: JSON.t,
    }

    let postUsersUpdateMemoRequestSchema = S.object(s => {
        userid: s.field("userId", S.string),
        memo: s.field("memo", S.json),
      })

    type postUsersUpdateMemoResponse = unit

    /**
     * users/update-memo
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *write:account*
     */
    let postUsersUpdateMemo = (~body: postUsersUpdateMemoRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersUpdateMemoResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersUpdateMemoRequestSchema)

      fetch(
        ~url="/users/update-memo",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

    type postV2AdminEmojiListRequest = {
      query: option<JSON.t>,
      sinceid: option<string>,
      untilid: option<string>,
      sincedate: option<int>,
      untildate: option<int>,
      limit: option<int>,
      page: option<int>,
      sortkeys: option<array<string>>,
    }

    let postV2AdminEmojiListRequestSchema = S.object(s => {
        query: s.fieldOr("query", S.nullableAsOption(S.json), None),
        sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
        untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
        sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
        untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
        limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
        page: s.fieldOr("page", S.nullableAsOption(S.int), None),
        sortkeys: s.fieldOr("sortKeys", S.nullableAsOption(S.array(S.string)), None),
      })

    type postV2AdminEmojiListResponse = {
      emojis: array<ComponentSchemas.Emojidetailedadmin.t>,
      count: int,
      allcount: int,
      allpages: int,
    }

    let postV2AdminEmojiListResponseSchema = S.object(s => {
        emojis: s.field("emojis", S.array(ComponentSchemas.Emojidetailedadmin.schema)),
        count: s.field("count", S.int),
        allcount: s.field("allCount", S.int),
        allpages: s.field("allPages", S.int),
      })

    /**
     * v2/admin/emoji/list
     *
     * No description provided.
     *
     * **Credential required**: *Yes* / **Permission**: *read:admin:emoji*
     */
    let postV2AdminEmojiList = (~body: postV2AdminEmojiListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postV2AdminEmojiListResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postV2AdminEmojiListRequestSchema)

      fetch(
        ~url="/v2/admin/emoji/list",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let validatedResponse = response->S.parseOrThrow(postV2AdminEmojiListResponseSchema)
      validatedResponse
    ->Promise.resolve
      })
    }

    type postVerifyEmailRequest = {
      code: string,
    }

    let postVerifyEmailRequestSchema = S.object(s => {
        code: s.field("code", S.string),
      })

    type postVerifyEmailResponse = unit

    /**
     * verify-email
     *
     * No description provided.
     *
     * **Credential required**: *No*
     */
    let postVerifyEmail = (~body: postVerifyEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postVerifyEmailResponse> => {
      let jsonBody = body->S.reverseConvertToJsonOrThrow(postVerifyEmailRequestSchema)

      fetch(
        ~url="/verify-email",
        ~method_="POST",
        ~body=Some(jsonBody),
      )->Promise.then(response => {
      let _ = response
      ()
    ->Promise.resolve
      })
    }

}