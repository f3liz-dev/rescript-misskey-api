// SPDX-License-Identifier: MIT
// API endpoints for notes
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type postChannelsTimelineRequest = {
  channelid: string,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
  sincedate: option<int>,
  untildate: option<int>,
  allowpartial: option<bool>,
  dimension: option<JSON.t>,
}

let postChannelsTimelineRequestSchema = S.object(s => {
    channelid: s.field("channelId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    dimension: s.fieldOr("dimension", S.nullableAsOption(S.json), None),
  })

type postChannelsTimelineResponse = array<ComponentSchemas.Note.t>

let postChannelsTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * channels/timeline
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChannelsTimeline = (~body: postChannelsTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsTimelineRequestSchema)
  
  fetch(
    ~url="/channels/timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChannelsTimelineResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesRequest = {
  local: option<bool>,
  reply: option<bool>,
  renote: option<bool>,
  withfiles: option<bool>,
  poll: option<bool>,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
}

let postNotesRequestSchema = S.object(s => {
    local: s.fieldOr("local", S.nullableAsOption(S.bool), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.bool), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.bool), None),
    withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    poll: s.fieldOr("poll", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postNotesResponse = array<ComponentSchemas.Note.t>

let postNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotes = (~body: postNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRequestSchema)
  
  fetch(
    ~url="/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesChildrenRequest = {
  noteid: string,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
}

let postNotesChildrenRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postNotesChildrenResponse = array<ComponentSchemas.Note.t>

let postNotesChildrenResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/children
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesChildren = (~body: postNotesChildrenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesChildrenResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesChildrenRequestSchema)
  
  fetch(
    ~url="/notes/children",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesChildrenResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesConversationRequest = {
  noteid: string,
  limit: option<int>,
  offset: option<int>,
}

let postNotesConversationRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
  })

type postNotesConversationResponse = array<ComponentSchemas.Note.t>

let postNotesConversationResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/conversation
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesConversation = (~body: postNotesConversationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesConversationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesConversationRequestSchema)
  
  fetch(
    ~url="/notes/conversation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesConversationResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesCreateRequest = {
  visibility: option<string>,
  visibleuserids: option<array<string>>,
  cw: option<JSON.t>,
  localonly: option<bool>,
  dimension: option<JSON.t>,
  reactionacceptance: option<JSON.t>,
  noextractmentions: option<bool>,
  noextracthashtags: option<bool>,
  noextractemojis: option<bool>,
  replyid: option<JSON.t>,
  renoteid: option<JSON.t>,
  channelid: option<JSON.t>,
  lang: option<JSON.t>,
  text: option<JSON.t>,
  fileids: option<array<string>>,
  mediaids: option<array<string>>,
  poll: option<JSON.t>,
  scheduledat: option<JSON.t>,
  nocreatednote: option<bool>,
}

let postNotesCreateRequestSchema = S.object(s => {
    visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
    visibleuserids: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
    cw: s.fieldOr("cw", S.nullableAsOption(S.json), None),
    localonly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    dimension: s.fieldOr("dimension", S.nullableAsOption(S.json), None),
    reactionacceptance: s.fieldOr("reactionAcceptance", S.nullableAsOption(S.json), None),
    noextractmentions: s.fieldOr("noExtractMentions", S.nullableAsOption(S.bool), None),
    noextracthashtags: s.fieldOr("noExtractHashtags", S.nullableAsOption(S.bool), None),
    noextractemojis: s.fieldOr("noExtractEmojis", S.nullableAsOption(S.bool), None),
    replyid: s.fieldOr("replyId", S.nullableAsOption(S.json), None),
    renoteid: s.fieldOr("renoteId", S.nullableAsOption(S.json), None),
    channelid: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
    lang: s.fieldOr("lang", S.nullableAsOption(S.json), None),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileids: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    mediaids: s.fieldOr("mediaIds", S.nullableAsOption(S.array(S.string)), None),
    poll: s.fieldOr("poll", S.nullableAsOption(S.json), None),
    scheduledat: s.fieldOr("scheduledAt", S.nullableAsOption(S.json), None),
    nocreatednote: s.fieldOr("noCreatedNote", S.nullableAsOption(S.bool), None),
  })

type postNotesCreateResponse = {
  creatednote: ComponentSchemas.Note.t,
}

let postNotesCreateResponseSchema = S.object(s => {
    creatednote: s.field("createdNote", ComponentSchemas.Note.schema),
  })

/**
 * notes/create
 *
 * Create a new note (post) on Misskey.
 *
 * This endpoint allows you to:
 * - Create text notes with markdown support
 * - Upload files/images
 * - Set visibility (public, home, followers, specified)
 * - Add content warnings (CW)
 * - Create polls
 * - Reply to or quote other notes
 *
 * **Important:** Requires the write:notes permission.
 *
 * Example usage:
 */
let postNotesCreate = (~body: postNotesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesCreateRequestSchema)
  
  fetch(
    ~url="/notes/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesCreateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesDeleteRequest = {
  noteid: string,
}

let postNotesDeleteRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
  })

type postNotesDeleteResponse = unit

/**
 * notes/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:notes*
 */
let postNotesDelete = (~body: postNotesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDeleteRequestSchema)
  
  fetch(
    ~url="/notes/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postNotesFavoritesCreateRequest = {
  noteid: string,
}

let postNotesFavoritesCreateRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
  })

type postNotesFavoritesCreateResponse = unit

/**
 * notes/favorites/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:favorites*
 */
let postNotesFavoritesCreate = (~body: postNotesFavoritesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesFavoritesCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFavoritesCreateRequestSchema)
  
  fetch(
    ~url="/notes/favorites/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postNotesFavoritesDeleteRequest = {
  noteid: string,
}

let postNotesFavoritesDeleteRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
  })

type postNotesFavoritesDeleteResponse = unit

/**
 * notes/favorites/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:favorites*
 */
let postNotesFavoritesDelete = (~body: postNotesFavoritesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesFavoritesDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFavoritesDeleteRequestSchema)
  
  fetch(
    ~url="/notes/favorites/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type getNotesFeaturedRequest = {
  limit: option<int>,
  untilid: option<string>,
  channelid: option<JSON.t>,
}

let getNotesFeaturedRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    channelid: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
  })

type getNotesFeaturedResponse = array<ComponentSchemas.Note.t>

let getNotesFeaturedResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/featured
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getNotesFeatured = (~body: getNotesFeaturedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getNotesFeaturedResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getNotesFeaturedRequestSchema)
  
  fetch(
    ~url="/notes/featured",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getNotesFeaturedResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesFeaturedRequest = {
  limit: option<int>,
  untilid: option<string>,
  channelid: option<JSON.t>,
}

let postNotesFeaturedRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    channelid: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
  })

type postNotesFeaturedResponse = array<ComponentSchemas.Note.t>

let postNotesFeaturedResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/featured
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesFeatured = (~body: postNotesFeaturedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesFeaturedResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFeaturedRequestSchema)
  
  fetch(
    ~url="/notes/featured",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesFeaturedResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesGlobalTimelineRequest = {
  withfiles: option<bool>,
  withrenotes: option<bool>,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
  sincedate: option<int>,
  untildate: option<int>,
  dimension: option<JSON.t>,
}

let postNotesGlobalTimelineRequestSchema = S.object(s => {
    withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    dimension: s.fieldOr("dimension", S.nullableAsOption(S.json), None),
  })

type postNotesGlobalTimelineResponse = array<ComponentSchemas.Note.t>

let postNotesGlobalTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/global-timeline
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesGlobalTimeline = (~body: postNotesGlobalTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesGlobalTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesGlobalTimelineRequestSchema)
  
  fetch(
    ~url="/notes/global-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesGlobalTimelineResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesHybridTimelineRequest = {
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
  sincedate: option<int>,
  untildate: option<int>,
  allowpartial: option<bool>,
  includemyrenotes: option<bool>,
  includerenotedmynotes: option<bool>,
  includelocalrenotes: option<bool>,
  withfiles: option<bool>,
  withrenotes: option<bool>,
  withreplies: option<bool>,
  dimension: option<JSON.t>,
}

let postNotesHybridTimelineRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    includemyrenotes: s.fieldOr("includeMyRenotes", S.nullableAsOption(S.bool), None),
    includerenotedmynotes: s.fieldOr("includeRenotedMyNotes", S.nullableAsOption(S.bool), None),
    includelocalrenotes: s.fieldOr("includeLocalRenotes", S.nullableAsOption(S.bool), None),
    withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
    dimension: s.fieldOr("dimension", S.nullableAsOption(S.json), None),
  })

type postNotesHybridTimelineResponse = array<ComponentSchemas.Note.t>

let postNotesHybridTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/hybrid-timeline
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesHybridTimeline = (~body: postNotesHybridTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesHybridTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesHybridTimelineRequestSchema)
  
  fetch(
    ~url="/notes/hybrid-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesHybridTimelineResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesLocalTimelineRequest = {
  withfiles: option<bool>,
  withrenotes: option<bool>,
  withreplies: option<bool>,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
  allowpartial: option<bool>,
  sincedate: option<int>,
  untildate: option<int>,
  dimension: option<JSON.t>,
}

let postNotesLocalTimelineRequestSchema = S.object(s => {
    withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    dimension: s.fieldOr("dimension", S.nullableAsOption(S.json), None),
  })

type postNotesLocalTimelineResponse = array<ComponentSchemas.Note.t>

let postNotesLocalTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/local-timeline
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesLocalTimeline = (~body: postNotesLocalTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesLocalTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesLocalTimelineRequestSchema)
  
  fetch(
    ~url="/notes/local-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesLocalTimelineResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesMentionsRequest = {
  following: option<bool>,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
  visibility: option<string>,
}

let postNotesMentionsRequestSchema = S.object(s => {
    following: s.fieldOr("following", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
  })

type postNotesMentionsResponse = array<ComponentSchemas.Note.t>

let postNotesMentionsResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/mentions
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesMentions = (~body: postNotesMentionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesMentionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesMentionsRequestSchema)
  
  fetch(
    ~url="/notes/mentions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesMentionsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesPollsRecommendationRequest = {
  limit: option<int>,
  offset: option<int>,
  excludechannels: option<bool>,
}

let postNotesPollsRecommendationRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    excludechannels: s.fieldOr("excludeChannels", S.nullableAsOption(S.bool), None),
  })

type postNotesPollsRecommendationResponse = array<ComponentSchemas.Note.t>

let postNotesPollsRecommendationResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/polls/recommendation
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesPollsRecommendation = (~body: postNotesPollsRecommendationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesPollsRecommendationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesPollsRecommendationRequestSchema)
  
  fetch(
    ~url="/notes/polls/recommendation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesPollsRecommendationResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesPollsVoteRequest = {
  noteid: string,
  choice: int,
}

let postNotesPollsVoteRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
    choice: s.field("choice", S.int),
  })

type postNotesPollsVoteResponse = unit

/**
 * notes/polls/vote
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:votes*
 */
let postNotesPollsVote = (~body: postNotesPollsVoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesPollsVoteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesPollsVoteRequestSchema)
  
  fetch(
    ~url="/notes/polls/vote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type getNotesReactionsRequest = {
  noteid: string,
  @as("type") type_: option<JSON.t>,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
}

let getNotesReactionsRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
    type_: s.fieldOr("type", S.nullableAsOption(S.json), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type getNotesReactionsResponse = array<ComponentSchemas.Notereaction.t>

let getNotesReactionsResponseSchema = S.array(ComponentSchemas.Notereaction.schema)

/**
 * notes/reactions
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getNotesReactions = (~body: getNotesReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getNotesReactionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getNotesReactionsRequestSchema)
  
  fetch(
    ~url="/notes/reactions",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getNotesReactionsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesReactionsRequest = {
  noteid: string,
  @as("type") type_: option<JSON.t>,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
}

let postNotesReactionsRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
    type_: s.fieldOr("type", S.nullableAsOption(S.json), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postNotesReactionsResponse = array<ComponentSchemas.Notereaction.t>

let postNotesReactionsResponseSchema = S.array(ComponentSchemas.Notereaction.schema)

/**
 * notes/reactions
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesReactions = (~body: postNotesReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesReactionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesReactionsRequestSchema)
  
  fetch(
    ~url="/notes/reactions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesReactionsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesRenotesRequest = {
  noteid: string,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
}

let postNotesRenotesRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postNotesRenotesResponse = array<ComponentSchemas.Note.t>

let postNotesRenotesResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/renotes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesRenotes = (~body: postNotesRenotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesRenotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRenotesRequestSchema)
  
  fetch(
    ~url="/notes/renotes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesRenotesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesRepliesRequest = {
  noteid: string,
  sinceid: option<string>,
  untilid: option<string>,
  limit: option<int>,
}

let postNotesRepliesRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postNotesRepliesResponse = array<ComponentSchemas.Note.t>

let postNotesRepliesResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/replies
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesReplies = (~body: postNotesRepliesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesRepliesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRepliesRequestSchema)
  
  fetch(
    ~url="/notes/replies",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesRepliesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesScheduledCancelRequest = {
  draftid: string,
}

let postNotesScheduledCancelRequestSchema = S.object(s => {
    draftid: s.field("draftId", S.string),
  })

type postNotesScheduledCancelResponse = unit

/**
 * notes/scheduled/cancel
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:notes*
 */
let postNotesScheduledCancel = (~body: postNotesScheduledCancelRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesScheduledCancelResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesScheduledCancelRequestSchema)
  
  fetch(
    ~url="/notes/scheduled/cancel",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postNotesScheduledListRequest = {
  limit: option<int>,
  offset: option<int>,
}

let postNotesScheduledListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
  })

type postNotesScheduledListResponse = array<ComponentSchemas.Notedraft.t>

let postNotesScheduledListResponseSchema = S.array(ComponentSchemas.Notedraft.schema)

/**
 * notes/scheduled/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:notes*
 */
let postNotesScheduledList = (~body: postNotesScheduledListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesScheduledListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesScheduledListRequestSchema)
  
  fetch(
    ~url="/notes/scheduled/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesScheduledListResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesSearchRequest = {
  query: string,
  sinceid: option<string>,
  untilid: option<string>,
  limit: option<int>,
  offset: option<int>,
  host: option<string>,
  userid: option<JSON.t>,
  channelid: option<JSON.t>,
}

let postNotesSearchRequestSchema = S.object(s => {
    query: s.field("query", S.string),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    host: s.fieldOr("host", S.nullableAsOption(S.string), None),
    userid: s.fieldOr("userId", S.nullableAsOption(S.json), None),
    channelid: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
  })

type postNotesSearchResponse = array<ComponentSchemas.Note.t>

let postNotesSearchResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/search
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesSearch = (~body: postNotesSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesSearchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesSearchRequestSchema)
  
  fetch(
    ~url="/notes/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesSearchResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesSearchByTagRequest = {
  local: option<JSON.t>,
  reply: option<JSON.t>,
  renote: option<JSON.t>,
  withfiles: option<bool>,
  poll: option<JSON.t>,
  sinceid: option<string>,
  untilid: option<string>,
  limit: option<int>,
  tag: option<string>,
  query: option<array<array<string>>>,
}

let postNotesSearchByTagRequestSchema = S.object(s => {
    local: s.fieldOr("local", S.nullableAsOption(S.json), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.json), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.json), None),
    withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    poll: s.fieldOr("poll", S.nullableAsOption(S.json), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    tag: s.fieldOr("tag", S.nullableAsOption(S.string->S.min(1)), None),
    query: s.fieldOr("query", S.nullableAsOption(S.array(S.array(S.string->S.min(1)))), None),
  })

type postNotesSearchByTagResponse = array<ComponentSchemas.Note.t>

let postNotesSearchByTagResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/search-by-tag
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesSearchByTag = (~body: postNotesSearchByTagRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesSearchByTagResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesSearchByTagRequestSchema)
  
  fetch(
    ~url="/notes/search-by-tag",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesSearchByTagResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesShowRequest = {
  noteid: string,
}

let postNotesShowRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
  })

type postNotesShowResponse = ComponentSchemas.Note.t

let postNotesShowResponseSchema = ComponentSchemas.Note.schema

/**
 * notes/show
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesShow = (~body: postNotesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesShowRequestSchema)
  
  fetch(
    ~url="/notes/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesShowResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesStateRequest = {
  noteid: string,
}

let postNotesStateRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
  })

type postNotesStateResponse = {
  isfavorited: bool,
  ismutedthread: bool,
}

let postNotesStateResponseSchema = S.object(s => {
    isfavorited: s.field("isFavorited", S.bool),
    ismutedthread: s.field("isMutedThread", S.bool),
  })

/**
 * notes/state
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesState = (~body: postNotesStateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesStateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesStateRequestSchema)
  
  fetch(
    ~url="/notes/state",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesStateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesThreadMutingCreateRequest = {
  noteid: string,
}

let postNotesThreadMutingCreateRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
  })

type postNotesThreadMutingCreateResponse = unit

/**
 * notes/thread-muting/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postNotesThreadMutingCreate = (~body: postNotesThreadMutingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesThreadMutingCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesThreadMutingCreateRequestSchema)
  
  fetch(
    ~url="/notes/thread-muting/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postNotesThreadMutingDeleteRequest = {
  noteid: string,
}

let postNotesThreadMutingDeleteRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
  })

type postNotesThreadMutingDeleteResponse = unit

/**
 * notes/thread-muting/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postNotesThreadMutingDelete = (~body: postNotesThreadMutingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesThreadMutingDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesThreadMutingDeleteRequestSchema)
  
  fetch(
    ~url="/notes/thread-muting/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postNotesTimelineRequest = {
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
  sincedate: option<int>,
  untildate: option<int>,
  allowpartial: option<bool>,
  includemyrenotes: option<bool>,
  includerenotedmynotes: option<bool>,
  includelocalrenotes: option<bool>,
  withfiles: option<bool>,
  withrenotes: option<bool>,
  dimension: option<JSON.t>,
}

let postNotesTimelineRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    includemyrenotes: s.fieldOr("includeMyRenotes", S.nullableAsOption(S.bool), None),
    includerenotedmynotes: s.fieldOr("includeRenotedMyNotes", S.nullableAsOption(S.bool), None),
    includelocalrenotes: s.fieldOr("includeLocalRenotes", S.nullableAsOption(S.bool), None),
    withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    dimension: s.fieldOr("dimension", S.nullableAsOption(S.json), None),
  })

type postNotesTimelineResponse = array<ComponentSchemas.Note.t>

let postNotesTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/timeline
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesTimeline = (~body: postNotesTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesTimelineRequestSchema)
  
  fetch(
    ~url="/notes/timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesTimelineResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesTranslateRequest = {
  noteid: string,
  targetlang: string,
}

let postNotesTranslateRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
    targetlang: s.field("targetLang", S.string),
  })

type postNotesTranslateResponse = {
  sourcelang: string,
  text: string,
}

let postNotesTranslateResponseSchema = S.object(s => {
    sourcelang: s.field("sourceLang", S.string),
    text: s.field("text", S.string),
  })

/**
 * notes/translate
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesTranslate = (~body: postNotesTranslateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesTranslateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesTranslateRequestSchema)
  
  fetch(
    ~url="/notes/translate",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesTranslateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postNotesUnrenoteRequest = {
  noteid: string,
}

let postNotesUnrenoteRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
  })

type postNotesUnrenoteResponse = unit

/**
 * notes/unrenote
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:notes*
 */
let postNotesUnrenote = (~body: postNotesUnrenoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesUnrenoteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesUnrenoteRequestSchema)
  
  fetch(
    ~url="/notes/unrenote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postNotesUserListTimelineRequest = {
  listid: string,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
  sincedate: option<int>,
  untildate: option<int>,
  allowpartial: option<bool>,
  includemyrenotes: option<bool>,
  includerenotedmynotes: option<bool>,
  includelocalrenotes: option<bool>,
  withrenotes: option<bool>,
  withfiles: option<bool>,
}

let postNotesUserListTimelineRequestSchema = S.object(s => {
    listid: s.field("listId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    includemyrenotes: s.fieldOr("includeMyRenotes", S.nullableAsOption(S.bool), None),
    includerenotedmynotes: s.fieldOr("includeRenotedMyNotes", S.nullableAsOption(S.bool), None),
    includelocalrenotes: s.fieldOr("includeLocalRenotes", S.nullableAsOption(S.bool), None),
    withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
  })

type postNotesUserListTimelineResponse = array<ComponentSchemas.Note.t>

let postNotesUserListTimelineResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * notes/user-list-timeline
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesUserListTimeline = (~body: postNotesUserListTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesUserListTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesUserListTimelineRequestSchema)
  
  fetch(
    ~url="/notes/user-list-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postNotesUserListTimelineResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postPromoReadRequest = {
  noteid: string,
}

let postPromoReadRequestSchema = S.object(s => {
    noteid: s.field("noteId", S.string),
  })

type postPromoReadResponse = unit

/**
 * promo/read
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postPromoRead = (~body: postPromoReadRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPromoReadResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postPromoReadRequestSchema)
  
  fetch(
    ~url="/promo/read",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type getUsersFeaturedNotesRequest = {
  limit: option<int>,
  untilid: option<string>,
  userid: string,
}

let getUsersFeaturedNotesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    userid: s.field("userId", S.string),
  })

type getUsersFeaturedNotesResponse = array<ComponentSchemas.Note.t>

let getUsersFeaturedNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * users/featured-notes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getUsersFeaturedNotes = (~body: getUsersFeaturedNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getUsersFeaturedNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getUsersFeaturedNotesRequestSchema)
  
  fetch(
    ~url="/users/featured-notes",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getUsersFeaturedNotesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersFeaturedNotesRequest = {
  limit: option<int>,
  untilid: option<string>,
  userid: string,
}

let postUsersFeaturedNotesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    userid: s.field("userId", S.string),
  })

type postUsersFeaturedNotesResponse = array<ComponentSchemas.Note.t>

let postUsersFeaturedNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * users/featured-notes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsersFeaturedNotes = (~body: postUsersFeaturedNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFeaturedNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFeaturedNotesRequestSchema)
  
  fetch(
    ~url="/users/featured-notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersFeaturedNotesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}
