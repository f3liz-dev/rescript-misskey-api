// SPDX-License-Identifier: MIT
// API endpoints for users
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type postEmailAddressAvailableRequest = {
  emailaddress: string,
}

let postEmailAddressAvailableRequestSchema = S.object(s => {
    emailaddress: s.field("emailAddress", S.string),
  })

type postEmailAddressAvailableResponse = {
  available: bool,
  reason: JSON.t,
}

let postEmailAddressAvailableResponseSchema = S.object(s => {
    available: s.field("available", S.bool),
    reason: s.field("reason", S.json),
  })

/**
 * email-address/available
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEmailAddressAvailable = (~body: postEmailAddressAvailableRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEmailAddressAvailableResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postEmailAddressAvailableRequestSchema)
  
  fetch(
    ~url="/email-address/available",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postEmailAddressAvailableResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postGetAvatarDecorationsResponse = array<JSON.t>

let postGetAvatarDecorationsResponseSchema = S.array(S.json)

/**
 * get-avatar-decorations
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postGetAvatarDecorations = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGetAvatarDecorationsResponse> => {
  
  fetch(
    ~url="/get-avatar-decorations",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postGetAvatarDecorationsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postIMoveRequest = {
  movetoaccount: string,
}

let postIMoveRequestSchema = S.object(s => {
    movetoaccount: s.field("moveToAccount", S.string),
  })

type postIMoveResponse = JSON.t

let postIMoveResponseSchema = S.json

/**
 * i/move
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIMove = (~body: postIMoveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIMoveResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIMoveRequestSchema)
  
  fetch(
    ~url="/i/move",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postIMoveResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postPinnedUsersResponse = array<ComponentSchemas.Userdetailed.t>

let postPinnedUsersResponseSchema = S.array(ComponentSchemas.Userdetailed.schema)

/**
 * pinned-users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postPinnedUsers = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPinnedUsersResponse> => {
  
  fetch(
    ~url="/pinned-users",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postPinnedUsersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getRetentionResponse = array<JSON.t>

let getRetentionResponseSchema = S.array(S.json)

/**
 * retention
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getRetention = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getRetentionResponse> => {
  
  fetch(
    ~url="/retention",
    ~method_="GET",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getRetentionResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postRetentionResponse = array<JSON.t>

let postRetentionResponseSchema = S.array(S.json)

/**
 * retention
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postRetention = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRetentionResponse> => {
  
  fetch(
    ~url="/retention",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postRetentionResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsernameAvailableRequest = {
  username: string,
}

let postUsernameAvailableRequestSchema = S.object(s => {
    username: s.field("username", S.string->S.pattern(%re("/^\\w{1,20}$/"))),
  })

type postUsernameAvailableResponse = {
  available: bool,
}

let postUsernameAvailableResponseSchema = S.object(s => {
    available: s.field("available", S.bool),
  })

/**
 * username/available
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsernameAvailable = (~body: postUsernameAvailableRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsernameAvailableResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsernameAvailableRequestSchema)
  
  fetch(
    ~url="/username/available",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsernameAvailableResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersRequest = {
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
  state: option<string>,
  origin: option<string>,
  hostname: option<JSON.t>,
}

let postUsersRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
    state: s.fieldOr("state", S.nullableAsOption(S.string), None),
    origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
    hostname: s.fieldOr("hostname", S.nullableAsOption(S.json), None),
  })

type postUsersResponse = array<ComponentSchemas.Userdetailed.t>

let postUsersResponseSchema = S.array(ComponentSchemas.Userdetailed.schema)

/**
 * users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsers = (~body: postUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersRequestSchema)
  
  fetch(
    ~url="/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersClipsRequest = {
  userid: string,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
}

let postUsersClipsRequestSchema = S.object(s => {
    userid: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postUsersClipsResponse = array<ComponentSchemas.Clip.t>

let postUsersClipsResponseSchema = S.array(ComponentSchemas.Clip.schema)

/**
 * users/clips
 *
 * Show all clips this user owns.
 *
 * **Credential required**: *No*
 */
let postUsersClips = (~body: postUsersClipsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersClipsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersClipsRequestSchema)
  
  fetch(
    ~url="/users/clips",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersClipsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersFlashsRequest = {
  userid: string,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
}

let postUsersFlashsRequestSchema = S.object(s => {
    userid: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postUsersFlashsResponse = array<ComponentSchemas.Flash.t>

let postUsersFlashsResponseSchema = S.array(ComponentSchemas.Flash.schema)

/**
 * users/flashs
 *
 * Show all flashs this user created.
 *
 * **Credential required**: *No*
 */
let postUsersFlashs = (~body: postUsersFlashsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFlashsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFlashsRequestSchema)
  
  fetch(
    ~url="/users/flashs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersFlashsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersFollowersRequest = {
  sinceid: option<string>,
  untilid: option<string>,
  limit: option<int>,
  userid: option<string>,
  username: option<string>,
  host: option<JSON.t>,
}

let postUsersFollowersRequestSchema = S.object(s => {
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    userid: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    username: s.fieldOr("username", S.nullableAsOption(S.string), None),
    host: s.fieldOr("host", S.nullableAsOption(S.json), None),
  })

type postUsersFollowersResponse = array<ComponentSchemas.Following.t>

let postUsersFollowersResponseSchema = S.array(ComponentSchemas.Following.schema)

/**
 * users/followers
 *
 * Show everyone that follows this user.
 *
 * **Credential required**: *No*
 */
let postUsersFollowers = (~body: postUsersFollowersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFollowersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFollowersRequestSchema)
  
  fetch(
    ~url="/users/followers",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersFollowersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersFollowingRequest = {
  sinceid: option<string>,
  untilid: option<string>,
  limit: option<int>,
  userid: option<string>,
  username: option<string>,
  host: option<JSON.t>,
  birthday: option<JSON.t>,
}

let postUsersFollowingRequestSchema = S.object(s => {
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    userid: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    username: s.fieldOr("username", S.nullableAsOption(S.string), None),
    host: s.fieldOr("host", S.nullableAsOption(S.json), None),
    birthday: s.fieldOr("birthday", S.nullableAsOption(S.json), None),
  })

type postUsersFollowingResponse = array<ComponentSchemas.Following.t>

let postUsersFollowingResponseSchema = S.array(ComponentSchemas.Following.schema)

/**
 * users/following
 *
 * Show everyone that this user is following.
 *
 * **Credential required**: *No*
 */
let postUsersFollowing = (~body: postUsersFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFollowingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFollowingRequestSchema)
  
  fetch(
    ~url="/users/following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersFollowingResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersGalleryPostsRequest = {
  userid: string,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
}

let postUsersGalleryPostsRequestSchema = S.object(s => {
    userid: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postUsersGalleryPostsResponse = array<ComponentSchemas.Gallerypost.t>

let postUsersGalleryPostsResponseSchema = S.array(ComponentSchemas.Gallerypost.schema)

/**
 * users/gallery/posts
 *
 * Show all gallery posts by the given user.
 *
 * **Credential required**: *No*
 */
let postUsersGalleryPosts = (~body: postUsersGalleryPostsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGalleryPostsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGalleryPostsRequestSchema)
  
  fetch(
    ~url="/users/gallery/posts",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersGalleryPostsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersGetFollowingBirthdayUsersRequest = {
  limit: option<int>,
  offset: option<int>,
  birthday: JSON.t,
}

let postUsersGetFollowingBirthdayUsersRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    birthday: s.field("birthday", S.json),
  })

type postUsersGetFollowingBirthdayUsersResponse = array<JSON.t>

let postUsersGetFollowingBirthdayUsersResponseSchema = S.array(S.json)

/**
 * users/get-following-birthday-users
 *
 * Find users who have a birthday on the specified range.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postUsersGetFollowingBirthdayUsers = (~body: postUsersGetFollowingBirthdayUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGetFollowingBirthdayUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGetFollowingBirthdayUsersRequestSchema)
  
  fetch(
    ~url="/users/get-following-birthday-users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersGetFollowingBirthdayUsersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersGetFrequentlyRepliedUsersRequest = {
  userid: string,
  limit: option<int>,
}

let postUsersGetFrequentlyRepliedUsersRequestSchema = S.object(s => {
    userid: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postUsersGetFrequentlyRepliedUsersResponse = array<JSON.t>

let postUsersGetFrequentlyRepliedUsersResponseSchema = S.array(S.json)

/**
 * users/get-frequently-replied-users
 *
 * Get a list of other users that the specified user frequently replies to.
 *
 * **Credential required**: *No*
 */
let postUsersGetFrequentlyRepliedUsers = (~body: postUsersGetFrequentlyRepliedUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGetFrequentlyRepliedUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGetFrequentlyRepliedUsersRequestSchema)
  
  fetch(
    ~url="/users/get-frequently-replied-users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersGetFrequentlyRepliedUsersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersGetSecurityInfoRequest = {
  email: string,
  password: string,
}

let postUsersGetSecurityInfoRequestSchema = S.object(s => {
    email: s.field("email", S.string),
    password: s.field("password", S.string),
  })

type postUsersGetSecurityInfoResponse = {
  twofactorenabled: bool,
  usepasswordlesslogin: bool,
  securitykeys: bool,
}

let postUsersGetSecurityInfoResponseSchema = S.object(s => {
    twofactorenabled: s.field("twoFactorEnabled", S.bool),
    usepasswordlesslogin: s.field("usePasswordLessLogin", S.bool),
    securitykeys: s.field("securityKeys", S.bool),
  })

/**
 * users/get-security-info
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsersGetSecurityInfo = (~body: postUsersGetSecurityInfoRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGetSecurityInfoResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGetSecurityInfoRequestSchema)
  
  fetch(
    ~url="/users/get-security-info",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersGetSecurityInfoResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getUsersGetSkebStatusRequest = {
  userid: string,
}

let getUsersGetSkebStatusRequestSchema = S.object(s => {
    userid: s.field("userId", S.string),
  })

type getUsersGetSkebStatusResponse = {
  screenname: string,
  iscreator: bool,
  isacceptable: bool,
  creatorrequestcount: int,
  clientrequestcount: int,
  skills: array<JSON.t>,
}

let getUsersGetSkebStatusResponseSchema = S.object(s => {
    screenname: s.field("screenName", S.string),
    iscreator: s.field("isCreator", S.bool),
    isacceptable: s.field("isAcceptable", S.bool),
    creatorrequestcount: s.field("creatorRequestCount", S.int),
    clientrequestcount: s.field("clientRequestCount", S.int),
    skills: s.field("skills", S.array(S.json)),
  })

/**
 * users/get-skeb-status
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getUsersGetSkebStatus = (~body: getUsersGetSkebStatusRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getUsersGetSkebStatusResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getUsersGetSkebStatusRequestSchema)
  
  fetch(
    ~url="/users/get-skeb-status",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getUsersGetSkebStatusResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersGetSkebStatusRequest = {
  userid: string,
}

let postUsersGetSkebStatusRequestSchema = S.object(s => {
    userid: s.field("userId", S.string),
  })

type postUsersGetSkebStatusResponse = {
  screenname: string,
  iscreator: bool,
  isacceptable: bool,
  creatorrequestcount: int,
  clientrequestcount: int,
  skills: array<JSON.t>,
}

let postUsersGetSkebStatusResponseSchema = S.object(s => {
    screenname: s.field("screenName", S.string),
    iscreator: s.field("isCreator", S.bool),
    isacceptable: s.field("isAcceptable", S.bool),
    creatorrequestcount: s.field("creatorRequestCount", S.int),
    clientrequestcount: s.field("clientRequestCount", S.int),
    skills: s.field("skills", S.array(S.json)),
  })

/**
 * users/get-skeb-status
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsersGetSkebStatus = (~body: postUsersGetSkebStatusRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGetSkebStatusResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGetSkebStatusRequestSchema)
  
  fetch(
    ~url="/users/get-skeb-status",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersGetSkebStatusResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersNotesRequest = {
  userid: string,
  withreplies: option<bool>,
  withrenotes: option<bool>,
  withchannelnotes: option<bool>,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
  sincedate: option<int>,
  untildate: option<int>,
  allowpartial: option<bool>,
  withfiles: option<bool>,
}

let postUsersNotesRequestSchema = S.object(s => {
    userid: s.field("userId", S.string),
    withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
    withrenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    withchannelnotes: s.fieldOr("withChannelNotes", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    allowpartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    withfiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
  })

type postUsersNotesResponse = array<ComponentSchemas.Note.t>

let postUsersNotesResponseSchema = S.array(ComponentSchemas.Note.schema)

/**
 * users/notes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsersNotes = (~body: postUsersNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersNotesRequestSchema)
  
  fetch(
    ~url="/users/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersNotesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersPagesRequest = {
  userid: string,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
}

let postUsersPagesRequestSchema = S.object(s => {
    userid: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postUsersPagesResponse = array<ComponentSchemas.Page.t>

let postUsersPagesResponseSchema = S.array(ComponentSchemas.Page.schema)

/**
 * users/pages
 *
 * Show all pages this user created.
 *
 * **Credential required**: *No*
 */
let postUsersPages = (~body: postUsersPagesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersPagesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersPagesRequestSchema)
  
  fetch(
    ~url="/users/pages",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersPagesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersReactionsRequest = {
  userid: string,
  limit: option<int>,
  sinceid: option<string>,
  untilid: option<string>,
  sincedate: option<int>,
  untildate: option<int>,
}

let postUsersReactionsRequestSchema = S.object(s => {
    userid: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceid: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilid: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sincedate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untildate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postUsersReactionsResponse = array<ComponentSchemas.Notereaction.t>

let postUsersReactionsResponseSchema = S.array(ComponentSchemas.Notereaction.schema)

/**
 * users/reactions
 *
 * Show all reactions this user made.
 *
 * **Credential required**: *No*
 */
let postUsersReactions = (~body: postUsersReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersReactionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersReactionsRequestSchema)
  
  fetch(
    ~url="/users/reactions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersReactionsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersRecommendationRequest = {
  limit: option<int>,
  offset: option<int>,
}

let postUsersRecommendationRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
  })

type postUsersRecommendationResponse = array<ComponentSchemas.Userdetailed.t>

let postUsersRecommendationResponseSchema = S.array(ComponentSchemas.Userdetailed.schema)

/**
 * users/recommendation
 *
 * Show users that the authenticated user might be interested to follow.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postUsersRecommendation = (~body: postUsersRecommendationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersRecommendationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersRecommendationRequestSchema)
  
  fetch(
    ~url="/users/recommendation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersRecommendationResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersRelationRequest = {
  userid: array<string>,
}

let postUsersRelationRequestSchema = S.object(s => {
    userid: s.field("userId", S.array(S.string)),
  })

type postUsersRelationResponse = JSON.t

let postUsersRelationResponseSchema = S.json

/**
 * users/relation
 *
 * Show the different kinds of relations between the authenticated user and the specified user(s).
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postUsersRelation = (~body: postUsersRelationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersRelationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersRelationRequestSchema)
  
  fetch(
    ~url="/users/relation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersRelationResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersReportAbuseRequest = {
  userid: string,
  comment: string,
  category: option<string>,
}

let postUsersReportAbuseRequestSchema = S.object(s => {
    userid: s.field("userId", S.string),
    comment: s.field("comment", S.string->S.min(1)->S.max(2048)),
    category: s.fieldOr("category", S.nullableAsOption(S.string), None),
  })

type postUsersReportAbuseResponse = unit

/**
 * users/report-abuse
 *
 * File a report.
 *
 * **Credential required**: *Yes* / **Permission**: *write:report-abuse*
 */
let postUsersReportAbuse = (~body: postUsersReportAbuseRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersReportAbuseResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersReportAbuseRequestSchema)
  
  fetch(
    ~url="/users/report-abuse",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postUsersSearchRequest = {
  query: string,
  offset: option<int>,
  limit: option<int>,
  origin: option<string>,
  detail: option<bool>,
}

let postUsersSearchRequestSchema = S.object(s => {
    query: s.field("query", S.string),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
    detail: s.fieldOr("detail", S.nullableAsOption(S.bool), None),
  })

type postUsersSearchResponse = array<ComponentSchemas.User.t>

let postUsersSearchResponseSchema = S.array(ComponentSchemas.User.schema)

/**
 * users/search
 *
 * Search for users.
 *
 * **Credential required**: *No*
 */
let postUsersSearch = (~body: postUsersSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersSearchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersSearchRequestSchema)
  
  fetch(
    ~url="/users/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersSearchResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersSearchByUsernameAndHostRequest = {
  limit: option<int>,
  detail: option<bool>,
  username: option<JSON.t>,
  host: option<JSON.t>,
}

let postUsersSearchByUsernameAndHostRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    detail: s.fieldOr("detail", S.nullableAsOption(S.bool), None),
    username: s.fieldOr("username", S.nullableAsOption(S.json), None),
    host: s.fieldOr("host", S.nullableAsOption(S.json), None),
  })

type postUsersSearchByUsernameAndHostResponse = array<ComponentSchemas.User.t>

let postUsersSearchByUsernameAndHostResponseSchema = S.array(ComponentSchemas.User.schema)

/**
 * users/search-by-username-and-host
 *
 * Search for a user by username and/or host.
 *
 * **Credential required**: *No*
 */
let postUsersSearchByUsernameAndHost = (~body: postUsersSearchByUsernameAndHostRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersSearchByUsernameAndHostResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersSearchByUsernameAndHostRequestSchema)
  
  fetch(
    ~url="/users/search-by-username-and-host",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersSearchByUsernameAndHostResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersShowRequest = {
  userid: option<string>,
  userids: option<array<string>>,
  username: option<string>,
  host: option<JSON.t>,
  detailed: option<bool>,
}

let postUsersShowRequestSchema = S.object(s => {
    userid: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    userids: s.fieldOr("userIds", S.nullableAsOption(S.array(S.string)), None),
    username: s.fieldOr("username", S.nullableAsOption(S.string), None),
    host: s.fieldOr("host", S.nullableAsOption(S.json), None),
    detailed: s.fieldOr("detailed", S.nullableAsOption(S.bool), None),
  })

type postUsersShowResponse = array<ComponentSchemas.Userdetailed.t>

let postUsersShowResponseSchema = S.array(ComponentSchemas.Userdetailed.schema)

/**
 * users/show
 *
 * Show the properties of a user.
 *
 * **Credential required**: *No*
 */
let postUsersShow = (~body: postUsersShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersShowRequestSchema)
  
  fetch(
    ~url="/users/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersShowResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersStatsRequest = {
  userid: string,
}

let postUsersStatsRequestSchema = S.object(s => {
    userid: s.field("userId", S.string),
  })

type postUsersStatsResponse = {
  notescount: int,
  repliescount: int,
  renotescount: int,
  repliedcount: int,
  renotedcount: int,
  pollvotescount: int,
  pollvotedcount: int,
  localfollowingcount: int,
  remotefollowingcount: int,
  localfollowerscount: int,
  remotefollowerscount: int,
  followingcount: int,
  followerscount: int,
  sentreactionscount: int,
  receivedreactionscount: int,
  notefavoritescount: int,
  pagelikescount: int,
  pagelikedcount: int,
  drivefilescount: int,
  driveusage: int,
}

let postUsersStatsResponseSchema = S.object(s => {
    notescount: s.field("notesCount", S.int),
    repliescount: s.field("repliesCount", S.int),
    renotescount: s.field("renotesCount", S.int),
    repliedcount: s.field("repliedCount", S.int),
    renotedcount: s.field("renotedCount", S.int),
    pollvotescount: s.field("pollVotesCount", S.int),
    pollvotedcount: s.field("pollVotedCount", S.int),
    localfollowingcount: s.field("localFollowingCount", S.int),
    remotefollowingcount: s.field("remoteFollowingCount", S.int),
    localfollowerscount: s.field("localFollowersCount", S.int),
    remotefollowerscount: s.field("remoteFollowersCount", S.int),
    followingcount: s.field("followingCount", S.int),
    followerscount: s.field("followersCount", S.int),
    sentreactionscount: s.field("sentReactionsCount", S.int),
    receivedreactionscount: s.field("receivedReactionsCount", S.int),
    notefavoritescount: s.field("noteFavoritesCount", S.int),
    pagelikescount: s.field("pageLikesCount", S.int),
    pagelikedcount: s.field("pageLikedCount", S.int),
    drivefilescount: s.field("driveFilesCount", S.int),
    driveusage: s.field("driveUsage", S.int),
  })

/**
 * users/stats
 *
 * Show statistics about a user.
 *
 * **Credential required**: *No*
 */
let postUsersStats = (~body: postUsersStatsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersStatsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersStatsRequestSchema)
  
  fetch(
    ~url="/users/stats",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersStatsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}
