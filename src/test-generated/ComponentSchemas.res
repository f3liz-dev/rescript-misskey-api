// SPDX-License-Identifier: MIT
// Component Schemas - Shared types and validation schemas
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



module Error = {
  type t = {
  error: JSON.t,
}
  
  let schema = S.object(s => {
    error: s.field("error", S.json),
  })
}

module Userlite = {
  type t = {
  id: string,
  name: JSON.t,
  username: string,
  host: JSON.t,
  avatarurl: JSON.t,
  avatarblurhash: JSON.t,
  avatardecorations: array<JSON.t>,
  isbot: option<bool>,
  iscat: option<bool>,
  requiresignintoviewcontents: option<bool>,
  makenotesfollowersonlybefore: option<JSON.t>,
  makenoteshiddenbefore: option<JSON.t>,
  instance: option<JSON.t>,
  emojis: JSON.t,
  onlinestatus: string,
  badgeroles: option<array<JSON.t>>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.json),
    username: s.field("username", S.string),
    host: s.field("host", S.json),
    avatarurl: s.field("avatarUrl", S.json),
    avatarblurhash: s.field("avatarBlurhash", S.json),
    avatardecorations: s.field("avatarDecorations", S.array(S.json)),
    isbot: s.fieldOr("isBot", S.nullableAsOption(S.bool), None),
    iscat: s.fieldOr("isCat", S.nullableAsOption(S.bool), None),
    requiresignintoviewcontents: s.fieldOr("requireSigninToViewContents", S.nullableAsOption(S.bool), None),
    makenotesfollowersonlybefore: s.fieldOr("makeNotesFollowersOnlyBefore", S.nullableAsOption(S.json), None),
    makenoteshiddenbefore: s.fieldOr("makeNotesHiddenBefore", S.nullableAsOption(S.json), None),
    instance: s.fieldOr("instance", S.nullableAsOption(S.json), None),
    emojis: s.field("emojis", S.json),
    onlinestatus: s.field("onlineStatus", S.string),
    badgeroles: s.fieldOr("badgeRoles", S.nullableAsOption(S.array(S.json)), None),
  })
}

module Userdetailednotme = {
  type t = JSON.t
  
  let schema = S.json
}

module Medetailed = {
  type t = JSON.t
  
  let schema = S.json
}

module Userlist = {
  type t = {
  id: string,
  createdat: string,
  name: string,
  userids: option<array<string>>,
  ispublic: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    userids: s.fieldOr("userIds", S.nullableAsOption(S.array(S.string)), None),
    ispublic: s.field("isPublic", S.bool),
  })
}

module Ad = {
  type t = {
  id: string,
  expiresat: string,
  startsat: string,
  place: string,
  priority: string,
  ratio: float,
  url: string,
  imageurl: string,
  imageblurhash: JSON.t,
  memo: string,
  dayofweek: int,
  issensitive: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    expiresat: s.field("expiresAt", S.string),
    startsat: s.field("startsAt", S.string),
    place: s.field("place", S.string),
    priority: s.field("priority", S.string),
    ratio: s.field("ratio", S.float),
    url: s.field("url", S.string),
    imageurl: s.field("imageUrl", S.string),
    imageblurhash: s.field("imageBlurhash", S.json),
    memo: s.field("memo", S.string),
    dayofweek: s.field("dayOfWeek", S.int),
    issensitive: s.field("isSensitive", S.bool),
  })
}

module Announcement = {
  type t = {
  id: string,
  createdat: string,
  updatedat: JSON.t,
  text: string,
  title: string,
  imageurl: JSON.t,
  icon: string,
  display: string,
  needconfirmationtoread: bool,
  needenrollmenttutorialtoread: bool,
  foryou: bool,
  closeduration: float,
  displayorder: float,
  silence: bool,
  isread: option<bool>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    updatedat: s.field("updatedAt", S.json),
    text: s.field("text", S.string),
    title: s.field("title", S.string),
    imageurl: s.field("imageUrl", S.json),
    icon: s.field("icon", S.string),
    display: s.field("display", S.string),
    needconfirmationtoread: s.field("needConfirmationToRead", S.bool),
    needenrollmenttutorialtoread: s.field("needEnrollmentTutorialToRead", S.bool),
    foryou: s.field("forYou", S.bool),
    closeduration: s.field("closeDuration", S.float),
    displayorder: s.field("displayOrder", S.float),
    silence: s.field("silence", S.bool),
    isread: s.fieldOr("isRead", S.nullableAsOption(S.bool), None),
  })
}

module App = {
  type t = {
  id: string,
  name: string,
  callbackurl: JSON.t,
  permission: array<string>,
  secret: option<string>,
  isauthorized: option<bool>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    callbackurl: s.field("callbackUrl", S.json),
    permission: s.field("permission", S.array(S.string)),
    secret: s.fieldOr("secret", S.nullableAsOption(S.string), None),
    isauthorized: s.fieldOr("isAuthorized", S.nullableAsOption(S.bool), None),
  })
}

module Notification = {
  type t = JSON.t
  
  let schema = S.json
}

module Drivefile = {
  type t = {
  id: string,
  createdat: string,
  name: string,
  @as("type") type_: string,
  md5: string,
  size: float,
  issensitive: bool,
  issensitivebymoderator: option<JSON.t>,
  blurhash: JSON.t,
  properties: JSON.t,
  url: string,
  thumbnailurl: JSON.t,
  comment: JSON.t,
  folderid: JSON.t,
  folder: option<JSON.t>,
  userid: JSON.t,
  user: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    type_: s.field("type", S.string),
    md5: s.field("md5", S.string),
    size: s.field("size", S.float),
    issensitive: s.field("isSensitive", S.bool),
    issensitivebymoderator: s.fieldOr("isSensitiveByModerator", S.nullableAsOption(S.json), None),
    blurhash: s.field("blurhash", S.json),
    properties: s.field("properties", S.json),
    url: s.field("url", S.string),
    thumbnailurl: s.field("thumbnailUrl", S.json),
    comment: s.field("comment", S.json),
    folderid: s.field("folderId", S.json),
    folder: s.fieldOr("folder", S.nullableAsOption(S.json), None),
    userid: s.field("userId", S.json),
    user: s.fieldOr("user", S.nullableAsOption(S.json), None),
  })
}

module Drivefolder = {
  type t = {
  id: string,
  createdat: string,
  name: string,
  parentid: JSON.t,
  folderscount: option<float>,
  filescount: option<float>,
  parent: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    parentid: s.field("parentId", S.json),
    folderscount: s.fieldOr("foldersCount", S.nullableAsOption(S.float), None),
    filescount: s.fieldOr("filesCount", S.nullableAsOption(S.float), None),
    parent: s.fieldOr("parent", S.nullableAsOption(S.json), None),
  })
}

module Following = {
  type t = {
  id: string,
  createdat: string,
  followeeid: string,
  followerid: string,
  followee: option<JSON.t>,
  follower: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    followeeid: s.field("followeeId", S.string),
    followerid: s.field("followerId", S.string),
    followee: s.fieldOr("followee", S.nullableAsOption(S.json), None),
    follower: s.fieldOr("follower", S.nullableAsOption(S.json), None),
  })
}

module Hashtag = {
  type t = {
  tag: string,
  mentioneduserscount: float,
  mentionedlocaluserscount: float,
  mentionedremoteuserscount: float,
  attacheduserscount: float,
  attachedlocaluserscount: float,
  attachedremoteuserscount: float,
}
  
  let schema = S.object(s => {
    tag: s.field("tag", S.string),
    mentioneduserscount: s.field("mentionedUsersCount", S.float),
    mentionedlocaluserscount: s.field("mentionedLocalUsersCount", S.float),
    mentionedremoteuserscount: s.field("mentionedRemoteUsersCount", S.float),
    attacheduserscount: s.field("attachedUsersCount", S.float),
    attachedlocaluserscount: s.field("attachedLocalUsersCount", S.float),
    attachedremoteuserscount: s.field("attachedRemoteUsersCount", S.float),
  })
}

module Invitecode = {
  type t = {
  id: string,
  code: string,
  expiresat: JSON.t,
  createdat: string,
  createdby: JSON.t,
  usedby: JSON.t,
  usedat: JSON.t,
  used: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    code: s.field("code", S.string),
    expiresat: s.field("expiresAt", S.json),
    createdat: s.field("createdAt", S.string),
    createdby: s.field("createdBy", S.json),
    usedby: s.field("usedBy", S.json),
    usedat: s.field("usedAt", S.json),
    used: s.field("used", S.bool),
  })
}

module Pageblock = {
  type t = JSON.t
  
  let schema = S.json
}

module Queuecount = {
  type t = {
  waiting: float,
  active: float,
  completed: float,
  failed: float,
  delayed: float,
}
  
  let schema = S.object(s => {
    waiting: s.field("waiting", S.float),
    active: s.field("active", S.float),
    completed: s.field("completed", S.float),
    failed: s.field("failed", S.float),
    delayed: s.field("delayed", S.float),
  })
}

module Antenna = {
  type t = {
  id: string,
  createdat: string,
  name: string,
  keywords: array<array<string>>,
  excludekeywords: array<array<string>>,
  src: string,
  userlistid: JSON.t,
  users: array<string>,
  casesensitive: bool,
  localonly: bool,
  excludebots: bool,
  withreplies: bool,
  withfile: bool,
  isactive: bool,
  hasunreadnote: bool,
  notify: bool,
  excludenotesinsensitivechannel: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    keywords: s.field("keywords", S.array(S.array(S.string))),
    excludekeywords: s.field("excludeKeywords", S.array(S.array(S.string))),
    src: s.field("src", S.string),
    userlistid: s.field("userListId", S.json),
    users: s.field("users", S.array(S.string)),
    casesensitive: s.field("caseSensitive", S.bool),
    localonly: s.field("localOnly", S.bool),
    excludebots: s.field("excludeBots", S.bool),
    withreplies: s.field("withReplies", S.bool),
    withfile: s.field("withFile", S.bool),
    isactive: s.field("isActive", S.bool),
    hasunreadnote: s.field("hasUnreadNote", S.bool),
    notify: s.field("notify", S.bool),
    excludenotesinsensitivechannel: s.field("excludeNotesInSensitiveChannel", S.bool),
  })
}

module Federationinstance = {
  type t = {
  id: string,
  firstretrievedat: string,
  host: string,
  userscount: float,
  notescount: float,
  followingcount: float,
  followerscount: float,
  isnotresponding: bool,
  issuspended: bool,
  suspensionstate: string,
  isblocked: bool,
  softwarename: JSON.t,
  softwareversion: JSON.t,
  openregistrations: JSON.t,
  name: JSON.t,
  description: JSON.t,
  maintainername: JSON.t,
  maintaineremail: JSON.t,
  issilenced: bool,
  issensitivemedia: bool,
  iconurl: JSON.t,
  faviconurl: JSON.t,
  themecolor: JSON.t,
  infoupdatedat: JSON.t,
  latestrequestreceivedat: JSON.t,
  moderationnote: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    firstretrievedat: s.field("firstRetrievedAt", S.string),
    host: s.field("host", S.string),
    userscount: s.field("usersCount", S.float),
    notescount: s.field("notesCount", S.float),
    followingcount: s.field("followingCount", S.float),
    followerscount: s.field("followersCount", S.float),
    isnotresponding: s.field("isNotResponding", S.bool),
    issuspended: s.field("isSuspended", S.bool),
    suspensionstate: s.field("suspensionState", S.string),
    isblocked: s.field("isBlocked", S.bool),
    softwarename: s.field("softwareName", S.json),
    softwareversion: s.field("softwareVersion", S.json),
    openregistrations: s.field("openRegistrations", S.json),
    name: s.field("name", S.json),
    description: s.field("description", S.json),
    maintainername: s.field("maintainerName", S.json),
    maintaineremail: s.field("maintainerEmail", S.json),
    issilenced: s.field("isSilenced", S.bool),
    issensitivemedia: s.field("isSensitiveMedia", S.bool),
    iconurl: s.field("iconUrl", S.json),
    faviconurl: s.field("faviconUrl", S.json),
    themecolor: s.field("themeColor", S.json),
    infoupdatedat: s.field("infoUpdatedAt", S.json),
    latestrequestreceivedat: s.field("latestRequestReceivedAt", S.json),
    moderationnote: s.fieldOr("moderationNote", S.nullableAsOption(S.json), None),
  })
}

module Emojisimple = {
  type t = {
  aliases: array<string>,
  name: string,
  category: JSON.t,
  url: string,
  localonly: option<bool>,
  issensitive: option<bool>,
  roleidsthatcanbeusedthisemojiasreaction: option<array<string>>,
  roleidsthatcannotbeusedthisemojiasreaction: option<array<string>>,
}
  
  let schema = S.object(s => {
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.json),
    url: s.field("url", S.string),
    localonly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    issensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
    roleidsthatcanbeusedthisemojiasreaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
    roleidsthatcannotbeusedthisemojiasreaction: s.fieldOr("roleIdsThatCanNotBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
  })
}

module Emojidetailed = {
  type t = {
  id: string,
  createdat: option<string>,
  updatedat: option<JSON.t>,
  aliases: array<string>,
  name: string,
  category: JSON.t,
  host: JSON.t,
  url: string,
  license: JSON.t,
  issensitive: bool,
  localonly: bool,
  requestedby: option<JSON.t>,
  memo: option<JSON.t>,
  roleidsthatcanbeusedthisemojiasreaction: option<array<string>>,
  roleidsthatcannotbeusedthisemojiasreaction: option<array<string>>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.fieldOr("createdAt", S.nullableAsOption(S.string), None),
    updatedat: s.fieldOr("updatedAt", S.nullableAsOption(S.json), None),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.json),
    host: s.field("host", S.json),
    url: s.field("url", S.string),
    license: s.field("license", S.json),
    issensitive: s.field("isSensitive", S.bool),
    localonly: s.field("localOnly", S.bool),
    requestedby: s.fieldOr("requestedBy", S.nullableAsOption(S.json), None),
    memo: s.fieldOr("memo", S.nullableAsOption(S.json), None),
    roleidsthatcanbeusedthisemojiasreaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
    roleidsthatcannotbeusedthisemojiasreaction: s.fieldOr("roleIdsThatCanNotBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
  })
}

module Emojidetailedadmin = {
  type t = {
  id: string,
  updatedat: JSON.t,
  name: string,
  host: JSON.t,
  publicurl: string,
  originalurl: string,
  uri: JSON.t,
  @as("type") type_: JSON.t,
  aliases: array<string>,
  category: JSON.t,
  license: JSON.t,
  localonly: bool,
  issensitive: bool,
  roleidsthatcanbeusedthisemojiasreaction: array<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    updatedat: s.field("updatedAt", S.json),
    name: s.field("name", S.string),
    host: s.field("host", S.json),
    publicurl: s.field("publicUrl", S.string),
    originalurl: s.field("originalUrl", S.string),
    uri: s.field("uri", S.json),
    type_: s.field("type", S.json),
    aliases: s.field("aliases", S.array(S.string)),
    category: s.field("category", S.json),
    license: s.field("license", S.json),
    localonly: s.field("localOnly", S.bool),
    issensitive: s.field("isSensitive", S.bool),
    roleidsthatcanbeusedthisemojiasreaction: s.field("roleIdsThatCanBeUsedThisEmojiAsReaction", S.array(S.json)),
  })
}

module Signin = {
  type t = {
  id: string,
  createdat: string,
  ip: string,
  headers: JSON.t,
  success: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    ip: s.field("ip", S.string),
    headers: s.field("headers", S.json),
    success: s.field("success", S.bool),
  })
}

module Rolecondformulavalueislocalorremote = {
  type t = {
  id: string,
  @as("type") type_: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
  })
}

module Rolecondformulavalueusersettingbooleanschema = {
  type t = {
  id: string,
  @as("type") type_: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
  })
}

module Rolecondformulavalueassignedrole = {
  type t = {
  id: string,
  @as("type") type_: string,
  roleid: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    roleid: s.field("roleId", S.string),
  })
}

module Rolecondformulavaluecreated = {
  type t = {
  id: string,
  @as("type") type_: string,
  sec: float,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    sec: s.field("sec", S.float),
  })
}

module Rolecondformulafollowersorfollowingornotes = {
  type t = {
  id: string,
  @as("type") type_: string,
  value: float,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    value: s.field("value", S.float),
  })
}

module Rolecondformulavalue = {
  type t = JSON.t
  
  let schema = S.json
}

module Rolelite = {
  type t = {
  id: string,
  name: string,
  color: JSON.t,
  iconurl: JSON.t,
  description: string,
  ismoderator: bool,
  isadministrator: bool,
  displayorder: int,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    color: s.field("color", S.json),
    iconurl: s.field("iconUrl", S.json),
    description: s.field("description", S.string),
    ismoderator: s.field("isModerator", S.bool),
    isadministrator: s.field("isAdministrator", S.bool),
    displayorder: s.field("displayOrder", S.int),
  })
}

module Role = {
  type t = JSON.t
  
  let schema = S.json
}

module Rolepolicies = {
  type t = {
  gtlavailable: bool,
  ltlavailable: bool,
  canpublicnote: bool,
  canschedulenote: bool,
  schedulenotelimit: int,
  schedulenotemaxdays: int,
  caninitiateconversation: bool,
  cancreatecontent: bool,
  canupdatecontent: bool,
  candeletecontent: bool,
  canpurgeaccount: bool,
  canupdateavatar: bool,
  canupdatebanner: bool,
  mentionlimit: int,
  caninvite: bool,
  invitelimit: int,
  invitelimitcycle: int,
  inviteexpirationtime: int,
  canmanagecustomemojis: bool,
  canmanageavatardecorations: bool,
  cansearchnotes: bool,
  canusetranslator: bool,
  canusedrivefileinsoundsettings: bool,
  canusereaction: bool,
  canhideads: bool,
  drivecapacitymb: int,
  maxfilesizemb: int,
  alwaysmarknsfw: bool,
  skipnsfwdetection: bool,
  canupdatebiomedia: bool,
  pinlimit: int,
  antennalimit: int,
  antennanoteslimit: int,
  wordmutelimit: int,
  webhooklimit: int,
  cliplimit: int,
  noteeachclipslimit: int,
  userlistlimit: int,
  usereachuserlistslimit: int,
  ratelimitfactor: int,
  avatardecorationlimit: int,
  canimportantennas: bool,
  canimportblocking: bool,
  canimportfollowing: bool,
  canimportmuting: bool,
  canimportuserlists: bool,
  mutuallinksectionlimit: int,
  mutuallinklimit: int,
  chatavailability: string,
}
  
  let schema = S.object(s => {
    gtlavailable: s.field("gtlAvailable", S.bool),
    ltlavailable: s.field("ltlAvailable", S.bool),
    canpublicnote: s.field("canPublicNote", S.bool),
    canschedulenote: s.field("canScheduleNote", S.bool),
    schedulenotelimit: s.field("scheduleNoteLimit", S.int),
    schedulenotemaxdays: s.field("scheduleNoteMaxDays", S.int),
    caninitiateconversation: s.field("canInitiateConversation", S.bool),
    cancreatecontent: s.field("canCreateContent", S.bool),
    canupdatecontent: s.field("canUpdateContent", S.bool),
    candeletecontent: s.field("canDeleteContent", S.bool),
    canpurgeaccount: s.field("canPurgeAccount", S.bool),
    canupdateavatar: s.field("canUpdateAvatar", S.bool),
    canupdatebanner: s.field("canUpdateBanner", S.bool),
    mentionlimit: s.field("mentionLimit", S.int),
    caninvite: s.field("canInvite", S.bool),
    invitelimit: s.field("inviteLimit", S.int),
    invitelimitcycle: s.field("inviteLimitCycle", S.int),
    inviteexpirationtime: s.field("inviteExpirationTime", S.int),
    canmanagecustomemojis: s.field("canManageCustomEmojis", S.bool),
    canmanageavatardecorations: s.field("canManageAvatarDecorations", S.bool),
    cansearchnotes: s.field("canSearchNotes", S.bool),
    canusetranslator: s.field("canUseTranslator", S.bool),
    canusedrivefileinsoundsettings: s.field("canUseDriveFileInSoundSettings", S.bool),
    canusereaction: s.field("canUseReaction", S.bool),
    canhideads: s.field("canHideAds", S.bool),
    drivecapacitymb: s.field("driveCapacityMb", S.int),
    maxfilesizemb: s.field("maxFileSizeMb", S.int),
    alwaysmarknsfw: s.field("alwaysMarkNsfw", S.bool),
    skipnsfwdetection: s.field("skipNsfwDetection", S.bool),
    canupdatebiomedia: s.field("canUpdateBioMedia", S.bool),
    pinlimit: s.field("pinLimit", S.int),
    antennalimit: s.field("antennaLimit", S.int),
    antennanoteslimit: s.field("antennaNotesLimit", S.int),
    wordmutelimit: s.field("wordMuteLimit", S.int),
    webhooklimit: s.field("webhookLimit", S.int),
    cliplimit: s.field("clipLimit", S.int),
    noteeachclipslimit: s.field("noteEachClipsLimit", S.int),
    userlistlimit: s.field("userListLimit", S.int),
    usereachuserlistslimit: s.field("userEachUserListsLimit", S.int),
    ratelimitfactor: s.field("rateLimitFactor", S.int),
    avatardecorationlimit: s.field("avatarDecorationLimit", S.int),
    canimportantennas: s.field("canImportAntennas", S.bool),
    canimportblocking: s.field("canImportBlocking", S.bool),
    canimportfollowing: s.field("canImportFollowing", S.bool),
    canimportmuting: s.field("canImportMuting", S.bool),
    canimportuserlists: s.field("canImportUserLists", S.bool),
    mutuallinksectionlimit: s.field("mutualLinkSectionLimit", S.int),
    mutuallinklimit: s.field("mutualLinkLimit", S.int),
    chatavailability: s.field("chatAvailability", S.string),
  })
}

module Metadetailedonly = {
  type t = {
  features: option<JSON.t>,
  proxyaccountname: JSON.t,
  requiresetup: bool,
  cacheremotefiles: bool,
  cacheremotesensitivefiles: bool,
}
  
  let schema = S.object(s => {
    features: s.fieldOr("features", S.nullableAsOption(S.json), None),
    proxyaccountname: s.field("proxyAccountName", S.json),
    requiresetup: s.field("requireSetup", S.bool),
    cacheremotefiles: s.field("cacheRemoteFiles", S.bool),
    cacheremotesensitivefiles: s.field("cacheRemoteSensitiveFiles", S.bool),
  })
}

module Metadetailed = {
  type t = JSON.t
  
  let schema = S.json
}

module Systemwebhook = {
  type t = {
  id: string,
  isactive: bool,
  updatedat: string,
  latestsentat: JSON.t,
  lateststatus: JSON.t,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    isactive: s.field("isActive", S.bool),
    updatedat: s.field("updatedAt", S.string),
    latestsentat: s.field("latestSentAt", S.json),
    lateststatus: s.field("latestStatus", S.json),
    name: s.field("name", S.string),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
  })
}

module Abusereportnotificationrecipient = {
  type t = {
  id: string,
  isactive: bool,
  updatedat: string,
  name: string,
  @as("method") method_: string,
  userid: option<string>,
  user: option<JSON.t>,
  systemwebhookid: option<string>,
  systemwebhook: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    isactive: s.field("isActive", S.bool),
    updatedat: s.field("updatedAt", S.string),
    name: s.field("name", S.string),
    method_: s.field("method", S.string),
    userid: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    user: s.fieldOr("user", S.nullableAsOption(S.json), None),
    systemwebhookid: s.fieldOr("systemWebhookId", S.nullableAsOption(S.string), None),
    systemwebhook: s.fieldOr("systemWebhook", S.nullableAsOption(S.json), None),
  })
}

module Chatmessagelite = {
  type t = {
  id: string,
  createdat: string,
  fromuserid: string,
  fromuser: option<JSON.t>,
  touserid: option<JSON.t>,
  toroomid: option<JSON.t>,
  text: option<JSON.t>,
  fileid: option<JSON.t>,
  file: option<JSON.t>,
  reactions: array<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    fromuserid: s.field("fromUserId", S.string),
    fromuser: s.fieldOr("fromUser", S.nullableAsOption(S.json), None),
    touserid: s.fieldOr("toUserId", S.nullableAsOption(S.json), None),
    toroomid: s.fieldOr("toRoomId", S.nullableAsOption(S.json), None),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileid: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    reactions: s.field("reactions", S.array(S.json)),
  })
}

module Chatmessagelitefor1on1 = {
  type t = {
  id: string,
  createdat: string,
  fromuserid: string,
  touserid: string,
  text: option<JSON.t>,
  fileid: option<JSON.t>,
  file: option<JSON.t>,
  reactions: array<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    fromuserid: s.field("fromUserId", S.string),
    touserid: s.field("toUserId", S.string),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileid: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    reactions: s.field("reactions", S.array(S.json)),
  })
}

module Chatroommembership = {
  type t = {
  id: string,
  createdat: string,
  userid: string,
  user: option<JSON.t>,
  roomid: string,
  room: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    userid: s.field("userId", S.string),
    user: s.fieldOr("user", S.nullableAsOption(S.json), None),
    roomid: s.field("roomId", S.string),
    room: s.fieldOr("room", S.nullableAsOption(S.json), None),
  })
}

module Userlistmembership = {
  type t = {
  id: string,
  createdat: string,
  userid: string,
  user: Userlite.t,
  withreplies: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    userid: s.field("userId", S.string),
    user: s.field("user", Userlite.schema),
    withreplies: s.field("withReplies", S.bool),
  })
}

module Notereaction = {
  type t = {
  id: string,
  createdat: string,
  user: Userlite.t,
  @as("type") type_: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    user: s.field("user", Userlite.schema),
    type_: s.field("type", S.string),
  })
}

module Clip = {
  type t = {
  id: string,
  createdat: string,
  lastclippedat: JSON.t,
  userid: string,
  user: Userlite.t,
  name: string,
  description: JSON.t,
  ispublic: bool,
  favoritedcount: float,
  isfavorited: option<bool>,
  notescount: option<int>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    lastclippedat: s.field("lastClippedAt", S.json),
    userid: s.field("userId", S.string),
    user: s.field("user", Userlite.schema),
    name: s.field("name", S.string),
    description: s.field("description", S.json),
    ispublic: s.field("isPublic", S.bool),
    favoritedcount: s.field("favoritedCount", S.float),
    isfavorited: s.fieldOr("isFavorited", S.nullableAsOption(S.bool), None),
    notescount: s.fieldOr("notesCount", S.nullableAsOption(S.int), None),
  })
}

module Flash = {
  type t = {
  id: string,
  createdat: string,
  updatedat: string,
  userid: string,
  user: Userlite.t,
  title: string,
  summary: string,
  script: string,
  visibility: string,
  likedcount: JSON.t,
  isliked: option<bool>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    updatedat: s.field("updatedAt", S.string),
    userid: s.field("userId", S.string),
    user: s.field("user", Userlite.schema),
    title: s.field("title", S.string),
    summary: s.field("summary", S.string),
    script: s.field("script", S.string),
    visibility: s.field("visibility", S.string),
    likedcount: s.field("likedCount", S.json),
    isliked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
  })
}

module Chatroom = {
  type t = {
  id: string,
  createdat: string,
  ownerid: string,
  owner: Userlite.t,
  name: string,
  description: string,
  ismuted: option<bool>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    ownerid: s.field("ownerId", S.string),
    owner: s.field("owner", Userlite.schema),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    ismuted: s.fieldOr("isMuted", S.nullableAsOption(S.bool), None),
  })
}

module Muting = {
  type t = {
  id: string,
  createdat: string,
  expiresat: JSON.t,
  muteeid: string,
  mutee: Userdetailednotme.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    expiresat: s.field("expiresAt", S.json),
    muteeid: s.field("muteeId", S.string),
    mutee: s.field("mutee", Userdetailednotme.schema),
  })
}

module Renotemuting = {
  type t = {
  id: string,
  createdat: string,
  muteeid: string,
  mutee: Userdetailednotme.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    muteeid: s.field("muteeId", S.string),
    mutee: s.field("mutee", Userdetailednotme.schema),
  })
}

module Blocking = {
  type t = {
  id: string,
  createdat: string,
  blockeeid: string,
  blockee: Userdetailednotme.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    blockeeid: s.field("blockeeId", S.string),
    blockee: s.field("blockee", Userdetailednotme.schema),
  })
}

module Userdetailed = {
  type t = JSON.t
  
  let schema = S.json
}

module Note = {
  type t = {
  id: string,
  createdat: string,
  deletedat: option<JSON.t>,
  text: JSON.t,
  cw: option<JSON.t>,
  userid: string,
  user: Userlite.t,
  replyid: option<JSON.t>,
  renoteid: option<JSON.t>,
  reply: option<JSON.t>,
  renote: option<JSON.t>,
  ishidden: option<bool>,
  visibility: string,
  mentions: option<array<string>>,
  visibleuserids: option<array<string>>,
  fileids: option<array<string>>,
  files: option<array<Drivefile.t>>,
  tags: option<array<string>>,
  poll: option<JSON.t>,
  emojis: option<JSON.t>,
  channelid: option<JSON.t>,
  channel: option<JSON.t>,
  localonly: option<bool>,
  dimension: option<JSON.t>,
  reactionacceptance: JSON.t,
  reactionemojis: JSON.t,
  reactions: JSON.t,
  reactioncount: float,
  renotecount: float,
  repliescount: float,
  uri: option<string>,
  url: option<string>,
  reactionanduserpaircache: option<array<string>>,
  clippedcount: option<float>,
  myreaction: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    deletedat: s.fieldOr("deletedAt", S.nullableAsOption(S.json), None),
    text: s.field("text", S.json),
    cw: s.fieldOr("cw", S.nullableAsOption(S.json), None),
    userid: s.field("userId", S.string),
    user: s.field("user", Userlite.schema),
    replyid: s.fieldOr("replyId", S.nullableAsOption(S.json), None),
    renoteid: s.fieldOr("renoteId", S.nullableAsOption(S.json), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.json), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.json), None),
    ishidden: s.fieldOr("isHidden", S.nullableAsOption(S.bool), None),
    visibility: s.field("visibility", S.string),
    mentions: s.fieldOr("mentions", S.nullableAsOption(S.array(S.string)), None),
    visibleuserids: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
    fileids: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    files: s.fieldOr("files", S.nullableAsOption(S.array(Drivefile.schema)), None),
    tags: s.fieldOr("tags", S.nullableAsOption(S.array(S.string)), None),
    poll: s.fieldOr("poll", S.nullableAsOption(S.json), None),
    emojis: s.fieldOr("emojis", S.nullableAsOption(S.json), None),
    channelid: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
    channel: s.fieldOr("channel", S.nullableAsOption(S.json), None),
    localonly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    dimension: s.fieldOr("dimension", S.nullableAsOption(S.json), None),
    reactionacceptance: s.field("reactionAcceptance", S.json),
    reactionemojis: s.field("reactionEmojis", S.json),
    reactions: s.field("reactions", S.json),
    reactioncount: s.field("reactionCount", S.float),
    renotecount: s.field("renoteCount", S.float),
    repliescount: s.field("repliesCount", S.float),
    uri: s.fieldOr("uri", S.nullableAsOption(S.string), None),
    url: s.fieldOr("url", S.nullableAsOption(S.string), None),
    reactionanduserpaircache: s.fieldOr("reactionAndUserPairCache", S.nullableAsOption(S.array(S.string)), None),
    clippedcount: s.fieldOr("clippedCount", S.nullableAsOption(S.float), None),
    myreaction: s.fieldOr("myReaction", S.nullableAsOption(S.json), None),
  })
}

module Notedraft = {
  type t = {
  id: string,
  updatedat: string,
  scheduledat: JSON.t,
  reason: option<string>,
  channel: option<JSON.t>,
  renote: option<JSON.t>,
  reply: option<JSON.t>,
  data: JSON.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    updatedat: s.field("updatedAt", S.string),
    scheduledat: s.field("scheduledAt", S.json),
    reason: s.fieldOr("reason", S.nullableAsOption(S.string), None),
    channel: s.fieldOr("channel", S.nullableAsOption(S.json), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.json), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.json), None),
    data: s.field("data", S.json),
  })
}

module Gallerypost = {
  type t = {
  id: string,
  createdat: string,
  updatedat: string,
  userid: string,
  user: Userlite.t,
  title: string,
  description: JSON.t,
  fileids: option<array<string>>,
  files: option<array<Drivefile.t>>,
  tags: option<array<string>>,
  issensitive: bool,
  likedcount: float,
  isliked: option<bool>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    updatedat: s.field("updatedAt", S.string),
    userid: s.field("userId", S.string),
    user: s.field("user", Userlite.schema),
    title: s.field("title", S.string),
    description: s.field("description", S.json),
    fileids: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    files: s.fieldOr("files", S.nullableAsOption(S.array(Drivefile.schema)), None),
    tags: s.fieldOr("tags", S.nullableAsOption(S.array(S.string)), None),
    issensitive: s.field("isSensitive", S.bool),
    likedcount: s.field("likedCount", S.float),
    isliked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
  })
}

module Page = {
  type t = {
  id: string,
  createdat: string,
  updatedat: string,
  userid: string,
  user: Userlite.t,
  content: array<Pageblock.t>,
  variables: array<JSON.t>,
  title: string,
  name: string,
  summary: JSON.t,
  hidetitlewhenpinned: bool,
  aligncenter: bool,
  font: string,
  script: string,
  eyecatchingimageid: JSON.t,
  eyecatchingimage: JSON.t,
  attachedfiles: array<Drivefile.t>,
  likedcount: float,
  isliked: option<bool>,
  visibility: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    updatedat: s.field("updatedAt", S.string),
    userid: s.field("userId", S.string),
    user: s.field("user", Userlite.schema),
    content: s.field("content", S.array(Pageblock.schema)),
    variables: s.field("variables", S.array(S.json)),
    title: s.field("title", S.string),
    name: s.field("name", S.string),
    summary: s.field("summary", S.json),
    hidetitlewhenpinned: s.field("hideTitleWhenPinned", S.bool),
    aligncenter: s.field("alignCenter", S.bool),
    font: s.field("font", S.string),
    script: s.field("script", S.string),
    eyecatchingimageid: s.field("eyeCatchingImageId", S.json),
    eyecatchingimage: s.field("eyeCatchingImage", S.json),
    attachedfiles: s.field("attachedFiles", S.array(Drivefile.schema)),
    likedcount: s.field("likedCount", S.float),
    isliked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
    visibility: s.field("visibility", S.string),
  })
}

module Rolecondformulalogics = {
  type t = {
  id: string,
  @as("type") type_: string,
  values: array<Rolecondformulavalue.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    values: s.field("values", S.array(Rolecondformulavalue.schema)),
  })
}

module Rolecondformulavaluenot = {
  type t = {
  id: string,
  @as("type") type_: string,
  value: Rolecondformulavalue.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    value: s.field("value", Rolecondformulavalue.schema),
  })
}

module Medetailedonly = {
  type t = {
  avatarid: JSON.t,
  bannerid: JSON.t,
  followedmessage: JSON.t,
  ismoderator: JSON.t,
  isadmin: JSON.t,
  injectfeaturednote: bool,
  receiveannouncementemail: bool,
  alwaysmarknsfw: bool,
  autosensitive: bool,
  carefulbot: bool,
  autoacceptfollowed: bool,
  nocrawle: bool,
  preventailearning: bool,
  isexplorable: bool,
  isdeleted: bool,
  twofactorbackupcodesstock: string,
  hideonlinestatus: bool,
  hasunreadspecifiednotes: bool,
  hasunreadmentions: bool,
  hasunreadannouncement: bool,
  unreadannouncements: array<Announcement.t>,
  hasunreadantenna: bool,
  hasunreadchannel: bool,
  hasunreadchatmessages: bool,
  hasunreadnotification: bool,
  haspendingreceivedfollowrequest: bool,
  unreadnotificationscount: float,
  mutedwords: array<array<string>>,
  mutedinstances: JSON.t,
  postinglang: JSON.t,
  viewinglangs: array<string>,
  showmediainalllanguages: bool,
  showhashtagsinalllanguages: bool,
  notificationrecieveconfig: JSON.t,
  emailnotificationtypes: array<string>,
  achievements: array<JSON.t>,
  loggedindays: float,
  policies: Rolepolicies.t,
  twofactorenabled: bool,
  usepasswordlesslogin: bool,
  securitykeys: bool,
  email: option<JSON.t>,
  emailverified: option<JSON.t>,
  securitykeyslist: option<array<JSON.t>>,
}
  
  let schema = S.object(s => {
    avatarid: s.field("avatarId", S.json),
    bannerid: s.field("bannerId", S.json),
    followedmessage: s.field("followedMessage", S.json),
    ismoderator: s.field("isModerator", S.json),
    isadmin: s.field("isAdmin", S.json),
    injectfeaturednote: s.field("injectFeaturedNote", S.bool),
    receiveannouncementemail: s.field("receiveAnnouncementEmail", S.bool),
    alwaysmarknsfw: s.field("alwaysMarkNsfw", S.bool),
    autosensitive: s.field("autoSensitive", S.bool),
    carefulbot: s.field("carefulBot", S.bool),
    autoacceptfollowed: s.field("autoAcceptFollowed", S.bool),
    nocrawle: s.field("noCrawle", S.bool),
    preventailearning: s.field("preventAiLearning", S.bool),
    isexplorable: s.field("isExplorable", S.bool),
    isdeleted: s.field("isDeleted", S.bool),
    twofactorbackupcodesstock: s.field("twoFactorBackupCodesStock", S.string),
    hideonlinestatus: s.field("hideOnlineStatus", S.bool),
    hasunreadspecifiednotes: s.field("hasUnreadSpecifiedNotes", S.bool),
    hasunreadmentions: s.field("hasUnreadMentions", S.bool),
    hasunreadannouncement: s.field("hasUnreadAnnouncement", S.bool),
    unreadannouncements: s.field("unreadAnnouncements", S.array(Announcement.schema)),
    hasunreadantenna: s.field("hasUnreadAntenna", S.bool),
    hasunreadchannel: s.field("hasUnreadChannel", S.bool),
    hasunreadchatmessages: s.field("hasUnreadChatMessages", S.bool),
    hasunreadnotification: s.field("hasUnreadNotification", S.bool),
    haspendingreceivedfollowrequest: s.field("hasPendingReceivedFollowRequest", S.bool),
    unreadnotificationscount: s.field("unreadNotificationsCount", S.float),
    mutedwords: s.field("mutedWords", S.array(S.array(S.string))),
    mutedinstances: s.field("mutedInstances", S.json),
    postinglang: s.field("postingLang", S.json),
    viewinglangs: s.field("viewingLangs", S.array(S.string)),
    showmediainalllanguages: s.field("showMediaInAllLanguages", S.bool),
    showhashtagsinalllanguages: s.field("showHashtagsInAllLanguages", S.bool),
    notificationrecieveconfig: s.field("notificationRecieveConfig", S.json),
    emailnotificationtypes: s.field("emailNotificationTypes", S.array(S.string)),
    achievements: s.field("achievements", S.array(S.json)),
    loggedindays: s.field("loggedInDays", S.float),
    policies: s.field("policies", Rolepolicies.schema),
    twofactorenabled: s.field("twoFactorEnabled", S.bool),
    usepasswordlesslogin: s.field("usePasswordLessLogin", S.bool),
    securitykeys: s.field("securityKeys", S.bool),
    email: s.fieldOr("email", S.nullableAsOption(S.json), None),
    emailverified: s.fieldOr("emailVerified", S.nullableAsOption(S.json), None),
    securitykeyslist: s.fieldOr("securityKeysList", S.nullableAsOption(S.array(S.json)), None),
  })
}

module Metalite = {
  type t = {
  maintainername: JSON.t,
  maintaineremail: JSON.t,
  version: string,
  name: JSON.t,
  shortname: JSON.t,
  uri: string,
  description: JSON.t,
  langs: array<string>,
  dimensions: float,
  tosurl: JSON.t,
  repositoryurl: JSON.t,
  feedbackurl: JSON.t,
  defaultdarktheme: JSON.t,
  defaultlighttheme: JSON.t,
  disableregistration: bool,
  emailrequiredforsignup: bool,
  enablehcaptcha: bool,
  hcaptchasitekey: JSON.t,
  enablemcaptcha: bool,
  mcaptchasitekey: JSON.t,
  mcaptchainstanceurl: JSON.t,
  enablerecaptcha: bool,
  recaptchasitekey: JSON.t,
  enableturnstile: bool,
  turnstilesitekey: JSON.t,
  googleanalyticsid: JSON.t,
  enabletestcaptcha: bool,
  swpublickey: JSON.t,
  mascotimageurl: string,
  bannerurl: JSON.t,
  servererrorimageurl: JSON.t,
  infoimageurl: JSON.t,
  notfoundimageurl: JSON.t,
  iconurl: JSON.t,
  maxnotetextlength: float,
  ads: array<JSON.t>,
  wellknownwebsites: array<string>,
  notesperonead: float,
  enableemail: bool,
  enableserviceworker: bool,
  translatoravailable: bool,
  sentryforfrontend: JSON.t,
  mediaproxy: string,
  enableurlpreview: bool,
  enableskebstatus: bool,
  backgroundimageurl: JSON.t,
  impressumurl: JSON.t,
  logoimageurl: JSON.t,
  privacypolicyurl: JSON.t,
  inquiryurl: JSON.t,
  serverrules: array<string>,
  themecolor: JSON.t,
  policies: Rolepolicies.t,
  notesearchablescope: string,
  maxfilesize: float,
  federation: string,
}
  
  let schema = S.object(s => {
    maintainername: s.field("maintainerName", S.json),
    maintaineremail: s.field("maintainerEmail", S.json),
    version: s.field("version", S.string),
    name: s.field("name", S.json),
    shortname: s.field("shortName", S.json),
    uri: s.field("uri", S.string),
    description: s.field("description", S.json),
    langs: s.field("langs", S.array(S.string)),
    dimensions: s.field("dimensions", S.float->S.min(1)),
    tosurl: s.field("tosUrl", S.json),
    repositoryurl: s.field("repositoryUrl", S.json),
    feedbackurl: s.field("feedbackUrl", S.json),
    defaultdarktheme: s.field("defaultDarkTheme", S.json),
    defaultlighttheme: s.field("defaultLightTheme", S.json),
    disableregistration: s.field("disableRegistration", S.bool),
    emailrequiredforsignup: s.field("emailRequiredForSignup", S.bool),
    enablehcaptcha: s.field("enableHcaptcha", S.bool),
    hcaptchasitekey: s.field("hcaptchaSiteKey", S.json),
    enablemcaptcha: s.field("enableMcaptcha", S.bool),
    mcaptchasitekey: s.field("mcaptchaSiteKey", S.json),
    mcaptchainstanceurl: s.field("mcaptchaInstanceUrl", S.json),
    enablerecaptcha: s.field("enableRecaptcha", S.bool),
    recaptchasitekey: s.field("recaptchaSiteKey", S.json),
    enableturnstile: s.field("enableTurnstile", S.bool),
    turnstilesitekey: s.field("turnstileSiteKey", S.json),
    googleanalyticsid: s.field("googleAnalyticsId", S.json),
    enabletestcaptcha: s.field("enableTestcaptcha", S.bool),
    swpublickey: s.field("swPublickey", S.json),
    mascotimageurl: s.field("mascotImageUrl", S.string),
    bannerurl: s.field("bannerUrl", S.json),
    servererrorimageurl: s.field("serverErrorImageUrl", S.json),
    infoimageurl: s.field("infoImageUrl", S.json),
    notfoundimageurl: s.field("notFoundImageUrl", S.json),
    iconurl: s.field("iconUrl", S.json),
    maxnotetextlength: s.field("maxNoteTextLength", S.float),
    ads: s.field("ads", S.array(S.json)),
    wellknownwebsites: s.field("wellKnownWebsites", S.array(S.string)),
    notesperonead: s.field("notesPerOneAd", S.float),
    enableemail: s.field("enableEmail", S.bool),
    enableserviceworker: s.field("enableServiceWorker", S.bool),
    translatoravailable: s.field("translatorAvailable", S.bool),
    sentryforfrontend: s.field("sentryForFrontend", S.json),
    mediaproxy: s.field("mediaProxy", S.string),
    enableurlpreview: s.field("enableUrlPreview", S.bool),
    enableskebstatus: s.field("enableSkebStatus", S.bool),
    backgroundimageurl: s.field("backgroundImageUrl", S.json),
    impressumurl: s.field("impressumUrl", S.json),
    logoimageurl: s.field("logoImageUrl", S.json),
    privacypolicyurl: s.field("privacyPolicyUrl", S.json),
    inquiryurl: s.field("inquiryUrl", S.json),
    serverrules: s.field("serverRules", S.array(S.string)),
    themecolor: s.field("themeColor", S.json),
    policies: s.field("policies", Rolepolicies.schema),
    notesearchablescope: s.field("noteSearchableScope", S.string),
    maxfilesize: s.field("maxFileSize", S.float),
    federation: s.field("federation", S.string),
  })
}

module Flashlike = {
  type t = {
  id: string,
  flash: Flash.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    flash: s.field("flash", Flash.schema),
  })
}

module Chatroominvitation = {
  type t = {
  id: string,
  createdat: string,
  userid: string,
  user: Userlite.t,
  roomid: string,
  room: Chatroom.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    userid: s.field("userId", S.string),
    user: s.field("user", Userlite.schema),
    roomid: s.field("roomId", S.string),
    room: s.field("room", Chatroom.schema),
  })
}

module User = {
  type t = JSON.t
  
  let schema = S.json
}

module Moderationlog = {
  type t = {
  id: string,
  createdat: string,
  @as("type") type_: string,
  info: JSON.t,
  userid: string,
  user: Userdetailed.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    type_: s.field("type", S.string),
    info: s.field("info", S.json),
    userid: s.field("userId", S.string),
    user: s.field("user", Userdetailed.schema),
  })
}

module Userdetailednotmeonly = {
  type t = {
  url: JSON.t,
  uri: JSON.t,
  movedto: JSON.t,
  alsoknownas: JSON.t,
  createdat: string,
  updatedat: JSON.t,
  lastfetchedat: JSON.t,
  bannerurl: JSON.t,
  bannerblurhash: JSON.t,
  islocked: bool,
  issilenced: bool,
  islimited: bool,
  issuspended: bool,
  description: JSON.t,
  location: JSON.t,
  birthday: JSON.t,
  lang: JSON.t,
  fields: array<JSON.t>,
  verifiedlinks: array<string>,
  followerscount: float,
  followingcount: float,
  notescount: float,
  pinnednoteids: array<string>,
  pinnednotes: array<Note.t>,
  pinnedpageid: JSON.t,
  pinnedpage: JSON.t,
  publicreactions: bool,
  followingvisibility: string,
  followersvisibility: string,
  chatscope: string,
  canchat: bool,
  roles: array<Rolelite.t>,
  followedmessage: option<JSON.t>,
  memo: JSON.t,
  moderationnote: option<string>,
  twofactorenabled: option<bool>,
  usepasswordlesslogin: option<bool>,
  securitykeys: option<bool>,
  mutuallinksections: array<JSON.t>,
  isfollowing: option<bool>,
  isfollowed: option<bool>,
  haspendingfollowrequestfromyou: option<bool>,
  haspendingfollowrequesttoyou: option<bool>,
  isblocking: option<bool>,
  isblocked: option<bool>,
  ismuted: option<bool>,
  isrenotemuted: option<bool>,
  notify: option<string>,
  withreplies: option<bool>,
}
  
  let schema = S.object(s => {
    url: s.field("url", S.json),
    uri: s.field("uri", S.json),
    movedto: s.field("movedTo", S.json),
    alsoknownas: s.field("alsoKnownAs", S.json),
    createdat: s.field("createdAt", S.string),
    updatedat: s.field("updatedAt", S.json),
    lastfetchedat: s.field("lastFetchedAt", S.json),
    bannerurl: s.field("bannerUrl", S.json),
    bannerblurhash: s.field("bannerBlurhash", S.json),
    islocked: s.field("isLocked", S.bool),
    issilenced: s.field("isSilenced", S.bool),
    islimited: s.field("isLimited", S.bool),
    issuspended: s.field("isSuspended", S.bool),
    description: s.field("description", S.json),
    location: s.field("location", S.json),
    birthday: s.field("birthday", S.json),
    lang: s.field("lang", S.json),
    fields: s.field("fields", S.array(S.json)),
    verifiedlinks: s.field("verifiedLinks", S.array(S.string)),
    followerscount: s.field("followersCount", S.float),
    followingcount: s.field("followingCount", S.float),
    notescount: s.field("notesCount", S.float),
    pinnednoteids: s.field("pinnedNoteIds", S.array(S.string)),
    pinnednotes: s.field("pinnedNotes", S.array(Note.schema)),
    pinnedpageid: s.field("pinnedPageId", S.json),
    pinnedpage: s.field("pinnedPage", S.json),
    publicreactions: s.field("publicReactions", S.bool),
    followingvisibility: s.field("followingVisibility", S.string),
    followersvisibility: s.field("followersVisibility", S.string),
    chatscope: s.field("chatScope", S.string),
    canchat: s.field("canChat", S.bool),
    roles: s.field("roles", S.array(Rolelite.schema)),
    followedmessage: s.fieldOr("followedMessage", S.nullableAsOption(S.json), None),
    memo: s.field("memo", S.json),
    moderationnote: s.fieldOr("moderationNote", S.nullableAsOption(S.string), None),
    twofactorenabled: s.fieldOr("twoFactorEnabled", S.nullableAsOption(S.bool), None),
    usepasswordlesslogin: s.fieldOr("usePasswordLessLogin", S.nullableAsOption(S.bool), None),
    securitykeys: s.fieldOr("securityKeys", S.nullableAsOption(S.bool), None),
    mutuallinksections: s.field("mutualLinkSections", S.array(S.json)),
    isfollowing: s.fieldOr("isFollowing", S.nullableAsOption(S.bool), None),
    isfollowed: s.fieldOr("isFollowed", S.nullableAsOption(S.bool), None),
    haspendingfollowrequestfromyou: s.fieldOr("hasPendingFollowRequestFromYou", S.nullableAsOption(S.bool), None),
    haspendingfollowrequesttoyou: s.fieldOr("hasPendingFollowRequestToYou", S.nullableAsOption(S.bool), None),
    isblocking: s.fieldOr("isBlocking", S.nullableAsOption(S.bool), None),
    isblocked: s.fieldOr("isBlocked", S.nullableAsOption(S.bool), None),
    ismuted: s.fieldOr("isMuted", S.nullableAsOption(S.bool), None),
    isrenotemuted: s.fieldOr("isRenoteMuted", S.nullableAsOption(S.bool), None),
    notify: s.fieldOr("notify", S.nullableAsOption(S.string), None),
    withreplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
  })
}

module Notefavorite = {
  type t = {
  id: string,
  createdat: string,
  note: Note.t,
  noteid: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    note: s.field("note", Note.schema),
    noteid: s.field("noteId", S.string),
  })
}

module Channel = {
  type t = {
  id: string,
  createdat: string,
  lastnotedat: JSON.t,
  name: string,
  description: JSON.t,
  userid: JSON.t,
  bannerurl: JSON.t,
  pinnednoteids: array<string>,
  color: string,
  isarchived: bool,
  userscount: float,
  notescount: float,
  issensitive: bool,
  allowrenotetoexternal: bool,
  isfollowing: option<bool>,
  isfavorited: option<bool>,
  pinnednotes: option<array<Note.t>>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    lastnotedat: s.field("lastNotedAt", S.json),
    name: s.field("name", S.string),
    description: s.field("description", S.json),
    userid: s.field("userId", S.json),
    bannerurl: s.field("bannerUrl", S.json),
    pinnednoteids: s.field("pinnedNoteIds", S.array(S.string)),
    color: s.field("color", S.string),
    isarchived: s.field("isArchived", S.bool),
    userscount: s.field("usersCount", S.float),
    notescount: s.field("notesCount", S.float),
    issensitive: s.field("isSensitive", S.bool),
    allowrenotetoexternal: s.field("allowRenoteToExternal", S.bool),
    isfollowing: s.fieldOr("isFollowing", S.nullableAsOption(S.bool), None),
    isfavorited: s.fieldOr("isFavorited", S.nullableAsOption(S.bool), None),
    pinnednotes: s.fieldOr("pinnedNotes", S.nullableAsOption(S.array(Note.schema)), None),
  })
}

module Gallerylike = {
  type t = {
  id: string,
  post: Gallerypost.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    post: s.field("post", Gallerypost.schema),
  })
}

module Pagelike = {
  type t = {
  id: string,
  page: Page.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    page: s.field("page", Page.schema),
  })
}

module Abuseuserreport = {
  type t = {
  id: string,
  category: string,
  createdat: string,
  comment: string,
  resolved: bool,
  reporterid: string,
  reporter: Userdetailed.t,
  targetuserid: string,
  targetuser: Userdetailed.t,
  assigneeid: JSON.t,
  assignee: option<JSON.t>,
  forwarded: bool,
  moderationnote: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    category: s.field("category", S.string),
    createdat: s.field("createdAt", S.string),
    comment: s.field("comment", S.string),
    resolved: s.field("resolved", S.bool),
    reporterid: s.field("reporterId", S.string),
    reporter: s.field("reporter", Userdetailed.schema),
    targetuserid: s.field("targetUserId", S.string),
    targetuser: s.field("targetUser", Userdetailed.schema),
    assigneeid: s.field("assigneeId", S.json),
    assignee: s.fieldOr("assignee", S.nullableAsOption(S.json), None),
    forwarded: s.field("forwarded", S.bool),
    moderationnote: s.field("moderationNote", S.string),
  })
}

module Chatmessage = {
  type t = {
  id: string,
  createdat: string,
  fromuserid: string,
  fromuser: Userlite.t,
  touserid: option<JSON.t>,
  touser: option<JSON.t>,
  toroomid: option<JSON.t>,
  toroom: option<JSON.t>,
  text: option<JSON.t>,
  fileid: option<JSON.t>,
  file: option<JSON.t>,
  isread: option<bool>,
  reactions: array<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    fromuserid: s.field("fromUserId", S.string),
    fromuser: s.field("fromUser", Userlite.schema),
    touserid: s.fieldOr("toUserId", S.nullableAsOption(S.json), None),
    touser: s.fieldOr("toUser", S.nullableAsOption(S.json), None),
    toroomid: s.fieldOr("toRoomId", S.nullableAsOption(S.json), None),
    toroom: s.fieldOr("toRoom", S.nullableAsOption(S.json), None),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileid: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    isread: s.fieldOr("isRead", S.nullableAsOption(S.bool), None),
    reactions: s.field("reactions", S.array(S.json)),
  })
}

module Chatmessageliteforroom = {
  type t = {
  id: string,
  createdat: string,
  fromuserid: string,
  fromuser: Userlite.t,
  toroomid: string,
  text: option<JSON.t>,
  fileid: option<JSON.t>,
  file: option<JSON.t>,
  reactions: array<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    fromuserid: s.field("fromUserId", S.string),
    fromuser: s.field("fromUser", Userlite.schema),
    toroomid: s.field("toRoomId", S.string),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileid: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    reactions: s.field("reactions", S.array(S.json)),
  })
}

module Followrequest = {
  type t = {
  id: string,
  follower: Userlite.t,
  followee: Userlite.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    follower: s.field("follower", Userlite.schema),
    followee: s.field("followee", Userlite.schema),
  })
}

module Reversigamedetailed = {
  type t = {
  id: string,
  createdat: string,
  startedat: JSON.t,
  endedat: JSON.t,
  isstarted: bool,
  isended: bool,
  form1: JSON.t,
  form2: JSON.t,
  user1ready: bool,
  user2ready: bool,
  user1id: string,
  user2id: string,
  user1: Userlite.t,
  user2: Userlite.t,
  winnerid: JSON.t,
  winner: JSON.t,
  surrendereduserid: JSON.t,
  timeoutuserid: JSON.t,
  black: JSON.t,
  bw: string,
  noirregularrules: bool,
  isllotheo: bool,
  canputeverywhere: bool,
  loopedboard: bool,
  timelimitforeachturn: float,
  logs: array<array<float>>,
  map: array<string>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    startedat: s.field("startedAt", S.json),
    endedat: s.field("endedAt", S.json),
    isstarted: s.field("isStarted", S.bool),
    isended: s.field("isEnded", S.bool),
    form1: s.field("form1", S.json),
    form2: s.field("form2", S.json),
    user1ready: s.field("user1Ready", S.bool),
    user2ready: s.field("user2Ready", S.bool),
    user1id: s.field("user1Id", S.string),
    user2id: s.field("user2Id", S.string),
    user1: s.field("user1", Userlite.schema),
    user2: s.field("user2", Userlite.schema),
    winnerid: s.field("winnerId", S.json),
    winner: s.field("winner", S.json),
    surrendereduserid: s.field("surrenderedUserId", S.json),
    timeoutuserid: s.field("timeoutUserId", S.json),
    black: s.field("black", S.json),
    bw: s.field("bw", S.string),
    noirregularrules: s.field("noIrregularRules", S.bool),
    isllotheo: s.field("isLlotheo", S.bool),
    canputeverywhere: s.field("canPutEverywhere", S.bool),
    loopedboard: s.field("loopedBoard", S.bool),
    timelimitforeachturn: s.field("timeLimitForEachTurn", S.float),
    logs: s.field("logs", S.array(S.array(S.float))),
    map: s.field("map", S.array(S.string)),
  })
}

module Reversigamelite = {
  type t = {
  id: string,
  createdat: string,
  startedat: JSON.t,
  endedat: JSON.t,
  isstarted: bool,
  isended: bool,
  user1id: string,
  user2id: string,
  user1: Userlite.t,
  user2: Userlite.t,
  winnerid: JSON.t,
  winner: JSON.t,
  surrendereduserid: JSON.t,
  timeoutuserid: JSON.t,
  black: JSON.t,
  bw: string,
  noirregularrules: bool,
  isllotheo: bool,
  canputeverywhere: bool,
  loopedboard: bool,
  timelimitforeachturn: float,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    startedat: s.field("startedAt", S.json),
    endedat: s.field("endedAt", S.json),
    isstarted: s.field("isStarted", S.bool),
    isended: s.field("isEnded", S.bool),
    user1id: s.field("user1Id", S.string),
    user2id: s.field("user2Id", S.string),
    user1: s.field("user1", Userlite.schema),
    user2: s.field("user2", Userlite.schema),
    winnerid: s.field("winnerId", S.json),
    winner: s.field("winner", S.json),
    surrendereduserid: s.field("surrenderedUserId", S.json),
    timeoutuserid: s.field("timeoutUserId", S.json),
    black: s.field("black", S.json),
    bw: s.field("bw", S.string),
    noirregularrules: s.field("noIrregularRules", S.bool),
    isllotheo: s.field("isLlotheo", S.bool),
    canputeverywhere: s.field("canPutEverywhere", S.bool),
    loopedboard: s.field("loopedBoard", S.bool),
    timelimitforeachturn: s.field("timeLimitForEachTurn", S.float),
  })
}

module Useraccountmovelog = {
  type t = {
  id: string,
  createdat: string,
  movedtoid: string,
  movedto: Userdetailed.t,
  movedfromid: string,
  movedfrom: Userdetailed.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdat: s.field("createdAt", S.string),
    movedtoid: s.field("movedToId", S.string),
    movedto: s.field("movedTo", Userdetailed.schema),
    movedfromid: s.field("movedFromId", S.string),
    movedfrom: s.field("movedFrom", Userdetailed.schema),
  })
}
