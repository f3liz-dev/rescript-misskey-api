// kokonect-link API for channels
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postChannelsCreateRequest = {
  name: string,
  description: option<string>,
  bannerId: option<string>,
  color: option<string>,
  isSensitive: option<bool>,
  allowRenoteToExternal: option<bool>,
}

let postChannelsCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(128)),
    description: s.field("description", S.option(S.string->S.min(1)->S.max(2048))),
    bannerId: s.field("bannerId", S.option(S.string)),
    color: s.field("color", S.option(S.string->S.min(1)->S.max(16))),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
    allowRenoteToExternal: s.field("allowRenoteToExternal", S.option(S.bool)),
  })

type postChannelsCreateResponse = KokonectLinkComponentSchemas.Channel.t

let postChannelsCreateResponseSchema = KokonectLinkComponentSchemas.Channel.schema

/**
 * channels/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:channels*
 */
let postChannelsCreate = (~body: postChannelsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsCreateRequestSchema)
  fetch(
    ~url="/channels/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postChannelsCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postChannelsFollowedRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postChannelsFollowedRequestSchema = S.object(s => {
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postChannelsFollowedResponse = array<KokonectLinkComponentSchemas.Channel.t>

let postChannelsFollowedResponseSchema = S.array(KokonectLinkComponentSchemas.Channel.schema)

/**
 * channels/followed
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:channels*
 */
let postChannelsFollowed = (~body: postChannelsFollowedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsFollowedResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsFollowedRequestSchema)
  fetch(
    ~url="/channels/followed",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postChannelsFollowedResponseSchema)
  value
    ->Promise.resolve
  })
}

type postChannelsOwnedRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postChannelsOwnedRequestSchema = S.object(s => {
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postChannelsOwnedResponse = array<KokonectLinkComponentSchemas.Channel.t>

let postChannelsOwnedResponseSchema = S.array(KokonectLinkComponentSchemas.Channel.schema)

/**
 * channels/owned
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:channels*
 */
let postChannelsOwned = (~body: postChannelsOwnedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsOwnedResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsOwnedRequestSchema)
  fetch(
    ~url="/channels/owned",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postChannelsOwnedResponseSchema)
  value
    ->Promise.resolve
  })
}

type postChannelsSearchRequest = {
  query: string,
  @as("type") type_: option<string>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postChannelsSearchRequestSchema = S.object(s => {
    query: s.field("query", S.string),
    type_: s.field("type", S.option(S.string)),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postChannelsSearchResponse = array<KokonectLinkComponentSchemas.Channel.t>

let postChannelsSearchResponseSchema = S.array(KokonectLinkComponentSchemas.Channel.schema)

/**
 * channels/search
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChannelsSearch = (~body: postChannelsSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsSearchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsSearchRequestSchema)
  fetch(
    ~url="/channels/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postChannelsSearchResponseSchema)
  value
    ->Promise.resolve
  })
}

type postChannelsShowRequest = {
  channelId: string,
}

let postChannelsShowRequestSchema = S.object(s => {
    channelId: s.field("channelId", S.string),
  })

type postChannelsShowResponse = KokonectLinkComponentSchemas.Channel.t

let postChannelsShowResponseSchema = KokonectLinkComponentSchemas.Channel.schema

/**
 * channels/show
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChannelsShow = (~body: postChannelsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsShowRequestSchema)
  fetch(
    ~url="/channels/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postChannelsShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postChannelsUpdateRequest = {
  channelId: string,
  name: option<string>,
  description: option<string>,
  bannerId: option<string>,
  isArchived: option<bool>,
  pinnedNoteIds: option<array<string>>,
  color: option<string>,
  isSensitive: option<bool>,
  allowRenoteToExternal: option<bool>,
}

let postChannelsUpdateRequestSchema = S.object(s => {
    channelId: s.field("channelId", S.string),
    name: s.field("name", S.option(S.string->S.min(1)->S.max(128))),
    description: s.field("description", S.option(S.string->S.min(1)->S.max(2048))),
    bannerId: s.field("bannerId", S.option(S.string)),
    isArchived: s.field("isArchived", S.option(S.bool)),
    pinnedNoteIds: s.field("pinnedNoteIds", S.option(S.array(S.string))),
    color: s.field("color", S.option(S.string->S.min(1)->S.max(16))),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
    allowRenoteToExternal: s.field("allowRenoteToExternal", S.option(S.bool)),
  })

type postChannelsUpdateResponse = KokonectLinkComponentSchemas.Channel.t

let postChannelsUpdateResponseSchema = KokonectLinkComponentSchemas.Channel.schema

/**
 * channels/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:channels*
 */
let postChannelsUpdate = (~body: postChannelsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsUpdateRequestSchema)
  fetch(
    ~url="/channels/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postChannelsUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}
