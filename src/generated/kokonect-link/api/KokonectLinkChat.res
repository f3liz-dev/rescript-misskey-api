// kokonect-link API for chat
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postChatHistoryRequest = {
  limit: option<int>,
  room: option<bool>,
}

let postChatHistoryRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    room: s.field("room", S.option(S.bool)),
  })

type postChatHistoryResponse = array<KokonectLinkComponentSchemas.ChatMessage.t>

let postChatHistoryResponseSchema = S.array(KokonectLinkComponentSchemas.ChatMessage.schema)

/**
chat/history

No description provided.

**Credential required**: *Yes* / **Permission**: *read:chat*
*/
let postChatHistory = async (~body: postChatHistoryRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatHistoryResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatHistoryRequestSchema)
  let response = await fetch(
    ~url="/chat/history",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatHistoryResponseSchema)
}

type postChatMessagesCreateToRoomRequest = {
  text: option<string>,
  fileId: option<string>,
  toRoomId: string,
}

let postChatMessagesCreateToRoomRequestSchema = S.object(s => {
    text: s.field("text", S.option(S.string->S.max(2000))),
    fileId: s.field("fileId", S.option(S.string)),
    toRoomId: s.field("toRoomId", S.string),
  })

type postChatMessagesCreateToRoomResponse = KokonectLinkComponentSchemas.ChatMessageLiteForRoom.t

let postChatMessagesCreateToRoomResponseSchema = KokonectLinkComponentSchemas.ChatMessageLiteForRoom.schema

/**
chat/messages/create-to-room

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatMessagesCreateToRoom = async (~body: postChatMessagesCreateToRoomRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatMessagesCreateToRoomResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesCreateToRoomRequestSchema)
  let response = await fetch(
    ~url="/chat/messages/create-to-room",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatMessagesCreateToRoomResponseSchema)
}

type postChatMessagesCreateToUserRequest = {
  text: option<string>,
  fileId: option<string>,
  toUserId: string,
}

let postChatMessagesCreateToUserRequestSchema = S.object(s => {
    text: s.field("text", S.option(S.string->S.max(2000))),
    fileId: s.field("fileId", S.option(S.string)),
    toUserId: s.field("toUserId", S.string),
  })

type postChatMessagesCreateToUserResponse = KokonectLinkComponentSchemas.ChatMessageLiteFor1on1.t

let postChatMessagesCreateToUserResponseSchema = KokonectLinkComponentSchemas.ChatMessageLiteFor1on1.schema

/**
chat/messages/create-to-user

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatMessagesCreateToUser = async (~body: postChatMessagesCreateToUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatMessagesCreateToUserResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesCreateToUserRequestSchema)
  let response = await fetch(
    ~url="/chat/messages/create-to-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatMessagesCreateToUserResponseSchema)
}

type postChatMessagesDeleteRequest = {
  messageId: string,
}

let postChatMessagesDeleteRequestSchema = S.object(s => {
    messageId: s.field("messageId", S.string),
  })

type postChatMessagesDeleteResponse = unit

/**
chat/messages/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatMessagesDelete = async (~body: postChatMessagesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatMessagesDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesDeleteRequestSchema)
  let response = await fetch(
    ~url="/chat/messages/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postChatMessagesReactRequest = {
  messageId: string,
  reaction: string,
}

let postChatMessagesReactRequestSchema = S.object(s => {
    messageId: s.field("messageId", S.string),
    reaction: s.field("reaction", S.string),
  })

type postChatMessagesReactResponse = unit

/**
chat/messages/react

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatMessagesReact = async (~body: postChatMessagesReactRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatMessagesReactResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesReactRequestSchema)
  let response = await fetch(
    ~url="/chat/messages/react",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postChatMessagesRoomTimelineRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  roomId: string,
}

let postChatMessagesRoomTimelineRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    roomId: s.field("roomId", S.string),
  })

type postChatMessagesRoomTimelineResponse = array<KokonectLinkComponentSchemas.ChatMessageLiteForRoom.t>

let postChatMessagesRoomTimelineResponseSchema = S.array(KokonectLinkComponentSchemas.ChatMessageLiteForRoom.schema)

/**
chat/messages/room-timeline

No description provided.

**Credential required**: *Yes* / **Permission**: *read:chat*
*/
let postChatMessagesRoomTimeline = async (~body: postChatMessagesRoomTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatMessagesRoomTimelineResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesRoomTimelineRequestSchema)
  let response = await fetch(
    ~url="/chat/messages/room-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatMessagesRoomTimelineResponseSchema)
}

type postChatMessagesSearchRequest = {
  query: string,
  limit: option<int>,
  userId: option<string>,
  roomId: option<string>,
}

let postChatMessagesSearchRequestSchema = S.object(s => {
    query: s.field("query", S.string->S.min(1)->S.max(256)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    userId: s.field("userId", S.option(S.string)),
    roomId: s.field("roomId", S.option(S.string)),
  })

type postChatMessagesSearchResponse = array<KokonectLinkComponentSchemas.ChatMessage.t>

let postChatMessagesSearchResponseSchema = S.array(KokonectLinkComponentSchemas.ChatMessage.schema)

/**
chat/messages/search

No description provided.

**Credential required**: *Yes* / **Permission**: *read:chat*
*/
let postChatMessagesSearch = async (~body: postChatMessagesSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatMessagesSearchResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesSearchRequestSchema)
  let response = await fetch(
    ~url="/chat/messages/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatMessagesSearchResponseSchema)
}

type postChatMessagesShowRequest = {
  messageId: string,
}

let postChatMessagesShowRequestSchema = S.object(s => {
    messageId: s.field("messageId", S.string),
  })

type postChatMessagesShowResponse = KokonectLinkComponentSchemas.ChatMessage.t

let postChatMessagesShowResponseSchema = KokonectLinkComponentSchemas.ChatMessage.schema

/**
chat/messages/show

No description provided.

**Credential required**: *Yes* / **Permission**: *read:chat*
*/
let postChatMessagesShow = async (~body: postChatMessagesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatMessagesShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesShowRequestSchema)
  let response = await fetch(
    ~url="/chat/messages/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatMessagesShowResponseSchema)
}

type postChatMessagesUnreactRequest = {
  messageId: string,
  reaction: string,
}

let postChatMessagesUnreactRequestSchema = S.object(s => {
    messageId: s.field("messageId", S.string),
    reaction: s.field("reaction", S.string),
  })

type postChatMessagesUnreactResponse = unit

/**
chat/messages/unreact

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatMessagesUnreact = async (~body: postChatMessagesUnreactRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatMessagesUnreactResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesUnreactRequestSchema)
  let response = await fetch(
    ~url="/chat/messages/unreact",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postChatMessagesUserTimelineRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  userId: string,
}

let postChatMessagesUserTimelineRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    userId: s.field("userId", S.string),
  })

type postChatMessagesUserTimelineResponse = array<KokonectLinkComponentSchemas.ChatMessageLiteFor1on1.t>

let postChatMessagesUserTimelineResponseSchema = S.array(KokonectLinkComponentSchemas.ChatMessageLiteFor1on1.schema)

/**
chat/messages/user-timeline

No description provided.

**Credential required**: *Yes* / **Permission**: *read:chat*
*/
let postChatMessagesUserTimeline = async (~body: postChatMessagesUserTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatMessagesUserTimelineResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesUserTimelineRequestSchema)
  let response = await fetch(
    ~url="/chat/messages/user-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatMessagesUserTimelineResponseSchema)
}

type postChatReadAllResponse = unit

/**
chat/read-all

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatReadAll = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatReadAllResponse => {

  let response = await fetch(
    ~url="/chat/read-all",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postChatRoomsCreateRequest = {
  name: string,
  description: option<string>,
}

let postChatRoomsCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.max(256)),
    description: s.field("description", S.option(S.string->S.max(1024))),
  })

type postChatRoomsCreateResponse = KokonectLinkComponentSchemas.ChatRoom.t

let postChatRoomsCreateResponseSchema = KokonectLinkComponentSchemas.ChatRoom.schema

/**
chat/rooms/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatRoomsCreate = async (~body: postChatRoomsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsCreateRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatRoomsCreateResponseSchema)
}

type postChatRoomsDeleteRequest = {
  roomId: string,
}

let postChatRoomsDeleteRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsDeleteResponse = unit

/**
chat/rooms/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatRoomsDelete = async (~body: postChatRoomsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsDeleteRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postChatRoomsInvitationsCancelRequest = {
  invitationId: string,
}

let postChatRoomsInvitationsCancelRequestSchema = S.object(s => {
    invitationId: s.field("invitationId", S.string),
  })

type postChatRoomsInvitationsCancelResponse = unit

/**
chat/rooms/invitations/cancel

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatRoomsInvitationsCancel = async (~body: postChatRoomsInvitationsCancelRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsInvitationsCancelResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsCancelRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/invitations/cancel",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postChatRoomsInvitationsCreateRequest = {
  roomId: string,
  userId: string,
}

let postChatRoomsInvitationsCreateRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
    userId: s.field("userId", S.string),
  })

type postChatRoomsInvitationsCreateResponse = KokonectLinkComponentSchemas.ChatRoomInvitation.t

let postChatRoomsInvitationsCreateResponseSchema = KokonectLinkComponentSchemas.ChatRoomInvitation.schema

/**
chat/rooms/invitations/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatRoomsInvitationsCreate = async (~body: postChatRoomsInvitationsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsInvitationsCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsCreateRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/invitations/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatRoomsInvitationsCreateResponseSchema)
}

type postChatRoomsInvitationsIgnoreRequest = {
  roomId: string,
}

let postChatRoomsInvitationsIgnoreRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsInvitationsIgnoreResponse = unit

/**
chat/rooms/invitations/ignore

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatRoomsInvitationsIgnore = async (~body: postChatRoomsInvitationsIgnoreRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsInvitationsIgnoreResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsIgnoreRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/invitations/ignore",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postChatRoomsInvitationsInboxRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postChatRoomsInvitationsInboxRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postChatRoomsInvitationsInboxResponse = array<KokonectLinkComponentSchemas.ChatRoomInvitation.t>

let postChatRoomsInvitationsInboxResponseSchema = S.array(KokonectLinkComponentSchemas.ChatRoomInvitation.schema)

/**
chat/rooms/invitations/inbox

No description provided.

**Credential required**: *Yes* / **Permission**: *read:chat*
*/
let postChatRoomsInvitationsInbox = async (~body: postChatRoomsInvitationsInboxRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsInvitationsInboxResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsInboxRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/invitations/inbox",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatRoomsInvitationsInboxResponseSchema)
}

type postChatRoomsInvitationsOutboxRequest = {
  roomId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postChatRoomsInvitationsOutboxRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postChatRoomsInvitationsOutboxResponse = array<KokonectLinkComponentSchemas.ChatRoomInvitation.t>

let postChatRoomsInvitationsOutboxResponseSchema = S.array(KokonectLinkComponentSchemas.ChatRoomInvitation.schema)

/**
chat/rooms/invitations/outbox

No description provided.

**Credential required**: *Yes* / **Permission**: *read:chat*
*/
let postChatRoomsInvitationsOutbox = async (~body: postChatRoomsInvitationsOutboxRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsInvitationsOutboxResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsOutboxRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/invitations/outbox",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatRoomsInvitationsOutboxResponseSchema)
}

type postChatRoomsInvitationsRejectRequest = {
  roomId: string,
}

let postChatRoomsInvitationsRejectRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsInvitationsRejectResponse = unit

/**
chat/rooms/invitations/reject

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatRoomsInvitationsReject = async (~body: postChatRoomsInvitationsRejectRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsInvitationsRejectResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsRejectRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/invitations/reject",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postChatRoomsJoinRequest = {
  roomId: string,
}

let postChatRoomsJoinRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsJoinResponse = unit

/**
chat/rooms/join

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatRoomsJoin = async (~body: postChatRoomsJoinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsJoinResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsJoinRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/join",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postChatRoomsJoiningRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postChatRoomsJoiningRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postChatRoomsJoiningResponse = array<KokonectLinkComponentSchemas.ChatRoomMembership.t>

let postChatRoomsJoiningResponseSchema = S.array(KokonectLinkComponentSchemas.ChatRoomMembership.schema)

/**
chat/rooms/joining

No description provided.

**Credential required**: *Yes* / **Permission**: *read:chat*
*/
let postChatRoomsJoining = async (~body: postChatRoomsJoiningRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsJoiningResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsJoiningRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/joining",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatRoomsJoiningResponseSchema)
}

type postChatRoomsLeaveRequest = {
  roomId: string,
}

let postChatRoomsLeaveRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsLeaveResponse = unit

/**
chat/rooms/leave

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatRoomsLeave = async (~body: postChatRoomsLeaveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsLeaveResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsLeaveRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/leave",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postChatRoomsMembersRequest = {
  roomId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postChatRoomsMembersRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postChatRoomsMembersResponse = array<KokonectLinkComponentSchemas.ChatRoomMembership.t>

let postChatRoomsMembersResponseSchema = S.array(KokonectLinkComponentSchemas.ChatRoomMembership.schema)

/**
chat/rooms/members

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatRoomsMembers = async (~body: postChatRoomsMembersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsMembersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsMembersRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/members",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatRoomsMembersResponseSchema)
}

type postChatRoomsMuteRequest = {
  roomId: string,
  mute: bool,
}

let postChatRoomsMuteRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
    mute: s.field("mute", S.bool),
  })

type postChatRoomsMuteResponse = unit

/**
chat/rooms/mute

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatRoomsMute = async (~body: postChatRoomsMuteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsMuteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsMuteRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/mute",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postChatRoomsOwnedRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postChatRoomsOwnedRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postChatRoomsOwnedResponse = array<KokonectLinkComponentSchemas.ChatRoom.t>

let postChatRoomsOwnedResponseSchema = S.array(KokonectLinkComponentSchemas.ChatRoom.schema)

/**
chat/rooms/owned

No description provided.

**Credential required**: *Yes* / **Permission**: *read:chat*
*/
let postChatRoomsOwned = async (~body: postChatRoomsOwnedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsOwnedResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsOwnedRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/owned",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatRoomsOwnedResponseSchema)
}

type postChatRoomsShowRequest = {
  roomId: string,
}

let postChatRoomsShowRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsShowResponse = KokonectLinkComponentSchemas.ChatRoom.t

let postChatRoomsShowResponseSchema = KokonectLinkComponentSchemas.ChatRoom.schema

/**
chat/rooms/show

No description provided.

**Credential required**: *Yes* / **Permission**: *read:chat*
*/
let postChatRoomsShow = async (~body: postChatRoomsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsShowRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatRoomsShowResponseSchema)
}

type postChatRoomsUpdateRequest = {
  roomId: string,
  name: option<string>,
  description: option<string>,
}

let postChatRoomsUpdateRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
    name: s.field("name", S.option(S.string->S.max(256))),
    description: s.field("description", S.option(S.string->S.max(1024))),
  })

type postChatRoomsUpdateResponse = KokonectLinkComponentSchemas.ChatRoom.t

let postChatRoomsUpdateResponseSchema = KokonectLinkComponentSchemas.ChatRoom.schema

/**
chat/rooms/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:chat*
*/
let postChatRoomsUpdate = async (~body: postChatRoomsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChatRoomsUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsUpdateRequestSchema)
  let response = await fetch(
    ~url="/chat/rooms/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChatRoomsUpdateResponseSchema)
}
