// SPDX-License-Identifier: MIT
// kokonect-link API for chat
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type postChatHistoryRequest = {
  limit: option<int>,
  room: option<bool>,
}

let postChatHistoryRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    room: s.fieldOr("room", S.nullableAsOption(S.bool), None),
  })

type postChatHistoryResponse = array<KokonectLinkComponentSchemas.ChatMessage.t>

let postChatHistoryResponseSchema = S.array(KokonectLinkComponentSchemas.ChatMessage.schema)

/**
 * chat/history
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:chat*
 */
let postChatHistory = (~body: postChatHistoryRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatHistoryResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatHistoryRequestSchema)
  
  fetch(
    ~url="/chat/history",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatHistoryResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatMessagesCreateToRoomRequest = {
  text: option<JSON.t>,
  fileId: option<string>,
  toRoomId: string,
}

let postChatMessagesCreateToRoomRequestSchema = S.object(s => {
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.string), None),
    toRoomId: s.field("toRoomId", S.string),
  })

type postChatMessagesCreateToRoomResponse = KokonectLinkComponentSchemas.ChatMessageLiteForRoom.t

let postChatMessagesCreateToRoomResponseSchema = KokonectLinkComponentSchemas.ChatMessageLiteForRoom.schema

/**
 * chat/messages/create-to-room
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatMessagesCreateToRoom = (~body: postChatMessagesCreateToRoomRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesCreateToRoomResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesCreateToRoomRequestSchema)
  
  fetch(
    ~url="/chat/messages/create-to-room",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatMessagesCreateToRoomResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatMessagesCreateToUserRequest = {
  text: option<JSON.t>,
  fileId: option<string>,
  toUserId: string,
}

let postChatMessagesCreateToUserRequestSchema = S.object(s => {
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.string), None),
    toUserId: s.field("toUserId", S.string),
  })

type postChatMessagesCreateToUserResponse = KokonectLinkComponentSchemas.ChatMessageLiteFor1on1.t

let postChatMessagesCreateToUserResponseSchema = KokonectLinkComponentSchemas.ChatMessageLiteFor1on1.schema

/**
 * chat/messages/create-to-user
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatMessagesCreateToUser = (~body: postChatMessagesCreateToUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesCreateToUserResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesCreateToUserRequestSchema)
  
  fetch(
    ~url="/chat/messages/create-to-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatMessagesCreateToUserResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatMessagesDeleteRequest = {
  messageId: string,
}

let postChatMessagesDeleteRequestSchema = S.object(s => {
    messageId: s.field("messageId", S.string),
  })

type postChatMessagesDeleteResponse = unit

/**
 * chat/messages/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatMessagesDelete = (~body: postChatMessagesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesDeleteRequestSchema)
  
  fetch(
    ~url="/chat/messages/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postChatMessagesReactRequest = {
  messageId: string,
  reaction: string,
}

let postChatMessagesReactRequestSchema = S.object(s => {
    messageId: s.field("messageId", S.string),
    reaction: s.field("reaction", S.string),
  })

type postChatMessagesReactResponse = unit

/**
 * chat/messages/react
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatMessagesReact = (~body: postChatMessagesReactRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesReactResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesReactRequestSchema)
  
  fetch(
    ~url="/chat/messages/react",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postChatMessagesRoomTimelineRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  roomId: string,
}

let postChatMessagesRoomTimelineRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    roomId: s.field("roomId", S.string),
  })

type postChatMessagesRoomTimelineResponse = array<KokonectLinkComponentSchemas.ChatMessageLiteForRoom.t>

let postChatMessagesRoomTimelineResponseSchema = S.array(KokonectLinkComponentSchemas.ChatMessageLiteForRoom.schema)

/**
 * chat/messages/room-timeline
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:chat*
 */
let postChatMessagesRoomTimeline = (~body: postChatMessagesRoomTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesRoomTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesRoomTimelineRequestSchema)
  
  fetch(
    ~url="/chat/messages/room-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatMessagesRoomTimelineResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatMessagesSearchRequest = {
  query: string,
  limit: option<int>,
  userId: option<JSON.t>,
  roomId: option<JSON.t>,
}

let postChatMessagesSearchRequestSchema = S.object(s => {
    query: s.field("query", S.string->S.min(1)->S.max(256)),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.json), None),
    roomId: s.fieldOr("roomId", S.nullableAsOption(S.json), None),
  })

type postChatMessagesSearchResponse = array<KokonectLinkComponentSchemas.ChatMessage.t>

let postChatMessagesSearchResponseSchema = S.array(KokonectLinkComponentSchemas.ChatMessage.schema)

/**
 * chat/messages/search
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:chat*
 */
let postChatMessagesSearch = (~body: postChatMessagesSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesSearchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesSearchRequestSchema)
  
  fetch(
    ~url="/chat/messages/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatMessagesSearchResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatMessagesShowRequest = {
  messageId: string,
}

let postChatMessagesShowRequestSchema = S.object(s => {
    messageId: s.field("messageId", S.string),
  })

type postChatMessagesShowResponse = KokonectLinkComponentSchemas.ChatMessage.t

let postChatMessagesShowResponseSchema = KokonectLinkComponentSchemas.ChatMessage.schema

/**
 * chat/messages/show
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:chat*
 */
let postChatMessagesShow = (~body: postChatMessagesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesShowRequestSchema)
  
  fetch(
    ~url="/chat/messages/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatMessagesShowResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatMessagesUnreactRequest = {
  messageId: string,
  reaction: string,
}

let postChatMessagesUnreactRequestSchema = S.object(s => {
    messageId: s.field("messageId", S.string),
    reaction: s.field("reaction", S.string),
  })

type postChatMessagesUnreactResponse = unit

/**
 * chat/messages/unreact
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatMessagesUnreact = (~body: postChatMessagesUnreactRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesUnreactResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesUnreactRequestSchema)
  
  fetch(
    ~url="/chat/messages/unreact",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postChatMessagesUserTimelineRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  userId: string,
}

let postChatMessagesUserTimelineRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    userId: s.field("userId", S.string),
  })

type postChatMessagesUserTimelineResponse = array<KokonectLinkComponentSchemas.ChatMessageLiteFor1on1.t>

let postChatMessagesUserTimelineResponseSchema = S.array(KokonectLinkComponentSchemas.ChatMessageLiteFor1on1.schema)

/**
 * chat/messages/user-timeline
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:chat*
 */
let postChatMessagesUserTimeline = (~body: postChatMessagesUserTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatMessagesUserTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatMessagesUserTimelineRequestSchema)
  
  fetch(
    ~url="/chat/messages/user-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatMessagesUserTimelineResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatReadAllResponse = unit

/**
 * chat/read-all
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatReadAll = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatReadAllResponse> => {
  
  fetch(
    ~url="/chat/read-all",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postChatRoomsCreateRequest = {
  name: string,
  description: option<string>,
}

let postChatRoomsCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.max(256)),
    description: s.fieldOr("description", S.nullableAsOption(S.string->S.max(1024)), None),
  })

type postChatRoomsCreateResponse = KokonectLinkComponentSchemas.ChatRoom.t

let postChatRoomsCreateResponseSchema = KokonectLinkComponentSchemas.ChatRoom.schema

/**
 * chat/rooms/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatRoomsCreate = (~body: postChatRoomsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsCreateRequestSchema)
  
  fetch(
    ~url="/chat/rooms/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatRoomsCreateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatRoomsDeleteRequest = {
  roomId: string,
}

let postChatRoomsDeleteRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsDeleteResponse = unit

/**
 * chat/rooms/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatRoomsDelete = (~body: postChatRoomsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsDeleteRequestSchema)
  
  fetch(
    ~url="/chat/rooms/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postChatRoomsInvitationsCancelRequest = {
  invitationId: string,
}

let postChatRoomsInvitationsCancelRequestSchema = S.object(s => {
    invitationId: s.field("invitationId", S.string),
  })

type postChatRoomsInvitationsCancelResponse = unit

/**
 * chat/rooms/invitations/cancel
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatRoomsInvitationsCancel = (~body: postChatRoomsInvitationsCancelRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsInvitationsCancelResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsCancelRequestSchema)
  
  fetch(
    ~url="/chat/rooms/invitations/cancel",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postChatRoomsInvitationsCreateRequest = {
  roomId: string,
  userId: string,
}

let postChatRoomsInvitationsCreateRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
    userId: s.field("userId", S.string),
  })

type postChatRoomsInvitationsCreateResponse = KokonectLinkComponentSchemas.ChatRoomInvitation.t

let postChatRoomsInvitationsCreateResponseSchema = KokonectLinkComponentSchemas.ChatRoomInvitation.schema

/**
 * chat/rooms/invitations/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatRoomsInvitationsCreate = (~body: postChatRoomsInvitationsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsInvitationsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsCreateRequestSchema)
  
  fetch(
    ~url="/chat/rooms/invitations/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatRoomsInvitationsCreateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatRoomsInvitationsIgnoreRequest = {
  roomId: string,
}

let postChatRoomsInvitationsIgnoreRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsInvitationsIgnoreResponse = unit

/**
 * chat/rooms/invitations/ignore
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatRoomsInvitationsIgnore = (~body: postChatRoomsInvitationsIgnoreRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsInvitationsIgnoreResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsIgnoreRequestSchema)
  
  fetch(
    ~url="/chat/rooms/invitations/ignore",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postChatRoomsInvitationsInboxRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postChatRoomsInvitationsInboxRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postChatRoomsInvitationsInboxResponse = array<KokonectLinkComponentSchemas.ChatRoomInvitation.t>

let postChatRoomsInvitationsInboxResponseSchema = S.array(KokonectLinkComponentSchemas.ChatRoomInvitation.schema)

/**
 * chat/rooms/invitations/inbox
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:chat*
 */
let postChatRoomsInvitationsInbox = (~body: postChatRoomsInvitationsInboxRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsInvitationsInboxResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsInboxRequestSchema)
  
  fetch(
    ~url="/chat/rooms/invitations/inbox",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatRoomsInvitationsInboxResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatRoomsInvitationsOutboxRequest = {
  roomId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postChatRoomsInvitationsOutboxRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postChatRoomsInvitationsOutboxResponse = array<KokonectLinkComponentSchemas.ChatRoomInvitation.t>

let postChatRoomsInvitationsOutboxResponseSchema = S.array(KokonectLinkComponentSchemas.ChatRoomInvitation.schema)

/**
 * chat/rooms/invitations/outbox
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:chat*
 */
let postChatRoomsInvitationsOutbox = (~body: postChatRoomsInvitationsOutboxRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsInvitationsOutboxResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsOutboxRequestSchema)
  
  fetch(
    ~url="/chat/rooms/invitations/outbox",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatRoomsInvitationsOutboxResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatRoomsInvitationsRejectRequest = {
  roomId: string,
}

let postChatRoomsInvitationsRejectRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsInvitationsRejectResponse = unit

/**
 * chat/rooms/invitations/reject
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatRoomsInvitationsReject = (~body: postChatRoomsInvitationsRejectRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsInvitationsRejectResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsInvitationsRejectRequestSchema)
  
  fetch(
    ~url="/chat/rooms/invitations/reject",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postChatRoomsJoinRequest = {
  roomId: string,
}

let postChatRoomsJoinRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsJoinResponse = unit

/**
 * chat/rooms/join
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatRoomsJoin = (~body: postChatRoomsJoinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsJoinResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsJoinRequestSchema)
  
  fetch(
    ~url="/chat/rooms/join",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postChatRoomsJoiningRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postChatRoomsJoiningRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postChatRoomsJoiningResponse = array<KokonectLinkComponentSchemas.ChatRoomMembership.t>

let postChatRoomsJoiningResponseSchema = S.array(KokonectLinkComponentSchemas.ChatRoomMembership.schema)

/**
 * chat/rooms/joining
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:chat*
 */
let postChatRoomsJoining = (~body: postChatRoomsJoiningRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsJoiningResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsJoiningRequestSchema)
  
  fetch(
    ~url="/chat/rooms/joining",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatRoomsJoiningResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatRoomsLeaveRequest = {
  roomId: string,
}

let postChatRoomsLeaveRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsLeaveResponse = unit

/**
 * chat/rooms/leave
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatRoomsLeave = (~body: postChatRoomsLeaveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsLeaveResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsLeaveRequestSchema)
  
  fetch(
    ~url="/chat/rooms/leave",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postChatRoomsMembersRequest = {
  roomId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postChatRoomsMembersRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postChatRoomsMembersResponse = array<KokonectLinkComponentSchemas.ChatRoomMembership.t>

let postChatRoomsMembersResponseSchema = S.array(KokonectLinkComponentSchemas.ChatRoomMembership.schema)

/**
 * chat/rooms/members
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatRoomsMembers = (~body: postChatRoomsMembersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsMembersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsMembersRequestSchema)
  
  fetch(
    ~url="/chat/rooms/members",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatRoomsMembersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatRoomsMuteRequest = {
  roomId: string,
  mute: bool,
}

let postChatRoomsMuteRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
    mute: s.field("mute", S.bool),
  })

type postChatRoomsMuteResponse = unit

/**
 * chat/rooms/mute
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatRoomsMute = (~body: postChatRoomsMuteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsMuteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsMuteRequestSchema)
  
  fetch(
    ~url="/chat/rooms/mute",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postChatRoomsOwnedRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postChatRoomsOwnedRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postChatRoomsOwnedResponse = array<KokonectLinkComponentSchemas.ChatRoom.t>

let postChatRoomsOwnedResponseSchema = S.array(KokonectLinkComponentSchemas.ChatRoom.schema)

/**
 * chat/rooms/owned
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:chat*
 */
let postChatRoomsOwned = (~body: postChatRoomsOwnedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsOwnedResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsOwnedRequestSchema)
  
  fetch(
    ~url="/chat/rooms/owned",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatRoomsOwnedResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatRoomsShowRequest = {
  roomId: string,
}

let postChatRoomsShowRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
  })

type postChatRoomsShowResponse = KokonectLinkComponentSchemas.ChatRoom.t

let postChatRoomsShowResponseSchema = KokonectLinkComponentSchemas.ChatRoom.schema

/**
 * chat/rooms/show
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:chat*
 */
let postChatRoomsShow = (~body: postChatRoomsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsShowRequestSchema)
  
  fetch(
    ~url="/chat/rooms/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatRoomsShowResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChatRoomsUpdateRequest = {
  roomId: string,
  name: option<string>,
  description: option<string>,
}

let postChatRoomsUpdateRequestSchema = S.object(s => {
    roomId: s.field("roomId", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string->S.max(256)), None),
    description: s.fieldOr("description", S.nullableAsOption(S.string->S.max(1024)), None),
  })

type postChatRoomsUpdateResponse = KokonectLinkComponentSchemas.ChatRoom.t

let postChatRoomsUpdateResponseSchema = KokonectLinkComponentSchemas.ChatRoom.schema

/**
 * chat/rooms/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:chat*
 */
let postChatRoomsUpdate = (~body: postChatRoomsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChatRoomsUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChatRoomsUpdateRequestSchema)
  
  fetch(
    ~url="/chat/rooms/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChatRoomsUpdateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}
