// SPDX-License-Identifier: MIT
// kokonect-link API for meta
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type postAdminMetaResponse = {
  cacheRemoteFiles: bool,
  cacheRemoteSensitiveFiles: bool,
  emailRequiredForSignup: bool,
  enableHcaptcha: bool,
  hcaptchaSiteKey: JSON.t,
  enableMcaptcha: bool,
  mcaptchaSiteKey: JSON.t,
  mcaptchaInstanceUrl: JSON.t,
  enableRecaptcha: bool,
  recaptchaSiteKey: JSON.t,
  enableTurnstile: bool,
  turnstileSiteKey: JSON.t,
  enableTestcaptcha: bool,
  googleAnalyticsMeasurementId: JSON.t,
  swPublickey: JSON.t,
  mascotImageUrl: JSON.t,
  bannerUrl: JSON.t,
  serverErrorImageUrl: JSON.t,
  infoImageUrl: JSON.t,
  notFoundImageUrl: JSON.t,
  youBlockedImageUrl: JSON.t,
  iconUrl: JSON.t,
  app192IconUrl: JSON.t,
  app512IconUrl: JSON.t,
  enableEmail: bool,
  enableServiceWorker: bool,
  translatorAvailable: bool,
  translatorType: JSON.t,
  silencedHosts: option<array<string>>,
  mediaSilencedHosts: array<string>,
  pinnedUsers: array<string>,
  hiddenTags: array<string>,
  blockedHosts: array<string>,
  sensitiveWords: array<string>,
  prohibitedWords: array<string>,
  prohibitedWordsForNameOfUser: array<string>,
  bannedEmailDomains: option<array<string>>,
  preservedUsernames: array<string>,
  hcaptchaSecretKey: JSON.t,
  mcaptchaSecretKey: JSON.t,
  recaptchaSecretKey: JSON.t,
  turnstileSecretKey: JSON.t,
  sensitiveMediaDetection: string,
  sensitiveMediaDetectionSensitivity: string,
  setSensitiveFlagAutomatically: bool,
  enableSensitiveMediaDetectionForVideos: bool,
  proxyAccountId: string,
  email: JSON.t,
  smtpSecure: bool,
  smtpHost: JSON.t,
  smtpPort: JSON.t,
  smtpUser: JSON.t,
  smtpPass: JSON.t,
  swPrivateKey: JSON.t,
  useObjectStorage: bool,
  objectStorageBaseUrl: JSON.t,
  objectStorageBucket: JSON.t,
  objectStoragePrefix: JSON.t,
  objectStorageEndpoint: JSON.t,
  objectStorageRegion: JSON.t,
  objectStoragePort: JSON.t,
  objectStorageAccessKey: JSON.t,
  objectStorageSecretKey: JSON.t,
  objectStorageUseSSL: bool,
  objectStorageUseProxy: bool,
  objectStorageSetPublicRead: bool,
  useRemoteObjectStorage: bool,
  remoteObjectStorageBaseUrl: JSON.t,
  remoteObjectStorageBucket: JSON.t,
  remoteObjectStoragePrefix: JSON.t,
  remoteObjectStorageEndpoint: JSON.t,
  remoteObjectStorageRegion: JSON.t,
  remoteObjectStoragePort: JSON.t,
  remoteObjectStorageAccessKey: JSON.t,
  remoteObjectStorageSecretKey: JSON.t,
  remoteObjectStorageUseSSL: bool,
  remoteObjectStorageUseProxy: bool,
  remoteObjectStorageSetPublicRead: bool,
  enableIpLogging: bool,
  enableActiveEmailValidation: bool,
  enableVerifymailApi: bool,
  verifymailAuthKey: JSON.t,
  enableTruemailApi: bool,
  truemailInstance: JSON.t,
  truemailAuthKey: JSON.t,
  enableChartsForRemoteUser: bool,
  enableChartsForFederatedInstances: bool,
  enableStatsForFederatedInstances: bool,
  enableServerMachineStats: bool,
  enableIdenticonGeneration: bool,
  manifestJsonOverride: string,
  policies: JSON.t,
  enableFanoutTimeline: bool,
  enableFanoutTimelineDbFallback: bool,
  perLocalUserUserTimelineCacheMax: float,
  perRemoteUserUserTimelineCacheMax: float,
  perUserHomeTimelineCacheMax: float,
  perUserListTimelineCacheMax: float,
  enableReactionsBuffering: bool,
  notesPerOneAd: float,
  backgroundImageUrl: JSON.t,
  deeplAuthKey: JSON.t,
  deeplIsPro: bool,
  ctav3SaKey: JSON.t,
  ctav3ProjectId: JSON.t,
  ctav3Location: JSON.t,
  ctav3Model: JSON.t,
  ctav3Glossary: JSON.t,
  libreTranslateEndPoint: JSON.t,
  libreTranslateApiKey: JSON.t,
  defaultDarkTheme: JSON.t,
  defaultLightTheme: JSON.t,
  clientOptions: JSON.t,
  description: JSON.t,
  disableRegistration: bool,
  impressumUrl: JSON.t,
  maintainerEmail: JSON.t,
  maintainerName: JSON.t,
  name: JSON.t,
  shortName: JSON.t,
  objectStorageS3ForcePathStyle: bool,
  remoteObjectStorageS3ForcePathStyle: bool,
  privacyPolicyUrl: JSON.t,
  inquiryUrl: JSON.t,
  repositoryUrl: JSON.t,
  feedbackUrl: JSON.t,
  summalyProxy: JSON.t,
  themeColor: JSON.t,
  tosUrl: JSON.t,
  uri: string,
  version: string,
  urlPreviewEnabled: bool,
  urlPreviewAllowRedirect: bool,
  urlPreviewTimeout: float,
  urlPreviewMaximumContentLength: float,
  urlPreviewRequireContentLength: bool,
  urlPreviewUserAgent: JSON.t,
  urlPreviewSummaryProxyUrl: JSON.t,
  federation: string,
  federationHosts: array<string>,
  deliverSuspendedSoftware: array<JSON.t>,
  singleUserMode: bool,
  ugcVisibilityForVisitor: string,
  proxyRemoteFiles: bool,
  signToActivityPubGet: bool,
  allowExternalApRedirect: bool,
  enableRemoteNotesCleaning: bool,
  remoteNotesCleaningExpiryDaysForEachNotes: float,
  remoteNotesCleaningMaxProcessingDurationInMinutes: float,
  doNotSendNotificationEmailsForAbuseReport: bool,
  emailToReceiveAbuseReport: JSON.t,
  enableReceivePrerelease: bool,
  skipVersion: bool,
  skipCherryPickVersion: option<JSON.t>,
  trustedLinkUrlPatterns: array<string>,
  customSplashText: array<string>,
  disableRegistrationWhenInactive: bool,
  disablePublicNoteWhenInactive: bool,
  moderatorInactivityLimitDays: float,
  bubbleInstances: array<string>,
  customRobotsTxt: JSON.t,
  showRoleBadgesOfRemoteUsers: bool,
}

let postAdminMetaResponseSchema = S.object(s => {
    cacheRemoteFiles: s.field("cacheRemoteFiles", S.bool),
    cacheRemoteSensitiveFiles: s.field("cacheRemoteSensitiveFiles", S.bool),
    emailRequiredForSignup: s.field("emailRequiredForSignup", S.bool),
    enableHcaptcha: s.field("enableHcaptcha", S.bool),
    hcaptchaSiteKey: s.field("hcaptchaSiteKey", S.json),
    enableMcaptcha: s.field("enableMcaptcha", S.bool),
    mcaptchaSiteKey: s.field("mcaptchaSiteKey", S.json),
    mcaptchaInstanceUrl: s.field("mcaptchaInstanceUrl", S.json),
    enableRecaptcha: s.field("enableRecaptcha", S.bool),
    recaptchaSiteKey: s.field("recaptchaSiteKey", S.json),
    enableTurnstile: s.field("enableTurnstile", S.bool),
    turnstileSiteKey: s.field("turnstileSiteKey", S.json),
    enableTestcaptcha: s.field("enableTestcaptcha", S.bool),
    googleAnalyticsMeasurementId: s.field("googleAnalyticsMeasurementId", S.json),
    swPublickey: s.field("swPublickey", S.json),
    mascotImageUrl: s.field("mascotImageUrl", S.json),
    bannerUrl: s.field("bannerUrl", S.json),
    serverErrorImageUrl: s.field("serverErrorImageUrl", S.json),
    infoImageUrl: s.field("infoImageUrl", S.json),
    notFoundImageUrl: s.field("notFoundImageUrl", S.json),
    youBlockedImageUrl: s.field("youBlockedImageUrl", S.json),
    iconUrl: s.field("iconUrl", S.json),
    app192IconUrl: s.field("app192IconUrl", S.json),
    app512IconUrl: s.field("app512IconUrl", S.json),
    enableEmail: s.field("enableEmail", S.bool),
    enableServiceWorker: s.field("enableServiceWorker", S.bool),
    translatorAvailable: s.field("translatorAvailable", S.bool),
    translatorType: s.field("translatorType", S.json),
    silencedHosts: s.fieldOr("silencedHosts", S.nullableAsOption(S.array(S.string)), None),
    mediaSilencedHosts: s.field("mediaSilencedHosts", S.array(S.string)),
    pinnedUsers: s.field("pinnedUsers", S.array(S.string)),
    hiddenTags: s.field("hiddenTags", S.array(S.string)),
    blockedHosts: s.field("blockedHosts", S.array(S.string)),
    sensitiveWords: s.field("sensitiveWords", S.array(S.string)),
    prohibitedWords: s.field("prohibitedWords", S.array(S.string)),
    prohibitedWordsForNameOfUser: s.field("prohibitedWordsForNameOfUser", S.array(S.string)),
    bannedEmailDomains: s.fieldOr("bannedEmailDomains", S.nullableAsOption(S.array(S.string)), None),
    preservedUsernames: s.field("preservedUsernames", S.array(S.string)),
    hcaptchaSecretKey: s.field("hcaptchaSecretKey", S.json),
    mcaptchaSecretKey: s.field("mcaptchaSecretKey", S.json),
    recaptchaSecretKey: s.field("recaptchaSecretKey", S.json),
    turnstileSecretKey: s.field("turnstileSecretKey", S.json),
    sensitiveMediaDetection: s.field("sensitiveMediaDetection", S.string),
    sensitiveMediaDetectionSensitivity: s.field("sensitiveMediaDetectionSensitivity", S.string),
    setSensitiveFlagAutomatically: s.field("setSensitiveFlagAutomatically", S.bool),
    enableSensitiveMediaDetectionForVideos: s.field("enableSensitiveMediaDetectionForVideos", S.bool),
    proxyAccountId: s.field("proxyAccountId", S.string),
    email: s.field("email", S.json),
    smtpSecure: s.field("smtpSecure", S.bool),
    smtpHost: s.field("smtpHost", S.json),
    smtpPort: s.field("smtpPort", S.json),
    smtpUser: s.field("smtpUser", S.json),
    smtpPass: s.field("smtpPass", S.json),
    swPrivateKey: s.field("swPrivateKey", S.json),
    useObjectStorage: s.field("useObjectStorage", S.bool),
    objectStorageBaseUrl: s.field("objectStorageBaseUrl", S.json),
    objectStorageBucket: s.field("objectStorageBucket", S.json),
    objectStoragePrefix: s.field("objectStoragePrefix", S.json),
    objectStorageEndpoint: s.field("objectStorageEndpoint", S.json),
    objectStorageRegion: s.field("objectStorageRegion", S.json),
    objectStoragePort: s.field("objectStoragePort", S.json),
    objectStorageAccessKey: s.field("objectStorageAccessKey", S.json),
    objectStorageSecretKey: s.field("objectStorageSecretKey", S.json),
    objectStorageUseSSL: s.field("objectStorageUseSSL", S.bool),
    objectStorageUseProxy: s.field("objectStorageUseProxy", S.bool),
    objectStorageSetPublicRead: s.field("objectStorageSetPublicRead", S.bool),
    useRemoteObjectStorage: s.field("useRemoteObjectStorage", S.bool),
    remoteObjectStorageBaseUrl: s.field("remoteObjectStorageBaseUrl", S.json),
    remoteObjectStorageBucket: s.field("remoteObjectStorageBucket", S.json),
    remoteObjectStoragePrefix: s.field("remoteObjectStoragePrefix", S.json),
    remoteObjectStorageEndpoint: s.field("remoteObjectStorageEndpoint", S.json),
    remoteObjectStorageRegion: s.field("remoteObjectStorageRegion", S.json),
    remoteObjectStoragePort: s.field("remoteObjectStoragePort", S.json),
    remoteObjectStorageAccessKey: s.field("remoteObjectStorageAccessKey", S.json),
    remoteObjectStorageSecretKey: s.field("remoteObjectStorageSecretKey", S.json),
    remoteObjectStorageUseSSL: s.field("remoteObjectStorageUseSSL", S.bool),
    remoteObjectStorageUseProxy: s.field("remoteObjectStorageUseProxy", S.bool),
    remoteObjectStorageSetPublicRead: s.field("remoteObjectStorageSetPublicRead", S.bool),
    enableIpLogging: s.field("enableIpLogging", S.bool),
    enableActiveEmailValidation: s.field("enableActiveEmailValidation", S.bool),
    enableVerifymailApi: s.field("enableVerifymailApi", S.bool),
    verifymailAuthKey: s.field("verifymailAuthKey", S.json),
    enableTruemailApi: s.field("enableTruemailApi", S.bool),
    truemailInstance: s.field("truemailInstance", S.json),
    truemailAuthKey: s.field("truemailAuthKey", S.json),
    enableChartsForRemoteUser: s.field("enableChartsForRemoteUser", S.bool),
    enableChartsForFederatedInstances: s.field("enableChartsForFederatedInstances", S.bool),
    enableStatsForFederatedInstances: s.field("enableStatsForFederatedInstances", S.bool),
    enableServerMachineStats: s.field("enableServerMachineStats", S.bool),
    enableIdenticonGeneration: s.field("enableIdenticonGeneration", S.bool),
    manifestJsonOverride: s.field("manifestJsonOverride", S.string),
    policies: s.field("policies", S.json),
    enableFanoutTimeline: s.field("enableFanoutTimeline", S.bool),
    enableFanoutTimelineDbFallback: s.field("enableFanoutTimelineDbFallback", S.bool),
    perLocalUserUserTimelineCacheMax: s.field("perLocalUserUserTimelineCacheMax", S.float),
    perRemoteUserUserTimelineCacheMax: s.field("perRemoteUserUserTimelineCacheMax", S.float),
    perUserHomeTimelineCacheMax: s.field("perUserHomeTimelineCacheMax", S.float),
    perUserListTimelineCacheMax: s.field("perUserListTimelineCacheMax", S.float),
    enableReactionsBuffering: s.field("enableReactionsBuffering", S.bool),
    notesPerOneAd: s.field("notesPerOneAd", S.float),
    backgroundImageUrl: s.field("backgroundImageUrl", S.json),
    deeplAuthKey: s.field("deeplAuthKey", S.json),
    deeplIsPro: s.field("deeplIsPro", S.bool),
    ctav3SaKey: s.field("ctav3SaKey", S.json),
    ctav3ProjectId: s.field("ctav3ProjectId", S.json),
    ctav3Location: s.field("ctav3Location", S.json),
    ctav3Model: s.field("ctav3Model", S.json),
    ctav3Glossary: s.field("ctav3Glossary", S.json),
    libreTranslateEndPoint: s.field("libreTranslateEndPoint", S.json),
    libreTranslateApiKey: s.field("libreTranslateApiKey", S.json),
    defaultDarkTheme: s.field("defaultDarkTheme", S.json),
    defaultLightTheme: s.field("defaultLightTheme", S.json),
    clientOptions: s.field("clientOptions", S.json),
    description: s.field("description", S.json),
    disableRegistration: s.field("disableRegistration", S.bool),
    impressumUrl: s.field("impressumUrl", S.json),
    maintainerEmail: s.field("maintainerEmail", S.json),
    maintainerName: s.field("maintainerName", S.json),
    name: s.field("name", S.json),
    shortName: s.field("shortName", S.json),
    objectStorageS3ForcePathStyle: s.field("objectStorageS3ForcePathStyle", S.bool),
    remoteObjectStorageS3ForcePathStyle: s.field("remoteObjectStorageS3ForcePathStyle", S.bool),
    privacyPolicyUrl: s.field("privacyPolicyUrl", S.json),
    inquiryUrl: s.field("inquiryUrl", S.json),
    repositoryUrl: s.field("repositoryUrl", S.json),
    feedbackUrl: s.field("feedbackUrl", S.json),
    summalyProxy: s.field("summalyProxy", S.json),
    themeColor: s.field("themeColor", S.json),
    tosUrl: s.field("tosUrl", S.json),
    uri: s.field("uri", S.string),
    version: s.field("version", S.string),
    urlPreviewEnabled: s.field("urlPreviewEnabled", S.bool),
    urlPreviewAllowRedirect: s.field("urlPreviewAllowRedirect", S.bool),
    urlPreviewTimeout: s.field("urlPreviewTimeout", S.float),
    urlPreviewMaximumContentLength: s.field("urlPreviewMaximumContentLength", S.float),
    urlPreviewRequireContentLength: s.field("urlPreviewRequireContentLength", S.bool),
    urlPreviewUserAgent: s.field("urlPreviewUserAgent", S.json),
    urlPreviewSummaryProxyUrl: s.field("urlPreviewSummaryProxyUrl", S.json),
    federation: s.field("federation", S.string),
    federationHosts: s.field("federationHosts", S.array(S.string)),
    deliverSuspendedSoftware: s.field("deliverSuspendedSoftware", S.array(S.json)),
    singleUserMode: s.field("singleUserMode", S.bool),
    ugcVisibilityForVisitor: s.field("ugcVisibilityForVisitor", S.string),
    proxyRemoteFiles: s.field("proxyRemoteFiles", S.bool),
    signToActivityPubGet: s.field("signToActivityPubGet", S.bool),
    allowExternalApRedirect: s.field("allowExternalApRedirect", S.bool),
    enableRemoteNotesCleaning: s.field("enableRemoteNotesCleaning", S.bool),
    remoteNotesCleaningExpiryDaysForEachNotes: s.field("remoteNotesCleaningExpiryDaysForEachNotes", S.float),
    remoteNotesCleaningMaxProcessingDurationInMinutes: s.field("remoteNotesCleaningMaxProcessingDurationInMinutes", S.float),
    doNotSendNotificationEmailsForAbuseReport: s.field("doNotSendNotificationEmailsForAbuseReport", S.bool),
    emailToReceiveAbuseReport: s.field("emailToReceiveAbuseReport", S.json),
    enableReceivePrerelease: s.field("enableReceivePrerelease", S.bool),
    skipVersion: s.field("skipVersion", S.bool),
    skipCherryPickVersion: s.fieldOr("skipCherryPickVersion", S.nullableAsOption(S.json), None),
    trustedLinkUrlPatterns: s.field("trustedLinkUrlPatterns", S.array(S.string)),
    customSplashText: s.field("customSplashText", S.array(S.string)),
    disableRegistrationWhenInactive: s.field("disableRegistrationWhenInactive", S.bool),
    disablePublicNoteWhenInactive: s.field("disablePublicNoteWhenInactive", S.bool),
    moderatorInactivityLimitDays: s.field("moderatorInactivityLimitDays", S.float),
    bubbleInstances: s.field("bubbleInstances", S.array(S.string)),
    customRobotsTxt: s.field("customRobotsTxt", S.json),
    showRoleBadgesOfRemoteUsers: s.field("showRoleBadgesOfRemoteUsers", S.bool),
  })

/**
 * admin/meta
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:meta*
 */
let postAdminMeta = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminMetaResponse> => {
  
  fetch(
    ~url="/admin/meta",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postAdminMetaResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postAnnouncementsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  isActive: option<bool>,
}

let postAnnouncementsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    isActive: s.fieldOr("isActive", S.nullableAsOption(S.bool), None),
  })

type postAnnouncementsResponse = array<KokonectLinkComponentSchemas.Announcement.t>

let postAnnouncementsResponseSchema = S.array(KokonectLinkComponentSchemas.Announcement.schema)

/**
 * announcements
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAnnouncements = (~body: postAnnouncementsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementsRequestSchema)
  
  fetch(
    ~url="/announcements",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postAnnouncementsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postAnnouncementsShowRequest = {
  announcementId: string,
}

let postAnnouncementsShowRequestSchema = S.object(s => {
    announcementId: s.field("announcementId", S.string),
  })

type postAnnouncementsShowResponse = KokonectLinkComponentSchemas.Announcement.t

let postAnnouncementsShowResponseSchema = KokonectLinkComponentSchemas.Announcement.schema

/**
 * announcements/show
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAnnouncementsShow = (~body: postAnnouncementsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementsShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementsShowRequestSchema)
  
  fetch(
    ~url="/announcements/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postAnnouncementsShowResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getEmojiRequest = {
  name: string,
}

let getEmojiRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type getEmojiResponse = KokonectLinkComponentSchemas.EmojiDetailed.t

let getEmojiResponseSchema = KokonectLinkComponentSchemas.EmojiDetailed.schema

/**
 * emoji
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getEmoji = (~body: getEmojiRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getEmojiResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getEmojiRequestSchema)
  
  fetch(
    ~url="/emoji",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getEmojiResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postEmojiRequest = {
  name: string,
}

let postEmojiRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type postEmojiResponse = KokonectLinkComponentSchemas.EmojiDetailed.t

let postEmojiResponseSchema = KokonectLinkComponentSchemas.EmojiDetailed.schema

/**
 * emoji
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEmoji = (~body: postEmojiRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEmojiResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postEmojiRequestSchema)
  
  fetch(
    ~url="/emoji",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postEmojiResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postInviteCreateResponse = KokonectLinkComponentSchemas.InviteCode.t

let postInviteCreateResponseSchema = KokonectLinkComponentSchemas.InviteCode.schema

/**
 * invite/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:invite-codes*
 */
let postInviteCreate = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteCreateResponse> => {
  
  fetch(
    ~url="/invite/create",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postInviteCreateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postInviteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postInviteListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postInviteListResponse = array<KokonectLinkComponentSchemas.InviteCode.t>

let postInviteListResponseSchema = S.array(KokonectLinkComponentSchemas.InviteCode.schema)

/**
 * invite/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:invite-codes*
 */
let postInviteList = (~body: postInviteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postInviteListRequestSchema)
  
  fetch(
    ~url="/invite/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postInviteListResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getServerInfoResponse = {
  machine: string,
  cpu: JSON.t,
  mem: JSON.t,
  fs: JSON.t,
}

let getServerInfoResponseSchema = S.object(s => {
    machine: s.field("machine", S.string),
    cpu: s.field("cpu", S.json),
    mem: s.field("mem", S.json),
    fs: s.field("fs", S.json),
  })

/**
 * server-info
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getServerInfo = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getServerInfoResponse> => {
  
  fetch(
    ~url="/server-info",
    ~method_="GET",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getServerInfoResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postServerInfoResponse = {
  machine: string,
  cpu: JSON.t,
  mem: JSON.t,
  fs: JSON.t,
}

let postServerInfoResponseSchema = S.object(s => {
    machine: s.field("machine", S.string),
    cpu: s.field("cpu", S.json),
    mem: s.field("mem", S.json),
    fs: s.field("fs", S.json),
  })

/**
 * server-info
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postServerInfo = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postServerInfoResponse> => {
  
  fetch(
    ~url="/server-info",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postServerInfoResponseSchema)
  validatedResponse
->Promise.resolve
  })
}
