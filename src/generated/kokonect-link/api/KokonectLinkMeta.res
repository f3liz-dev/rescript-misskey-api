// kokonect-link API for meta
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postAdminMetaResponse_1 = {
  software: string,
  versionRange: string,
}

type postAdminMetaResponse = {
  cacheRemoteFiles: bool,
  cacheRemoteSensitiveFiles: bool,
  emailRequiredForSignup: bool,
  enableHcaptcha: bool,
  hcaptchaSiteKey: option<string>,
  enableMcaptcha: bool,
  mcaptchaSiteKey: option<string>,
  mcaptchaInstanceUrl: option<string>,
  enableRecaptcha: bool,
  recaptchaSiteKey: option<string>,
  enableTurnstile: bool,
  turnstileSiteKey: option<string>,
  enableTestcaptcha: bool,
  googleAnalyticsMeasurementId: option<string>,
  swPublickey: option<string>,
  mascotImageUrl: option<string>,
  bannerUrl: option<string>,
  serverErrorImageUrl: option<string>,
  infoImageUrl: option<string>,
  notFoundImageUrl: option<string>,
  youBlockedImageUrl: option<string>,
  iconUrl: option<string>,
  @as("app192IconUrl") app192iconUrl: option<string>,
  @as("app512IconUrl") app512iconUrl: option<string>,
  enableEmail: bool,
  enableServiceWorker: bool,
  translatorAvailable: bool,
  translatorType: option<string>,
  silencedHosts: option<array<string>>,
  mediaSilencedHosts: array<string>,
  pinnedUsers: array<string>,
  hiddenTags: array<string>,
  blockedHosts: array<string>,
  sensitiveWords: array<string>,
  prohibitedWords: array<string>,
  prohibitedWordsForNameOfUser: array<string>,
  bannedEmailDomains: option<array<string>>,
  preservedUsernames: array<string>,
  hcaptchaSecretKey: option<string>,
  mcaptchaSecretKey: option<string>,
  recaptchaSecretKey: option<string>,
  turnstileSecretKey: option<string>,
  sensitiveMediaDetection: string,
  sensitiveMediaDetectionSensitivity: string,
  setSensitiveFlagAutomatically: bool,
  enableSensitiveMediaDetectionForVideos: bool,
  proxyAccountId: string,
  email: option<string>,
  smtpSecure: bool,
  smtpHost: option<string>,
  smtpPort: option<float>,
  smtpUser: option<string>,
  smtpPass: option<string>,
  swPrivateKey: option<string>,
  useObjectStorage: bool,
  objectStorageBaseUrl: option<string>,
  objectStorageBucket: option<string>,
  objectStoragePrefix: option<string>,
  objectStorageEndpoint: option<string>,
  objectStorageRegion: option<string>,
  objectStoragePort: option<float>,
  objectStorageAccessKey: option<string>,
  objectStorageSecretKey: option<string>,
  @as("objectStorageUseSSL") objectStorageUseSsl: bool,
  objectStorageUseProxy: bool,
  objectStorageSetPublicRead: bool,
  useRemoteObjectStorage: bool,
  remoteObjectStorageBaseUrl: option<string>,
  remoteObjectStorageBucket: option<string>,
  remoteObjectStoragePrefix: option<string>,
  remoteObjectStorageEndpoint: option<string>,
  remoteObjectStorageRegion: option<string>,
  remoteObjectStoragePort: option<float>,
  remoteObjectStorageAccessKey: option<string>,
  remoteObjectStorageSecretKey: option<string>,
  @as("remoteObjectStorageUseSSL") remoteObjectStorageUseSsl: bool,
  remoteObjectStorageUseProxy: bool,
  remoteObjectStorageSetPublicRead: bool,
  enableIpLogging: bool,
  enableActiveEmailValidation: bool,
  enableVerifymailApi: bool,
  verifymailAuthKey: option<string>,
  enableTruemailApi: bool,
  truemailInstance: option<string>,
  truemailAuthKey: option<string>,
  enableChartsForRemoteUser: bool,
  enableChartsForFederatedInstances: bool,
  enableStatsForFederatedInstances: bool,
  enableServerMachineStats: bool,
  enableIdenticonGeneration: bool,
  manifestJsonOverride: string,
  policies: dict<JSON.t>,
  enableFanoutTimeline: bool,
  enableFanoutTimelineDbFallback: bool,
  perLocalUserUserTimelineCacheMax: float,
  perRemoteUserUserTimelineCacheMax: float,
  perUserHomeTimelineCacheMax: float,
  perUserListTimelineCacheMax: float,
  enableReactionsBuffering: bool,
  notesPerOneAd: float,
  backgroundImageUrl: option<string>,
  deeplAuthKey: option<string>,
  deeplIsPro: bool,
  @as("ctav3SaKey") ctav3saKey: option<string>,
  @as("ctav3ProjectId") ctav3projectId: option<string>,
  @as("ctav3Location") ctav3location: option<string>,
  @as("ctav3Model") ctav3model: option<string>,
  @as("ctav3Glossary") ctav3glossary: option<string>,
  libreTranslateEndPoint: option<string>,
  libreTranslateApiKey: option<string>,
  defaultDarkTheme: option<string>,
  defaultLightTheme: option<string>,
  clientOptions: dict<JSON.t>,
  description: option<string>,
  disableRegistration: bool,
  impressumUrl: option<string>,
  maintainerEmail: option<string>,
  maintainerName: option<string>,
  name: option<string>,
  shortName: option<string>,
  @as("objectStorageS3ForcePathStyle") objectStorageS3forcePathStyle: bool,
  @as("remoteObjectStorageS3ForcePathStyle") remoteObjectStorageS3forcePathStyle: bool,
  privacyPolicyUrl: option<string>,
  inquiryUrl: option<string>,
  repositoryUrl: option<string>,
  feedbackUrl: option<string>,
  summalyProxy: option<string>,
  themeColor: option<string>,
  tosUrl: option<string>,
  uri: string,
  version: string,
  urlPreviewEnabled: bool,
  urlPreviewAllowRedirect: bool,
  urlPreviewTimeout: float,
  urlPreviewMaximumContentLength: float,
  urlPreviewRequireContentLength: bool,
  urlPreviewUserAgent: option<string>,
  urlPreviewSummaryProxyUrl: option<string>,
  federation: string,
  federationHosts: array<string>,
  deliverSuspendedSoftware: array<postAdminMetaResponse_1>,
  singleUserMode: bool,
  ugcVisibilityForVisitor: string,
  proxyRemoteFiles: bool,
  signToActivityPubGet: bool,
  allowExternalApRedirect: bool,
  enableRemoteNotesCleaning: bool,
  remoteNotesCleaningExpiryDaysForEachNotes: float,
  remoteNotesCleaningMaxProcessingDurationInMinutes: float,
  doNotSendNotificationEmailsForAbuseReport: bool,
  emailToReceiveAbuseReport: option<string>,
  enableReceivePrerelease: bool,
  skipVersion: bool,
  skipCherryPickVersion: option<string>,
  trustedLinkUrlPatterns: array<string>,
  customSplashText: array<string>,
  disableRegistrationWhenInactive: bool,
  disablePublicNoteWhenInactive: bool,
  moderatorInactivityLimitDays: float,
  bubbleInstances: array<string>,
  customRobotsTxt: option<string>,
  showRoleBadgesOfRemoteUsers: bool,
}

let postAdminMetaResponse_1Schema = S.object(s => {
    software: s.field("software", S.string),
    versionRange: s.field("versionRange", S.string),
  })

let postAdminMetaResponseSchema = S.object(s => {
    cacheRemoteFiles: s.field("cacheRemoteFiles", S.bool),
    cacheRemoteSensitiveFiles: s.field("cacheRemoteSensitiveFiles", S.bool),
    emailRequiredForSignup: s.field("emailRequiredForSignup", S.bool),
    enableHcaptcha: s.field("enableHcaptcha", S.bool),
    hcaptchaSiteKey: s.field("hcaptchaSiteKey", S.nullableAsOption(S.string)),
    enableMcaptcha: s.field("enableMcaptcha", S.bool),
    mcaptchaSiteKey: s.field("mcaptchaSiteKey", S.nullableAsOption(S.string)),
    mcaptchaInstanceUrl: s.field("mcaptchaInstanceUrl", S.nullableAsOption(S.string)),
    enableRecaptcha: s.field("enableRecaptcha", S.bool),
    recaptchaSiteKey: s.field("recaptchaSiteKey", S.nullableAsOption(S.string)),
    enableTurnstile: s.field("enableTurnstile", S.bool),
    turnstileSiteKey: s.field("turnstileSiteKey", S.nullableAsOption(S.string)),
    enableTestcaptcha: s.field("enableTestcaptcha", S.bool),
    googleAnalyticsMeasurementId: s.field("googleAnalyticsMeasurementId", S.nullableAsOption(S.string)),
    swPublickey: s.field("swPublickey", S.nullableAsOption(S.string)),
    mascotImageUrl: s.field("mascotImageUrl", S.nullableAsOption(S.string)),
    bannerUrl: s.field("bannerUrl", S.nullableAsOption(S.string)),
    serverErrorImageUrl: s.field("serverErrorImageUrl", S.nullableAsOption(S.string)),
    infoImageUrl: s.field("infoImageUrl", S.nullableAsOption(S.string)),
    notFoundImageUrl: s.field("notFoundImageUrl", S.nullableAsOption(S.string)),
    youBlockedImageUrl: s.field("youBlockedImageUrl", S.nullableAsOption(S.string)),
    iconUrl: s.field("iconUrl", S.nullableAsOption(S.string)),
    app192iconUrl: s.field("app192IconUrl", S.nullableAsOption(S.string)),
    app512iconUrl: s.field("app512IconUrl", S.nullableAsOption(S.string)),
    enableEmail: s.field("enableEmail", S.bool),
    enableServiceWorker: s.field("enableServiceWorker", S.bool),
    translatorAvailable: s.field("translatorAvailable", S.bool),
    translatorType: s.field("translatorType", S.nullableAsOption(S.string)),
    silencedHosts: s.fieldOr("silencedHosts", S.nullableAsOption(S.array(S.string)), None),
    mediaSilencedHosts: s.field("mediaSilencedHosts", S.array(S.string)),
    pinnedUsers: s.field("pinnedUsers", S.array(S.string)),
    hiddenTags: s.field("hiddenTags", S.array(S.string)),
    blockedHosts: s.field("blockedHosts", S.array(S.string)),
    sensitiveWords: s.field("sensitiveWords", S.array(S.string)),
    prohibitedWords: s.field("prohibitedWords", S.array(S.string)),
    prohibitedWordsForNameOfUser: s.field("prohibitedWordsForNameOfUser", S.array(S.string)),
    bannedEmailDomains: s.fieldOr("bannedEmailDomains", S.nullableAsOption(S.array(S.string)), None),
    preservedUsernames: s.field("preservedUsernames", S.array(S.string)),
    hcaptchaSecretKey: s.field("hcaptchaSecretKey", S.nullableAsOption(S.string)),
    mcaptchaSecretKey: s.field("mcaptchaSecretKey", S.nullableAsOption(S.string)),
    recaptchaSecretKey: s.field("recaptchaSecretKey", S.nullableAsOption(S.string)),
    turnstileSecretKey: s.field("turnstileSecretKey", S.nullableAsOption(S.string)),
    sensitiveMediaDetection: s.field("sensitiveMediaDetection", S.string),
    sensitiveMediaDetectionSensitivity: s.field("sensitiveMediaDetectionSensitivity", S.string),
    setSensitiveFlagAutomatically: s.field("setSensitiveFlagAutomatically", S.bool),
    enableSensitiveMediaDetectionForVideos: s.field("enableSensitiveMediaDetectionForVideos", S.bool),
    proxyAccountId: s.field("proxyAccountId", S.string),
    email: s.field("email", S.nullableAsOption(S.string)),
    smtpSecure: s.field("smtpSecure", S.bool),
    smtpHost: s.field("smtpHost", S.nullableAsOption(S.string)),
    smtpPort: s.field("smtpPort", S.nullableAsOption(S.float)),
    smtpUser: s.field("smtpUser", S.nullableAsOption(S.string)),
    smtpPass: s.field("smtpPass", S.nullableAsOption(S.string)),
    swPrivateKey: s.field("swPrivateKey", S.nullableAsOption(S.string)),
    useObjectStorage: s.field("useObjectStorage", S.bool),
    objectStorageBaseUrl: s.field("objectStorageBaseUrl", S.nullableAsOption(S.string)),
    objectStorageBucket: s.field("objectStorageBucket", S.nullableAsOption(S.string)),
    objectStoragePrefix: s.field("objectStoragePrefix", S.nullableAsOption(S.string)),
    objectStorageEndpoint: s.field("objectStorageEndpoint", S.nullableAsOption(S.string)),
    objectStorageRegion: s.field("objectStorageRegion", S.nullableAsOption(S.string)),
    objectStoragePort: s.field("objectStoragePort", S.nullableAsOption(S.float)),
    objectStorageAccessKey: s.field("objectStorageAccessKey", S.nullableAsOption(S.string)),
    objectStorageSecretKey: s.field("objectStorageSecretKey", S.nullableAsOption(S.string)),
    objectStorageUseSsl: s.field("objectStorageUseSSL", S.bool),
    objectStorageUseProxy: s.field("objectStorageUseProxy", S.bool),
    objectStorageSetPublicRead: s.field("objectStorageSetPublicRead", S.bool),
    useRemoteObjectStorage: s.field("useRemoteObjectStorage", S.bool),
    remoteObjectStorageBaseUrl: s.field("remoteObjectStorageBaseUrl", S.nullableAsOption(S.string)),
    remoteObjectStorageBucket: s.field("remoteObjectStorageBucket", S.nullableAsOption(S.string)),
    remoteObjectStoragePrefix: s.field("remoteObjectStoragePrefix", S.nullableAsOption(S.string)),
    remoteObjectStorageEndpoint: s.field("remoteObjectStorageEndpoint", S.nullableAsOption(S.string)),
    remoteObjectStorageRegion: s.field("remoteObjectStorageRegion", S.nullableAsOption(S.string)),
    remoteObjectStoragePort: s.field("remoteObjectStoragePort", S.nullableAsOption(S.float)),
    remoteObjectStorageAccessKey: s.field("remoteObjectStorageAccessKey", S.nullableAsOption(S.string)),
    remoteObjectStorageSecretKey: s.field("remoteObjectStorageSecretKey", S.nullableAsOption(S.string)),
    remoteObjectStorageUseSsl: s.field("remoteObjectStorageUseSSL", S.bool),
    remoteObjectStorageUseProxy: s.field("remoteObjectStorageUseProxy", S.bool),
    remoteObjectStorageSetPublicRead: s.field("remoteObjectStorageSetPublicRead", S.bool),
    enableIpLogging: s.field("enableIpLogging", S.bool),
    enableActiveEmailValidation: s.field("enableActiveEmailValidation", S.bool),
    enableVerifymailApi: s.field("enableVerifymailApi", S.bool),
    verifymailAuthKey: s.field("verifymailAuthKey", S.nullableAsOption(S.string)),
    enableTruemailApi: s.field("enableTruemailApi", S.bool),
    truemailInstance: s.field("truemailInstance", S.nullableAsOption(S.string)),
    truemailAuthKey: s.field("truemailAuthKey", S.nullableAsOption(S.string)),
    enableChartsForRemoteUser: s.field("enableChartsForRemoteUser", S.bool),
    enableChartsForFederatedInstances: s.field("enableChartsForFederatedInstances", S.bool),
    enableStatsForFederatedInstances: s.field("enableStatsForFederatedInstances", S.bool),
    enableServerMachineStats: s.field("enableServerMachineStats", S.bool),
    enableIdenticonGeneration: s.field("enableIdenticonGeneration", S.bool),
    manifestJsonOverride: s.field("manifestJsonOverride", S.string),
    policies: s.field("policies", S.dict(S.json)),
    enableFanoutTimeline: s.field("enableFanoutTimeline", S.bool),
    enableFanoutTimelineDbFallback: s.field("enableFanoutTimelineDbFallback", S.bool),
    perLocalUserUserTimelineCacheMax: s.field("perLocalUserUserTimelineCacheMax", S.float),
    perRemoteUserUserTimelineCacheMax: s.field("perRemoteUserUserTimelineCacheMax", S.float),
    perUserHomeTimelineCacheMax: s.field("perUserHomeTimelineCacheMax", S.float),
    perUserListTimelineCacheMax: s.field("perUserListTimelineCacheMax", S.float),
    enableReactionsBuffering: s.field("enableReactionsBuffering", S.bool),
    notesPerOneAd: s.field("notesPerOneAd", S.float),
    backgroundImageUrl: s.field("backgroundImageUrl", S.nullableAsOption(S.string)),
    deeplAuthKey: s.field("deeplAuthKey", S.nullableAsOption(S.string)),
    deeplIsPro: s.field("deeplIsPro", S.bool),
    ctav3saKey: s.field("ctav3SaKey", S.nullableAsOption(S.string)),
    ctav3projectId: s.field("ctav3ProjectId", S.nullableAsOption(S.string)),
    ctav3location: s.field("ctav3Location", S.nullableAsOption(S.string)),
    ctav3model: s.field("ctav3Model", S.nullableAsOption(S.string)),
    ctav3glossary: s.field("ctav3Glossary", S.nullableAsOption(S.string)),
    libreTranslateEndPoint: s.field("libreTranslateEndPoint", S.nullableAsOption(S.string)),
    libreTranslateApiKey: s.field("libreTranslateApiKey", S.nullableAsOption(S.string)),
    defaultDarkTheme: s.field("defaultDarkTheme", S.nullableAsOption(S.string)),
    defaultLightTheme: s.field("defaultLightTheme", S.nullableAsOption(S.string)),
    clientOptions: s.field("clientOptions", S.dict(S.json)),
    description: s.field("description", S.nullableAsOption(S.string)),
    disableRegistration: s.field("disableRegistration", S.bool),
    impressumUrl: s.field("impressumUrl", S.nullableAsOption(S.string)),
    maintainerEmail: s.field("maintainerEmail", S.nullableAsOption(S.string)),
    maintainerName: s.field("maintainerName", S.nullableAsOption(S.string)),
    name: s.field("name", S.nullableAsOption(S.string)),
    shortName: s.field("shortName", S.nullableAsOption(S.string)),
    objectStorageS3forcePathStyle: s.field("objectStorageS3ForcePathStyle", S.bool),
    remoteObjectStorageS3forcePathStyle: s.field("remoteObjectStorageS3ForcePathStyle", S.bool),
    privacyPolicyUrl: s.field("privacyPolicyUrl", S.nullableAsOption(S.string)),
    inquiryUrl: s.field("inquiryUrl", S.nullableAsOption(S.string)),
    repositoryUrl: s.field("repositoryUrl", S.nullableAsOption(S.string)),
    feedbackUrl: s.field("feedbackUrl", S.nullableAsOption(S.string)),
    summalyProxy: s.field("summalyProxy", S.nullableAsOption(S.string)),
    themeColor: s.field("themeColor", S.nullableAsOption(S.string)),
    tosUrl: s.field("tosUrl", S.nullableAsOption(S.string)),
    uri: s.field("uri", S.string),
    version: s.field("version", S.string),
    urlPreviewEnabled: s.field("urlPreviewEnabled", S.bool),
    urlPreviewAllowRedirect: s.field("urlPreviewAllowRedirect", S.bool),
    urlPreviewTimeout: s.field("urlPreviewTimeout", S.float),
    urlPreviewMaximumContentLength: s.field("urlPreviewMaximumContentLength", S.float),
    urlPreviewRequireContentLength: s.field("urlPreviewRequireContentLength", S.bool),
    urlPreviewUserAgent: s.field("urlPreviewUserAgent", S.nullableAsOption(S.string)),
    urlPreviewSummaryProxyUrl: s.field("urlPreviewSummaryProxyUrl", S.nullableAsOption(S.string)),
    federation: s.field("federation", S.string),
    federationHosts: s.field("federationHosts", S.array(S.string)),
    deliverSuspendedSoftware: s.field("deliverSuspendedSoftware", S.array(postAdminMetaResponse_1Schema)),
    singleUserMode: s.field("singleUserMode", S.bool),
    ugcVisibilityForVisitor: s.field("ugcVisibilityForVisitor", S.string),
    proxyRemoteFiles: s.field("proxyRemoteFiles", S.bool),
    signToActivityPubGet: s.field("signToActivityPubGet", S.bool),
    allowExternalApRedirect: s.field("allowExternalApRedirect", S.bool),
    enableRemoteNotesCleaning: s.field("enableRemoteNotesCleaning", S.bool),
    remoteNotesCleaningExpiryDaysForEachNotes: s.field("remoteNotesCleaningExpiryDaysForEachNotes", S.float),
    remoteNotesCleaningMaxProcessingDurationInMinutes: s.field("remoteNotesCleaningMaxProcessingDurationInMinutes", S.float),
    doNotSendNotificationEmailsForAbuseReport: s.field("doNotSendNotificationEmailsForAbuseReport", S.bool),
    emailToReceiveAbuseReport: s.field("emailToReceiveAbuseReport", S.nullableAsOption(S.string)),
    enableReceivePrerelease: s.field("enableReceivePrerelease", S.bool),
    skipVersion: s.field("skipVersion", S.bool),
    skipCherryPickVersion: s.fieldOr("skipCherryPickVersion", S.nullableAsOption(S.string), None),
    trustedLinkUrlPatterns: s.field("trustedLinkUrlPatterns", S.array(S.string)),
    customSplashText: s.field("customSplashText", S.array(S.string)),
    disableRegistrationWhenInactive: s.field("disableRegistrationWhenInactive", S.bool),
    disablePublicNoteWhenInactive: s.field("disablePublicNoteWhenInactive", S.bool),
    moderatorInactivityLimitDays: s.field("moderatorInactivityLimitDays", S.float),
    bubbleInstances: s.field("bubbleInstances", S.array(S.string)),
    customRobotsTxt: s.field("customRobotsTxt", S.nullableAsOption(S.string)),
    showRoleBadgesOfRemoteUsers: s.field("showRoleBadgesOfRemoteUsers", S.bool),
  })

/**
 * admin/meta
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:meta*
 */
let postAdminMeta = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminMetaResponse> => {

  fetch(
    ~url="/admin/meta",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminMetaResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAnnouncementsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  isActive: option<bool>,
}

let postAnnouncementsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    isActive: s.fieldOr("isActive", S.nullableAsOption(S.bool), None),
  })

type postAnnouncementsResponse = array<KokonectLinkComponentSchemas.Announcement.t>

let postAnnouncementsResponseSchema = S.array(KokonectLinkComponentSchemas.Announcement.schema)

/**
 * announcements
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAnnouncements = (~body: postAnnouncementsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementsRequestSchema)
  fetch(
    ~url="/announcements",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAnnouncementsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAnnouncementsShowRequest = {
  announcementId: string,
}

let postAnnouncementsShowRequestSchema = S.object(s => {
    announcementId: s.field("announcementId", S.string),
  })

type postAnnouncementsShowResponse = KokonectLinkComponentSchemas.Announcement.t

let postAnnouncementsShowResponseSchema = KokonectLinkComponentSchemas.Announcement.schema

/**
 * announcements/show
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAnnouncementsShow = (~body: postAnnouncementsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementsShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementsShowRequestSchema)
  fetch(
    ~url="/announcements/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAnnouncementsShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type getEmojiRequest = {
  name: string,
}

let getEmojiRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type getEmojiResponse = KokonectLinkComponentSchemas.EmojiDetailed.t

let getEmojiResponseSchema = KokonectLinkComponentSchemas.EmojiDetailed.schema

/**
 * emoji
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getEmoji = (~body: getEmojiRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getEmojiResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getEmojiRequestSchema)
  fetch(
    ~url="/emoji",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getEmojiResponseSchema)
  value
    ->Promise.resolve
  })
}

type postEmojiRequest = {
  name: string,
}

let postEmojiRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type postEmojiResponse = KokonectLinkComponentSchemas.EmojiDetailed.t

let postEmojiResponseSchema = KokonectLinkComponentSchemas.EmojiDetailed.schema

/**
 * emoji
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEmoji = (~body: postEmojiRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEmojiResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postEmojiRequestSchema)
  fetch(
    ~url="/emoji",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postEmojiResponseSchema)
  value
    ->Promise.resolve
  })
}

type postInviteCreateResponse = KokonectLinkComponentSchemas.InviteCode.t

let postInviteCreateResponseSchema = KokonectLinkComponentSchemas.InviteCode.schema

/**
 * invite/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:invite-codes*
 */
let postInviteCreate = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteCreateResponse> => {

  fetch(
    ~url="/invite/create",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postInviteCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postInviteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postInviteListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postInviteListResponse = array<KokonectLinkComponentSchemas.InviteCode.t>

let postInviteListResponseSchema = S.array(KokonectLinkComponentSchemas.InviteCode.schema)

/**
 * invite/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:invite-codes*
 */
let postInviteList = (~body: postInviteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postInviteListRequestSchema)
  fetch(
    ~url="/invite/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postInviteListResponseSchema)
  value
    ->Promise.resolve
  })
}

type getServerInfoResponse_3 = {
  total: float,
  used: float,
}

type getServerInfoResponse_2 = {
  total: float,
}

type getServerInfoResponse_1 = {
  model: string,
  cores: float,
}

type getServerInfoResponse = {
  machine: string,
  cpu: getServerInfoResponse_1,
  mem: getServerInfoResponse_2,
  fs: getServerInfoResponse_3,
}

let getServerInfoResponse_3Schema = S.object(s => {
    total: s.field("total", S.float),
    used: s.field("used", S.float),
  })

let getServerInfoResponse_2Schema = S.object(s => {
    total: s.field("total", S.float),
  })

let getServerInfoResponse_1Schema = S.object(s => {
    model: s.field("model", S.string),
    cores: s.field("cores", S.float),
  })

let getServerInfoResponseSchema = S.object(s => {
    machine: s.field("machine", S.string),
    cpu: s.field("cpu", getServerInfoResponse_1Schema),
    mem: s.field("mem", getServerInfoResponse_2Schema),
    fs: s.field("fs", getServerInfoResponse_3Schema),
  })

/**
 * server-info
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getServerInfo = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getServerInfoResponse> => {

  fetch(
    ~url="/server-info",
    ~method_="GET",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getServerInfoResponseSchema)
  value
    ->Promise.resolve
  })
}

type postServerInfoResponse_3 = {
  total: float,
  used: float,
}

type postServerInfoResponse_2 = {
  total: float,
}

type postServerInfoResponse_1 = {
  model: string,
  cores: float,
}

type postServerInfoResponse = {
  machine: string,
  cpu: postServerInfoResponse_1,
  mem: postServerInfoResponse_2,
  fs: postServerInfoResponse_3,
}

let postServerInfoResponse_3Schema = S.object(s => {
    total: s.field("total", S.float),
    used: s.field("used", S.float),
  })

let postServerInfoResponse_2Schema = S.object(s => {
    total: s.field("total", S.float),
  })

let postServerInfoResponse_1Schema = S.object(s => {
    model: s.field("model", S.string),
    cores: s.field("cores", S.float),
  })

let postServerInfoResponseSchema = S.object(s => {
    machine: s.field("machine", S.string),
    cpu: s.field("cpu", postServerInfoResponse_1Schema),
    mem: s.field("mem", postServerInfoResponse_2Schema),
    fs: s.field("fs", postServerInfoResponse_3Schema),
  })

/**
 * server-info
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postServerInfo = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postServerInfoResponse> => {

  fetch(
    ~url="/server-info",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postServerInfoResponseSchema)
  value
    ->Promise.resolve
  })
}
