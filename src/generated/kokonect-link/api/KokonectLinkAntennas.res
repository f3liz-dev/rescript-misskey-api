// SPDX-License-Identifier: MIT
// kokonect-link API for antennas
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type postAntennasCreateRequest = {
  name: string,
  src: string,
  userListId: option<JSON.t>,
  userGroupId: option<JSON.t>,
  keywords: array<array<string>>,
  excludeKeywords: array<array<string>>,
  users: array<string>,
  caseSensitive: bool,
  localOnly: option<bool>,
  excludeBots: option<bool>,
  withReplies: bool,
  withFile: bool,
  excludeNotesInSensitiveChannel: option<bool>,
}

let postAntennasCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
    src: s.field("src", S.string),
    userListId: s.fieldOr("userListId", S.nullableAsOption(S.json), None),
    userGroupId: s.fieldOr("userGroupId", S.nullableAsOption(S.json), None),
    keywords: s.field("keywords", S.array(S.array(S.string))),
    excludeKeywords: s.field("excludeKeywords", S.array(S.array(S.string))),
    users: s.field("users", S.array(S.string)),
    caseSensitive: s.field("caseSensitive", S.bool),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    excludeBots: s.fieldOr("excludeBots", S.nullableAsOption(S.bool), None),
    withReplies: s.field("withReplies", S.bool),
    withFile: s.field("withFile", S.bool),
    excludeNotesInSensitiveChannel: s.fieldOr("excludeNotesInSensitiveChannel", S.nullableAsOption(S.bool), None),
  })

type postAntennasCreateResponse = KokonectLinkComponentSchemas.Antenna.t

let postAntennasCreateResponseSchema = KokonectLinkComponentSchemas.Antenna.schema

/**
 * antennas/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postAntennasCreate = (~body: postAntennasCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasCreateRequestSchema)
  
  fetch(
    ~url="/antennas/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postAntennasCreateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postAntennasShowRequest = {
  antennaId: string,
}

let postAntennasShowRequestSchema = S.object(s => {
    antennaId: s.field("antennaId", S.string),
  })

type postAntennasShowResponse = KokonectLinkComponentSchemas.Antenna.t

let postAntennasShowResponseSchema = KokonectLinkComponentSchemas.Antenna.schema

/**
 * antennas/show
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postAntennasShow = (~body: postAntennasShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasShowRequestSchema)
  
  fetch(
    ~url="/antennas/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postAntennasShowResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postAntennasUpdateRequest = {
  antennaId: string,
  name: option<string>,
  src: option<string>,
  userListId: option<JSON.t>,
  userGroupId: option<JSON.t>,
  keywords: option<array<array<string>>>,
  excludeKeywords: option<array<array<string>>>,
  users: option<array<string>>,
  caseSensitive: option<bool>,
  localOnly: option<bool>,
  excludeBots: option<bool>,
  withReplies: option<bool>,
  withFile: option<bool>,
  excludeNotesInSensitiveChannel: option<bool>,
}

let postAntennasUpdateRequestSchema = S.object(s => {
    antennaId: s.field("antennaId", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.max(100)), None),
    src: s.fieldOr("src", S.nullableAsOption(S.string), None),
    userListId: s.fieldOr("userListId", S.nullableAsOption(S.json), None),
    userGroupId: s.fieldOr("userGroupId", S.nullableAsOption(S.json), None),
    keywords: s.fieldOr("keywords", S.nullableAsOption(S.array(S.array(S.string))), None),
    excludeKeywords: s.fieldOr("excludeKeywords", S.nullableAsOption(S.array(S.array(S.string))), None),
    users: s.fieldOr("users", S.nullableAsOption(S.array(S.string)), None),
    caseSensitive: s.fieldOr("caseSensitive", S.nullableAsOption(S.bool), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    excludeBots: s.fieldOr("excludeBots", S.nullableAsOption(S.bool), None),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
    withFile: s.fieldOr("withFile", S.nullableAsOption(S.bool), None),
    excludeNotesInSensitiveChannel: s.fieldOr("excludeNotesInSensitiveChannel", S.nullableAsOption(S.bool), None),
  })

type postAntennasUpdateResponse = KokonectLinkComponentSchemas.Antenna.t

let postAntennasUpdateResponseSchema = KokonectLinkComponentSchemas.Antenna.schema

/**
 * antennas/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postAntennasUpdate = (~body: postAntennasUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasUpdateRequestSchema)
  
  fetch(
    ~url="/antennas/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postAntennasUpdateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}
