// kokonect-link API for admin
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postAdminAbuseReportNotificationRecipientCreateRequest = {
  isActive: bool,
  name: string,
  @as("method") method_: string,
  userId: option<string>,
  systemWebhookId: option<string>,
}

let postAdminAbuseReportNotificationRecipientCreateRequestSchema = S.object(s => {
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    method_: s.field("method", S.string),
    userId: s.field("userId", S.option(S.string)),
    systemWebhookId: s.field("systemWebhookId", S.option(S.string)),
  })

type postAdminAbuseReportNotificationRecipientCreateResponse = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientCreateResponseSchema = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.schema

/**
admin/abuse-report/notification-recipient/create

No description provided.

**Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
*/
let postAdminAbuseReportNotificationRecipientCreate = async (~body: postAdminAbuseReportNotificationRecipientCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportNotificationRecipientCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report/notification-recipient/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientCreateResponseSchema)
}

type postAdminAbuseReportNotificationRecipientShowRequest = {
  id: string,
}

let postAdminAbuseReportNotificationRecipientShowRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAbuseReportNotificationRecipientShowResponse = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientShowResponseSchema = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.schema

/**
admin/abuse-report/notification-recipient/show

No description provided.

**Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *read:admin:abuse-report:notification-recipient*
*/
let postAdminAbuseReportNotificationRecipientShow = async (~body: postAdminAbuseReportNotificationRecipientShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportNotificationRecipientShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientShowRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report/notification-recipient/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientShowResponseSchema)
}

type postAdminAbuseReportNotificationRecipientUpdateRequest = {
  id: string,
  isActive: bool,
  name: string,
  @as("method") method_: string,
  userId: option<string>,
  systemWebhookId: option<string>,
}

let postAdminAbuseReportNotificationRecipientUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    method_: s.field("method", S.string),
    userId: s.field("userId", S.option(S.string)),
    systemWebhookId: s.field("systemWebhookId", S.option(S.string)),
  })

type postAdminAbuseReportNotificationRecipientUpdateResponse = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientUpdateResponseSchema = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.schema

/**
admin/abuse-report/notification-recipient/update

No description provided.

**Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
*/
let postAdminAbuseReportNotificationRecipientUpdate = async (~body: postAdminAbuseReportNotificationRecipientUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportNotificationRecipientUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report/notification-recipient/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientUpdateResponseSchema)
}

type postAdminAbuseUserReportsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  state: option<string>,
  reporterOrigin: option<string>,
  targetUserOrigin: option<string>,
}

let postAdminAbuseUserReportsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    state: s.field("state", S.option(S.string)),
    reporterOrigin: s.field("reporterOrigin", S.option(S.string)),
    targetUserOrigin: s.field("targetUserOrigin", S.option(S.string)),
  })

type postAdminAbuseUserReportsResponse_1 = {
  id: string,
  createdAt: string,
  comment: string,
  resolved: bool,
  reporterId: string,
  targetUserId: string,
  assigneeId: option<string>,
  reporter: KokonectLinkComponentSchemas.UserDetailedNotMe.t,
  targetUser: KokonectLinkComponentSchemas.UserDetailedNotMe.t,
  assignee: option<KokonectLinkComponentSchemas.UserDetailedNotMe.t>,
  forwarded: bool,
  resolvedAs: option<string>,
  moderationNote: string,
}

type postAdminAbuseUserReportsResponse = array<postAdminAbuseUserReportsResponse_1>

let postAdminAbuseUserReportsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    comment: s.field("comment", S.string),
    resolved: s.field("resolved", S.bool),
    reporterId: s.field("reporterId", S.string),
    targetUserId: s.field("targetUserId", S.string),
    assigneeId: s.field("assigneeId", S.nullableAsOption(S.string)),
    reporter: s.field("reporter", KokonectLinkComponentSchemas.UserDetailedNotMe.schema),
    targetUser: s.field("targetUser", KokonectLinkComponentSchemas.UserDetailedNotMe.schema),
    assignee: s.field("assignee", S.nullableAsOption(KokonectLinkComponentSchemas.UserDetailedNotMe.schema)),
    forwarded: s.field("forwarded", S.bool),
    resolvedAs: s.field("resolvedAs", S.nullableAsOption(S.string)),
    moderationNote: s.field("moderationNote", S.string),
  })

let postAdminAbuseUserReportsResponseSchema = S.array(postAdminAbuseUserReportsResponse_1Schema)

/**
admin/abuse-user-reports

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:abuse-user-reports*
*/
let postAdminAbuseUserReports = async (~body: postAdminAbuseUserReportsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseUserReportsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseUserReportsRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-user-reports",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAbuseUserReportsResponseSchema)
}

type postAdminAccountsCreateRequest = {
  username: string,
  password: string,
  setupPassword: option<string>,
}

let postAdminAccountsCreateRequestSchema = S.object(s => {
    username: s.field("username", S.string->S.pattern(/^\w{1,20}$/)),
    password: s.field("password", S.string->S.min(1)),
    setupPassword: s.field("setupPassword", S.option(S.string)),
  })

type postAdminAccountsCreateResponse = {
  token: string,
}

let postAdminAccountsCreateResponseSchema = S.object(s => {
    token: s.field("token", S.string),
  })

/**
admin/accounts/create

No description provided.

**Credential required**: *No*
*/
let postAdminAccountsCreate = async (~body: postAdminAccountsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAccountsCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/accounts/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAccountsCreateResponseSchema)
}

type postAdminAccountsDeleteRequest = {
  userId: string,
}

let postAdminAccountsDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminAccountsDeleteResponse = unit

/**
admin/accounts/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:account*
*/
let postAdminAccountsDelete = async (~body: postAdminAccountsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAccountsDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/accounts/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAccountsFindByEmailRequest = {
  email: string,
}

let postAdminAccountsFindByEmailRequestSchema = S.object(s => {
    email: s.field("email", S.string),
  })

type postAdminAccountsFindByEmailResponse = KokonectLinkComponentSchemas.UserDetailedNotMe.t

let postAdminAccountsFindByEmailResponseSchema = KokonectLinkComponentSchemas.UserDetailedNotMe.schema

/**
admin/accounts/find-by-email

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:account*
*/
let postAdminAccountsFindByEmail = async (~body: postAdminAccountsFindByEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAccountsFindByEmailResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsFindByEmailRequestSchema)
  let response = await fetch(
    ~url="/admin/accounts/find-by-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAccountsFindByEmailResponseSchema)
}

type postAdminAdCreateRequest = {
  url: string,
  memo: string,
  place: string,
  priority: string,
  ratio: int,
  expiresAt: int,
  startsAt: int,
  imageUrl: string,
  dayOfWeek: int,
  isSensitive: option<bool>,
}

let postAdminAdCreateRequestSchema = S.object(s => {
    url: s.field("url", S.string->S.min(1)),
    memo: s.field("memo", S.string),
    place: s.field("place", S.string),
    priority: s.field("priority", S.string),
    ratio: s.field("ratio", S.int),
    expiresAt: s.field("expiresAt", S.int),
    startsAt: s.field("startsAt", S.int),
    imageUrl: s.field("imageUrl", S.string->S.min(1)),
    dayOfWeek: s.field("dayOfWeek", S.int),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
  })

type postAdminAdCreateResponse = KokonectLinkComponentSchemas.Ad.t

let postAdminAdCreateResponseSchema = KokonectLinkComponentSchemas.Ad.schema

/**
admin/ad/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:ad*
*/
let postAdminAdCreate = async (~body: postAdminAdCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAdCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/ad/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAdCreateResponseSchema)
}

type postAdminAdListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  publishing: option<bool>,
}

let postAdminAdListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    publishing: s.field("publishing", S.option(S.bool)),
  })

type postAdminAdListResponse = array<KokonectLinkComponentSchemas.Ad.t>

let postAdminAdListResponseSchema = S.array(KokonectLinkComponentSchemas.Ad.schema)

/**
admin/ad/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:ad*
*/
let postAdminAdList = async (~body: postAdminAdListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAdListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdListRequestSchema)
  let response = await fetch(
    ~url="/admin/ad/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAdListResponseSchema)
}

type postAdminAnnouncementsCreateRequest = {
  title: string,
  text: string,
  imageUrl: option<string>,
  icon: option<string>,
  display: option<string>,
  forExistingUsers: option<bool>,
  silence: option<bool>,
  needConfirmationToRead: option<bool>,
  userId: option<string>,
}

let postAdminAnnouncementsCreateRequestSchema = S.object(s => {
    title: s.field("title", S.string->S.min(1)),
    text: s.field("text", S.string->S.min(1)),
    imageUrl: s.field("imageUrl", S.nullableAsOption(S.string->S.min(0))),
    icon: s.field("icon", S.option(S.string)),
    display: s.field("display", S.option(S.string)),
    forExistingUsers: s.field("forExistingUsers", S.option(S.bool)),
    silence: s.field("silence", S.option(S.bool)),
    needConfirmationToRead: s.field("needConfirmationToRead", S.option(S.bool)),
    userId: s.field("userId", S.option(S.string)),
  })

type postAdminAnnouncementsCreateResponse = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  title: string,
  text: string,
  imageUrl: option<string>,
}

let postAdminAnnouncementsCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    title: s.field("title", S.string),
    text: s.field("text", S.string),
    imageUrl: s.field("imageUrl", S.nullableAsOption(S.string)),
  })

/**
admin/announcements/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:announcements*
*/
let postAdminAnnouncementsCreate = async (~body: postAdminAnnouncementsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAnnouncementsCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/announcements/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAnnouncementsCreateResponseSchema)
}

type postAdminAnnouncementsListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  userId: option<string>,
  status: option<string>,
}

let postAdminAnnouncementsListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    userId: s.field("userId", S.option(S.string)),
    status: s.field("status", S.option(S.string)),
  })

type postAdminAnnouncementsListResponse_1 = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  text: string,
  title: string,
  icon: option<string>,
  display: string,
  isActive: bool,
  forExistingUsers: bool,
  silence: bool,
  needConfirmationToRead: bool,
  userId: option<string>,
  imageUrl: option<string>,
  reads: float,
}

type postAdminAnnouncementsListResponse = array<postAdminAnnouncementsListResponse_1>

let postAdminAnnouncementsListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    text: s.field("text", S.string),
    title: s.field("title", S.string),
    icon: s.field("icon", S.nullableAsOption(S.string)),
    display: s.field("display", S.string),
    isActive: s.field("isActive", S.bool),
    forExistingUsers: s.field("forExistingUsers", S.bool),
    silence: s.field("silence", S.bool),
    needConfirmationToRead: s.field("needConfirmationToRead", S.bool),
    userId: s.field("userId", S.nullableAsOption(S.string)),
    imageUrl: s.field("imageUrl", S.nullableAsOption(S.string)),
    reads: s.field("reads", S.float),
  })

let postAdminAnnouncementsListResponseSchema = S.array(postAdminAnnouncementsListResponse_1Schema)

/**
admin/announcements/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:announcements*
*/
let postAdminAnnouncementsList = async (~body: postAdminAnnouncementsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAnnouncementsListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsListRequestSchema)
  let response = await fetch(
    ~url="/admin/announcements/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAnnouncementsListResponseSchema)
}

type postAdminAnnouncementsUpdateRequest = {
  id: string,
  title: option<string>,
  text: option<string>,
  imageUrl: option<string>,
  icon: option<string>,
  display: option<string>,
  forExistingUsers: option<bool>,
  silence: option<bool>,
  needConfirmationToRead: option<bool>,
  isActive: option<bool>,
}

let postAdminAnnouncementsUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    title: s.field("title", S.option(S.string->S.min(1))),
    text: s.field("text", S.option(S.string->S.min(1))),
    imageUrl: s.field("imageUrl", S.option(S.string->S.min(0))),
    icon: s.field("icon", S.option(S.string)),
    display: s.field("display", S.option(S.string)),
    forExistingUsers: s.field("forExistingUsers", S.option(S.bool)),
    silence: s.field("silence", S.option(S.bool)),
    needConfirmationToRead: s.field("needConfirmationToRead", S.option(S.bool)),
    isActive: s.field("isActive", S.option(S.bool)),
  })

type postAdminAnnouncementsUpdateResponse = unit

/**
admin/announcements/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:announcements*
*/
let postAdminAnnouncementsUpdate = async (~body: postAdminAnnouncementsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAnnouncementsUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/announcements/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAvatarDecorationsCopyRequest = {
  decorationId: string,
}

let postAdminAvatarDecorationsCopyRequestSchema = S.object(s => {
    decorationId: s.field("decorationId", S.string),
  })

type postAdminAvatarDecorationsCopyResponse = {
  id: string,
}

let postAdminAvatarDecorationsCopyResponseSchema = S.object(s => {
    id: s.field("id", S.string),
  })

/**
admin/avatar-decorations/copy

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:avatar-decorations*
*/
let postAdminAvatarDecorationsCopy = async (~body: postAdminAvatarDecorationsCopyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAvatarDecorationsCopyResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsCopyRequestSchema)
  let response = await fetch(
    ~url="/admin/avatar-decorations/copy",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAvatarDecorationsCopyResponseSchema)
}

type postAdminAvatarDecorationsListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  userId: option<string>,
}

let postAdminAvatarDecorationsListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    userId: s.field("userId", S.option(S.string)),
  })

type postAdminAvatarDecorationsListResponse_1 = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  name: string,
  description: string,
  url: string,
  roleIdsThatCanBeUsedThisDecoration: array<string>,
}

type postAdminAvatarDecorationsListResponse = array<postAdminAvatarDecorationsListResponse_1>

let postAdminAvatarDecorationsListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    url: s.field("url", S.string),
    roleIdsThatCanBeUsedThisDecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.array(S.string)),
  })

let postAdminAvatarDecorationsListResponseSchema = S.array(postAdminAvatarDecorationsListResponse_1Schema)

/**
admin/avatar-decorations/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:avatar-decorations*
*/
let postAdminAvatarDecorationsList = async (~body: postAdminAvatarDecorationsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAvatarDecorationsListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsListRequestSchema)
  let response = await fetch(
    ~url="/admin/avatar-decorations/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAvatarDecorationsListResponseSchema)
}

type postAdminAvatarDecorationsListRemoteRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  userId: option<string>,
}

let postAdminAvatarDecorationsListRemoteRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    userId: s.field("userId", S.option(S.string)),
  })

type postAdminAvatarDecorationsListRemoteResponse_1 = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  name: string,
  description: string,
  url: string,
  roleIdsThatCanBeUsedThisDecoration: array<string>,
}

type postAdminAvatarDecorationsListRemoteResponse = array<postAdminAvatarDecorationsListRemoteResponse_1>

let postAdminAvatarDecorationsListRemoteResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    url: s.field("url", S.string),
    roleIdsThatCanBeUsedThisDecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.array(S.string)),
  })

let postAdminAvatarDecorationsListRemoteResponseSchema = S.array(postAdminAvatarDecorationsListRemoteResponse_1Schema)

/**
admin/avatar-decorations/list-remote

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:avatar-decorations*
*/
let postAdminAvatarDecorationsListRemote = async (~body: postAdminAvatarDecorationsListRemoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAvatarDecorationsListRemoteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsListRemoteRequestSchema)
  let response = await fetch(
    ~url="/admin/avatar-decorations/list-remote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAvatarDecorationsListRemoteResponseSchema)
}

type postAdminDeleteAccountRequest = {
  userId: string,
}

let postAdminDeleteAccountRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminDeleteAccountResponse = unit

/**
admin/delete-account

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:delete-account*
*/
let postAdminDeleteAccount = async (~body: postAdminDeleteAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminDeleteAccountResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDeleteAccountRequestSchema)
  let response = await fetch(
    ~url="/admin/delete-account",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminDeleteAllFilesOfAUserRequest = {
  userId: string,
}

let postAdminDeleteAllFilesOfAUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminDeleteAllFilesOfAUserResponse = unit

/**
admin/delete-all-files-of-a-user

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:delete-all-files-of-a-user*
*/
let postAdminDeleteAllFilesOfAUser = async (~body: postAdminDeleteAllFilesOfAUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminDeleteAllFilesOfAUserResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDeleteAllFilesOfAUserRequestSchema)
  let response = await fetch(
    ~url="/admin/delete-all-files-of-a-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminDriveFilesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  userId: option<string>,
  @as("type") type_: option<string>,
  origin: option<string>,
  hostname: option<string>,
}

let postAdminDriveFilesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    userId: s.field("userId", S.option(S.string)),
    type_: s.field("type", S.option(S.string->S.pattern(/^[a-zA-Z0-9\/\*-]+$/))),
    origin: s.field("origin", S.option(S.string)),
    hostname: s.field("hostname", S.option(S.string)),
  })

type postAdminDriveFilesResponse = array<KokonectLinkComponentSchemas.DriveFile.t>

let postAdminDriveFilesResponseSchema = S.array(KokonectLinkComponentSchemas.DriveFile.schema)

/**
admin/drive/files

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:drive*
*/
let postAdminDriveFiles = async (~body: postAdminDriveFilesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminDriveFilesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveFilesRequestSchema)
  let response = await fetch(
    ~url="/admin/drive/files",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminDriveFilesResponseSchema)
}

type postAdminDriveShowFileRequest_1 = {
  url: string,
}

type postAdminDriveShowFileRequest = postAdminDriveShowFileRequest_1

let postAdminDriveShowFileRequest_1Schema = S.object(s => {
    url: s.field("url", S.string),
  })

let postAdminDriveShowFileRequestSchema = postAdminDriveShowFileRequest_1Schema

type postAdminDriveShowFileResponse_1 = {
  width: option<float>,
  height: option<float>,
  orientation: option<float>,
  avgColor: option<string>,
}

type postAdminDriveShowFileResponse = {
  id: string,
  createdAt: string,
  userId: option<string>,
  userHost: option<string>,
  md5: string,
  name: string,
  @as("type") type_: string,
  size: float,
  comment: option<string>,
  blurhash: option<string>,
  properties: postAdminDriveShowFileResponse_1,
  storedInternal: option<bool>,
  url: option<string>,
  thumbnailUrl: option<string>,
  webpublicUrl: option<string>,
  accessKey: option<string>,
  thumbnailAccessKey: option<string>,
  webpublicAccessKey: option<string>,
  uri: option<string>,
  src: option<string>,
  folderId: option<string>,
  isSensitive: bool,
  isLink: bool,
  maybeSensitive: bool,
  maybePorn: bool,
  requestIp: option<string>,
  requestHeaders: option<dict<JSON.t>>,
}

let postAdminDriveShowFileResponse_1Schema = S.object(s => {
    width: s.field("width", S.option(S.float)),
    height: s.field("height", S.option(S.float)),
    orientation: s.field("orientation", S.option(S.float)),
    avgColor: s.field("avgColor", S.option(S.string)),
  })

let postAdminDriveShowFileResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.nullableAsOption(S.string)),
    userHost: s.field("userHost", S.nullableAsOption(S.string)),
    md5: s.field("md5", S.string),
    name: s.field("name", S.string),
    type_: s.field("type", S.string),
    size: s.field("size", S.float),
    comment: s.field("comment", S.nullableAsOption(S.string)),
    blurhash: s.field("blurhash", S.nullableAsOption(S.string)),
    properties: s.field("properties", postAdminDriveShowFileResponse_1Schema),
    storedInternal: s.field("storedInternal", S.nullableAsOption(S.bool)),
    url: s.field("url", S.nullableAsOption(S.string)),
    thumbnailUrl: s.field("thumbnailUrl", S.nullableAsOption(S.string)),
    webpublicUrl: s.field("webpublicUrl", S.nullableAsOption(S.string)),
    accessKey: s.field("accessKey", S.nullableAsOption(S.string)),
    thumbnailAccessKey: s.field("thumbnailAccessKey", S.nullableAsOption(S.string)),
    webpublicAccessKey: s.field("webpublicAccessKey", S.nullableAsOption(S.string)),
    uri: s.field("uri", S.nullableAsOption(S.string)),
    src: s.field("src", S.nullableAsOption(S.string)),
    folderId: s.field("folderId", S.nullableAsOption(S.string)),
    isSensitive: s.field("isSensitive", S.bool),
    isLink: s.field("isLink", S.bool),
    maybeSensitive: s.field("maybeSensitive", S.bool),
    maybePorn: s.field("maybePorn", S.bool),
    requestIp: s.field("requestIp", S.nullableAsOption(S.string)),
    requestHeaders: s.field("requestHeaders", S.nullableAsOption(S.dict(S.json))),
  })

/**
admin/drive/show-file

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:drive*
*/
let postAdminDriveShowFile = async (~body: postAdminDriveShowFileRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminDriveShowFileResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveShowFileRequestSchema)
  let response = await fetch(
    ~url="/admin/drive/show-file",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminDriveShowFileResponseSchema)
}

type postAdminEmojiAddRequest = {
  name: string,
  fileId: string,
  category: option<string>,
  aliases: option<array<string>>,
  license: option<string>,
  isSensitive: option<bool>,
  localOnly: option<bool>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
}

let postAdminEmojiAddRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.pattern(/^[a-zA-Z0-9_]+$/)),
    fileId: s.field("fileId", S.string),
    category: s.field("category", S.option(S.string)),
    aliases: s.field("aliases", S.option(S.array(S.string))),
    license: s.field("license", S.option(S.string)),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
    localOnly: s.field("localOnly", S.option(S.bool)),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.field("roleIdsThatCanBeUsedThisEmojiAsReaction", S.option(S.array(S.string))),
  })

type postAdminEmojiAddResponse = KokonectLinkComponentSchemas.EmojiDetailed.t

let postAdminEmojiAddResponseSchema = KokonectLinkComponentSchemas.EmojiDetailed.schema

/**
admin/emoji/add

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiAdd = async (~body: postAdminEmojiAddRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiAddResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiAddRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/add",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminEmojiAddResponseSchema)
}

type postAdminEmojiListRequest = {
  query: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postAdminEmojiListRequestSchema = S.object(s => {
    query: s.field("query", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postAdminEmojiListResponse_1 = {
  id: string,
  aliases: array<string>,
  name: string,
  category: option<string>,
  host: option<string>,
  url: string,
}

type postAdminEmojiListResponse = array<postAdminEmojiListResponse_1>

let postAdminEmojiListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.nullableAsOption(S.string)),
    host: s.field("host", S.nullableAsOption(S.string)),
    url: s.field("url", S.string),
  })

let postAdminEmojiListResponseSchema = S.array(postAdminEmojiListResponse_1Schema)

/**
admin/emoji/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:emoji*
*/
let postAdminEmojiList = async (~body: postAdminEmojiListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiListRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminEmojiListResponseSchema)
}

type postAdminEmojiListRemoteRequest = {
  query: option<string>,
  host: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postAdminEmojiListRemoteRequestSchema = S.object(s => {
    query: s.field("query", S.option(S.string)),
    host: s.field("host", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postAdminEmojiListRemoteResponse_1 = {
  id: string,
  aliases: array<string>,
  name: string,
  category: option<string>,
  host: option<string>,
  url: string,
}

type postAdminEmojiListRemoteResponse = array<postAdminEmojiListRemoteResponse_1>

let postAdminEmojiListRemoteResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.nullableAsOption(S.string)),
    host: s.field("host", S.nullableAsOption(S.string)),
    url: s.field("url", S.string),
  })

let postAdminEmojiListRemoteResponseSchema = S.array(postAdminEmojiListRemoteResponse_1Schema)

/**
admin/emoji/list-remote

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:emoji*
*/
let postAdminEmojiListRemote = async (~body: postAdminEmojiListRemoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiListRemoteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiListRemoteRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/list-remote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminEmojiListRemoteResponseSchema)
}

type postAdminEmojiStealRequest = {
  name: string,
  host: string,
}

let postAdminEmojiStealRequestSchema = S.object(s => {
    name: s.field("name", S.string),
    host: s.field("host", S.string),
  })

type postAdminEmojiStealResponse = {
  id: string,
}

let postAdminEmojiStealResponseSchema = S.object(s => {
    id: s.field("id", S.string),
  })

/**
admin/emoji/steal

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiSteal = async (~body: postAdminEmojiStealRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiStealResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiStealRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/steal",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminEmojiStealResponseSchema)
}

type postAdminEmojiUpdateRequest = {
  fileId: option<string>,
  category: option<string>,
  aliases: option<array<string>>,
  license: option<string>,
  isSensitive: option<bool>,
  localOnly: option<bool>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
}

let postAdminEmojiUpdateRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.option(S.string)),
    category: s.field("category", S.option(S.string)),
    aliases: s.field("aliases", S.option(S.array(S.string))),
    license: s.field("license", S.option(S.string)),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
    localOnly: s.field("localOnly", S.option(S.bool)),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.field("roleIdsThatCanBeUsedThisEmojiAsReaction", S.option(S.array(S.string))),
  })

type postAdminEmojiUpdateResponse = unit

/**
admin/emoji/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiUpdate = async (~body: postAdminEmojiUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminInviteRevokeResponse = unit

/**
admin/invite/revoke

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:invite-codes*
*/
let postAdminInviteRevoke = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminInviteRevokeResponse => {

  let response = await fetch(
    ~url="/admin/invite/revoke",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postAdminQueueClearRequest = {
  queue: string,
  state: string,
}

let postAdminQueueClearRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    state: s.field("state", S.string),
  })

type postAdminQueueClearResponse = unit

/**
admin/queue/clear

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:queue*
*/
let postAdminQueueClear = async (~body: postAdminQueueClearRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueClearResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueClearRequestSchema)
  let response = await fetch(
    ~url="/admin/queue/clear",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminQueueJobsRequest = {
  queue: string,
  state: array<string>,
  search: option<string>,
}

let postAdminQueueJobsRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    state: s.field("state", S.array(S.string)),
    search: s.field("search", S.option(S.string)),
  })

type postAdminQueueJobsResponse = array<KokonectLinkComponentSchemas.QueueJob.t>

let postAdminQueueJobsResponseSchema = S.array(KokonectLinkComponentSchemas.QueueJob.schema)

/**
admin/queue/jobs

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:queue*
*/
let postAdminQueueJobs = async (~body: postAdminQueueJobsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueJobsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueJobsRequestSchema)
  let response = await fetch(
    ~url="/admin/queue/jobs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminQueueJobsResponseSchema)
}

type postAdminQueuePromoteJobsRequest = {
  queue: string,
}

let postAdminQueuePromoteJobsRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
  })

type postAdminQueuePromoteJobsResponse = unit

/**
admin/queue/promote-jobs

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:queue*
*/
let postAdminQueuePromoteJobs = async (~body: postAdminQueuePromoteJobsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueuePromoteJobsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueuePromoteJobsRequestSchema)
  let response = await fetch(
    ~url="/admin/queue/promote-jobs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminQueueQueueStatsRequest = {
  queue: string,
}

let postAdminQueueQueueStatsRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
  })

type postAdminQueueQueueStatsResponse_4 = {
  blocked: float,
  connected: float,
}

type postAdminQueueQueueStatsResponse_3 = {
  total: float,
  used: float,
  fragmentationRatio: float,
  peak: float,
}

type postAdminQueueQueueStatsResponse_2 = {
  version: string,
  mode: string,
  runId: string,
  processId: string,
  port: float,
  os: string,
  uptime: float,
  memory: postAdminQueueQueueStatsResponse_3,
  clients: postAdminQueueQueueStatsResponse_4,
}

type postAdminQueueQueueStatsResponse_1 = {
  completed: KokonectLinkComponentSchemas.QueueMetrics.t,
  failed: KokonectLinkComponentSchemas.QueueMetrics.t,
}

type postAdminQueueQueueStatsResponse = {
  name: string,
  qualifiedName: string,
  counts: dict<JSON.t>,
  isPaused: bool,
  metrics: postAdminQueueQueueStatsResponse_1,
  db: postAdminQueueQueueStatsResponse_2,
}

let postAdminQueueQueueStatsResponse_4Schema = S.object(s => {
    blocked: s.field("blocked", S.float),
    connected: s.field("connected", S.float),
  })

let postAdminQueueQueueStatsResponse_3Schema = S.object(s => {
    total: s.field("total", S.float),
    used: s.field("used", S.float),
    fragmentationRatio: s.field("fragmentationRatio", S.float),
    peak: s.field("peak", S.float),
  })

let postAdminQueueQueueStatsResponse_2Schema = S.object(s => {
    version: s.field("version", S.string),
    mode: s.field("mode", S.string),
    runId: s.field("runId", S.string),
    processId: s.field("processId", S.string),
    port: s.field("port", S.float),
    os: s.field("os", S.string),
    uptime: s.field("uptime", S.float),
    memory: s.field("memory", postAdminQueueQueueStatsResponse_3Schema),
    clients: s.field("clients", postAdminQueueQueueStatsResponse_4Schema),
  })

let postAdminQueueQueueStatsResponse_1Schema = S.object(s => {
    completed: s.field("completed", KokonectLinkComponentSchemas.QueueMetrics.schema),
    failed: s.field("failed", KokonectLinkComponentSchemas.QueueMetrics.schema),
  })

let postAdminQueueQueueStatsResponseSchema = S.object(s => {
    name: s.field("name", S.string),
    qualifiedName: s.field("qualifiedName", S.string),
    counts: s.field("counts", S.dict(S.json)),
    isPaused: s.field("isPaused", S.bool),
    metrics: s.field("metrics", postAdminQueueQueueStatsResponse_1Schema),
    db: s.field("db", postAdminQueueQueueStatsResponse_2Schema),
  })

/**
admin/queue/queue-stats

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:queue*
*/
let postAdminQueueQueueStats = async (~body: postAdminQueueQueueStatsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueQueueStatsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueQueueStatsRequestSchema)
  let response = await fetch(
    ~url="/admin/queue/queue-stats",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminQueueQueueStatsResponseSchema)
}

type postAdminQueueQueuesResponse_2 = {
  completed: KokonectLinkComponentSchemas.QueueMetrics.t,
  failed: KokonectLinkComponentSchemas.QueueMetrics.t,
}

type postAdminQueueQueuesResponse_1 = {
  name: string,
  counts: dict<JSON.t>,
  isPaused: bool,
  metrics: postAdminQueueQueuesResponse_2,
}

type postAdminQueueQueuesResponse = array<postAdminQueueQueuesResponse_1>

let postAdminQueueQueuesResponse_2Schema = S.object(s => {
    completed: s.field("completed", KokonectLinkComponentSchemas.QueueMetrics.schema),
    failed: s.field("failed", KokonectLinkComponentSchemas.QueueMetrics.schema),
  })

let postAdminQueueQueuesResponse_1Schema = S.object(s => {
    name: s.field("name", S.string),
    counts: s.field("counts", S.dict(S.json)),
    isPaused: s.field("isPaused", S.bool),
    metrics: s.field("metrics", postAdminQueueQueuesResponse_2Schema),
  })

let postAdminQueueQueuesResponseSchema = S.array(postAdminQueueQueuesResponse_1Schema)

/**
admin/queue/queues

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:queue*
*/
let postAdminQueueQueues = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueQueuesResponse => {

  let response = await fetch(
    ~url="/admin/queue/queues",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postAdminQueueQueuesResponseSchema)
}

type postAdminQueueRemoveJobRequest = {
  queue: string,
  jobId: string,
}

let postAdminQueueRemoveJobRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    jobId: s.field("jobId", S.string),
  })

type postAdminQueueRemoveJobResponse = unit

/**
admin/queue/remove-job

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:queue*
*/
let postAdminQueueRemoveJob = async (~body: postAdminQueueRemoveJobRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueRemoveJobResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueRemoveJobRequestSchema)
  let response = await fetch(
    ~url="/admin/queue/remove-job",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminQueueRetryJobRequest = {
  queue: string,
  jobId: string,
}

let postAdminQueueRetryJobRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    jobId: s.field("jobId", S.string),
  })

type postAdminQueueRetryJobResponse = unit

/**
admin/queue/retry-job

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:queue*
*/
let postAdminQueueRetryJob = async (~body: postAdminQueueRetryJobRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueRetryJobResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueRetryJobRequestSchema)
  let response = await fetch(
    ~url="/admin/queue/retry-job",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminQueueShowJobRequest = {
  queue: string,
  jobId: string,
}

let postAdminQueueShowJobRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    jobId: s.field("jobId", S.string),
  })

type postAdminQueueShowJobResponse = KokonectLinkComponentSchemas.QueueJob.t

let postAdminQueueShowJobResponseSchema = KokonectLinkComponentSchemas.QueueJob.schema

/**
admin/queue/show-job

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:queue*
*/
let postAdminQueueShowJob = async (~body: postAdminQueueShowJobRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueShowJobResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueShowJobRequestSchema)
  let response = await fetch(
    ~url="/admin/queue/show-job",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminQueueShowJobResponseSchema)
}

type postAdminQueueShowJobLogsRequest = {
  queue: string,
  jobId: string,
}

let postAdminQueueShowJobLogsRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    jobId: s.field("jobId", S.string),
  })

type postAdminQueueShowJobLogsResponse = array<string>

let postAdminQueueShowJobLogsResponseSchema = S.array(S.string)

/**
admin/queue/show-job-logs

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:queue*
*/
let postAdminQueueShowJobLogs = async (~body: postAdminQueueShowJobLogsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueShowJobLogsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueShowJobLogsRequestSchema)
  let response = await fetch(
    ~url="/admin/queue/show-job-logs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminQueueShowJobLogsResponseSchema)
}

type postAdminResolveAbuseUserReportRequest = {
  reportId: string,
  resolvedAs: option<string>,
}

let postAdminResolveAbuseUserReportRequestSchema = S.object(s => {
    reportId: s.field("reportId", S.string),
    resolvedAs: s.field("resolvedAs", S.option(S.string)),
  })

type postAdminResolveAbuseUserReportResponse = unit

/**
admin/resolve-abuse-user-report

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:resolve-abuse-user-report*
*/
let postAdminResolveAbuseUserReport = async (~body: postAdminResolveAbuseUserReportRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminResolveAbuseUserReportResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminResolveAbuseUserReportRequestSchema)
  let response = await fetch(
    ~url="/admin/resolve-abuse-user-report",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminRolesAssignRequest = {
  roleId: string,
  userId: string,
  expiresAt: option<int>,
}

let postAdminRolesAssignRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    userId: s.field("userId", S.string),
    expiresAt: s.field("expiresAt", S.option(S.int)),
  })

type postAdminRolesAssignResponse = unit

/**
admin/roles/assign

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:roles*
*/
let postAdminRolesAssign = async (~body: postAdminRolesAssignRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesAssignResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesAssignRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/assign",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminRolesCreateRequest = {
  name: string,
  description: string,
  color: option<string>,
  iconUrl: option<string>,
  target: string,
  condFormula: dict<JSON.t>,
  isPublic: bool,
  isModerator: bool,
  isAdministrator: bool,
  isExplorable: option<bool>,
  asBadge: bool,
  preserveAssignmentOnMoveAccount: option<bool>,
  canEditMembersByModerator: bool,
  displayOrder: float,
  policies: dict<JSON.t>,
}

let postAdminRolesCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    color: s.field("color", S.nullableAsOption(S.string)),
    iconUrl: s.field("iconUrl", S.nullableAsOption(S.string)),
    target: s.field("target", S.string),
    condFormula: s.field("condFormula", S.dict(S.json)),
    isPublic: s.field("isPublic", S.bool),
    isModerator: s.field("isModerator", S.bool),
    isAdministrator: s.field("isAdministrator", S.bool),
    isExplorable: s.field("isExplorable", S.option(S.bool)),
    asBadge: s.field("asBadge", S.bool),
    preserveAssignmentOnMoveAccount: s.field("preserveAssignmentOnMoveAccount", S.option(S.bool)),
    canEditMembersByModerator: s.field("canEditMembersByModerator", S.bool),
    displayOrder: s.field("displayOrder", S.float),
    policies: s.field("policies", S.dict(S.json)),
  })

type postAdminRolesCreateResponse = KokonectLinkComponentSchemas.Role.t

let postAdminRolesCreateResponseSchema = KokonectLinkComponentSchemas.Role.schema

/**
admin/roles/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:roles*
*/
let postAdminRolesCreate = async (~body: postAdminRolesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminRolesCreateResponseSchema)
}

type postAdminRolesShowRequest = {
  roleId: string,
}

let postAdminRolesShowRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
  })

type postAdminRolesShowResponse = KokonectLinkComponentSchemas.Role.t

let postAdminRolesShowResponseSchema = KokonectLinkComponentSchemas.Role.schema

/**
admin/roles/show

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:roles*
*/
let postAdminRolesShow = async (~body: postAdminRolesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesShowRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminRolesShowResponseSchema)
}

type postAdminRolesUpdateRequest = {
  roleId: string,
  name: option<string>,
  description: option<string>,
  color: option<string>,
  iconUrl: option<string>,
  target: option<string>,
  condFormula: option<dict<JSON.t>>,
  isPublic: option<bool>,
  isModerator: option<bool>,
  isAdministrator: option<bool>,
  isExplorable: option<bool>,
  asBadge: option<bool>,
  preserveAssignmentOnMoveAccount: option<bool>,
  canEditMembersByModerator: option<bool>,
  displayOrder: option<float>,
  policies: option<dict<JSON.t>>,
}

let postAdminRolesUpdateRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    name: s.field("name", S.option(S.string)),
    description: s.field("description", S.option(S.string)),
    color: s.field("color", S.option(S.string)),
    iconUrl: s.field("iconUrl", S.option(S.string)),
    target: s.field("target", S.option(S.string)),
    condFormula: s.field("condFormula", S.option(S.dict(S.json))),
    isPublic: s.field("isPublic", S.option(S.bool)),
    isModerator: s.field("isModerator", S.option(S.bool)),
    isAdministrator: s.field("isAdministrator", S.option(S.bool)),
    isExplorable: s.field("isExplorable", S.option(S.bool)),
    asBadge: s.field("asBadge", S.option(S.bool)),
    preserveAssignmentOnMoveAccount: s.field("preserveAssignmentOnMoveAccount", S.option(S.bool)),
    canEditMembersByModerator: s.field("canEditMembersByModerator", S.option(S.bool)),
    displayOrder: s.field("displayOrder", S.option(S.float)),
    policies: s.field("policies", S.option(S.dict(S.json))),
  })

type postAdminRolesUpdateResponse = unit

/**
admin/roles/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:roles*
*/
let postAdminRolesUpdate = async (~body: postAdminRolesUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminRolesUsersRequest = {
  roleId: string,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postAdminRolesUsersRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postAdminRolesUsersResponse_1 = {
  id: string,
  createdAt: string,
  user: KokonectLinkComponentSchemas.UserDetailed.t,
  expiresAt: option<string>,
}

type postAdminRolesUsersResponse = array<postAdminRolesUsersResponse_1>

let postAdminRolesUsersResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    user: s.field("user", KokonectLinkComponentSchemas.UserDetailed.schema),
    expiresAt: s.field("expiresAt", S.nullableAsOption(S.string)),
  })

let postAdminRolesUsersResponseSchema = S.array(postAdminRolesUsersResponse_1Schema)

/**
admin/roles/users

No description provided.

**Credential required**: *No* / **Permission**: *read:admin:roles*
*/
let postAdminRolesUsers = async (~body: postAdminRolesUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesUsersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUsersRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminRolesUsersResponseSchema)
}

type postAdminServerInfoResponse_4 = {
  interface: string,
}

type postAdminServerInfoResponse_3 = {
  total: float,
  used: float,
}

type postAdminServerInfoResponse_2 = {
  total: float,
}

type postAdminServerInfoResponse_1 = {
  model: string,
  cores: float,
}

type postAdminServerInfoResponse = {
  machine: string,
  os: string,
  node: string,
  psql: string,
  cpu: postAdminServerInfoResponse_1,
  mem: postAdminServerInfoResponse_2,
  fs: postAdminServerInfoResponse_3,
  net: postAdminServerInfoResponse_4,
}

let postAdminServerInfoResponse_4Schema = S.object(s => {
    interface: s.field("interface", S.string),
  })

let postAdminServerInfoResponse_3Schema = S.object(s => {
    total: s.field("total", S.float),
    used: s.field("used", S.float),
  })

let postAdminServerInfoResponse_2Schema = S.object(s => {
    total: s.field("total", S.float),
  })

let postAdminServerInfoResponse_1Schema = S.object(s => {
    model: s.field("model", S.string),
    cores: s.field("cores", S.float),
  })

let postAdminServerInfoResponseSchema = S.object(s => {
    machine: s.field("machine", S.string),
    os: s.field("os", S.string),
    node: s.field("node", S.string),
    psql: s.field("psql", S.string),
    cpu: s.field("cpu", postAdminServerInfoResponse_1Schema),
    mem: s.field("mem", postAdminServerInfoResponse_2Schema),
    fs: s.field("fs", postAdminServerInfoResponse_3Schema),
    net: s.field("net", postAdminServerInfoResponse_4Schema),
  })

/**
admin/server-info

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:server-info*
*/
let postAdminServerInfo = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminServerInfoResponse => {

  let response = await fetch(
    ~url="/admin/server-info",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postAdminServerInfoResponseSchema)
}

type postAdminShowModerationLogsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  @as("type") type_: option<string>,
  userId: option<string>,
  search: option<string>,
}

let postAdminShowModerationLogsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    type_: s.field("type", S.option(S.string)),
    userId: s.field("userId", S.option(S.string)),
    search: s.field("search", S.option(S.string)),
  })

type postAdminShowModerationLogsResponse_1 = {
  id: string,
  createdAt: string,
  @as("type") type_: string,
  info: dict<JSON.t>,
  userId: string,
  user: KokonectLinkComponentSchemas.UserDetailedNotMe.t,
}

type postAdminShowModerationLogsResponse = array<postAdminShowModerationLogsResponse_1>

let postAdminShowModerationLogsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    type_: s.field("type", S.string),
    info: s.field("info", S.dict(S.json)),
    userId: s.field("userId", S.string),
    user: s.field("user", KokonectLinkComponentSchemas.UserDetailedNotMe.schema),
  })

let postAdminShowModerationLogsResponseSchema = S.array(postAdminShowModerationLogsResponse_1Schema)

/**
admin/show-moderation-logs

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:show-moderation-log*
*/
let postAdminShowModerationLogs = async (~body: postAdminShowModerationLogsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminShowModerationLogsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowModerationLogsRequestSchema)
  let response = await fetch(
    ~url="/admin/show-moderation-logs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminShowModerationLogsResponseSchema)
}

type postAdminShowUserRequest = {
  userId: string,
}

let postAdminShowUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminShowUserResponse_2 = {
  createdAt: string,
  expiresAt: option<string>,
  roleId: string,
}

type postAdminShowUserResponse_1 = {
  note: option<dict<JSON.t>>,
  follow: option<dict<JSON.t>>,
  mention: option<dict<JSON.t>>,
  reply: option<dict<JSON.t>>,
  renote: option<dict<JSON.t>>,
  quote: option<dict<JSON.t>>,
  reaction: option<dict<JSON.t>>,
  pollEnded: option<dict<JSON.t>>,
  scheduledNotePosted: option<dict<JSON.t>>,
  scheduledNotePostFailed: option<dict<JSON.t>>,
  receiveFollowRequest: option<dict<JSON.t>>,
  followRequestAccepted: option<dict<JSON.t>>,
  groupInvited: option<dict<JSON.t>>,
  roleAssigned: option<dict<JSON.t>>,
  chatRoomInvitationReceived: option<dict<JSON.t>>,
  achievementEarned: option<dict<JSON.t>>,
  app: option<dict<JSON.t>>,
  test: option<dict<JSON.t>>,
}

type postAdminShowUserResponse = {
  email: option<string>,
  emailVerified: bool,
  followedMessage: option<string>,
  autoAcceptFollowed: bool,
  noCrawle: bool,
  preventAiLearning: bool,
  alwaysMarkNsfw: bool,
  autoSensitive: bool,
  carefulBot: bool,
  injectFeaturedNote: bool,
  receiveAnnouncementEmail: bool,
  mutedWords: array<array<string>>,
  mutedInstances: array<string>,
  notificationRecieveConfig: postAdminShowUserResponse_1,
  isModerator: bool,
  isSilenced: bool,
  isSuspended: bool,
  isHibernated: bool,
  lastActiveDate: option<string>,
  moderationNote: string,
  signins: array<KokonectLinkComponentSchemas.Signin.t>,
  policies: KokonectLinkComponentSchemas.RolePolicies.t,
  roles: array<KokonectLinkComponentSchemas.Role.t>,
  roleAssigns: array<postAdminShowUserResponse_2>,
  setFederationAvatarShape: option<bool>,
  isSquareAvatars: option<bool>,
}

let postAdminShowUserResponse_2Schema = S.object(s => {
    createdAt: s.field("createdAt", S.string),
    expiresAt: s.field("expiresAt", S.nullableAsOption(S.string)),
    roleId: s.field("roleId", S.string),
  })

let postAdminShowUserResponse_1Schema = S.object(s => {
    note: s.field("note", S.option(S.dict(S.json))),
    follow: s.field("follow", S.option(S.dict(S.json))),
    mention: s.field("mention", S.option(S.dict(S.json))),
    reply: s.field("reply", S.option(S.dict(S.json))),
    renote: s.field("renote", S.option(S.dict(S.json))),
    quote: s.field("quote", S.option(S.dict(S.json))),
    reaction: s.field("reaction", S.option(S.dict(S.json))),
    pollEnded: s.field("pollEnded", S.option(S.dict(S.json))),
    scheduledNotePosted: s.field("scheduledNotePosted", S.option(S.dict(S.json))),
    scheduledNotePostFailed: s.field("scheduledNotePostFailed", S.option(S.dict(S.json))),
    receiveFollowRequest: s.field("receiveFollowRequest", S.option(S.dict(S.json))),
    followRequestAccepted: s.field("followRequestAccepted", S.option(S.dict(S.json))),
    groupInvited: s.field("groupInvited", S.option(S.dict(S.json))),
    roleAssigned: s.field("roleAssigned", S.option(S.dict(S.json))),
    chatRoomInvitationReceived: s.field("chatRoomInvitationReceived", S.option(S.dict(S.json))),
    achievementEarned: s.field("achievementEarned", S.option(S.dict(S.json))),
    app: s.field("app", S.option(S.dict(S.json))),
    test: s.field("test", S.option(S.dict(S.json))),
  })

let postAdminShowUserResponseSchema = S.object(s => {
    email: s.field("email", S.nullableAsOption(S.string)),
    emailVerified: s.field("emailVerified", S.bool),
    followedMessage: s.field("followedMessage", S.nullableAsOption(S.string)),
    autoAcceptFollowed: s.field("autoAcceptFollowed", S.bool),
    noCrawle: s.field("noCrawle", S.bool),
    preventAiLearning: s.field("preventAiLearning", S.bool),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.bool),
    autoSensitive: s.field("autoSensitive", S.bool),
    carefulBot: s.field("carefulBot", S.bool),
    injectFeaturedNote: s.field("injectFeaturedNote", S.bool),
    receiveAnnouncementEmail: s.field("receiveAnnouncementEmail", S.bool),
    mutedWords: s.field("mutedWords", S.array(S.array(S.string))),
    mutedInstances: s.field("mutedInstances", S.array(S.string)),
    notificationRecieveConfig: s.field("notificationRecieveConfig", postAdminShowUserResponse_1Schema),
    isModerator: s.field("isModerator", S.bool),
    isSilenced: s.field("isSilenced", S.bool),
    isSuspended: s.field("isSuspended", S.bool),
    isHibernated: s.field("isHibernated", S.bool),
    lastActiveDate: s.field("lastActiveDate", S.nullableAsOption(S.string)),
    moderationNote: s.field("moderationNote", S.string),
    signins: s.field("signins", S.array(KokonectLinkComponentSchemas.Signin.schema)),
    policies: s.field("policies", KokonectLinkComponentSchemas.RolePolicies.schema),
    roles: s.field("roles", S.array(KokonectLinkComponentSchemas.Role.schema)),
    roleAssigns: s.field("roleAssigns", S.array(postAdminShowUserResponse_2Schema)),
    setFederationAvatarShape: s.field("setFederationAvatarShape", S.nullableAsOption(S.bool)),
    isSquareAvatars: s.field("isSquareAvatars", S.nullableAsOption(S.bool)),
  })

/**
admin/show-user

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:show-user*
*/
let postAdminShowUser = async (~body: postAdminShowUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminShowUserResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowUserRequestSchema)
  let response = await fetch(
    ~url="/admin/show-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminShowUserResponseSchema)
}

type postAdminSystemWebhookCreateRequest = {
  isActive: bool,
  name: string,
  on: array<string>,
  url: string,
  secret: option<string>,
}

let postAdminSystemWebhookCreateRequestSchema = S.object(s => {
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string->S.min(1)->S.max(1024)),
    secret: s.field("secret", S.option(S.string->S.max(1024))),
  })

type postAdminSystemWebhookCreateResponse = KokonectLinkComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookCreateResponseSchema = KokonectLinkComponentSchemas.SystemWebhook.schema

/**
admin/system-webhook/create

No description provided.

**Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
*/
let postAdminSystemWebhookCreate = async (~body: postAdminSystemWebhookCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSystemWebhookCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/system-webhook/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminSystemWebhookCreateResponseSchema)
}

type postAdminSystemWebhookShowRequest = {
  id: string,
}

let postAdminSystemWebhookShowRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminSystemWebhookShowResponse = KokonectLinkComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookShowResponseSchema = KokonectLinkComponentSchemas.SystemWebhook.schema

/**
admin/system-webhook/show

No description provided.

**Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
*/
let postAdminSystemWebhookShow = async (~body: postAdminSystemWebhookShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSystemWebhookShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookShowRequestSchema)
  let response = await fetch(
    ~url="/admin/system-webhook/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminSystemWebhookShowResponseSchema)
}

type postAdminSystemWebhookUpdateRequest = {
  id: string,
  isActive: bool,
  name: string,
  on: array<string>,
  url: string,
  secret: option<string>,
}

let postAdminSystemWebhookUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string->S.min(1)->S.max(1024)),
    secret: s.field("secret", S.option(S.string->S.max(1024))),
  })

type postAdminSystemWebhookUpdateResponse = KokonectLinkComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookUpdateResponseSchema = KokonectLinkComponentSchemas.SystemWebhook.schema

/**
admin/system-webhook/update

No description provided.

**Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
*/
let postAdminSystemWebhookUpdate = async (~body: postAdminSystemWebhookUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSystemWebhookUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/system-webhook/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminSystemWebhookUpdateResponseSchema)
}

type postAdminUpdateMetaRequest_1 = {
  software: string,
  versionRange: string,
}

type postAdminUpdateMetaRequest = {
  disableRegistration: option<bool>,
  pinnedUsers: option<JSON.t>,
  hiddenTags: option<JSON.t>,
  blockedHosts: option<JSON.t>,
  sensitiveWords: option<JSON.t>,
  prohibitedWords: option<JSON.t>,
  prohibitedWordsForNameOfUser: option<JSON.t>,
  themeColor: option<string>,
  mascotImageUrl: option<string>,
  bannerUrl: option<string>,
  serverErrorImageUrl: option<string>,
  infoImageUrl: option<string>,
  notFoundImageUrl: option<string>,
  youBlockedImageUrl: option<string>,
  iconUrl: option<string>,
  @as("app192IconUrl") app192iconUrl: option<string>,
  @as("app512IconUrl") app512iconUrl: option<string>,
  backgroundImageUrl: option<string>,
  logoImageUrl: option<string>,
  name: option<string>,
  shortName: option<string>,
  description: option<string>,
  defaultLightTheme: option<string>,
  defaultDarkTheme: option<string>,
  clientOptions: option<dict<JSON.t>>,
  cacheRemoteFiles: option<bool>,
  cacheRemoteSensitiveFiles: option<bool>,
  emailRequiredForSignup: option<bool>,
  enableHcaptcha: option<bool>,
  hcaptchaSiteKey: option<string>,
  hcaptchaSecretKey: option<string>,
  enableMcaptcha: option<bool>,
  mcaptchaSiteKey: option<string>,
  mcaptchaInstanceUrl: option<string>,
  mcaptchaSecretKey: option<string>,
  enableRecaptcha: option<bool>,
  recaptchaSiteKey: option<string>,
  recaptchaSecretKey: option<string>,
  enableTurnstile: option<bool>,
  turnstileSiteKey: option<string>,
  turnstileSecretKey: option<string>,
  enableTestcaptcha: option<bool>,
  googleAnalyticsMeasurementId: option<string>,
  sensitiveMediaDetection: option<string>,
  sensitiveMediaDetectionSensitivity: option<string>,
  setSensitiveFlagAutomatically: option<bool>,
  enableSensitiveMediaDetectionForVideos: option<bool>,
  maintainerName: option<string>,
  maintainerEmail: option<string>,
  langs: option<array<string>>,
  translatorType: option<string>,
  deeplAuthKey: option<string>,
  deeplIsPro: option<bool>,
  @as("ctav3SaKey") ctav3saKey: option<string>,
  @as("ctav3ProjectId") ctav3projectId: option<string>,
  @as("ctav3Location") ctav3location: option<string>,
  @as("ctav3Model") ctav3model: option<string>,
  @as("ctav3Glossary") ctav3glossary: option<string>,
  libreTranslateEndPoint: option<string>,
  libreTranslateApiKey: option<string>,
  enableEmail: option<bool>,
  email: option<string>,
  smtpSecure: option<bool>,
  smtpHost: option<string>,
  smtpPort: option<int>,
  smtpUser: option<string>,
  smtpPass: option<string>,
  enableServiceWorker: option<bool>,
  swPublicKey: option<string>,
  swPrivateKey: option<string>,
  tosUrl: option<string>,
  repositoryUrl: option<string>,
  feedbackUrl: option<string>,
  impressumUrl: option<string>,
  privacyPolicyUrl: option<string>,
  inquiryUrl: option<string>,
  useObjectStorage: option<bool>,
  objectStorageBaseUrl: option<string>,
  objectStorageBucket: option<string>,
  objectStoragePrefix: option<string>,
  objectStorageEndpoint: option<string>,
  objectStorageRegion: option<string>,
  objectStoragePort: option<int>,
  objectStorageAccessKey: option<string>,
  objectStorageSecretKey: option<string>,
  @as("objectStorageUseSSL") objectStorageUseSsl: option<bool>,
  objectStorageUseProxy: option<bool>,
  objectStorageSetPublicRead: option<bool>,
  @as("objectStorageS3ForcePathStyle") objectStorageS3forcePathStyle: option<bool>,
  useRemoteObjectStorage: option<bool>,
  remoteObjectStorageBaseUrl: option<string>,
  remoteObjectStorageBucket: option<string>,
  remoteObjectStoragePrefix: option<string>,
  remoteObjectStorageEndpoint: option<string>,
  remoteObjectStorageRegion: option<string>,
  remoteObjectStoragePort: option<int>,
  remoteObjectStorageAccessKey: option<string>,
  remoteObjectStorageSecretKey: option<string>,
  @as("remoteObjectStorageUseSSL") remoteObjectStorageUseSsl: option<bool>,
  remoteObjectStorageUseProxy: option<bool>,
  remoteObjectStorageSetPublicRead: option<bool>,
  @as("remoteObjectStorageS3ForcePathStyle") remoteObjectStorageS3forcePathStyle: option<bool>,
  enableIpLogging: option<bool>,
  enableActiveEmailValidation: option<bool>,
  enableVerifymailApi: option<bool>,
  verifymailAuthKey: option<string>,
  enableTruemailApi: option<bool>,
  truemailInstance: option<string>,
  truemailAuthKey: option<string>,
  enableChartsForRemoteUser: option<bool>,
  enableChartsForFederatedInstances: option<bool>,
  enableStatsForFederatedInstances: option<bool>,
  enableServerMachineStats: option<bool>,
  enableIdenticonGeneration: option<bool>,
  serverRules: option<array<string>>,
  bannedEmailDomains: option<array<string>>,
  preservedUsernames: option<array<string>>,
  manifestJsonOverride: option<string>,
  enableFanoutTimeline: option<bool>,
  enableFanoutTimelineDbFallback: option<bool>,
  perLocalUserUserTimelineCacheMax: option<int>,
  perRemoteUserUserTimelineCacheMax: option<int>,
  perUserHomeTimelineCacheMax: option<int>,
  perUserListTimelineCacheMax: option<int>,
  enableReactionsBuffering: option<bool>,
  notesPerOneAd: option<int>,
  silencedHosts: option<JSON.t>,
  mediaSilencedHosts: option<JSON.t>,
  summalyProxy: option<string>,
  urlPreviewEnabled: option<bool>,
  urlPreviewAllowRedirect: option<bool>,
  urlPreviewTimeout: option<int>,
  urlPreviewMaximumContentLength: option<int>,
  urlPreviewRequireContentLength: option<bool>,
  urlPreviewUserAgent: option<string>,
  urlPreviewSummaryProxyUrl: option<string>,
  federation: option<string>,
  federationHosts: option<array<string>>,
  deliverSuspendedSoftware: option<array<postAdminUpdateMetaRequest_1>>,
  singleUserMode: option<bool>,
  ugcVisibilityForVisitor: option<string>,
  proxyRemoteFiles: option<bool>,
  signToActivityPubGet: option<bool>,
  allowExternalApRedirect: option<bool>,
  enableRemoteNotesCleaning: option<bool>,
  remoteNotesCleaningExpiryDaysForEachNotes: option<float>,
  remoteNotesCleaningMaxProcessingDurationInMinutes: option<float>,
  showRoleBadgesOfRemoteUsers: option<bool>,
  doNotSendNotificationEmailsForAbuseReport: option<bool>,
  emailToReceiveAbuseReport: option<string>,
  enableReceivePrerelease: option<bool>,
  skipVersion: option<bool>,
  skipCherryPickVersion: option<string>,
  trustedLinkUrlPatterns: option<JSON.t>,
  customSplashText: option<JSON.t>,
  disableRegistrationWhenInactive: option<bool>,
  disablePublicNoteWhenInactive: option<bool>,
  moderatorInactivityLimitDays: option<int>,
  bubbleInstances: option<array<string>>,
  customRobotsTxt: option<string>,
}

let postAdminUpdateMetaRequest_1Schema = S.object(s => {
    software: s.field("software", S.string),
    versionRange: s.field("versionRange", S.string),
  })

let postAdminUpdateMetaRequestSchema = S.object(s => {
    disableRegistration: s.field("disableRegistration", S.option(S.bool)),
    pinnedUsers: s.field("pinnedUsers", S.option(S.json)),
    hiddenTags: s.field("hiddenTags", S.option(S.json)),
    blockedHosts: s.field("blockedHosts", S.option(S.json)),
    sensitiveWords: s.field("sensitiveWords", S.option(S.json)),
    prohibitedWords: s.field("prohibitedWords", S.option(S.json)),
    prohibitedWordsForNameOfUser: s.field("prohibitedWordsForNameOfUser", S.option(S.json)),
    themeColor: s.field("themeColor", S.option(S.string->S.pattern(/^#[0-9a-fA-F]{6}$/))),
    mascotImageUrl: s.field("mascotImageUrl", S.option(S.string)),
    bannerUrl: s.field("bannerUrl", S.option(S.string)),
    serverErrorImageUrl: s.field("serverErrorImageUrl", S.option(S.string)),
    infoImageUrl: s.field("infoImageUrl", S.option(S.string)),
    notFoundImageUrl: s.field("notFoundImageUrl", S.option(S.string)),
    youBlockedImageUrl: s.field("youBlockedImageUrl", S.option(S.string)),
    iconUrl: s.field("iconUrl", S.option(S.string)),
    app192iconUrl: s.field("app192IconUrl", S.option(S.string)),
    app512iconUrl: s.field("app512IconUrl", S.option(S.string)),
    backgroundImageUrl: s.field("backgroundImageUrl", S.option(S.string)),
    logoImageUrl: s.field("logoImageUrl", S.option(S.string)),
    name: s.field("name", S.option(S.string)),
    shortName: s.field("shortName", S.option(S.string)),
    description: s.field("description", S.option(S.string)),
    defaultLightTheme: s.field("defaultLightTheme", S.option(S.string)),
    defaultDarkTheme: s.field("defaultDarkTheme", S.option(S.string)),
    clientOptions: s.field("clientOptions", S.option(S.dict(S.json))),
    cacheRemoteFiles: s.field("cacheRemoteFiles", S.option(S.bool)),
    cacheRemoteSensitiveFiles: s.field("cacheRemoteSensitiveFiles", S.option(S.bool)),
    emailRequiredForSignup: s.field("emailRequiredForSignup", S.option(S.bool)),
    enableHcaptcha: s.field("enableHcaptcha", S.option(S.bool)),
    hcaptchaSiteKey: s.field("hcaptchaSiteKey", S.option(S.string)),
    hcaptchaSecretKey: s.field("hcaptchaSecretKey", S.option(S.string)),
    enableMcaptcha: s.field("enableMcaptcha", S.option(S.bool)),
    mcaptchaSiteKey: s.field("mcaptchaSiteKey", S.option(S.string)),
    mcaptchaInstanceUrl: s.field("mcaptchaInstanceUrl", S.option(S.string)),
    mcaptchaSecretKey: s.field("mcaptchaSecretKey", S.option(S.string)),
    enableRecaptcha: s.field("enableRecaptcha", S.option(S.bool)),
    recaptchaSiteKey: s.field("recaptchaSiteKey", S.option(S.string)),
    recaptchaSecretKey: s.field("recaptchaSecretKey", S.option(S.string)),
    enableTurnstile: s.field("enableTurnstile", S.option(S.bool)),
    turnstileSiteKey: s.field("turnstileSiteKey", S.option(S.string)),
    turnstileSecretKey: s.field("turnstileSecretKey", S.option(S.string)),
    enableTestcaptcha: s.field("enableTestcaptcha", S.option(S.bool)),
    googleAnalyticsMeasurementId: s.field("googleAnalyticsMeasurementId", S.option(S.string)),
    sensitiveMediaDetection: s.field("sensitiveMediaDetection", S.option(S.string)),
    sensitiveMediaDetectionSensitivity: s.field("sensitiveMediaDetectionSensitivity", S.option(S.string)),
    setSensitiveFlagAutomatically: s.field("setSensitiveFlagAutomatically", S.option(S.bool)),
    enableSensitiveMediaDetectionForVideos: s.field("enableSensitiveMediaDetectionForVideos", S.option(S.bool)),
    maintainerName: s.field("maintainerName", S.option(S.string)),
    maintainerEmail: s.field("maintainerEmail", S.option(S.string)),
    langs: s.field("langs", S.option(S.array(S.string))),
    translatorType: s.field("translatorType", S.option(S.string)),
    deeplAuthKey: s.field("deeplAuthKey", S.option(S.string)),
    deeplIsPro: s.field("deeplIsPro", S.option(S.bool)),
    ctav3saKey: s.field("ctav3SaKey", S.option(S.string)),
    ctav3projectId: s.field("ctav3ProjectId", S.option(S.string)),
    ctav3location: s.field("ctav3Location", S.option(S.string)),
    ctav3model: s.field("ctav3Model", S.option(S.string)),
    ctav3glossary: s.field("ctav3Glossary", S.option(S.string)),
    libreTranslateEndPoint: s.field("libreTranslateEndPoint", S.option(S.string)),
    libreTranslateApiKey: s.field("libreTranslateApiKey", S.option(S.string)),
    enableEmail: s.field("enableEmail", S.option(S.bool)),
    email: s.field("email", S.option(S.string)),
    smtpSecure: s.field("smtpSecure", S.option(S.bool)),
    smtpHost: s.field("smtpHost", S.option(S.string)),
    smtpPort: s.field("smtpPort", S.option(S.int)),
    smtpUser: s.field("smtpUser", S.option(S.string)),
    smtpPass: s.field("smtpPass", S.option(S.string)),
    enableServiceWorker: s.field("enableServiceWorker", S.option(S.bool)),
    swPublicKey: s.field("swPublicKey", S.option(S.string)),
    swPrivateKey: s.field("swPrivateKey", S.option(S.string)),
    tosUrl: s.field("tosUrl", S.option(S.string)),
    repositoryUrl: s.field("repositoryUrl", S.option(S.string)),
    feedbackUrl: s.field("feedbackUrl", S.option(S.string)),
    impressumUrl: s.field("impressumUrl", S.option(S.string)),
    privacyPolicyUrl: s.field("privacyPolicyUrl", S.option(S.string)),
    inquiryUrl: s.field("inquiryUrl", S.option(S.string)),
    useObjectStorage: s.field("useObjectStorage", S.option(S.bool)),
    objectStorageBaseUrl: s.field("objectStorageBaseUrl", S.option(S.string)),
    objectStorageBucket: s.field("objectStorageBucket", S.option(S.string)),
    objectStoragePrefix: s.field("objectStoragePrefix", S.option(S.string->S.pattern(/^[a-zA-Z0-9._-]*$/))),
    objectStorageEndpoint: s.field("objectStorageEndpoint", S.option(S.string)),
    objectStorageRegion: s.field("objectStorageRegion", S.option(S.string)),
    objectStoragePort: s.field("objectStoragePort", S.option(S.int)),
    objectStorageAccessKey: s.field("objectStorageAccessKey", S.option(S.string)),
    objectStorageSecretKey: s.field("objectStorageSecretKey", S.option(S.string)),
    objectStorageUseSsl: s.field("objectStorageUseSSL", S.option(S.bool)),
    objectStorageUseProxy: s.field("objectStorageUseProxy", S.option(S.bool)),
    objectStorageSetPublicRead: s.field("objectStorageSetPublicRead", S.option(S.bool)),
    objectStorageS3forcePathStyle: s.field("objectStorageS3ForcePathStyle", S.option(S.bool)),
    useRemoteObjectStorage: s.field("useRemoteObjectStorage", S.option(S.bool)),
    remoteObjectStorageBaseUrl: s.field("remoteObjectStorageBaseUrl", S.option(S.string)),
    remoteObjectStorageBucket: s.field("remoteObjectStorageBucket", S.option(S.string)),
    remoteObjectStoragePrefix: s.field("remoteObjectStoragePrefix", S.option(S.string->S.pattern(/^[a-zA-Z0-9._-]*$/))),
    remoteObjectStorageEndpoint: s.field("remoteObjectStorageEndpoint", S.option(S.string)),
    remoteObjectStorageRegion: s.field("remoteObjectStorageRegion", S.option(S.string)),
    remoteObjectStoragePort: s.field("remoteObjectStoragePort", S.option(S.int)),
    remoteObjectStorageAccessKey: s.field("remoteObjectStorageAccessKey", S.option(S.string)),
    remoteObjectStorageSecretKey: s.field("remoteObjectStorageSecretKey", S.option(S.string)),
    remoteObjectStorageUseSsl: s.field("remoteObjectStorageUseSSL", S.option(S.bool)),
    remoteObjectStorageUseProxy: s.field("remoteObjectStorageUseProxy", S.option(S.bool)),
    remoteObjectStorageSetPublicRead: s.field("remoteObjectStorageSetPublicRead", S.option(S.bool)),
    remoteObjectStorageS3forcePathStyle: s.field("remoteObjectStorageS3ForcePathStyle", S.option(S.bool)),
    enableIpLogging: s.field("enableIpLogging", S.option(S.bool)),
    enableActiveEmailValidation: s.field("enableActiveEmailValidation", S.option(S.bool)),
    enableVerifymailApi: s.field("enableVerifymailApi", S.option(S.bool)),
    verifymailAuthKey: s.field("verifymailAuthKey", S.option(S.string)),
    enableTruemailApi: s.field("enableTruemailApi", S.option(S.bool)),
    truemailInstance: s.field("truemailInstance", S.option(S.string)),
    truemailAuthKey: s.field("truemailAuthKey", S.option(S.string)),
    enableChartsForRemoteUser: s.field("enableChartsForRemoteUser", S.option(S.bool)),
    enableChartsForFederatedInstances: s.field("enableChartsForFederatedInstances", S.option(S.bool)),
    enableStatsForFederatedInstances: s.field("enableStatsForFederatedInstances", S.option(S.bool)),
    enableServerMachineStats: s.field("enableServerMachineStats", S.option(S.bool)),
    enableIdenticonGeneration: s.field("enableIdenticonGeneration", S.option(S.bool)),
    serverRules: s.field("serverRules", S.option(S.array(S.string))),
    bannedEmailDomains: s.field("bannedEmailDomains", S.option(S.array(S.string))),
    preservedUsernames: s.field("preservedUsernames", S.option(S.array(S.string))),
    manifestJsonOverride: s.field("manifestJsonOverride", S.option(S.string)),
    enableFanoutTimeline: s.field("enableFanoutTimeline", S.option(S.bool)),
    enableFanoutTimelineDbFallback: s.field("enableFanoutTimelineDbFallback", S.option(S.bool)),
    perLocalUserUserTimelineCacheMax: s.field("perLocalUserUserTimelineCacheMax", S.option(S.int)),
    perRemoteUserUserTimelineCacheMax: s.field("perRemoteUserUserTimelineCacheMax", S.option(S.int)),
    perUserHomeTimelineCacheMax: s.field("perUserHomeTimelineCacheMax", S.option(S.int)),
    perUserListTimelineCacheMax: s.field("perUserListTimelineCacheMax", S.option(S.int)),
    enableReactionsBuffering: s.field("enableReactionsBuffering", S.option(S.bool)),
    notesPerOneAd: s.field("notesPerOneAd", S.option(S.int)),
    silencedHosts: s.field("silencedHosts", S.option(S.json)),
    mediaSilencedHosts: s.field("mediaSilencedHosts", S.option(S.json)),
    summalyProxy: s.field("summalyProxy", S.option(S.string)),
    urlPreviewEnabled: s.field("urlPreviewEnabled", S.option(S.bool)),
    urlPreviewAllowRedirect: s.field("urlPreviewAllowRedirect", S.option(S.bool)),
    urlPreviewTimeout: s.field("urlPreviewTimeout", S.option(S.int)),
    urlPreviewMaximumContentLength: s.field("urlPreviewMaximumContentLength", S.option(S.int)),
    urlPreviewRequireContentLength: s.field("urlPreviewRequireContentLength", S.option(S.bool)),
    urlPreviewUserAgent: s.field("urlPreviewUserAgent", S.option(S.string)),
    urlPreviewSummaryProxyUrl: s.field("urlPreviewSummaryProxyUrl", S.option(S.string)),
    federation: s.field("federation", S.option(S.string)),
    federationHosts: s.field("federationHosts", S.option(S.array(S.string))),
    deliverSuspendedSoftware: s.field("deliverSuspendedSoftware", S.option(S.array(postAdminUpdateMetaRequest_1Schema))),
    singleUserMode: s.field("singleUserMode", S.option(S.bool)),
    ugcVisibilityForVisitor: s.field("ugcVisibilityForVisitor", S.option(S.string)),
    proxyRemoteFiles: s.field("proxyRemoteFiles", S.option(S.bool)),
    signToActivityPubGet: s.field("signToActivityPubGet", S.option(S.bool)),
    allowExternalApRedirect: s.field("allowExternalApRedirect", S.option(S.bool)),
    enableRemoteNotesCleaning: s.field("enableRemoteNotesCleaning", S.option(S.bool)),
    remoteNotesCleaningExpiryDaysForEachNotes: s.field("remoteNotesCleaningExpiryDaysForEachNotes", S.option(S.float)),
    remoteNotesCleaningMaxProcessingDurationInMinutes: s.field("remoteNotesCleaningMaxProcessingDurationInMinutes", S.option(S.float)),
    showRoleBadgesOfRemoteUsers: s.field("showRoleBadgesOfRemoteUsers", S.option(S.bool)),
    doNotSendNotificationEmailsForAbuseReport: s.field("doNotSendNotificationEmailsForAbuseReport", S.option(S.bool)),
    emailToReceiveAbuseReport: s.field("emailToReceiveAbuseReport", S.option(S.string)),
    enableReceivePrerelease: s.field("enableReceivePrerelease", S.option(S.bool)),
    skipVersion: s.field("skipVersion", S.option(S.bool)),
    skipCherryPickVersion: s.field("skipCherryPickVersion", S.option(S.string)),
    trustedLinkUrlPatterns: s.field("trustedLinkUrlPatterns", S.option(S.json)),
    customSplashText: s.field("customSplashText", S.option(S.json)),
    disableRegistrationWhenInactive: s.field("disableRegistrationWhenInactive", S.option(S.bool)),
    disablePublicNoteWhenInactive: s.field("disablePublicNoteWhenInactive", S.option(S.bool)),
    moderatorInactivityLimitDays: s.field("moderatorInactivityLimitDays", S.option(S.int)),
    bubbleInstances: s.field("bubbleInstances", S.option(S.array(S.string))),
    customRobotsTxt: s.field("customRobotsTxt", S.option(S.string)),
  })

type postAdminUpdateMetaResponse = unit

/**
admin/update-meta

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:meta*
*/
let postAdminUpdateMeta = async (~body: postAdminUpdateMetaRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminUpdateMetaResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateMetaRequestSchema)
  let response = await fetch(
    ~url="/admin/update-meta",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminUpdateProxyAccountRequest = {
  description: option<string>,
}

let postAdminUpdateProxyAccountRequestSchema = S.object(s => {
    description: s.field("description", S.option(S.string->S.min(1)->S.max(1500))),
  })

type postAdminUpdateProxyAccountResponse = KokonectLinkComponentSchemas.UserDetailed.t

let postAdminUpdateProxyAccountResponseSchema = KokonectLinkComponentSchemas.UserDetailed.schema

/**
admin/update-proxy-account

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:account*
*/
let postAdminUpdateProxyAccount = async (~body: postAdminUpdateProxyAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminUpdateProxyAccountResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateProxyAccountRequestSchema)
  let response = await fetch(
    ~url="/admin/update-proxy-account",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminUpdateProxyAccountResponseSchema)
}

type postV2AdminEmojiListRequest_1 = {
  updatedAtFrom: option<string>,
  updatedAtTo: option<string>,
  name: option<string>,
  host: option<string>,
  uri: option<string>,
  publicUrl: option<string>,
  originalUrl: option<string>,
  @as("type") type_: option<string>,
  aliases: option<string>,
  category: option<string>,
  license: option<string>,
  isSensitive: option<bool>,
  localOnly: option<bool>,
  hostType: option<string>,
  roleIds: option<array<string>>,
}

type postV2AdminEmojiListRequest = {
  query: option<postV2AdminEmojiListRequest_1>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
  page: option<int>,
  sortKeys: option<array<string>>,
}

let postV2AdminEmojiListRequest_1Schema = S.object(s => {
    updatedAtFrom: s.field("updatedAtFrom", S.option(S.string)),
    updatedAtTo: s.field("updatedAtTo", S.option(S.string)),
    name: s.field("name", S.option(S.string)),
    host: s.field("host", S.option(S.string)),
    uri: s.field("uri", S.option(S.string)),
    publicUrl: s.field("publicUrl", S.option(S.string)),
    originalUrl: s.field("originalUrl", S.option(S.string)),
    type_: s.field("type", S.option(S.string)),
    aliases: s.field("aliases", S.option(S.string)),
    category: s.field("category", S.option(S.string)),
    license: s.field("license", S.option(S.string)),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
    localOnly: s.field("localOnly", S.option(S.bool)),
    hostType: s.field("hostType", S.option(S.string)),
    roleIds: s.field("roleIds", S.option(S.array(S.string))),
  })

let postV2AdminEmojiListRequestSchema = S.object(s => {
    query: s.field("query", S.option(postV2AdminEmojiListRequest_1Schema)),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    page: s.field("page", S.option(S.int)),
    sortKeys: s.field("sortKeys", S.option(S.array(S.string))),
  })

type postV2AdminEmojiListResponse = {
  emojis: array<KokonectLinkComponentSchemas.EmojiDetailedAdmin.t>,
  count: int,
  allCount: int,
  allPages: int,
}

let postV2AdminEmojiListResponseSchema = S.object(s => {
    emojis: s.field("emojis", S.array(KokonectLinkComponentSchemas.EmojiDetailedAdmin.schema)),
    count: s.field("count", S.int),
    allCount: s.field("allCount", S.int),
    allPages: s.field("allPages", S.int),
  })

/**
v2/admin/emoji/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:emoji*
*/
let postV2AdminEmojiList = async (~body: postV2AdminEmojiListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postV2AdminEmojiListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postV2AdminEmojiListRequestSchema)
  let response = await fetch(
    ~url="/v2/admin/emoji/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postV2AdminEmojiListResponseSchema)
}
