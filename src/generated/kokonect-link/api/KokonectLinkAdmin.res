// kokonect-link API for admin
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postAdminAbuseReportNotificationRecipientCreateRequest = {
  isActive: bool,
  name: string,
  @as("method") method_: string,
  userId: option<string>,
  systemWebhookId: option<string>,
}

let postAdminAbuseReportNotificationRecipientCreateRequestSchema = S.object(s => {
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    method_: s.field("method", S.string),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    systemWebhookId: s.fieldOr("systemWebhookId", S.nullableAsOption(S.string), None),
  })

type postAdminAbuseReportNotificationRecipientCreateResponse = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientCreateResponseSchema = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.schema

/**
 * admin/abuse-report/notification-recipient/create
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
 */
let postAdminAbuseReportNotificationRecipientCreate = (~body: postAdminAbuseReportNotificationRecipientCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientCreateRequestSchema)
  fetch(
    ~url="/admin/abuse-report/notification-recipient/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAbuseReportNotificationRecipientShowRequest = {
  id: string,
}

let postAdminAbuseReportNotificationRecipientShowRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAbuseReportNotificationRecipientShowResponse = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientShowResponseSchema = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.schema

/**
 * admin/abuse-report/notification-recipient/show
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *read:admin:abuse-report:notification-recipient*
 */
let postAdminAbuseReportNotificationRecipientShow = (~body: postAdminAbuseReportNotificationRecipientShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientShowRequestSchema)
  fetch(
    ~url="/admin/abuse-report/notification-recipient/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAbuseReportNotificationRecipientUpdateRequest = {
  id: string,
  isActive: bool,
  name: string,
  @as("method") method_: string,
  userId: option<string>,
  systemWebhookId: option<string>,
}

let postAdminAbuseReportNotificationRecipientUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    method_: s.field("method", S.string),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    systemWebhookId: s.fieldOr("systemWebhookId", S.nullableAsOption(S.string), None),
  })

type postAdminAbuseReportNotificationRecipientUpdateResponse = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientUpdateResponseSchema = KokonectLinkComponentSchemas.AbuseReportNotificationRecipient.schema

/**
 * admin/abuse-report/notification-recipient/update
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
 */
let postAdminAbuseReportNotificationRecipientUpdate = (~body: postAdminAbuseReportNotificationRecipientUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientUpdateRequestSchema)
  fetch(
    ~url="/admin/abuse-report/notification-recipient/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAbuseUserReportsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  state: option<JSON.t>,
  reporterOrigin: option<string>,
  targetUserOrigin: option<string>,
}

let postAdminAbuseUserReportsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    state: s.fieldOr("state", S.nullableAsOption(S.json), None),
    reporterOrigin: s.fieldOr("reporterOrigin", S.nullableAsOption(S.string), None),
    targetUserOrigin: s.fieldOr("targetUserOrigin", S.nullableAsOption(S.string), None),
  })

type postAdminAbuseUserReportsResponse = array<{
  id: string,
  createdAt: string,
  comment: string,
  resolved: bool,
  reporterId: string,
  targetUserId: string,
  assigneeId: JSON.t,
  reporter: KokonectLinkComponentSchemas.UserDetailedNotMe.t,
  targetUser: KokonectLinkComponentSchemas.UserDetailedNotMe.t,
  assignee: option<KokonectLinkComponentSchemas.UserDetailedNotMe.t>,
  forwarded: bool,
  resolvedAs: JSON.t,
  moderationNote: string,
}>

let postAdminAbuseUserReportsResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    comment: s.field("comment", S.string),
    resolved: s.field("resolved", S.bool),
    reporterId: s.field("reporterId", S.string),
    targetUserId: s.field("targetUserId", S.string),
    assigneeId: s.field("assigneeId", S.json),
    reporter: s.field("reporter", KokonectLinkComponentSchemas.UserDetailedNotMe.schema),
    targetUser: s.field("targetUser", KokonectLinkComponentSchemas.UserDetailedNotMe.schema),
    assignee: s.field("assignee", S.nullableAsOption(KokonectLinkComponentSchemas.UserDetailedNotMe.schema)),
    forwarded: s.field("forwarded", S.bool),
    resolvedAs: s.field("resolvedAs", S.json),
    moderationNote: s.field("moderationNote", S.string),
  }))

/**
 * admin/abuse-user-reports
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:abuse-user-reports*
 */
let postAdminAbuseUserReports = (~body: postAdminAbuseUserReportsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseUserReportsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseUserReportsRequestSchema)
  fetch(
    ~url="/admin/abuse-user-reports",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAbuseUserReportsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAccountsCreateRequest = {
  username: string,
  password: string,
  setupPassword: option<JSON.t>,
}

let postAdminAccountsCreateRequestSchema = S.object(s => {
    username: s.field("username", S.string->S.pattern(%re("/^\\w{1,20}$/"))),
    password: s.field("password", S.string->S.min(1)),
    setupPassword: s.fieldOr("setupPassword", S.nullableAsOption(S.json), None),
  })

type postAdminAccountsCreateResponse = {
  token: string,
}

let postAdminAccountsCreateResponseSchema = S.object(s => {
    token: s.field("token", S.string),
  })

/**
 * admin/accounts/create
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAdminAccountsCreate = (~body: postAdminAccountsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAccountsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsCreateRequestSchema)
  fetch(
    ~url="/admin/accounts/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAccountsCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAccountsDeleteRequest = {
  userId: string,
}

let postAdminAccountsDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminAccountsDeleteResponse = unit

/**
 * admin/accounts/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:account*
 */
let postAdminAccountsDelete = (~body: postAdminAccountsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAccountsDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsDeleteRequestSchema)
  fetch(
    ~url="/admin/accounts/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAccountsFindByEmailRequest = {
  email: string,
}

let postAdminAccountsFindByEmailRequestSchema = S.object(s => {
    email: s.field("email", S.string),
  })

type postAdminAccountsFindByEmailResponse = KokonectLinkComponentSchemas.UserDetailedNotMe.t

let postAdminAccountsFindByEmailResponseSchema = KokonectLinkComponentSchemas.UserDetailedNotMe.schema

/**
 * admin/accounts/find-by-email
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:account*
 */
let postAdminAccountsFindByEmail = (~body: postAdminAccountsFindByEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAccountsFindByEmailResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsFindByEmailRequestSchema)
  fetch(
    ~url="/admin/accounts/find-by-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAccountsFindByEmailResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAdCreateRequest = {
  url: string,
  memo: string,
  place: string,
  priority: string,
  ratio: int,
  expiresAt: int,
  startsAt: int,
  imageUrl: string,
  dayOfWeek: int,
  isSensitive: option<bool>,
}

let postAdminAdCreateRequestSchema = S.object(s => {
    url: s.field("url", S.string->S.min(1)),
    memo: s.field("memo", S.string),
    place: s.field("place", S.string),
    priority: s.field("priority", S.string),
    ratio: s.field("ratio", S.int),
    expiresAt: s.field("expiresAt", S.int),
    startsAt: s.field("startsAt", S.int),
    imageUrl: s.field("imageUrl", S.string->S.min(1)),
    dayOfWeek: s.field("dayOfWeek", S.int),
    isSensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
  })

type postAdminAdCreateResponse = KokonectLinkComponentSchemas.Ad.t

let postAdminAdCreateResponseSchema = KokonectLinkComponentSchemas.Ad.schema

/**
 * admin/ad/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:ad*
 */
let postAdminAdCreate = (~body: postAdminAdCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAdCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdCreateRequestSchema)
  fetch(
    ~url="/admin/ad/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAdCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAdListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  publishing: option<JSON.t>,
}

let postAdminAdListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    publishing: s.fieldOr("publishing", S.nullableAsOption(S.json), None),
  })

type postAdminAdListResponse = array<KokonectLinkComponentSchemas.Ad.t>

let postAdminAdListResponseSchema = S.array(KokonectLinkComponentSchemas.Ad.schema)

/**
 * admin/ad/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:ad*
 */
let postAdminAdList = (~body: postAdminAdListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAdListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdListRequestSchema)
  fetch(
    ~url="/admin/ad/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAdListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAnnouncementsCreateRequest = {
  title: string,
  text: string,
  imageUrl: JSON.t,
  icon: option<string>,
  display: option<string>,
  forExistingUsers: option<bool>,
  silence: option<bool>,
  needConfirmationToRead: option<bool>,
  userId: option<JSON.t>,
}

let postAdminAnnouncementsCreateRequestSchema = S.object(s => {
    title: s.field("title", S.string->S.min(1)),
    text: s.field("text", S.string->S.min(1)),
    imageUrl: s.field("imageUrl", S.json),
    icon: s.fieldOr("icon", S.nullableAsOption(S.string), None),
    display: s.fieldOr("display", S.nullableAsOption(S.string), None),
    forExistingUsers: s.fieldOr("forExistingUsers", S.nullableAsOption(S.bool), None),
    silence: s.fieldOr("silence", S.nullableAsOption(S.bool), None),
    needConfirmationToRead: s.fieldOr("needConfirmationToRead", S.nullableAsOption(S.bool), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.json), None),
  })

type postAdminAnnouncementsCreateResponse = {
  id: string,
  createdAt: string,
  updatedAt: JSON.t,
  title: string,
  text: string,
  imageUrl: JSON.t,
}

let postAdminAnnouncementsCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.json),
    title: s.field("title", S.string),
    text: s.field("text", S.string),
    imageUrl: s.field("imageUrl", S.json),
  })

/**
 * admin/announcements/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:announcements*
 */
let postAdminAnnouncementsCreate = (~body: postAdminAnnouncementsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAnnouncementsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsCreateRequestSchema)
  fetch(
    ~url="/admin/announcements/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAnnouncementsCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAnnouncementsListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  userId: option<JSON.t>,
  status: option<string>,
}

let postAdminAnnouncementsListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.json), None),
    status: s.fieldOr("status", S.nullableAsOption(S.string), None),
  })

type postAdminAnnouncementsListResponse = array<{
  id: string,
  createdAt: string,
  updatedAt: JSON.t,
  text: string,
  title: string,
  icon: JSON.t,
  display: string,
  isActive: bool,
  forExistingUsers: bool,
  silence: bool,
  needConfirmationToRead: bool,
  userId: JSON.t,
  imageUrl: JSON.t,
  reads: float,
}>

let postAdminAnnouncementsListResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.json),
    text: s.field("text", S.string),
    title: s.field("title", S.string),
    icon: s.field("icon", S.json),
    display: s.field("display", S.string),
    isActive: s.field("isActive", S.bool),
    forExistingUsers: s.field("forExistingUsers", S.bool),
    silence: s.field("silence", S.bool),
    needConfirmationToRead: s.field("needConfirmationToRead", S.bool),
    userId: s.field("userId", S.json),
    imageUrl: s.field("imageUrl", S.json),
    reads: s.field("reads", S.float),
  }))

/**
 * admin/announcements/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:announcements*
 */
let postAdminAnnouncementsList = (~body: postAdminAnnouncementsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAnnouncementsListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsListRequestSchema)
  fetch(
    ~url="/admin/announcements/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAnnouncementsListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAnnouncementsUpdateRequest = {
  id: string,
  title: option<string>,
  text: option<string>,
  imageUrl: option<JSON.t>,
  icon: option<string>,
  display: option<string>,
  forExistingUsers: option<bool>,
  silence: option<bool>,
  needConfirmationToRead: option<bool>,
  isActive: option<bool>,
}

let postAdminAnnouncementsUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    title: s.fieldOr("title", S.nullableAsOption(S.string->S.min(1)), None),
    text: s.fieldOr("text", S.nullableAsOption(S.string->S.min(1)), None),
    imageUrl: s.fieldOr("imageUrl", S.nullableAsOption(S.json), None),
    icon: s.fieldOr("icon", S.nullableAsOption(S.string), None),
    display: s.fieldOr("display", S.nullableAsOption(S.string), None),
    forExistingUsers: s.fieldOr("forExistingUsers", S.nullableAsOption(S.bool), None),
    silence: s.fieldOr("silence", S.nullableAsOption(S.bool), None),
    needConfirmationToRead: s.fieldOr("needConfirmationToRead", S.nullableAsOption(S.bool), None),
    isActive: s.fieldOr("isActive", S.nullableAsOption(S.bool), None),
  })

type postAdminAnnouncementsUpdateResponse = unit

/**
 * admin/announcements/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:announcements*
 */
let postAdminAnnouncementsUpdate = (~body: postAdminAnnouncementsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAnnouncementsUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsUpdateRequestSchema)
  fetch(
    ~url="/admin/announcements/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAvatarDecorationsCopyRequest = {
  decorationId: string,
}

let postAdminAvatarDecorationsCopyRequestSchema = S.object(s => {
    decorationId: s.field("decorationId", S.string),
  })

type postAdminAvatarDecorationsCopyResponse = {
  id: string,
}

let postAdminAvatarDecorationsCopyResponseSchema = S.object(s => {
    id: s.field("id", S.string),
  })

/**
 * admin/avatar-decorations/copy
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:avatar-decorations*
 */
let postAdminAvatarDecorationsCopy = (~body: postAdminAvatarDecorationsCopyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAvatarDecorationsCopyResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsCopyRequestSchema)
  fetch(
    ~url="/admin/avatar-decorations/copy",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAvatarDecorationsCopyResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAvatarDecorationsListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  userId: option<JSON.t>,
}

let postAdminAvatarDecorationsListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.json), None),
  })

type postAdminAvatarDecorationsListResponse = array<{
  id: string,
  createdAt: string,
  updatedAt: JSON.t,
  name: string,
  description: string,
  url: string,
  roleIdsThatCanBeUsedThisDecoration: array<string>,
}>

let postAdminAvatarDecorationsListResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.json),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    url: s.field("url", S.string),
    roleIdsThatCanBeUsedThisDecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.array(S.string)),
  }))

/**
 * admin/avatar-decorations/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:avatar-decorations*
 */
let postAdminAvatarDecorationsList = (~body: postAdminAvatarDecorationsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAvatarDecorationsListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsListRequestSchema)
  fetch(
    ~url="/admin/avatar-decorations/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAvatarDecorationsListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAvatarDecorationsListRemoteRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  userId: option<JSON.t>,
}

let postAdminAvatarDecorationsListRemoteRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.json), None),
  })

type postAdminAvatarDecorationsListRemoteResponse = array<{
  id: string,
  createdAt: string,
  updatedAt: JSON.t,
  name: string,
  description: string,
  url: string,
  roleIdsThatCanBeUsedThisDecoration: array<string>,
}>

let postAdminAvatarDecorationsListRemoteResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.json),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    url: s.field("url", S.string),
    roleIdsThatCanBeUsedThisDecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.array(S.string)),
  }))

/**
 * admin/avatar-decorations/list-remote
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:avatar-decorations*
 */
let postAdminAvatarDecorationsListRemote = (~body: postAdminAvatarDecorationsListRemoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAvatarDecorationsListRemoteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsListRemoteRequestSchema)
  fetch(
    ~url="/admin/avatar-decorations/list-remote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAvatarDecorationsListRemoteResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminDeleteAccountRequest = {
  userId: string,
}

let postAdminDeleteAccountRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminDeleteAccountResponse = unit

/**
 * admin/delete-account
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:delete-account*
 */
let postAdminDeleteAccount = (~body: postAdminDeleteAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDeleteAccountResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDeleteAccountRequestSchema)
  fetch(
    ~url="/admin/delete-account",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminDeleteAllFilesOfAUserRequest = {
  userId: string,
}

let postAdminDeleteAllFilesOfAUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminDeleteAllFilesOfAUserResponse = unit

/**
 * admin/delete-all-files-of-a-user
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:delete-all-files-of-a-user*
 */
let postAdminDeleteAllFilesOfAUser = (~body: postAdminDeleteAllFilesOfAUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDeleteAllFilesOfAUserResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDeleteAllFilesOfAUserRequestSchema)
  fetch(
    ~url="/admin/delete-all-files-of-a-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminDriveFilesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  userId: option<JSON.t>,
  @as("type") type_: option<JSON.t>,
  origin: option<string>,
  hostname: option<JSON.t>,
}

let postAdminDriveFilesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.json), None),
    type_: s.fieldOr("type", S.nullableAsOption(S.json), None),
    origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
    hostname: s.fieldOr("hostname", S.nullableAsOption(S.json), None),
  })

type postAdminDriveFilesResponse = array<KokonectLinkComponentSchemas.DriveFile.t>

let postAdminDriveFilesResponseSchema = S.array(KokonectLinkComponentSchemas.DriveFile.schema)

/**
 * admin/drive/files
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:drive*
 */
let postAdminDriveFiles = (~body: postAdminDriveFilesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDriveFilesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveFilesRequestSchema)
  fetch(
    ~url="/admin/drive/files",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminDriveFilesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminDriveShowFileRequest = [
  | Object({
  fileId: string,
})
  | Object({
  url: string,
})
]

let postAdminDriveShowFileRequestSchema = S.union([S.object(s => {
    fileId: s.field("fileId", S.string),
  }), S.object(s => {
    url: s.field("url", S.string),
  })])

type postAdminDriveShowFileResponse = {
  id: string,
  createdAt: string,
  userId: JSON.t,
  userHost: JSON.t,
  md5: string,
  name: string,
  @as("type") type_: string,
  size: float,
  comment: JSON.t,
  blurhash: JSON.t,
  properties: {
  width: option<float>,
  height: option<float>,
  orientation: option<float>,
  avgColor: option<string>,
},
  storedInternal: JSON.t,
  url: JSON.t,
  thumbnailUrl: JSON.t,
  webpublicUrl: JSON.t,
  accessKey: JSON.t,
  thumbnailAccessKey: JSON.t,
  webpublicAccessKey: JSON.t,
  uri: JSON.t,
  src: JSON.t,
  folderId: JSON.t,
  isSensitive: bool,
  isLink: bool,
  maybeSensitive: bool,
  maybePorn: bool,
  requestIp: JSON.t,
  requestHeaders: JSON.t,
}

let postAdminDriveShowFileResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.json),
    userHost: s.field("userHost", S.json),
    md5: s.field("md5", S.string),
    name: s.field("name", S.string),
    type_: s.field("type", S.string),
    size: s.field("size", S.float),
    comment: s.field("comment", S.json),
    blurhash: s.field("blurhash", S.json),
    properties: s.field("properties", S.object(s => {
    width: s.fieldOr("width", S.nullableAsOption(S.float), None),
    height: s.fieldOr("height", S.nullableAsOption(S.float), None),
    orientation: s.fieldOr("orientation", S.nullableAsOption(S.float), None),
    avgColor: s.fieldOr("avgColor", S.nullableAsOption(S.string), None),
  })),
    storedInternal: s.field("storedInternal", S.json),
    url: s.field("url", S.json),
    thumbnailUrl: s.field("thumbnailUrl", S.json),
    webpublicUrl: s.field("webpublicUrl", S.json),
    accessKey: s.field("accessKey", S.json),
    thumbnailAccessKey: s.field("thumbnailAccessKey", S.json),
    webpublicAccessKey: s.field("webpublicAccessKey", S.json),
    uri: s.field("uri", S.json),
    src: s.field("src", S.json),
    folderId: s.field("folderId", S.json),
    isSensitive: s.field("isSensitive", S.bool),
    isLink: s.field("isLink", S.bool),
    maybeSensitive: s.field("maybeSensitive", S.bool),
    maybePorn: s.field("maybePorn", S.bool),
    requestIp: s.field("requestIp", S.json),
    requestHeaders: s.field("requestHeaders", S.json),
  })

/**
 * admin/drive/show-file
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:drive*
 */
let postAdminDriveShowFile = (~body: postAdminDriveShowFileRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDriveShowFileResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveShowFileRequestSchema)
  fetch(
    ~url="/admin/drive/show-file",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminDriveShowFileResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminEmojiAddRequest = {
  name: string,
  fileId: string,
  category: option<JSON.t>,
  aliases: option<array<string>>,
  license: option<JSON.t>,
  isSensitive: option<bool>,
  localOnly: option<bool>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
}

let postAdminEmojiAddRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/"))),
    fileId: s.field("fileId", S.string),
    category: s.fieldOr("category", S.nullableAsOption(S.json), None),
    aliases: s.fieldOr("aliases", S.nullableAsOption(S.array(S.string)), None),
    license: s.fieldOr("license", S.nullableAsOption(S.json), None),
    isSensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
  })

type postAdminEmojiAddResponse = KokonectLinkComponentSchemas.EmojiDetailed.t

let postAdminEmojiAddResponseSchema = KokonectLinkComponentSchemas.EmojiDetailed.schema

/**
 * admin/emoji/add
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiAdd = (~body: postAdminEmojiAddRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiAddResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiAddRequestSchema)
  fetch(
    ~url="/admin/emoji/add",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminEmojiAddResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminEmojiListRequest = {
  query: option<JSON.t>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postAdminEmojiListRequestSchema = S.object(s => {
    query: s.fieldOr("query", S.nullableAsOption(S.json), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postAdminEmojiListResponse = array<{
  id: string,
  aliases: array<string>,
  name: string,
  category: JSON.t,
  host: JSON.t,
  url: string,
}>

let postAdminEmojiListResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.json),
    host: s.field("host", S.json),
    url: s.field("url", S.string),
  }))

/**
 * admin/emoji/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:emoji*
 */
let postAdminEmojiList = (~body: postAdminEmojiListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiListRequestSchema)
  fetch(
    ~url="/admin/emoji/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminEmojiListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminEmojiListRemoteRequest = {
  query: option<JSON.t>,
  host: option<JSON.t>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postAdminEmojiListRemoteRequestSchema = S.object(s => {
    query: s.fieldOr("query", S.nullableAsOption(S.json), None),
    host: s.fieldOr("host", S.nullableAsOption(S.json), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postAdminEmojiListRemoteResponse = array<{
  id: string,
  aliases: array<string>,
  name: string,
  category: JSON.t,
  host: JSON.t,
  url: string,
}>

let postAdminEmojiListRemoteResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.json),
    host: s.field("host", S.json),
    url: s.field("url", S.string),
  }))

/**
 * admin/emoji/list-remote
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:emoji*
 */
let postAdminEmojiListRemote = (~body: postAdminEmojiListRemoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiListRemoteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiListRemoteRequestSchema)
  fetch(
    ~url="/admin/emoji/list-remote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminEmojiListRemoteResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminEmojiStealRequest = {
  name: string,
  host: string,
}

let postAdminEmojiStealRequestSchema = S.object(s => {
    name: s.field("name", S.string),
    host: s.field("host", S.string),
  })

type postAdminEmojiStealResponse = {
  id: string,
}

let postAdminEmojiStealResponseSchema = S.object(s => {
    id: s.field("id", S.string),
  })

/**
 * admin/emoji/steal
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiSteal = (~body: postAdminEmojiStealRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiStealResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiStealRequestSchema)
  fetch(
    ~url="/admin/emoji/steal",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminEmojiStealResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminEmojiUpdateRequest = {
  fileId: option<string>,
  category: option<JSON.t>,
  aliases: option<array<string>>,
  license: option<JSON.t>,
  isSensitive: option<bool>,
  localOnly: option<bool>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
}

let postAdminEmojiUpdateRequestSchema = S.object(s => {
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.string), None),
    category: s.fieldOr("category", S.nullableAsOption(S.json), None),
    aliases: s.fieldOr("aliases", S.nullableAsOption(S.array(S.string)), None),
    license: s.fieldOr("license", S.nullableAsOption(S.json), None),
    isSensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
  })

type postAdminEmojiUpdateResponse = unit

/**
 * admin/emoji/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiUpdate = (~body: postAdminEmojiUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiUpdateRequestSchema)
  fetch(
    ~url="/admin/emoji/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminInviteRevokeResponse = unit

/**
 * admin/invite/revoke
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:invite-codes*
 */
let postAdminInviteRevoke = (~body as _, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminInviteRevokeResponse> => {

  fetch(
    ~url="/admin/invite/revoke",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminQueueClearRequest = {
  queue: string,
  state: string,
}

let postAdminQueueClearRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    state: s.field("state", S.string),
  })

type postAdminQueueClearResponse = unit

/**
 * admin/queue/clear
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:queue*
 */
let postAdminQueueClear = (~body: postAdminQueueClearRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueClearResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueClearRequestSchema)
  fetch(
    ~url="/admin/queue/clear",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminQueueJobsRequest = {
  queue: string,
  state: array<string>,
  search: option<string>,
}

let postAdminQueueJobsRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    state: s.field("state", S.array(S.string)),
    search: s.fieldOr("search", S.nullableAsOption(S.string), None),
  })

type postAdminQueueJobsResponse = array<KokonectLinkComponentSchemas.QueueJob.t>

let postAdminQueueJobsResponseSchema = S.array(KokonectLinkComponentSchemas.QueueJob.schema)

/**
 * admin/queue/jobs
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
 */
let postAdminQueueJobs = (~body: postAdminQueueJobsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueJobsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueJobsRequestSchema)
  fetch(
    ~url="/admin/queue/jobs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminQueueJobsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminQueuePromoteJobsRequest = {
  queue: string,
}

let postAdminQueuePromoteJobsRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
  })

type postAdminQueuePromoteJobsResponse = unit

/**
 * admin/queue/promote-jobs
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:queue*
 */
let postAdminQueuePromoteJobs = (~body: postAdminQueuePromoteJobsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueuePromoteJobsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueuePromoteJobsRequestSchema)
  fetch(
    ~url="/admin/queue/promote-jobs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminQueueQueueStatsRequest = {
  queue: string,
}

let postAdminQueueQueueStatsRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
  })

type postAdminQueueQueueStatsResponse = {
  name: string,
  qualifiedName: string,
  counts: JSON.t,
  isPaused: bool,
  metrics: {
  completed: KokonectLinkComponentSchemas.QueueMetrics.t,
  failed: KokonectLinkComponentSchemas.QueueMetrics.t,
},
  db: {
  version: string,
  mode: string,
  runId: string,
  processId: string,
  port: float,
  os: string,
  uptime: float,
  memory: {
  total: float,
  used: float,
  fragmentationRatio: float,
  peak: float,
},
  clients: {
  blocked: float,
  connected: float,
},
},
}

let postAdminQueueQueueStatsResponseSchema = S.object(s => {
    name: s.field("name", S.string),
    qualifiedName: s.field("qualifiedName", S.string),
    counts: s.field("counts", S.json),
    isPaused: s.field("isPaused", S.bool),
    metrics: s.field("metrics", S.object(s => {
    completed: s.field("completed", KokonectLinkComponentSchemas.QueueMetrics.schema),
    failed: s.field("failed", KokonectLinkComponentSchemas.QueueMetrics.schema),
  })),
    db: s.field("db", S.object(s => {
    version: s.field("version", S.string),
    mode: s.field("mode", S.string),
    runId: s.field("runId", S.string),
    processId: s.field("processId", S.string),
    port: s.field("port", S.float),
    os: s.field("os", S.string),
    uptime: s.field("uptime", S.float),
    memory: s.field("memory", S.object(s => {
    total: s.field("total", S.float),
    used: s.field("used", S.float),
    fragmentationRatio: s.field("fragmentationRatio", S.float),
    peak: s.field("peak", S.float),
  })),
    clients: s.field("clients", S.object(s => {
    blocked: s.field("blocked", S.float),
    connected: s.field("connected", S.float),
  })),
  })),
  })

/**
 * admin/queue/queue-stats
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
 */
let postAdminQueueQueueStats = (~body: postAdminQueueQueueStatsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueQueueStatsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueQueueStatsRequestSchema)
  fetch(
    ~url="/admin/queue/queue-stats",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminQueueQueueStatsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminQueueQueuesResponse = array<{
  name: string,
  counts: JSON.t,
  isPaused: bool,
  metrics: {
  completed: KokonectLinkComponentSchemas.QueueMetrics.t,
  failed: KokonectLinkComponentSchemas.QueueMetrics.t,
},
}>

let postAdminQueueQueuesResponseSchema = S.array(S.object(s => {
    name: s.field("name", S.string),
    counts: s.field("counts", S.json),
    isPaused: s.field("isPaused", S.bool),
    metrics: s.field("metrics", S.object(s => {
    completed: s.field("completed", KokonectLinkComponentSchemas.QueueMetrics.schema),
    failed: s.field("failed", KokonectLinkComponentSchemas.QueueMetrics.schema),
  })),
  }))

/**
 * admin/queue/queues
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
 */
let postAdminQueueQueues = (~body as _, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueQueuesResponse> => {

  fetch(
    ~url="/admin/queue/queues",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminQueueQueuesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminQueueRemoveJobRequest = {
  queue: string,
  jobId: string,
}

let postAdminQueueRemoveJobRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    jobId: s.field("jobId", S.string),
  })

type postAdminQueueRemoveJobResponse = unit

/**
 * admin/queue/remove-job
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:queue*
 */
let postAdminQueueRemoveJob = (~body: postAdminQueueRemoveJobRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueRemoveJobResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueRemoveJobRequestSchema)
  fetch(
    ~url="/admin/queue/remove-job",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminQueueRetryJobRequest = {
  queue: string,
  jobId: string,
}

let postAdminQueueRetryJobRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    jobId: s.field("jobId", S.string),
  })

type postAdminQueueRetryJobResponse = unit

/**
 * admin/queue/retry-job
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:queue*
 */
let postAdminQueueRetryJob = (~body: postAdminQueueRetryJobRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueRetryJobResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueRetryJobRequestSchema)
  fetch(
    ~url="/admin/queue/retry-job",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminQueueShowJobRequest = {
  queue: string,
  jobId: string,
}

let postAdminQueueShowJobRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    jobId: s.field("jobId", S.string),
  })

type postAdminQueueShowJobResponse = KokonectLinkComponentSchemas.QueueJob.t

let postAdminQueueShowJobResponseSchema = KokonectLinkComponentSchemas.QueueJob.schema

/**
 * admin/queue/show-job
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
 */
let postAdminQueueShowJob = (~body: postAdminQueueShowJobRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueShowJobResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueShowJobRequestSchema)
  fetch(
    ~url="/admin/queue/show-job",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminQueueShowJobResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminQueueShowJobLogsRequest = {
  queue: string,
  jobId: string,
}

let postAdminQueueShowJobLogsRequestSchema = S.object(s => {
    queue: s.field("queue", S.string),
    jobId: s.field("jobId", S.string),
  })

type postAdminQueueShowJobLogsResponse = array<string>

let postAdminQueueShowJobLogsResponseSchema = S.array(S.string)

/**
 * admin/queue/show-job-logs
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
 */
let postAdminQueueShowJobLogs = (~body: postAdminQueueShowJobLogsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueShowJobLogsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueShowJobLogsRequestSchema)
  fetch(
    ~url="/admin/queue/show-job-logs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminQueueShowJobLogsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminResolveAbuseUserReportRequest = {
  reportId: string,
  resolvedAs: option<JSON.t>,
}

let postAdminResolveAbuseUserReportRequestSchema = S.object(s => {
    reportId: s.field("reportId", S.string),
    resolvedAs: s.fieldOr("resolvedAs", S.nullableAsOption(S.json), None),
  })

type postAdminResolveAbuseUserReportResponse = unit

/**
 * admin/resolve-abuse-user-report
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:resolve-abuse-user-report*
 */
let postAdminResolveAbuseUserReport = (~body: postAdminResolveAbuseUserReportRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminResolveAbuseUserReportResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminResolveAbuseUserReportRequestSchema)
  fetch(
    ~url="/admin/resolve-abuse-user-report",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminRolesAssignRequest = {
  roleId: string,
  userId: string,
  expiresAt: option<JSON.t>,
}

let postAdminRolesAssignRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    userId: s.field("userId", S.string),
    expiresAt: s.fieldOr("expiresAt", S.nullableAsOption(S.json), None),
  })

type postAdminRolesAssignResponse = unit

/**
 * admin/roles/assign
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
 */
let postAdminRolesAssign = (~body: postAdminRolesAssignRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesAssignResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesAssignRequestSchema)
  fetch(
    ~url="/admin/roles/assign",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminRolesCreateRequest = {
  name: string,
  description: string,
  color: JSON.t,
  iconUrl: JSON.t,
  target: string,
  condFormula: JSON.t,
  isPublic: bool,
  isModerator: bool,
  isAdministrator: bool,
  isExplorable: option<bool>,
  asBadge: bool,
  preserveAssignmentOnMoveAccount: option<bool>,
  canEditMembersByModerator: bool,
  displayOrder: float,
  policies: JSON.t,
}

let postAdminRolesCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    color: s.field("color", S.json),
    iconUrl: s.field("iconUrl", S.json),
    target: s.field("target", S.string),
    condFormula: s.field("condFormula", S.json),
    isPublic: s.field("isPublic", S.bool),
    isModerator: s.field("isModerator", S.bool),
    isAdministrator: s.field("isAdministrator", S.bool),
    isExplorable: s.fieldOr("isExplorable", S.nullableAsOption(S.bool), None),
    asBadge: s.field("asBadge", S.bool),
    preserveAssignmentOnMoveAccount: s.fieldOr("preserveAssignmentOnMoveAccount", S.nullableAsOption(S.bool), None),
    canEditMembersByModerator: s.field("canEditMembersByModerator", S.bool),
    displayOrder: s.field("displayOrder", S.float),
    policies: s.field("policies", S.json),
  })

type postAdminRolesCreateResponse = KokonectLinkComponentSchemas.Role.t

let postAdminRolesCreateResponseSchema = KokonectLinkComponentSchemas.Role.schema

/**
 * admin/roles/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
 */
let postAdminRolesCreate = (~body: postAdminRolesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesCreateRequestSchema)
  fetch(
    ~url="/admin/roles/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminRolesCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminRolesShowRequest = {
  roleId: string,
}

let postAdminRolesShowRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
  })

type postAdminRolesShowResponse = KokonectLinkComponentSchemas.Role.t

let postAdminRolesShowResponseSchema = KokonectLinkComponentSchemas.Role.schema

/**
 * admin/roles/show
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:roles*
 */
let postAdminRolesShow = (~body: postAdminRolesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesShowRequestSchema)
  fetch(
    ~url="/admin/roles/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminRolesShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminRolesUpdateRequest = {
  roleId: string,
  name: option<string>,
  description: option<string>,
  color: option<JSON.t>,
  iconUrl: option<JSON.t>,
  target: option<string>,
  condFormula: option<JSON.t>,
  isPublic: option<bool>,
  isModerator: option<bool>,
  isAdministrator: option<bool>,
  isExplorable: option<bool>,
  asBadge: option<bool>,
  preserveAssignmentOnMoveAccount: option<bool>,
  canEditMembersByModerator: option<bool>,
  displayOrder: option<float>,
  policies: option<JSON.t>,
}

let postAdminRolesUpdateRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    description: s.fieldOr("description", S.nullableAsOption(S.string), None),
    color: s.fieldOr("color", S.nullableAsOption(S.json), None),
    iconUrl: s.fieldOr("iconUrl", S.nullableAsOption(S.json), None),
    target: s.fieldOr("target", S.nullableAsOption(S.string), None),
    condFormula: s.fieldOr("condFormula", S.nullableAsOption(S.json), None),
    isPublic: s.fieldOr("isPublic", S.nullableAsOption(S.bool), None),
    isModerator: s.fieldOr("isModerator", S.nullableAsOption(S.bool), None),
    isAdministrator: s.fieldOr("isAdministrator", S.nullableAsOption(S.bool), None),
    isExplorable: s.fieldOr("isExplorable", S.nullableAsOption(S.bool), None),
    asBadge: s.fieldOr("asBadge", S.nullableAsOption(S.bool), None),
    preserveAssignmentOnMoveAccount: s.fieldOr("preserveAssignmentOnMoveAccount", S.nullableAsOption(S.bool), None),
    canEditMembersByModerator: s.fieldOr("canEditMembersByModerator", S.nullableAsOption(S.bool), None),
    displayOrder: s.fieldOr("displayOrder", S.nullableAsOption(S.float), None),
    policies: s.fieldOr("policies", S.nullableAsOption(S.json), None),
  })

type postAdminRolesUpdateResponse = unit

/**
 * admin/roles/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
 */
let postAdminRolesUpdate = (~body: postAdminRolesUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUpdateRequestSchema)
  fetch(
    ~url="/admin/roles/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminRolesUsersRequest = {
  roleId: string,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postAdminRolesUsersRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postAdminRolesUsersResponse = array<{
  id: string,
  createdAt: string,
  user: KokonectLinkComponentSchemas.UserDetailed.t,
  expiresAt: JSON.t,
}>

let postAdminRolesUsersResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    user: s.field("user", KokonectLinkComponentSchemas.UserDetailed.schema),
    expiresAt: s.field("expiresAt", S.json),
  }))

/**
 * admin/roles/users
 *
 * No description provided.
 *
 * **Credential required**: *No* / **Permission**: *read:admin:roles*
 */
let postAdminRolesUsers = (~body: postAdminRolesUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUsersRequestSchema)
  fetch(
    ~url="/admin/roles/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminRolesUsersResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminServerInfoResponse = {
  machine: string,
  os: string,
  node: string,
  psql: string,
  cpu: {
  model: string,
  cores: float,
},
  mem: {
  total: float,
},
  fs: {
  total: float,
  used: float,
},
  net: {
  interface: string,
},
}

let postAdminServerInfoResponseSchema = S.object(s => {
    machine: s.field("machine", S.string),
    os: s.field("os", S.string),
    node: s.field("node", S.string),
    psql: s.field("psql", S.string),
    cpu: s.field("cpu", S.object(s => {
    model: s.field("model", S.string),
    cores: s.field("cores", S.float),
  })),
    mem: s.field("mem", S.object(s => {
    total: s.field("total", S.float),
  })),
    fs: s.field("fs", S.object(s => {
    total: s.field("total", S.float),
    used: s.field("used", S.float),
  })),
    net: s.field("net", S.object(s => {
    interface: s.field("interface", S.string),
  })),
  })

/**
 * admin/server-info
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:server-info*
 */
let postAdminServerInfo = (~body as _, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminServerInfoResponse> => {

  fetch(
    ~url="/admin/server-info",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminServerInfoResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminShowModerationLogsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  @as("type") type_: option<JSON.t>,
  userId: option<JSON.t>,
  search: option<JSON.t>,
}

let postAdminShowModerationLogsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    type_: s.fieldOr("type", S.nullableAsOption(S.json), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.json), None),
    search: s.fieldOr("search", S.nullableAsOption(S.json), None),
  })

type postAdminShowModerationLogsResponse = array<{
  id: string,
  createdAt: string,
  @as("type") type_: string,
  info: JSON.t,
  userId: string,
  user: KokonectLinkComponentSchemas.UserDetailedNotMe.t,
}>

let postAdminShowModerationLogsResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    type_: s.field("type", S.string),
    info: s.field("info", S.json),
    userId: s.field("userId", S.string),
    user: s.field("user", KokonectLinkComponentSchemas.UserDetailedNotMe.schema),
  }))

/**
 * admin/show-moderation-logs
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:show-moderation-log*
 */
let postAdminShowModerationLogs = (~body: postAdminShowModerationLogsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminShowModerationLogsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowModerationLogsRequestSchema)
  fetch(
    ~url="/admin/show-moderation-logs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminShowModerationLogsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminShowUserRequest = {
  userId: string,
}

let postAdminShowUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminShowUserResponse = {
  email: JSON.t,
  emailVerified: bool,
  followedMessage: JSON.t,
  autoAcceptFollowed: bool,
  noCrawle: bool,
  preventAiLearning: bool,
  alwaysMarkNsfw: bool,
  autoSensitive: bool,
  carefulBot: bool,
  injectFeaturedNote: bool,
  receiveAnnouncementEmail: bool,
  mutedWords: array<array<string>>,
  mutedInstances: array<string>,
  notificationRecieveConfig: {
  note: option<JSON.t>,
  follow: option<JSON.t>,
  mention: option<JSON.t>,
  reply: option<JSON.t>,
  renote: option<JSON.t>,
  quote: option<JSON.t>,
  reaction: option<JSON.t>,
  pollEnded: option<JSON.t>,
  scheduledNotePosted: option<JSON.t>,
  scheduledNotePostFailed: option<JSON.t>,
  receiveFollowRequest: option<JSON.t>,
  followRequestAccepted: option<JSON.t>,
  groupInvited: option<JSON.t>,
  roleAssigned: option<JSON.t>,
  chatRoomInvitationReceived: option<JSON.t>,
  achievementEarned: option<JSON.t>,
  app: option<JSON.t>,
  test: option<JSON.t>,
},
  isModerator: bool,
  isSilenced: bool,
  isSuspended: bool,
  isHibernated: bool,
  lastActiveDate: JSON.t,
  moderationNote: string,
  signins: array<KokonectLinkComponentSchemas.Signin.t>,
  policies: KokonectLinkComponentSchemas.RolePolicies.t,
  roles: array<KokonectLinkComponentSchemas.Role.t>,
  roleAssigns: array<{
  createdAt: string,
  expiresAt: JSON.t,
  roleId: string,
}>,
  setFederationAvatarShape: JSON.t,
  isSquareAvatars: JSON.t,
}

let postAdminShowUserResponseSchema = S.object(s => {
    email: s.field("email", S.json),
    emailVerified: s.field("emailVerified", S.bool),
    followedMessage: s.field("followedMessage", S.json),
    autoAcceptFollowed: s.field("autoAcceptFollowed", S.bool),
    noCrawle: s.field("noCrawle", S.bool),
    preventAiLearning: s.field("preventAiLearning", S.bool),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.bool),
    autoSensitive: s.field("autoSensitive", S.bool),
    carefulBot: s.field("carefulBot", S.bool),
    injectFeaturedNote: s.field("injectFeaturedNote", S.bool),
    receiveAnnouncementEmail: s.field("receiveAnnouncementEmail", S.bool),
    mutedWords: s.field("mutedWords", S.array(S.array(S.string))),
    mutedInstances: s.field("mutedInstances", S.array(S.string)),
    notificationRecieveConfig: s.field("notificationRecieveConfig", S.object(s => {
    note: s.fieldOr("note", S.nullableAsOption(S.json), None),
    follow: s.fieldOr("follow", S.nullableAsOption(S.json), None),
    mention: s.fieldOr("mention", S.nullableAsOption(S.json), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.json), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.json), None),
    quote: s.fieldOr("quote", S.nullableAsOption(S.json), None),
    reaction: s.fieldOr("reaction", S.nullableAsOption(S.json), None),
    pollEnded: s.fieldOr("pollEnded", S.nullableAsOption(S.json), None),
    scheduledNotePosted: s.fieldOr("scheduledNotePosted", S.nullableAsOption(S.json), None),
    scheduledNotePostFailed: s.fieldOr("scheduledNotePostFailed", S.nullableAsOption(S.json), None),
    receiveFollowRequest: s.fieldOr("receiveFollowRequest", S.nullableAsOption(S.json), None),
    followRequestAccepted: s.fieldOr("followRequestAccepted", S.nullableAsOption(S.json), None),
    groupInvited: s.fieldOr("groupInvited", S.nullableAsOption(S.json), None),
    roleAssigned: s.fieldOr("roleAssigned", S.nullableAsOption(S.json), None),
    chatRoomInvitationReceived: s.fieldOr("chatRoomInvitationReceived", S.nullableAsOption(S.json), None),
    achievementEarned: s.fieldOr("achievementEarned", S.nullableAsOption(S.json), None),
    app: s.fieldOr("app", S.nullableAsOption(S.json), None),
    test: s.fieldOr("test", S.nullableAsOption(S.json), None),
  })),
    isModerator: s.field("isModerator", S.bool),
    isSilenced: s.field("isSilenced", S.bool),
    isSuspended: s.field("isSuspended", S.bool),
    isHibernated: s.field("isHibernated", S.bool),
    lastActiveDate: s.field("lastActiveDate", S.json),
    moderationNote: s.field("moderationNote", S.string),
    signins: s.field("signins", S.array(KokonectLinkComponentSchemas.Signin.schema)),
    policies: s.field("policies", KokonectLinkComponentSchemas.RolePolicies.schema),
    roles: s.field("roles", S.array(KokonectLinkComponentSchemas.Role.schema)),
    roleAssigns: s.field("roleAssigns", S.array(S.object(s => {
    createdAt: s.field("createdAt", S.string),
    expiresAt: s.field("expiresAt", S.json),
    roleId: s.field("roleId", S.string),
  }))),
    setFederationAvatarShape: s.field("setFederationAvatarShape", S.json),
    isSquareAvatars: s.field("isSquareAvatars", S.json),
  })

/**
 * admin/show-user
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:show-user*
 */
let postAdminShowUser = (~body: postAdminShowUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminShowUserResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowUserRequestSchema)
  fetch(
    ~url="/admin/show-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminShowUserResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminSystemWebhookCreateRequest = {
  isActive: bool,
  name: string,
  on: array<string>,
  url: string,
  secret: option<string>,
}

let postAdminSystemWebhookCreateRequestSchema = S.object(s => {
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string->S.min(1)->S.max(1024)),
    secret: s.fieldOr("secret", S.nullableAsOption(S.string->S.max(1024)), None),
  })

type postAdminSystemWebhookCreateResponse = KokonectLinkComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookCreateResponseSchema = KokonectLinkComponentSchemas.SystemWebhook.schema

/**
 * admin/system-webhook/create
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
 */
let postAdminSystemWebhookCreate = (~body: postAdminSystemWebhookCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookCreateRequestSchema)
  fetch(
    ~url="/admin/system-webhook/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminSystemWebhookCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminSystemWebhookShowRequest = {
  id: string,
}

let postAdminSystemWebhookShowRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminSystemWebhookShowResponse = KokonectLinkComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookShowResponseSchema = KokonectLinkComponentSchemas.SystemWebhook.schema

/**
 * admin/system-webhook/show
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
 */
let postAdminSystemWebhookShow = (~body: postAdminSystemWebhookShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookShowRequestSchema)
  fetch(
    ~url="/admin/system-webhook/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminSystemWebhookShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminSystemWebhookUpdateRequest = {
  id: string,
  isActive: bool,
  name: string,
  on: array<string>,
  url: string,
  secret: option<string>,
}

let postAdminSystemWebhookUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string->S.min(1)->S.max(1024)),
    secret: s.fieldOr("secret", S.nullableAsOption(S.string->S.max(1024)), None),
  })

type postAdminSystemWebhookUpdateResponse = KokonectLinkComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookUpdateResponseSchema = KokonectLinkComponentSchemas.SystemWebhook.schema

/**
 * admin/system-webhook/update
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
 */
let postAdminSystemWebhookUpdate = (~body: postAdminSystemWebhookUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookUpdateRequestSchema)
  fetch(
    ~url="/admin/system-webhook/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminSystemWebhookUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminUpdateMetaRequest = {
  disableRegistration: option<JSON.t>,
  pinnedUsers: option<JSON.t>,
  hiddenTags: option<JSON.t>,
  blockedHosts: option<JSON.t>,
  sensitiveWords: option<JSON.t>,
  prohibitedWords: option<JSON.t>,
  prohibitedWordsForNameOfUser: option<JSON.t>,
  themeColor: option<JSON.t>,
  mascotImageUrl: option<JSON.t>,
  bannerUrl: option<JSON.t>,
  serverErrorImageUrl: option<JSON.t>,
  infoImageUrl: option<JSON.t>,
  notFoundImageUrl: option<JSON.t>,
  youBlockedImageUrl: option<JSON.t>,
  iconUrl: option<JSON.t>,
  @as("app192IconUrl") app192iconUrl: option<JSON.t>,
  @as("app512IconUrl") app512iconUrl: option<JSON.t>,
  backgroundImageUrl: option<JSON.t>,
  logoImageUrl: option<JSON.t>,
  name: option<JSON.t>,
  shortName: option<JSON.t>,
  description: option<JSON.t>,
  defaultLightTheme: option<JSON.t>,
  defaultDarkTheme: option<JSON.t>,
  clientOptions: option<JSON.t>,
  cacheRemoteFiles: option<bool>,
  cacheRemoteSensitiveFiles: option<bool>,
  emailRequiredForSignup: option<bool>,
  enableHcaptcha: option<bool>,
  hcaptchaSiteKey: option<JSON.t>,
  hcaptchaSecretKey: option<JSON.t>,
  enableMcaptcha: option<bool>,
  mcaptchaSiteKey: option<JSON.t>,
  mcaptchaInstanceUrl: option<JSON.t>,
  mcaptchaSecretKey: option<JSON.t>,
  enableRecaptcha: option<bool>,
  recaptchaSiteKey: option<JSON.t>,
  recaptchaSecretKey: option<JSON.t>,
  enableTurnstile: option<bool>,
  turnstileSiteKey: option<JSON.t>,
  turnstileSecretKey: option<JSON.t>,
  enableTestcaptcha: option<bool>,
  googleAnalyticsMeasurementId: option<JSON.t>,
  sensitiveMediaDetection: option<string>,
  sensitiveMediaDetectionSensitivity: option<string>,
  setSensitiveFlagAutomatically: option<bool>,
  enableSensitiveMediaDetectionForVideos: option<bool>,
  maintainerName: option<JSON.t>,
  maintainerEmail: option<JSON.t>,
  langs: option<array<string>>,
  translatorType: option<JSON.t>,
  deeplAuthKey: option<JSON.t>,
  deeplIsPro: option<bool>,
  @as("ctav3SaKey") ctav3saKey: option<JSON.t>,
  @as("ctav3ProjectId") ctav3projectId: option<JSON.t>,
  @as("ctav3Location") ctav3location: option<JSON.t>,
  @as("ctav3Model") ctav3model: option<JSON.t>,
  @as("ctav3Glossary") ctav3glossary: option<JSON.t>,
  libreTranslateEndPoint: option<JSON.t>,
  libreTranslateApiKey: option<JSON.t>,
  enableEmail: option<bool>,
  email: option<JSON.t>,
  smtpSecure: option<bool>,
  smtpHost: option<JSON.t>,
  smtpPort: option<JSON.t>,
  smtpUser: option<JSON.t>,
  smtpPass: option<JSON.t>,
  enableServiceWorker: option<bool>,
  swPublicKey: option<JSON.t>,
  swPrivateKey: option<JSON.t>,
  tosUrl: option<JSON.t>,
  repositoryUrl: option<JSON.t>,
  feedbackUrl: option<JSON.t>,
  impressumUrl: option<JSON.t>,
  privacyPolicyUrl: option<JSON.t>,
  inquiryUrl: option<JSON.t>,
  useObjectStorage: option<bool>,
  objectStorageBaseUrl: option<JSON.t>,
  objectStorageBucket: option<JSON.t>,
  objectStoragePrefix: option<JSON.t>,
  objectStorageEndpoint: option<JSON.t>,
  objectStorageRegion: option<JSON.t>,
  objectStoragePort: option<JSON.t>,
  objectStorageAccessKey: option<JSON.t>,
  objectStorageSecretKey: option<JSON.t>,
  @as("objectStorageUseSSL") objectStorageUseSsl: option<bool>,
  objectStorageUseProxy: option<bool>,
  objectStorageSetPublicRead: option<bool>,
  @as("objectStorageS3ForcePathStyle") objectStorageS3forcePathStyle: option<bool>,
  useRemoteObjectStorage: option<bool>,
  remoteObjectStorageBaseUrl: option<JSON.t>,
  remoteObjectStorageBucket: option<JSON.t>,
  remoteObjectStoragePrefix: option<JSON.t>,
  remoteObjectStorageEndpoint: option<JSON.t>,
  remoteObjectStorageRegion: option<JSON.t>,
  remoteObjectStoragePort: option<JSON.t>,
  remoteObjectStorageAccessKey: option<JSON.t>,
  remoteObjectStorageSecretKey: option<JSON.t>,
  @as("remoteObjectStorageUseSSL") remoteObjectStorageUseSsl: option<bool>,
  remoteObjectStorageUseProxy: option<bool>,
  remoteObjectStorageSetPublicRead: option<bool>,
  @as("remoteObjectStorageS3ForcePathStyle") remoteObjectStorageS3forcePathStyle: option<bool>,
  enableIpLogging: option<bool>,
  enableActiveEmailValidation: option<bool>,
  enableVerifymailApi: option<bool>,
  verifymailAuthKey: option<JSON.t>,
  enableTruemailApi: option<bool>,
  truemailInstance: option<JSON.t>,
  truemailAuthKey: option<JSON.t>,
  enableChartsForRemoteUser: option<bool>,
  enableChartsForFederatedInstances: option<bool>,
  enableStatsForFederatedInstances: option<bool>,
  enableServerMachineStats: option<bool>,
  enableIdenticonGeneration: option<bool>,
  serverRules: option<array<string>>,
  bannedEmailDomains: option<array<string>>,
  preservedUsernames: option<array<string>>,
  manifestJsonOverride: option<string>,
  enableFanoutTimeline: option<bool>,
  enableFanoutTimelineDbFallback: option<bool>,
  perLocalUserUserTimelineCacheMax: option<int>,
  perRemoteUserUserTimelineCacheMax: option<int>,
  perUserHomeTimelineCacheMax: option<int>,
  perUserListTimelineCacheMax: option<int>,
  enableReactionsBuffering: option<bool>,
  notesPerOneAd: option<int>,
  silencedHosts: option<JSON.t>,
  mediaSilencedHosts: option<JSON.t>,
  summalyProxy: option<JSON.t>,
  urlPreviewEnabled: option<bool>,
  urlPreviewAllowRedirect: option<bool>,
  urlPreviewTimeout: option<int>,
  urlPreviewMaximumContentLength: option<int>,
  urlPreviewRequireContentLength: option<bool>,
  urlPreviewUserAgent: option<JSON.t>,
  urlPreviewSummaryProxyUrl: option<JSON.t>,
  federation: option<string>,
  federationHosts: option<array<string>>,
  deliverSuspendedSoftware: option<array<{
  software: string,
  versionRange: string,
}>>,
  singleUserMode: option<bool>,
  ugcVisibilityForVisitor: option<string>,
  proxyRemoteFiles: option<bool>,
  signToActivityPubGet: option<bool>,
  allowExternalApRedirect: option<bool>,
  enableRemoteNotesCleaning: option<bool>,
  remoteNotesCleaningExpiryDaysForEachNotes: option<float>,
  remoteNotesCleaningMaxProcessingDurationInMinutes: option<float>,
  showRoleBadgesOfRemoteUsers: option<bool>,
  doNotSendNotificationEmailsForAbuseReport: option<bool>,
  emailToReceiveAbuseReport: option<JSON.t>,
  enableReceivePrerelease: option<bool>,
  skipVersion: option<bool>,
  skipCherryPickVersion: option<JSON.t>,
  trustedLinkUrlPatterns: option<JSON.t>,
  customSplashText: option<JSON.t>,
  disableRegistrationWhenInactive: option<JSON.t>,
  disablePublicNoteWhenInactive: option<JSON.t>,
  moderatorInactivityLimitDays: option<int>,
  bubbleInstances: option<array<string>>,
  customRobotsTxt: option<JSON.t>,
}

let postAdminUpdateMetaRequestSchema = S.object(s => {
    disableRegistration: s.fieldOr("disableRegistration", S.nullableAsOption(S.json), None),
    pinnedUsers: s.fieldOr("pinnedUsers", S.nullableAsOption(S.json), None),
    hiddenTags: s.fieldOr("hiddenTags", S.nullableAsOption(S.json), None),
    blockedHosts: s.fieldOr("blockedHosts", S.nullableAsOption(S.json), None),
    sensitiveWords: s.fieldOr("sensitiveWords", S.nullableAsOption(S.json), None),
    prohibitedWords: s.fieldOr("prohibitedWords", S.nullableAsOption(S.json), None),
    prohibitedWordsForNameOfUser: s.fieldOr("prohibitedWordsForNameOfUser", S.nullableAsOption(S.json), None),
    themeColor: s.fieldOr("themeColor", S.nullableAsOption(S.json), None),
    mascotImageUrl: s.fieldOr("mascotImageUrl", S.nullableAsOption(S.json), None),
    bannerUrl: s.fieldOr("bannerUrl", S.nullableAsOption(S.json), None),
    serverErrorImageUrl: s.fieldOr("serverErrorImageUrl", S.nullableAsOption(S.json), None),
    infoImageUrl: s.fieldOr("infoImageUrl", S.nullableAsOption(S.json), None),
    notFoundImageUrl: s.fieldOr("notFoundImageUrl", S.nullableAsOption(S.json), None),
    youBlockedImageUrl: s.fieldOr("youBlockedImageUrl", S.nullableAsOption(S.json), None),
    iconUrl: s.fieldOr("iconUrl", S.nullableAsOption(S.json), None),
    app192iconUrl: s.fieldOr("app192IconUrl", S.nullableAsOption(S.json), None),
    app512iconUrl: s.fieldOr("app512IconUrl", S.nullableAsOption(S.json), None),
    backgroundImageUrl: s.fieldOr("backgroundImageUrl", S.nullableAsOption(S.json), None),
    logoImageUrl: s.fieldOr("logoImageUrl", S.nullableAsOption(S.json), None),
    name: s.fieldOr("name", S.nullableAsOption(S.json), None),
    shortName: s.fieldOr("shortName", S.nullableAsOption(S.json), None),
    description: s.fieldOr("description", S.nullableAsOption(S.json), None),
    defaultLightTheme: s.fieldOr("defaultLightTheme", S.nullableAsOption(S.json), None),
    defaultDarkTheme: s.fieldOr("defaultDarkTheme", S.nullableAsOption(S.json), None),
    clientOptions: s.fieldOr("clientOptions", S.nullableAsOption(S.json), None),
    cacheRemoteFiles: s.fieldOr("cacheRemoteFiles", S.nullableAsOption(S.bool), None),
    cacheRemoteSensitiveFiles: s.fieldOr("cacheRemoteSensitiveFiles", S.nullableAsOption(S.bool), None),
    emailRequiredForSignup: s.fieldOr("emailRequiredForSignup", S.nullableAsOption(S.bool), None),
    enableHcaptcha: s.fieldOr("enableHcaptcha", S.nullableAsOption(S.bool), None),
    hcaptchaSiteKey: s.fieldOr("hcaptchaSiteKey", S.nullableAsOption(S.json), None),
    hcaptchaSecretKey: s.fieldOr("hcaptchaSecretKey", S.nullableAsOption(S.json), None),
    enableMcaptcha: s.fieldOr("enableMcaptcha", S.nullableAsOption(S.bool), None),
    mcaptchaSiteKey: s.fieldOr("mcaptchaSiteKey", S.nullableAsOption(S.json), None),
    mcaptchaInstanceUrl: s.fieldOr("mcaptchaInstanceUrl", S.nullableAsOption(S.json), None),
    mcaptchaSecretKey: s.fieldOr("mcaptchaSecretKey", S.nullableAsOption(S.json), None),
    enableRecaptcha: s.fieldOr("enableRecaptcha", S.nullableAsOption(S.bool), None),
    recaptchaSiteKey: s.fieldOr("recaptchaSiteKey", S.nullableAsOption(S.json), None),
    recaptchaSecretKey: s.fieldOr("recaptchaSecretKey", S.nullableAsOption(S.json), None),
    enableTurnstile: s.fieldOr("enableTurnstile", S.nullableAsOption(S.bool), None),
    turnstileSiteKey: s.fieldOr("turnstileSiteKey", S.nullableAsOption(S.json), None),
    turnstileSecretKey: s.fieldOr("turnstileSecretKey", S.nullableAsOption(S.json), None),
    enableTestcaptcha: s.fieldOr("enableTestcaptcha", S.nullableAsOption(S.bool), None),
    googleAnalyticsMeasurementId: s.fieldOr("googleAnalyticsMeasurementId", S.nullableAsOption(S.json), None),
    sensitiveMediaDetection: s.fieldOr("sensitiveMediaDetection", S.nullableAsOption(S.string), None),
    sensitiveMediaDetectionSensitivity: s.fieldOr("sensitiveMediaDetectionSensitivity", S.nullableAsOption(S.string), None),
    setSensitiveFlagAutomatically: s.fieldOr("setSensitiveFlagAutomatically", S.nullableAsOption(S.bool), None),
    enableSensitiveMediaDetectionForVideos: s.fieldOr("enableSensitiveMediaDetectionForVideos", S.nullableAsOption(S.bool), None),
    maintainerName: s.fieldOr("maintainerName", S.nullableAsOption(S.json), None),
    maintainerEmail: s.fieldOr("maintainerEmail", S.nullableAsOption(S.json), None),
    langs: s.fieldOr("langs", S.nullableAsOption(S.array(S.string)), None),
    translatorType: s.fieldOr("translatorType", S.nullableAsOption(S.json), None),
    deeplAuthKey: s.fieldOr("deeplAuthKey", S.nullableAsOption(S.json), None),
    deeplIsPro: s.fieldOr("deeplIsPro", S.nullableAsOption(S.bool), None),
    ctav3saKey: s.fieldOr("ctav3SaKey", S.nullableAsOption(S.json), None),
    ctav3projectId: s.fieldOr("ctav3ProjectId", S.nullableAsOption(S.json), None),
    ctav3location: s.fieldOr("ctav3Location", S.nullableAsOption(S.json), None),
    ctav3model: s.fieldOr("ctav3Model", S.nullableAsOption(S.json), None),
    ctav3glossary: s.fieldOr("ctav3Glossary", S.nullableAsOption(S.json), None),
    libreTranslateEndPoint: s.fieldOr("libreTranslateEndPoint", S.nullableAsOption(S.json), None),
    libreTranslateApiKey: s.fieldOr("libreTranslateApiKey", S.nullableAsOption(S.json), None),
    enableEmail: s.fieldOr("enableEmail", S.nullableAsOption(S.bool), None),
    email: s.fieldOr("email", S.nullableAsOption(S.json), None),
    smtpSecure: s.fieldOr("smtpSecure", S.nullableAsOption(S.bool), None),
    smtpHost: s.fieldOr("smtpHost", S.nullableAsOption(S.json), None),
    smtpPort: s.fieldOr("smtpPort", S.nullableAsOption(S.json), None),
    smtpUser: s.fieldOr("smtpUser", S.nullableAsOption(S.json), None),
    smtpPass: s.fieldOr("smtpPass", S.nullableAsOption(S.json), None),
    enableServiceWorker: s.fieldOr("enableServiceWorker", S.nullableAsOption(S.bool), None),
    swPublicKey: s.fieldOr("swPublicKey", S.nullableAsOption(S.json), None),
    swPrivateKey: s.fieldOr("swPrivateKey", S.nullableAsOption(S.json), None),
    tosUrl: s.fieldOr("tosUrl", S.nullableAsOption(S.json), None),
    repositoryUrl: s.fieldOr("repositoryUrl", S.nullableAsOption(S.json), None),
    feedbackUrl: s.fieldOr("feedbackUrl", S.nullableAsOption(S.json), None),
    impressumUrl: s.fieldOr("impressumUrl", S.nullableAsOption(S.json), None),
    privacyPolicyUrl: s.fieldOr("privacyPolicyUrl", S.nullableAsOption(S.json), None),
    inquiryUrl: s.fieldOr("inquiryUrl", S.nullableAsOption(S.json), None),
    useObjectStorage: s.fieldOr("useObjectStorage", S.nullableAsOption(S.bool), None),
    objectStorageBaseUrl: s.fieldOr("objectStorageBaseUrl", S.nullableAsOption(S.json), None),
    objectStorageBucket: s.fieldOr("objectStorageBucket", S.nullableAsOption(S.json), None),
    objectStoragePrefix: s.fieldOr("objectStoragePrefix", S.nullableAsOption(S.json), None),
    objectStorageEndpoint: s.fieldOr("objectStorageEndpoint", S.nullableAsOption(S.json), None),
    objectStorageRegion: s.fieldOr("objectStorageRegion", S.nullableAsOption(S.json), None),
    objectStoragePort: s.fieldOr("objectStoragePort", S.nullableAsOption(S.json), None),
    objectStorageAccessKey: s.fieldOr("objectStorageAccessKey", S.nullableAsOption(S.json), None),
    objectStorageSecretKey: s.fieldOr("objectStorageSecretKey", S.nullableAsOption(S.json), None),
    objectStorageUseSsl: s.fieldOr("objectStorageUseSSL", S.nullableAsOption(S.bool), None),
    objectStorageUseProxy: s.fieldOr("objectStorageUseProxy", S.nullableAsOption(S.bool), None),
    objectStorageSetPublicRead: s.fieldOr("objectStorageSetPublicRead", S.nullableAsOption(S.bool), None),
    objectStorageS3forcePathStyle: s.fieldOr("objectStorageS3ForcePathStyle", S.nullableAsOption(S.bool), None),
    useRemoteObjectStorage: s.fieldOr("useRemoteObjectStorage", S.nullableAsOption(S.bool), None),
    remoteObjectStorageBaseUrl: s.fieldOr("remoteObjectStorageBaseUrl", S.nullableAsOption(S.json), None),
    remoteObjectStorageBucket: s.fieldOr("remoteObjectStorageBucket", S.nullableAsOption(S.json), None),
    remoteObjectStoragePrefix: s.fieldOr("remoteObjectStoragePrefix", S.nullableAsOption(S.json), None),
    remoteObjectStorageEndpoint: s.fieldOr("remoteObjectStorageEndpoint", S.nullableAsOption(S.json), None),
    remoteObjectStorageRegion: s.fieldOr("remoteObjectStorageRegion", S.nullableAsOption(S.json), None),
    remoteObjectStoragePort: s.fieldOr("remoteObjectStoragePort", S.nullableAsOption(S.json), None),
    remoteObjectStorageAccessKey: s.fieldOr("remoteObjectStorageAccessKey", S.nullableAsOption(S.json), None),
    remoteObjectStorageSecretKey: s.fieldOr("remoteObjectStorageSecretKey", S.nullableAsOption(S.json), None),
    remoteObjectStorageUseSsl: s.fieldOr("remoteObjectStorageUseSSL", S.nullableAsOption(S.bool), None),
    remoteObjectStorageUseProxy: s.fieldOr("remoteObjectStorageUseProxy", S.nullableAsOption(S.bool), None),
    remoteObjectStorageSetPublicRead: s.fieldOr("remoteObjectStorageSetPublicRead", S.nullableAsOption(S.bool), None),
    remoteObjectStorageS3forcePathStyle: s.fieldOr("remoteObjectStorageS3ForcePathStyle", S.nullableAsOption(S.bool), None),
    enableIpLogging: s.fieldOr("enableIpLogging", S.nullableAsOption(S.bool), None),
    enableActiveEmailValidation: s.fieldOr("enableActiveEmailValidation", S.nullableAsOption(S.bool), None),
    enableVerifymailApi: s.fieldOr("enableVerifymailApi", S.nullableAsOption(S.bool), None),
    verifymailAuthKey: s.fieldOr("verifymailAuthKey", S.nullableAsOption(S.json), None),
    enableTruemailApi: s.fieldOr("enableTruemailApi", S.nullableAsOption(S.bool), None),
    truemailInstance: s.fieldOr("truemailInstance", S.nullableAsOption(S.json), None),
    truemailAuthKey: s.fieldOr("truemailAuthKey", S.nullableAsOption(S.json), None),
    enableChartsForRemoteUser: s.fieldOr("enableChartsForRemoteUser", S.nullableAsOption(S.bool), None),
    enableChartsForFederatedInstances: s.fieldOr("enableChartsForFederatedInstances", S.nullableAsOption(S.bool), None),
    enableStatsForFederatedInstances: s.fieldOr("enableStatsForFederatedInstances", S.nullableAsOption(S.bool), None),
    enableServerMachineStats: s.fieldOr("enableServerMachineStats", S.nullableAsOption(S.bool), None),
    enableIdenticonGeneration: s.fieldOr("enableIdenticonGeneration", S.nullableAsOption(S.bool), None),
    serverRules: s.fieldOr("serverRules", S.nullableAsOption(S.array(S.string)), None),
    bannedEmailDomains: s.fieldOr("bannedEmailDomains", S.nullableAsOption(S.array(S.string)), None),
    preservedUsernames: s.fieldOr("preservedUsernames", S.nullableAsOption(S.array(S.string)), None),
    manifestJsonOverride: s.fieldOr("manifestJsonOverride", S.nullableAsOption(S.string), None),
    enableFanoutTimeline: s.fieldOr("enableFanoutTimeline", S.nullableAsOption(S.bool), None),
    enableFanoutTimelineDbFallback: s.fieldOr("enableFanoutTimelineDbFallback", S.nullableAsOption(S.bool), None),
    perLocalUserUserTimelineCacheMax: s.fieldOr("perLocalUserUserTimelineCacheMax", S.nullableAsOption(S.int), None),
    perRemoteUserUserTimelineCacheMax: s.fieldOr("perRemoteUserUserTimelineCacheMax", S.nullableAsOption(S.int), None),
    perUserHomeTimelineCacheMax: s.fieldOr("perUserHomeTimelineCacheMax", S.nullableAsOption(S.int), None),
    perUserListTimelineCacheMax: s.fieldOr("perUserListTimelineCacheMax", S.nullableAsOption(S.int), None),
    enableReactionsBuffering: s.fieldOr("enableReactionsBuffering", S.nullableAsOption(S.bool), None),
    notesPerOneAd: s.fieldOr("notesPerOneAd", S.nullableAsOption(S.int), None),
    silencedHosts: s.fieldOr("silencedHosts", S.nullableAsOption(S.json), None),
    mediaSilencedHosts: s.fieldOr("mediaSilencedHosts", S.nullableAsOption(S.json), None),
    summalyProxy: s.fieldOr("summalyProxy", S.nullableAsOption(S.json), None),
    urlPreviewEnabled: s.fieldOr("urlPreviewEnabled", S.nullableAsOption(S.bool), None),
    urlPreviewAllowRedirect: s.fieldOr("urlPreviewAllowRedirect", S.nullableAsOption(S.bool), None),
    urlPreviewTimeout: s.fieldOr("urlPreviewTimeout", S.nullableAsOption(S.int), None),
    urlPreviewMaximumContentLength: s.fieldOr("urlPreviewMaximumContentLength", S.nullableAsOption(S.int), None),
    urlPreviewRequireContentLength: s.fieldOr("urlPreviewRequireContentLength", S.nullableAsOption(S.bool), None),
    urlPreviewUserAgent: s.fieldOr("urlPreviewUserAgent", S.nullableAsOption(S.json), None),
    urlPreviewSummaryProxyUrl: s.fieldOr("urlPreviewSummaryProxyUrl", S.nullableAsOption(S.json), None),
    federation: s.fieldOr("federation", S.nullableAsOption(S.string), None),
    federationHosts: s.fieldOr("federationHosts", S.nullableAsOption(S.array(S.string)), None),
    deliverSuspendedSoftware: s.fieldOr("deliverSuspendedSoftware", S.nullableAsOption(S.array(S.object(s => {
    software: s.field("software", S.string),
    versionRange: s.field("versionRange", S.string),
  }))), None),
    singleUserMode: s.fieldOr("singleUserMode", S.nullableAsOption(S.bool), None),
    ugcVisibilityForVisitor: s.fieldOr("ugcVisibilityForVisitor", S.nullableAsOption(S.string), None),
    proxyRemoteFiles: s.fieldOr("proxyRemoteFiles", S.nullableAsOption(S.bool), None),
    signToActivityPubGet: s.fieldOr("signToActivityPubGet", S.nullableAsOption(S.bool), None),
    allowExternalApRedirect: s.fieldOr("allowExternalApRedirect", S.nullableAsOption(S.bool), None),
    enableRemoteNotesCleaning: s.fieldOr("enableRemoteNotesCleaning", S.nullableAsOption(S.bool), None),
    remoteNotesCleaningExpiryDaysForEachNotes: s.fieldOr("remoteNotesCleaningExpiryDaysForEachNotes", S.nullableAsOption(S.float), None),
    remoteNotesCleaningMaxProcessingDurationInMinutes: s.fieldOr("remoteNotesCleaningMaxProcessingDurationInMinutes", S.nullableAsOption(S.float), None),
    showRoleBadgesOfRemoteUsers: s.fieldOr("showRoleBadgesOfRemoteUsers", S.nullableAsOption(S.bool), None),
    doNotSendNotificationEmailsForAbuseReport: s.fieldOr("doNotSendNotificationEmailsForAbuseReport", S.nullableAsOption(S.bool), None),
    emailToReceiveAbuseReport: s.fieldOr("emailToReceiveAbuseReport", S.nullableAsOption(S.json), None),
    enableReceivePrerelease: s.fieldOr("enableReceivePrerelease", S.nullableAsOption(S.bool), None),
    skipVersion: s.fieldOr("skipVersion", S.nullableAsOption(S.bool), None),
    skipCherryPickVersion: s.fieldOr("skipCherryPickVersion", S.nullableAsOption(S.json), None),
    trustedLinkUrlPatterns: s.fieldOr("trustedLinkUrlPatterns", S.nullableAsOption(S.json), None),
    customSplashText: s.fieldOr("customSplashText", S.nullableAsOption(S.json), None),
    disableRegistrationWhenInactive: s.fieldOr("disableRegistrationWhenInactive", S.nullableAsOption(S.json), None),
    disablePublicNoteWhenInactive: s.fieldOr("disablePublicNoteWhenInactive", S.nullableAsOption(S.json), None),
    moderatorInactivityLimitDays: s.fieldOr("moderatorInactivityLimitDays", S.nullableAsOption(S.int), None),
    bubbleInstances: s.fieldOr("bubbleInstances", S.nullableAsOption(S.array(S.string)), None),
    customRobotsTxt: s.fieldOr("customRobotsTxt", S.nullableAsOption(S.json), None),
  })

type postAdminUpdateMetaResponse = unit

/**
 * admin/update-meta
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:meta*
 */
let postAdminUpdateMeta = (~body: postAdminUpdateMetaRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUpdateMetaResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateMetaRequestSchema)
  fetch(
    ~url="/admin/update-meta",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminUpdateProxyAccountRequest = {
  description: option<JSON.t>,
}

let postAdminUpdateProxyAccountRequestSchema = S.object(s => {
    description: s.fieldOr("description", S.nullableAsOption(S.json), None),
  })

type postAdminUpdateProxyAccountResponse = KokonectLinkComponentSchemas.UserDetailed.t

let postAdminUpdateProxyAccountResponseSchema = KokonectLinkComponentSchemas.UserDetailed.schema

/**
 * admin/update-proxy-account
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:account*
 */
let postAdminUpdateProxyAccount = (~body: postAdminUpdateProxyAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUpdateProxyAccountResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateProxyAccountRequestSchema)
  fetch(
    ~url="/admin/update-proxy-account",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminUpdateProxyAccountResponseSchema)
  value
    ->Promise.resolve
  })
}

type postV2AdminEmojiListRequest = {
  query: option<JSON.t>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
  page: option<int>,
  sortKeys: option<array<string>>,
}

let postV2AdminEmojiListRequestSchema = S.object(s => {
    query: s.fieldOr("query", S.nullableAsOption(S.json), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    page: s.fieldOr("page", S.nullableAsOption(S.int), None),
    sortKeys: s.fieldOr("sortKeys", S.nullableAsOption(S.array(S.string)), None),
  })

type postV2AdminEmojiListResponse = {
  emojis: array<KokonectLinkComponentSchemas.EmojiDetailedAdmin.t>,
  count: int,
  allCount: int,
  allPages: int,
}

let postV2AdminEmojiListResponseSchema = S.object(s => {
    emojis: s.field("emojis", S.array(KokonectLinkComponentSchemas.EmojiDetailedAdmin.schema)),
    count: s.field("count", S.int),
    allCount: s.field("allCount", S.int),
    allPages: s.field("allPages", S.int),
  })

/**
 * v2/admin/emoji/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:emoji*
 */
let postV2AdminEmojiList = (~body: postV2AdminEmojiListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postV2AdminEmojiListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postV2AdminEmojiListRequestSchema)
  fetch(
    ~url="/v2/admin/emoji/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postV2AdminEmojiListResponseSchema)
  value
    ->Promise.resolve
  })
}
