// kokonect-link API for clips
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postClipsCreateRequest = {
  name: string,
  isPublic: option<bool>,
  description: option<string>,
}

let postClipsCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
    isPublic: s.field("isPublic", S.option(S.bool)),
    description: s.field("description", S.option(S.string->S.max(2048))),
  })

type postClipsCreateResponse = KokonectLinkComponentSchemas.Clip.t

let postClipsCreateResponseSchema = KokonectLinkComponentSchemas.Clip.schema

/**
clips/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postClipsCreate = (~body: postClipsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsCreateRequestSchema)
  fetch(
    ~url="/clips/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postClipsCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postClipsListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postClipsListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postClipsListResponse = array<KokonectLinkComponentSchemas.Clip.t>

let postClipsListResponseSchema = S.array(KokonectLinkComponentSchemas.Clip.schema)

/**
clips/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postClipsList = (~body: postClipsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsListRequestSchema)
  fetch(
    ~url="/clips/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postClipsListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postClipsShowRequest = {
  clipId: string,
}

let postClipsShowRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
  })

type postClipsShowResponse = KokonectLinkComponentSchemas.Clip.t

let postClipsShowResponseSchema = KokonectLinkComponentSchemas.Clip.schema

/**
clips/show

No description provided.

**Credential required**: *No* / **Permission**: *read:account*
*/
let postClipsShow = (~body: postClipsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsShowRequestSchema)
  fetch(
    ~url="/clips/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postClipsShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postClipsUpdateRequest = {
  clipId: string,
  name: option<string>,
  isPublic: option<bool>,
  description: option<string>,
}

let postClipsUpdateRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
    name: s.field("name", S.option(S.string->S.min(1)->S.max(100))),
    isPublic: s.field("isPublic", S.option(S.bool)),
    description: s.field("description", S.option(S.string->S.max(2048))),
  })

type postClipsUpdateResponse = KokonectLinkComponentSchemas.Clip.t

let postClipsUpdateResponseSchema = KokonectLinkComponentSchemas.Clip.schema

/**
clips/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postClipsUpdate = (~body: postClipsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsUpdateRequestSchema)
  fetch(
    ~url="/clips/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postClipsUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}
