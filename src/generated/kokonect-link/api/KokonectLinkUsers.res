// SPDX-License-Identifier: MIT
// kokonect-link API for users
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type postUsersRequest = {
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
  state: option<string>,
  origin: option<string>,
  hostname: option<JSON.t>,
}

let postUsersRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
    state: s.fieldOr("state", S.nullableAsOption(S.string), None),
    origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
    hostname: s.fieldOr("hostname", S.nullableAsOption(S.json), None),
  })

type postUsersResponse = array<KokonectLinkComponentSchemas.UserDetailed.t>

let postUsersResponseSchema = S.array(KokonectLinkComponentSchemas.UserDetailed.schema)

/**
 * users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsers = (~body: postUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersRequestSchema)
  
  fetch(
    ~url="/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersClipsRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postUsersClipsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postUsersClipsResponse = array<KokonectLinkComponentSchemas.Clip.t>

let postUsersClipsResponseSchema = S.array(KokonectLinkComponentSchemas.Clip.schema)

/**
 * users/clips
 *
 * Show all clips this user owns.
 *
 * **Credential required**: *No*
 */
let postUsersClips = (~body: postUsersClipsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersClipsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersClipsRequestSchema)
  
  fetch(
    ~url="/users/clips",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersClipsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersFlashsRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postUsersFlashsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postUsersFlashsResponse = array<KokonectLinkComponentSchemas.Flash.t>

let postUsersFlashsResponseSchema = S.array(KokonectLinkComponentSchemas.Flash.schema)

/**
 * users/flashs
 *
 * Show all flashs this user created.
 *
 * **Credential required**: *No*
 */
let postUsersFlashs = (~body: postUsersFlashsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFlashsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFlashsRequestSchema)
  
  fetch(
    ~url="/users/flashs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersFlashsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersFollowersRequest = JSON.t

let postUsersFollowersRequestSchema = S.json

type postUsersFollowersResponse = array<KokonectLinkComponentSchemas.Following.t>

let postUsersFollowersResponseSchema = S.array(KokonectLinkComponentSchemas.Following.schema)

/**
 * users/followers
 *
 * Show everyone that follows this user.
 *
 * **Credential required**: *No*
 */
let postUsersFollowers = (~body: postUsersFollowersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFollowersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFollowersRequestSchema)
  
  fetch(
    ~url="/users/followers",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersFollowersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersFollowingRequest = JSON.t

let postUsersFollowingRequestSchema = S.json

type postUsersFollowingResponse = array<KokonectLinkComponentSchemas.Following.t>

let postUsersFollowingResponseSchema = S.array(KokonectLinkComponentSchemas.Following.schema)

/**
 * users/following
 *
 * Show everyone that this user is following.
 *
 * **Credential required**: *No*
 */
let postUsersFollowing = (~body: postUsersFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFollowingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFollowingRequestSchema)
  
  fetch(
    ~url="/users/following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersFollowingResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersGalleryPostsRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postUsersGalleryPostsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postUsersGalleryPostsResponse = array<KokonectLinkComponentSchemas.GalleryPost.t>

let postUsersGalleryPostsResponseSchema = S.array(KokonectLinkComponentSchemas.GalleryPost.schema)

/**
 * users/gallery/posts
 *
 * Show all gallery posts by the given user.
 *
 * **Credential required**: *No*
 */
let postUsersGalleryPosts = (~body: postUsersGalleryPostsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGalleryPostsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGalleryPostsRequestSchema)
  
  fetch(
    ~url="/users/gallery/posts",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersGalleryPostsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersNotesRequest = {
  userId: string,
  withReplies: option<bool>,
  withRenotes: option<bool>,
  withChannelNotes: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  withFiles: option<bool>,
  withCats: option<bool>,
}

let postUsersNotesRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
    withRenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    withChannelNotes: s.fieldOr("withChannelNotes", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    allowPartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    withFiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    withCats: s.fieldOr("withCats", S.nullableAsOption(S.bool), None),
  })

type postUsersNotesResponse = array<KokonectLinkComponentSchemas.Note.t>

let postUsersNotesResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * users/notes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsersNotes = (~body: postUsersNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersNotesRequestSchema)
  
  fetch(
    ~url="/users/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersNotesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersPagesRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postUsersPagesRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postUsersPagesResponse = array<KokonectLinkComponentSchemas.Page.t>

let postUsersPagesResponseSchema = S.array(KokonectLinkComponentSchemas.Page.schema)

/**
 * users/pages
 *
 * Show all pages this user created.
 *
 * **Credential required**: *No*
 */
let postUsersPages = (~body: postUsersPagesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersPagesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersPagesRequestSchema)
  
  fetch(
    ~url="/users/pages",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersPagesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersReportAbuseRequest = {
  userId: string,
  comment: string,
}

let postUsersReportAbuseRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    comment: s.field("comment", S.string->S.min(1)->S.max(2048)),
  })

type postUsersReportAbuseResponse = unit

/**
 * users/report-abuse
 *
 * File a report.
 *
 * **Credential required**: *Yes* / **Permission**: *write:report-abuse*
 */
let postUsersReportAbuse = (~body: postUsersReportAbuseRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersReportAbuseResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersReportAbuseRequestSchema)
  
  fetch(
    ~url="/users/report-abuse",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postUsersSearchByUsernameAndHostRequest = JSON.t

let postUsersSearchByUsernameAndHostRequestSchema = S.json

type postUsersSearchByUsernameAndHostResponse = array<KokonectLinkComponentSchemas.User.t>

let postUsersSearchByUsernameAndHostResponseSchema = S.array(KokonectLinkComponentSchemas.User.schema)

/**
 * users/search-by-username-and-host
 *
 * Search for a user by username and/or host.
 *
 * **Credential required**: *No*
 */
let postUsersSearchByUsernameAndHost = (~body: postUsersSearchByUsernameAndHostRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersSearchByUsernameAndHostResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersSearchByUsernameAndHostRequestSchema)
  
  fetch(
    ~url="/users/search-by-username-and-host",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersSearchByUsernameAndHostResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersShowRequest = JSON.t

let postUsersShowRequestSchema = S.json

type postUsersShowResponse = array<KokonectLinkComponentSchemas.UserDetailed.t>

let postUsersShowResponseSchema = S.array(KokonectLinkComponentSchemas.UserDetailed.schema)

/**
 * users/show
 *
 * Show the properties of a user.
 *
 * **Credential required**: *No*
 */
let postUsersShow = (~body: postUsersShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersShowRequestSchema)
  
  fetch(
    ~url="/users/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersShowResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersTranslateRequest = {
  userId: string,
  targetLang: string,
}

let postUsersTranslateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    targetLang: s.field("targetLang", S.string),
  })

type postUsersTranslateResponse = {
  sourceLang: string,
  text: string,
}

let postUsersTranslateResponseSchema = S.object(s => {
    sourceLang: s.field("sourceLang", S.string),
    text: s.field("text", S.string),
  })

/**
 * users/translate
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postUsersTranslate = (~body: postUsersTranslateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersTranslateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersTranslateRequestSchema)
  
  fetch(
    ~url="/users/translate",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersTranslateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}
