// kokonect-link API for users
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postUsersRequest = {
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
  state: option<string>,
  origin: option<string>,
  hostname: option<string>,
}

let postUsersRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
    sort: s.field("sort", S.option(S.string)),
    state: s.field("state", S.option(S.string)),
    origin: s.field("origin", S.option(S.string)),
    hostname: s.field("hostname", S.option(S.string)),
  })

type postUsersResponse = array<KokonectLinkComponentSchemas.UserDetailed.t>

let postUsersResponseSchema = S.array(KokonectLinkComponentSchemas.UserDetailed.schema)

/**
users

No description provided.

**Credential required**: *No*
*/
let postUsers = async (~body: postUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersRequestSchema)
  let response = await fetch(
    ~url="/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersResponseSchema)
}

type postUsersClipsRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postUsersClipsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postUsersClipsResponse = array<KokonectLinkComponentSchemas.Clip.t>

let postUsersClipsResponseSchema = S.array(KokonectLinkComponentSchemas.Clip.schema)

/**
users/clips

Show all clips this user owns.

**Credential required**: *No*
*/
let postUsersClips = async (~body: postUsersClipsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersClipsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersClipsRequestSchema)
  let response = await fetch(
    ~url="/users/clips",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersClipsResponseSchema)
}

type postUsersFlashsRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postUsersFlashsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postUsersFlashsResponse = array<KokonectLinkComponentSchemas.Flash.t>

let postUsersFlashsResponseSchema = S.array(KokonectLinkComponentSchemas.Flash.schema)

/**
users/flashs

Show all flashs this user created.

**Credential required**: *No*
*/
let postUsersFlashs = async (~body: postUsersFlashsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersFlashsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFlashsRequestSchema)
  let response = await fetch(
    ~url="/users/flashs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersFlashsResponseSchema)
}

type postUsersFollowersRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postUsersFollowersRequestSchema = S.object(s => {
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postUsersFollowersResponse = array<KokonectLinkComponentSchemas.Following.t>

let postUsersFollowersResponseSchema = S.array(KokonectLinkComponentSchemas.Following.schema)

/**
users/followers

Show everyone that follows this user.

**Credential required**: *No*
*/
let postUsersFollowers = async (~body: postUsersFollowersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersFollowersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFollowersRequestSchema)
  let response = await fetch(
    ~url="/users/followers",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersFollowersResponseSchema)
}

type postUsersFollowingRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
  birthday: option<string>,
}

let postUsersFollowingRequestSchema = S.object(s => {
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    birthday: s.field("birthday", S.option(S.string->S.pattern(/^([0-9]{4})-([0-9]{2})-([0-9]{2})$/))),
  })

type postUsersFollowingResponse = array<KokonectLinkComponentSchemas.Following.t>

let postUsersFollowingResponseSchema = S.array(KokonectLinkComponentSchemas.Following.schema)

/**
users/following

Show everyone that this user is following.

**Credential required**: *No*
*/
let postUsersFollowing = async (~body: postUsersFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersFollowingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFollowingRequestSchema)
  let response = await fetch(
    ~url="/users/following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersFollowingResponseSchema)
}

type postUsersGalleryPostsRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postUsersGalleryPostsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postUsersGalleryPostsResponse = array<KokonectLinkComponentSchemas.GalleryPost.t>

let postUsersGalleryPostsResponseSchema = S.array(KokonectLinkComponentSchemas.GalleryPost.schema)

/**
users/gallery/posts

Show all gallery posts by the given user.

**Credential required**: *No*
*/
let postUsersGalleryPosts = async (~body: postUsersGalleryPostsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersGalleryPostsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGalleryPostsRequestSchema)
  let response = await fetch(
    ~url="/users/gallery/posts",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersGalleryPostsResponseSchema)
}

type postUsersNotesRequest = {
  userId: string,
  withReplies: option<bool>,
  withRenotes: option<bool>,
  withChannelNotes: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  withFiles: option<bool>,
  withCats: option<bool>,
}

let postUsersNotesRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    withReplies: s.field("withReplies", S.option(S.bool)),
    withRenotes: s.field("withRenotes", S.option(S.bool)),
    withChannelNotes: s.field("withChannelNotes", S.option(S.bool)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    allowPartial: s.field("allowPartial", S.option(S.bool)),
    withFiles: s.field("withFiles", S.option(S.bool)),
    withCats: s.field("withCats", S.option(S.bool)),
  })

type postUsersNotesResponse = array<KokonectLinkComponentSchemas.Note.t>

let postUsersNotesResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
users/notes

No description provided.

**Credential required**: *No*
*/
let postUsersNotes = async (~body: postUsersNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersNotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersNotesRequestSchema)
  let response = await fetch(
    ~url="/users/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersNotesResponseSchema)
}

type postUsersPagesRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postUsersPagesRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postUsersPagesResponse = array<KokonectLinkComponentSchemas.Page.t>

let postUsersPagesResponseSchema = S.array(KokonectLinkComponentSchemas.Page.schema)

/**
users/pages

Show all pages this user created.

**Credential required**: *No*
*/
let postUsersPages = async (~body: postUsersPagesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersPagesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersPagesRequestSchema)
  let response = await fetch(
    ~url="/users/pages",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersPagesResponseSchema)
}

type postUsersReportAbuseRequest = {
  userId: string,
  comment: string,
}

let postUsersReportAbuseRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    comment: s.field("comment", S.string->S.min(1)->S.max(2048)),
  })

type postUsersReportAbuseResponse = unit

/**
users/report-abuse

File a report.

**Credential required**: *Yes* / **Permission**: *write:report-abuse*
*/
let postUsersReportAbuse = async (~body: postUsersReportAbuseRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersReportAbuseResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersReportAbuseRequestSchema)
  let response = await fetch(
    ~url="/users/report-abuse",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postUsersSearchByUsernameAndHostRequest = {
  limit: option<int>,
  detail: option<bool>,
}

let postUsersSearchByUsernameAndHostRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    detail: s.field("detail", S.option(S.bool)),
  })

type postUsersSearchByUsernameAndHostResponse = array<KokonectLinkComponentSchemas.User.t>

let postUsersSearchByUsernameAndHostResponseSchema = S.array(KokonectLinkComponentSchemas.User.schema)

/**
users/search-by-username-and-host

Search for a user by username and/or host.

**Credential required**: *No*
*/
let postUsersSearchByUsernameAndHost = async (~body: postUsersSearchByUsernameAndHostRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersSearchByUsernameAndHostResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersSearchByUsernameAndHostRequestSchema)
  let response = await fetch(
    ~url="/users/search-by-username-and-host",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersSearchByUsernameAndHostResponseSchema)
}

type postUsersShowRequest = {
  host: option<string>,
}

let postUsersShowRequestSchema = S.object(s => {
    host: s.field("host", S.option(S.string)),
  })

type postUsersShowResponse = array<KokonectLinkComponentSchemas.UserDetailed.t>

let postUsersShowResponseSchema = S.array(KokonectLinkComponentSchemas.UserDetailed.schema)

/**
users/show

Show the properties of a user.

**Credential required**: *No*
*/
let postUsersShow = async (~body: postUsersShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersShowRequestSchema)
  let response = await fetch(
    ~url="/users/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersShowResponseSchema)
}

type postUsersTranslateRequest = {
  userId: string,
  targetLang: string,
}

let postUsersTranslateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    targetLang: s.field("targetLang", S.string),
  })

type postUsersTranslateResponse = {
  sourceLang: string,
  text: string,
}

let postUsersTranslateResponseSchema = S.object(s => {
    sourceLang: s.field("sourceLang", S.string),
    text: s.field("text", S.string),
  })

/**
users/translate

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postUsersTranslate = async (~body: postUsersTranslateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersTranslateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersTranslateRequestSchema)
  let response = await fetch(
    ~url="/users/translate",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersTranslateResponseSchema)
}
