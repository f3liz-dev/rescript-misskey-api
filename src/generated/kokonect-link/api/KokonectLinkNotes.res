// kokonect-link API for notes
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postChannelsTimelineRequest = {
  channelId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
}

let postChannelsTimelineRequestSchema = S.object(s => {
    channelId: s.field("channelId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    allowPartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
  })

type postChannelsTimelineResponse = array<KokonectLinkComponentSchemas.Note.t>

let postChannelsTimelineResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * channels/timeline
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChannelsTimeline = (~body: postChannelsTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsTimelineRequestSchema)
  fetch(
    ~url="/channels/timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postChannelsTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesRequest = {
  local: option<bool>,
  reply: option<bool>,
  renote: option<bool>,
  withFiles: option<bool>,
  poll: option<bool>,
  event: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postNotesRequestSchema = S.object(s => {
    local: s.fieldOr("local", S.nullableAsOption(S.bool), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.bool), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.bool), None),
    withFiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    poll: s.fieldOr("poll", S.nullableAsOption(S.bool), None),
    event: s.fieldOr("event", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postNotesResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotes = (~body: postNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRequestSchema)
  fetch(
    ~url="/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesBubbleTimelineRequest = {
  withFiles: option<bool>,
  withCats: option<bool>,
  withBots: option<bool>,
  withRenotes: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postNotesBubbleTimelineRequestSchema = S.object(s => {
    withFiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    withCats: s.fieldOr("withCats", S.nullableAsOption(S.bool), None),
    withBots: s.fieldOr("withBots", S.nullableAsOption(S.bool), None),
    withRenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postNotesBubbleTimelineResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesBubbleTimelineResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/bubble-timeline
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesBubbleTimeline = (~body: postNotesBubbleTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesBubbleTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesBubbleTimelineRequestSchema)
  fetch(
    ~url="/notes/bubble-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesBubbleTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesChildrenRequest = {
  noteId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postNotesChildrenRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postNotesChildrenResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesChildrenResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/children
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesChildren = (~body: postNotesChildrenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesChildrenResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesChildrenRequestSchema)
  fetch(
    ~url="/notes/children",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesChildrenResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesCreateRequest_4 = {
  mode: string,
  hosts: array<string>,
}

type postNotesCreateRequest_3 = {
  deleteAt: option<int>,
  deleteAfter: option<int>,
}

type postNotesCreateRequest_2 = {
  title: option<string>,
  start: option<int>,
  @as("end") end_: option<int>,
  metadata: option<dict<JSON.t>>,
}

type postNotesCreateRequest_1 = {
  choices: array<string>,
  multiple: option<bool>,
  expiresAt: option<int>,
  expiredAfter: option<int>,
}

type postNotesCreateRequest = {
  visibility: option<string>,
  visibleUserIds: option<array<string>>,
  cw: option<string>,
  localOnly: option<bool>,
  reactionAcceptance: option<string>,
  disableRightClick: option<bool>,
  noExtractMentions: option<bool>,
  noExtractHashtags: option<bool>,
  noExtractEmojis: option<bool>,
  replyId: option<string>,
  renoteId: option<string>,
  channelId: option<string>,
  text: option<string>,
  fileIds: option<array<string>>,
  mediaIds: option<array<string>>,
  poll: option<postNotesCreateRequest_1>,
  event: option<postNotesCreateRequest_2>,
  scheduledDelete: option<postNotesCreateRequest_3>,
  deliveryTargets: option<postNotesCreateRequest_4>,
}

let postNotesCreateRequest_4Schema = S.object(s => {
    mode: s.field("mode", S.string),
    hosts: s.field("hosts", S.array(S.string)),
  })

let postNotesCreateRequest_3Schema = S.object(s => {
    deleteAt: s.fieldOr("deleteAt", S.nullableAsOption(S.int), None),
    deleteAfter: s.fieldOr("deleteAfter", S.nullableAsOption(S.int->S.min(1)), None),
  })

let postNotesCreateRequest_2Schema = S.object(s => {
    title: s.fieldOr("title", S.nullableAsOption(S.string->S.min(1)->S.max(128)), None),
    start: s.fieldOr("start", S.nullableAsOption(S.int), None),
    end_: s.fieldOr("end", S.nullableAsOption(S.int), None),
    metadata: s.field("metadata", S.option(S.dict(S.json))),
  })

let postNotesCreateRequest_1Schema = S.object(s => {
    choices: s.field("choices", S.array(S.string->S.min(1)->S.max(50))),
    multiple: s.fieldOr("multiple", S.nullableAsOption(S.bool), None),
    expiresAt: s.fieldOr("expiresAt", S.nullableAsOption(S.int), None),
    expiredAfter: s.fieldOr("expiredAfter", S.nullableAsOption(S.int->S.min(1)), None),
  })

let postNotesCreateRequestSchema = S.object(s => {
    visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
    visibleUserIds: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
    cw: s.fieldOr("cw", S.nullableAsOption(S.string->S.min(1)->S.max(100)), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    reactionAcceptance: s.fieldOr("reactionAcceptance", S.nullableAsOption(S.string), None),
    disableRightClick: s.fieldOr("disableRightClick", S.nullableAsOption(S.bool), None),
    noExtractMentions: s.fieldOr("noExtractMentions", S.nullableAsOption(S.bool), None),
    noExtractHashtags: s.fieldOr("noExtractHashtags", S.nullableAsOption(S.bool), None),
    noExtractEmojis: s.fieldOr("noExtractEmojis", S.nullableAsOption(S.bool), None),
    replyId: s.fieldOr("replyId", S.nullableAsOption(S.string), None),
    renoteId: s.fieldOr("renoteId", S.nullableAsOption(S.string), None),
    channelId: s.fieldOr("channelId", S.nullableAsOption(S.string), None),
    text: s.fieldOr("text", S.nullableAsOption(S.string->S.min(1)->S.max(3000)), None),
    fileIds: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    mediaIds: s.fieldOr("mediaIds", S.nullableAsOption(S.array(S.string)), None),
    poll: s.fieldOr("poll", S.nullableAsOption(postNotesCreateRequest_1Schema), None),
    event: s.fieldOr("event", S.nullableAsOption(postNotesCreateRequest_2Schema), None),
    scheduledDelete: s.fieldOr("scheduledDelete", S.nullableAsOption(postNotesCreateRequest_3Schema), None),
    deliveryTargets: s.fieldOr("deliveryTargets", S.nullableAsOption(postNotesCreateRequest_4Schema), None),
  })

type postNotesCreateResponse = {
  createdNote: KokonectLinkComponentSchemas.Note.t,
}

let postNotesCreateResponseSchema = S.object(s => {
    createdNote: s.field("createdNote", KokonectLinkComponentSchemas.Note.schema),
  })

/**
 * notes/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:notes*
 */
let postNotesCreate = (~body: postNotesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesCreateRequestSchema)
  fetch(
    ~url="/notes/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

/** The number of drafts */
type postNotesDraftsCountResponse = float

// The number of drafts
let postNotesDraftsCountResponseSchema = S.float

/**
 * notes/drafts/count
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesDraftsCount = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDraftsCountResponse> => {

  fetch(
    ~url="/notes/drafts/count",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesDraftsCountResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesDraftsCreateRequest_4 = {
  mode: string,
  hosts: array<string>,
}

type postNotesDraftsCreateRequest_3 = {
  deleteAt: option<int>,
  deleteAfter: option<int>,
}

type postNotesDraftsCreateRequest_2 = {
  title: option<string>,
  start: option<int>,
  @as("end") end_: option<int>,
  metadata: option<dict<JSON.t>>,
}

type postNotesDraftsCreateRequest_1 = {
  choices: array<string>,
  multiple: option<bool>,
  expiresAt: option<int>,
  expiredAfter: option<int>,
}

type postNotesDraftsCreateRequest = {
  visibility: option<string>,
  visibleUserIds: option<array<string>>,
  cw: option<string>,
  hashtag: option<string>,
  localOnly: option<bool>,
  reactionAcceptance: option<string>,
  disableRightClick: option<bool>,
  replyId: option<string>,
  renoteId: option<string>,
  channelId: option<string>,
  text: option<string>,
  fileIds: option<array<string>>,
  poll: option<postNotesDraftsCreateRequest_1>,
  event: option<postNotesDraftsCreateRequest_2>,
  scheduledAt: option<int>,
  isActuallyScheduled: option<bool>,
  scheduledDelete: option<postNotesDraftsCreateRequest_3>,
  deliveryTargets: option<postNotesDraftsCreateRequest_4>,
}

let postNotesDraftsCreateRequest_4Schema = S.object(s => {
    mode: s.field("mode", S.string),
    hosts: s.field("hosts", S.array(S.string)),
  })

let postNotesDraftsCreateRequest_3Schema = S.object(s => {
    deleteAt: s.fieldOr("deleteAt", S.nullableAsOption(S.int), None),
    deleteAfter: s.fieldOr("deleteAfter", S.nullableAsOption(S.int->S.min(1)), None),
  })

let postNotesDraftsCreateRequest_2Schema = S.object(s => {
    title: s.fieldOr("title", S.nullableAsOption(S.string->S.min(1)->S.max(128)), None),
    start: s.fieldOr("start", S.nullableAsOption(S.int), None),
    end_: s.fieldOr("end", S.nullableAsOption(S.int), None),
    metadata: s.field("metadata", S.option(S.dict(S.json))),
  })

let postNotesDraftsCreateRequest_1Schema = S.object(s => {
    choices: s.field("choices", S.array(S.string->S.min(1)->S.max(50))),
    multiple: s.fieldOr("multiple", S.nullableAsOption(S.bool), None),
    expiresAt: s.fieldOr("expiresAt", S.nullableAsOption(S.int), None),
    expiredAfter: s.fieldOr("expiredAfter", S.nullableAsOption(S.int->S.min(1)), None),
  })

let postNotesDraftsCreateRequestSchema = S.object(s => {
    visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
    visibleUserIds: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
    cw: s.fieldOr("cw", S.nullableAsOption(S.string->S.min(1)->S.max(100)), None),
    hashtag: s.fieldOr("hashtag", S.nullableAsOption(S.string->S.max(200)), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    reactionAcceptance: s.fieldOr("reactionAcceptance", S.nullableAsOption(S.string), None),
    disableRightClick: s.fieldOr("disableRightClick", S.nullableAsOption(S.bool), None),
    replyId: s.fieldOr("replyId", S.nullableAsOption(S.string), None),
    renoteId: s.fieldOr("renoteId", S.nullableAsOption(S.string), None),
    channelId: s.fieldOr("channelId", S.nullableAsOption(S.string), None),
    text: s.fieldOr("text", S.nullableAsOption(S.string->S.min(0)->S.max(3000)), None),
    fileIds: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    poll: s.fieldOr("poll", S.nullableAsOption(postNotesDraftsCreateRequest_1Schema), None),
    event: s.fieldOr("event", S.nullableAsOption(postNotesDraftsCreateRequest_2Schema), None),
    scheduledAt: s.fieldOr("scheduledAt", S.nullableAsOption(S.int), None),
    isActuallyScheduled: s.fieldOr("isActuallyScheduled", S.nullableAsOption(S.bool), None),
    scheduledDelete: s.fieldOr("scheduledDelete", S.nullableAsOption(postNotesDraftsCreateRequest_3Schema), None),
    deliveryTargets: s.fieldOr("deliveryTargets", S.nullableAsOption(postNotesDraftsCreateRequest_4Schema), None),
  })

type postNotesDraftsCreateResponse = {
  createdDraft: KokonectLinkComponentSchemas.NoteDraft.t,
}

let postNotesDraftsCreateResponseSchema = S.object(s => {
    createdDraft: s.field("createdDraft", KokonectLinkComponentSchemas.NoteDraft.schema),
  })

/**
 * notes/drafts/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postNotesDraftsCreate = (~body: postNotesDraftsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDraftsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDraftsCreateRequestSchema)
  fetch(
    ~url="/notes/drafts/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesDraftsCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesDraftsDeleteRequest = {
  draftId: string,
}

let postNotesDraftsDeleteRequestSchema = S.object(s => {
    draftId: s.field("draftId", S.string),
  })

type postNotesDraftsDeleteResponse = unit

/**
 * notes/drafts/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postNotesDraftsDelete = (~body: postNotesDraftsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDraftsDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDraftsDeleteRequestSchema)
  fetch(
    ~url="/notes/drafts/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postNotesDraftsListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  scheduled: option<bool>,
}

let postNotesDraftsListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    scheduled: s.fieldOr("scheduled", S.nullableAsOption(S.bool), None),
  })

type postNotesDraftsListResponse = array<KokonectLinkComponentSchemas.NoteDraft.t>

let postNotesDraftsListResponseSchema = S.array(KokonectLinkComponentSchemas.NoteDraft.schema)

/**
 * notes/drafts/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesDraftsList = (~body: postNotesDraftsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDraftsListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDraftsListRequestSchema)
  fetch(
    ~url="/notes/drafts/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesDraftsListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesDraftsUpdateRequest_4 = {
  mode: string,
  hosts: array<string>,
}

type postNotesDraftsUpdateRequest_3 = {
  deleteAt: option<int>,
  deleteAfter: option<int>,
}

type postNotesDraftsUpdateRequest_2 = {
  title: option<string>,
  start: option<int>,
  @as("end") end_: option<int>,
  metadata: option<dict<JSON.t>>,
}

type postNotesDraftsUpdateRequest_1 = {
  choices: array<string>,
  multiple: option<bool>,
  expiresAt: option<int>,
  expiredAfter: option<int>,
}

type postNotesDraftsUpdateRequest = {
  draftId: string,
  visibility: option<string>,
  visibleUserIds: option<array<string>>,
  cw: option<string>,
  disableRightClick: option<bool>,
  hashtag: option<string>,
  localOnly: option<bool>,
  reactionAcceptance: option<string>,
  replyId: option<string>,
  renoteId: option<string>,
  channelId: option<string>,
  text: option<string>,
  fileIds: option<array<string>>,
  poll: option<postNotesDraftsUpdateRequest_1>,
  scheduledAt: option<int>,
  isActuallyScheduled: option<bool>,
  event: option<postNotesDraftsUpdateRequest_2>,
  scheduledDelete: option<postNotesDraftsUpdateRequest_3>,
  deliveryTargets: option<postNotesDraftsUpdateRequest_4>,
}

let postNotesDraftsUpdateRequest_4Schema = S.object(s => {
    mode: s.field("mode", S.string),
    hosts: s.field("hosts", S.array(S.string)),
  })

let postNotesDraftsUpdateRequest_3Schema = S.object(s => {
    deleteAt: s.fieldOr("deleteAt", S.nullableAsOption(S.int), None),
    deleteAfter: s.fieldOr("deleteAfter", S.nullableAsOption(S.int->S.min(1)), None),
  })

let postNotesDraftsUpdateRequest_2Schema = S.object(s => {
    title: s.fieldOr("title", S.nullableAsOption(S.string->S.min(1)->S.max(128)), None),
    start: s.fieldOr("start", S.nullableAsOption(S.int), None),
    end_: s.fieldOr("end", S.nullableAsOption(S.int), None),
    metadata: s.field("metadata", S.option(S.dict(S.json))),
  })

let postNotesDraftsUpdateRequest_1Schema = S.object(s => {
    choices: s.field("choices", S.array(S.string->S.min(1)->S.max(50))),
    multiple: s.fieldOr("multiple", S.nullableAsOption(S.bool), None),
    expiresAt: s.fieldOr("expiresAt", S.nullableAsOption(S.int), None),
    expiredAfter: s.fieldOr("expiredAfter", S.nullableAsOption(S.int->S.min(1)), None),
  })

let postNotesDraftsUpdateRequestSchema = S.object(s => {
    draftId: s.field("draftId", S.string),
    visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
    visibleUserIds: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
    cw: s.fieldOr("cw", S.nullableAsOption(S.string->S.min(1)->S.max(100)), None),
    disableRightClick: s.fieldOr("disableRightClick", S.nullableAsOption(S.bool), None),
    hashtag: s.fieldOr("hashtag", S.nullableAsOption(S.string->S.max(200)), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    reactionAcceptance: s.fieldOr("reactionAcceptance", S.nullableAsOption(S.string), None),
    replyId: s.fieldOr("replyId", S.nullableAsOption(S.string), None),
    renoteId: s.fieldOr("renoteId", S.nullableAsOption(S.string), None),
    channelId: s.fieldOr("channelId", S.nullableAsOption(S.string), None),
    text: s.fieldOr("text", S.nullableAsOption(S.string->S.min(0)->S.max(3000)), None),
    fileIds: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    poll: s.fieldOr("poll", S.nullableAsOption(postNotesDraftsUpdateRequest_1Schema), None),
    scheduledAt: s.fieldOr("scheduledAt", S.nullableAsOption(S.int), None),
    isActuallyScheduled: s.fieldOr("isActuallyScheduled", S.nullableAsOption(S.bool), None),
    event: s.fieldOr("event", S.nullableAsOption(postNotesDraftsUpdateRequest_2Schema), None),
    scheduledDelete: s.fieldOr("scheduledDelete", S.nullableAsOption(postNotesDraftsUpdateRequest_3Schema), None),
    deliveryTargets: s.fieldOr("deliveryTargets", S.nullableAsOption(postNotesDraftsUpdateRequest_4Schema), None),
  })

type postNotesDraftsUpdateResponse = {
  updatedDraft: KokonectLinkComponentSchemas.NoteDraft.t,
}

let postNotesDraftsUpdateResponseSchema = S.object(s => {
    updatedDraft: s.field("updatedDraft", KokonectLinkComponentSchemas.NoteDraft.schema),
  })

/**
 * notes/drafts/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postNotesDraftsUpdate = (~body: postNotesDraftsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDraftsUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDraftsUpdateRequestSchema)
  fetch(
    ~url="/notes/drafts/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesDraftsUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesEventsSearchRequest = {
  query: option<string>,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
  origin: option<string>,
  offset: option<int>,
  users: option<JSON.t>,
  sinceDate: option<int>,
  untilDate: option<int>,
  filters: option<JSON.t>,
  sortBy: option<string>,
}

let postNotesEventsSearchRequestSchema = S.object(s => {
    query: s.fieldOr("query", S.nullableAsOption(S.string), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    users: s.fieldOr("users", S.nullableAsOption(S.json), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    filters: s.fieldOr("filters", S.nullableAsOption(S.json), None),
    sortBy: s.fieldOr("sortBy", S.nullableAsOption(S.string), None),
  })

type postNotesEventsSearchResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesEventsSearchResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/events/search
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesEventsSearch = (~body: postNotesEventsSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesEventsSearchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesEventsSearchRequestSchema)
  fetch(
    ~url="/notes/events/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesEventsSearchResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesGlobalTimelineRequest = {
  withFiles: option<bool>,
  withRenotes: option<bool>,
  withCats: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postNotesGlobalTimelineRequestSchema = S.object(s => {
    withFiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    withRenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    withCats: s.fieldOr("withCats", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postNotesGlobalTimelineResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesGlobalTimelineResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/global-timeline
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesGlobalTimeline = (~body: postNotesGlobalTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesGlobalTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesGlobalTimelineRequestSchema)
  fetch(
    ~url="/notes/global-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesGlobalTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesHistoryRequest = {
  noteId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postNotesHistoryRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postNotesHistoryResponse = array<KokonectLinkComponentSchemas.NoteHistory.t>

let postNotesHistoryResponseSchema = S.array(KokonectLinkComponentSchemas.NoteHistory.schema)

/**
 * notes/history
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesHistory = (~body: postNotesHistoryRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesHistoryResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesHistoryRequestSchema)
  fetch(
    ~url="/notes/history",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesHistoryResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesHybridTimelineRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  includeMyRenotes: option<bool>,
  includeRenotedMyNotes: option<bool>,
  includeLocalRenotes: option<bool>,
  withFiles: option<bool>,
  withRenotes: option<bool>,
  withReplies: option<bool>,
  withCats: option<bool>,
}

let postNotesHybridTimelineRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    allowPartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    includeMyRenotes: s.fieldOr("includeMyRenotes", S.nullableAsOption(S.bool), None),
    includeRenotedMyNotes: s.fieldOr("includeRenotedMyNotes", S.nullableAsOption(S.bool), None),
    includeLocalRenotes: s.fieldOr("includeLocalRenotes", S.nullableAsOption(S.bool), None),
    withFiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    withRenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
    withCats: s.fieldOr("withCats", S.nullableAsOption(S.bool), None),
  })

type postNotesHybridTimelineResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesHybridTimelineResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/hybrid-timeline
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesHybridTimeline = (~body: postNotesHybridTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesHybridTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesHybridTimelineRequestSchema)
  fetch(
    ~url="/notes/hybrid-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesHybridTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesLocalTimelineRequest = {
  withFiles: option<bool>,
  withRenotes: option<bool>,
  withReplies: option<bool>,
  withCats: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  allowPartial: option<bool>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postNotesLocalTimelineRequestSchema = S.object(s => {
    withFiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    withRenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
    withCats: s.fieldOr("withCats", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    allowPartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postNotesLocalTimelineResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesLocalTimelineResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/local-timeline
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesLocalTimeline = (~body: postNotesLocalTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesLocalTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesLocalTimelineRequestSchema)
  fetch(
    ~url="/notes/local-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesLocalTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesMentionsRequest = {
  following: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  visibility: option<string>,
}

let postNotesMentionsRequestSchema = S.object(s => {
    following: s.fieldOr("following", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
  })

type postNotesMentionsResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesMentionsResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/mentions
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesMentions = (~body: postNotesMentionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesMentionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesMentionsRequestSchema)
  fetch(
    ~url="/notes/mentions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesMentionsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesPollsTranslateRequest = {
  noteId: string,
  targetLang: string,
}

let postNotesPollsTranslateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    targetLang: s.field("targetLang", S.string),
  })

type postNotesPollsTranslateResponse = {
  sourceLang: string,
  text: option<array<option<string>>>,
}

let postNotesPollsTranslateResponseSchema = S.object(s => {
    sourceLang: s.field("sourceLang", S.string),
    text: s.fieldOr("text", S.nullableAsOption(S.array(S.nullableAsOption(S.string))), None),
  })

/**
 * notes/polls/translate
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesPollsTranslate = (~body: postNotesPollsTranslateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesPollsTranslateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesPollsTranslateRequestSchema)
  fetch(
    ~url="/notes/polls/translate",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesPollsTranslateResponseSchema)
  value
    ->Promise.resolve
  })
}

type getNotesReactionsRequest = {
  noteId: string,
  @as("type") type_: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let getNotesReactionsRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    type_: s.fieldOr("type", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type getNotesReactionsResponse = array<KokonectLinkComponentSchemas.NoteReaction.t>

let getNotesReactionsResponseSchema = S.array(KokonectLinkComponentSchemas.NoteReaction.schema)

/**
 * notes/reactions
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getNotesReactions = (~body: getNotesReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getNotesReactionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getNotesReactionsRequestSchema)
  fetch(
    ~url="/notes/reactions",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getNotesReactionsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesReactionsRequest = {
  noteId: string,
  @as("type") type_: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postNotesReactionsRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    type_: s.fieldOr("type", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postNotesReactionsResponse = array<KokonectLinkComponentSchemas.NoteReaction.t>

let postNotesReactionsResponseSchema = S.array(KokonectLinkComponentSchemas.NoteReaction.schema)

/**
 * notes/reactions
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesReactions = (~body: postNotesReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesReactionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesReactionsRequestSchema)
  fetch(
    ~url="/notes/reactions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesReactionsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesRenotesRequest = {
  noteId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postNotesRenotesRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postNotesRenotesResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesRenotesResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/renotes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesRenotes = (~body: postNotesRenotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesRenotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRenotesRequestSchema)
  fetch(
    ~url="/notes/renotes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesRenotesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesRepliesRequest = {
  noteId: string,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postNotesRepliesRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postNotesRepliesResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesRepliesResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/replies
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesReplies = (~body: postNotesRepliesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesRepliesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRepliesRequestSchema)
  fetch(
    ~url="/notes/replies",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesRepliesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesSearchRequest = {
  query: string,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
  offset: option<int>,
  host: option<string>,
  userId: option<string>,
  channelId: option<string>,
}

let postNotesSearchRequestSchema = S.object(s => {
    query: s.field("query", S.string),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    host: s.fieldOr("host", S.nullableAsOption(S.string), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    channelId: s.fieldOr("channelId", S.nullableAsOption(S.string), None),
  })

type postNotesSearchResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesSearchResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/search
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesSearch = (~body: postNotesSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesSearchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesSearchRequestSchema)
  fetch(
    ~url="/notes/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesSearchResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesSearchByTagRequest = {
  reply: option<bool>,
  renote: option<bool>,
  withFiles: option<bool>,
  poll: option<bool>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postNotesSearchByTagRequestSchema = S.object(s => {
    reply: s.fieldOr("reply", S.nullableAsOption(S.bool), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.bool), None),
    withFiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    poll: s.fieldOr("poll", S.nullableAsOption(S.bool), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postNotesSearchByTagResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesSearchByTagResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/search-by-tag
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesSearchByTag = (~body: postNotesSearchByTagRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesSearchByTagResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesSearchByTagRequestSchema)
  fetch(
    ~url="/notes/search-by-tag",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesSearchByTagResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesShowRequest = {
  noteId: string,
}

let postNotesShowRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesShowResponse = KokonectLinkComponentSchemas.Note.t

let postNotesShowResponseSchema = KokonectLinkComponentSchemas.Note.schema

/**
 * notes/show
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesShow = (~body: postNotesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesShowRequestSchema)
  fetch(
    ~url="/notes/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesShowPartialBulkRequest = {
  noteIds: array<string>,
}

let postNotesShowPartialBulkRequestSchema = S.object(s => {
    noteIds: s.field("noteIds", S.array(S.string)),
  })

type postNotesShowPartialBulkResponse_1 = {
  id: string,
  reactions: dict<JSON.t>,
  reactionEmojis: dict<JSON.t>,
}

type postNotesShowPartialBulkResponse = array<postNotesShowPartialBulkResponse_1>

let postNotesShowPartialBulkResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    reactions: s.field("reactions", S.dict(S.json)),
    reactionEmojis: s.field("reactionEmojis", S.dict(S.json)),
  })

let postNotesShowPartialBulkResponseSchema = S.array(postNotesShowPartialBulkResponse_1Schema)

/**
 * notes/show-partial-bulk
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesShowPartialBulk = (~body: postNotesShowPartialBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesShowPartialBulkResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesShowPartialBulkRequestSchema)
  fetch(
    ~url="/notes/show-partial-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesShowPartialBulkResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesStateRequest = {
  noteId: string,
}

let postNotesStateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesStateResponse = {
  isFavorited: bool,
  isMutedThread: bool,
  isRenoted: bool,
}

let postNotesStateResponseSchema = S.object(s => {
    isFavorited: s.field("isFavorited", S.bool),
    isMutedThread: s.field("isMutedThread", S.bool),
    isRenoted: s.field("isRenoted", S.bool),
  })

/**
 * notes/state
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesState = (~body: postNotesStateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesStateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesStateRequestSchema)
  fetch(
    ~url="/notes/state",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesStateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesTimelineRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  includeMyRenotes: option<bool>,
  includeRenotedMyNotes: option<bool>,
  includeLocalRenotes: option<bool>,
  withFiles: option<bool>,
  withRenotes: option<bool>,
  withCats: option<bool>,
}

let postNotesTimelineRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    allowPartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    includeMyRenotes: s.fieldOr("includeMyRenotes", S.nullableAsOption(S.bool), None),
    includeRenotedMyNotes: s.fieldOr("includeRenotedMyNotes", S.nullableAsOption(S.bool), None),
    includeLocalRenotes: s.fieldOr("includeLocalRenotes", S.nullableAsOption(S.bool), None),
    withFiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    withRenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    withCats: s.fieldOr("withCats", S.nullableAsOption(S.bool), None),
  })

type postNotesTimelineResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesTimelineResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/timeline
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesTimeline = (~body: postNotesTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesTimelineRequestSchema)
  fetch(
    ~url="/notes/timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesUpdateRequest_3 = {
  deleteAt: option<int>,
  deleteAfter: option<int>,
}

type postNotesUpdateRequest_2 = {
  title: option<string>,
  start: option<int>,
  @as("end") end_: option<int>,
  metadata: option<dict<JSON.t>>,
}

type postNotesUpdateRequest_1 = {
  choices: array<string>,
  multiple: option<bool>,
  expiresAt: option<int>,
  expiredAfter: option<int>,
}

type postNotesUpdateRequest = {
  noteId: string,
  text: string,
  fileIds: option<array<string>>,
  mediaIds: option<array<string>>,
  poll: option<postNotesUpdateRequest_1>,
  event: option<postNotesUpdateRequest_2>,
  cw: option<string>,
  disableRightClick: option<bool>,
  scheduledDelete: option<postNotesUpdateRequest_3>,
}

let postNotesUpdateRequest_3Schema = S.object(s => {
    deleteAt: s.fieldOr("deleteAt", S.nullableAsOption(S.int), None),
    deleteAfter: s.fieldOr("deleteAfter", S.nullableAsOption(S.int->S.min(1)), None),
  })

let postNotesUpdateRequest_2Schema = S.object(s => {
    title: s.fieldOr("title", S.nullableAsOption(S.string->S.min(1)->S.max(128)), None),
    start: s.fieldOr("start", S.nullableAsOption(S.int), None),
    end_: s.fieldOr("end", S.nullableAsOption(S.int), None),
    metadata: s.field("metadata", S.option(S.dict(S.json))),
  })

let postNotesUpdateRequest_1Schema = S.object(s => {
    choices: s.field("choices", S.array(S.string->S.min(1)->S.max(50))),
    multiple: s.fieldOr("multiple", S.nullableAsOption(S.bool), None),
    expiresAt: s.fieldOr("expiresAt", S.nullableAsOption(S.int), None),
    expiredAfter: s.fieldOr("expiredAfter", S.nullableAsOption(S.int->S.min(1)), None),
  })

let postNotesUpdateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    text: s.field("text", S.string->S.min(1)->S.max(3000)),
    fileIds: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    mediaIds: s.fieldOr("mediaIds", S.nullableAsOption(S.array(S.string)), None),
    poll: s.fieldOr("poll", S.nullableAsOption(postNotesUpdateRequest_1Schema), None),
    event: s.fieldOr("event", S.nullableAsOption(postNotesUpdateRequest_2Schema), None),
    cw: s.field("cw", S.nullableAsOption(S.string->S.max(100))),
    disableRightClick: s.fieldOr("disableRightClick", S.nullableAsOption(S.bool), None),
    scheduledDelete: s.fieldOr("scheduledDelete", S.nullableAsOption(postNotesUpdateRequest_3Schema), None),
  })

type postNotesUpdateResponse = unit

/**
 * notes/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:notes*
 */
let postNotesUpdate = (~body: postNotesUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesUpdateRequestSchema)
  fetch(
    ~url="/notes/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postNotesUserListTimelineRequest = {
  listId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  includeMyRenotes: option<bool>,
  includeRenotedMyNotes: option<bool>,
  includeLocalRenotes: option<bool>,
  withRenotes: option<bool>,
  withFiles: option<bool>,
  withCats: option<bool>,
}

let postNotesUserListTimelineRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    allowPartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    includeMyRenotes: s.fieldOr("includeMyRenotes", S.nullableAsOption(S.bool), None),
    includeRenotedMyNotes: s.fieldOr("includeRenotedMyNotes", S.nullableAsOption(S.bool), None),
    includeLocalRenotes: s.fieldOr("includeLocalRenotes", S.nullableAsOption(S.bool), None),
    withRenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    withFiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
    withCats: s.fieldOr("withCats", S.nullableAsOption(S.bool), None),
  })

type postNotesUserListTimelineResponse = array<KokonectLinkComponentSchemas.Note.t>

let postNotesUserListTimelineResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * notes/user-list-timeline
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postNotesUserListTimeline = (~body: postNotesUserListTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesUserListTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesUserListTimelineRequestSchema)
  fetch(
    ~url="/notes/user-list-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesUserListTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}
