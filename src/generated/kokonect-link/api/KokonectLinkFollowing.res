// kokonect-link API for following
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postFollowingCreateRequest = {
  userId: string,
  withReplies: option<bool>,
}

let postFollowingCreateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    withReplies: s.field("withReplies", S.option(S.bool)),
  })

type postFollowingCreateResponse = KokonectLinkComponentSchemas.UserLite.t

let postFollowingCreateResponseSchema = KokonectLinkComponentSchemas.UserLite.schema

/**
following/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingCreate = async (~body: postFollowingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingCreateRequestSchema)
  let response = await fetch(
    ~url="/following/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingCreateResponseSchema)
}

type postFollowingDeleteRequest = {
  userId: string,
}

let postFollowingDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingDeleteResponse = KokonectLinkComponentSchemas.UserLite.t

let postFollowingDeleteResponseSchema = KokonectLinkComponentSchemas.UserLite.schema

/**
following/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingDelete = async (~body: postFollowingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingDeleteRequestSchema)
  let response = await fetch(
    ~url="/following/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingDeleteResponseSchema)
}

type postFollowingInvalidateRequest = {
  userId: string,
}

let postFollowingInvalidateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingInvalidateResponse = KokonectLinkComponentSchemas.UserLite.t

let postFollowingInvalidateResponseSchema = KokonectLinkComponentSchemas.UserLite.schema

/**
following/invalidate

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingInvalidate = async (~body: postFollowingInvalidateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingInvalidateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingInvalidateRequestSchema)
  let response = await fetch(
    ~url="/following/invalidate",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingInvalidateResponseSchema)
}

type postFollowingRequestsCancelRequest = {
  userId: string,
}

let postFollowingRequestsCancelRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingRequestsCancelResponse = KokonectLinkComponentSchemas.UserLite.t

let postFollowingRequestsCancelResponseSchema = KokonectLinkComponentSchemas.UserLite.schema

/**
following/requests/cancel

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingRequestsCancel = async (~body: postFollowingRequestsCancelRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingRequestsCancelResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsCancelRequestSchema)
  let response = await fetch(
    ~url="/following/requests/cancel",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingRequestsCancelResponseSchema)
}

type postFollowingRequestsListRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postFollowingRequestsListRequestSchema = S.object(s => {
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postFollowingRequestsListResponse_1 = {
  id: string,
  follower: KokonectLinkComponentSchemas.UserLite.t,
  followee: KokonectLinkComponentSchemas.UserLite.t,
}

type postFollowingRequestsListResponse = array<postFollowingRequestsListResponse_1>

let postFollowingRequestsListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    follower: s.field("follower", KokonectLinkComponentSchemas.UserLite.schema),
    followee: s.field("followee", KokonectLinkComponentSchemas.UserLite.schema),
  })

let postFollowingRequestsListResponseSchema = S.array(postFollowingRequestsListResponse_1Schema)

/**
following/requests/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:following*
*/
let postFollowingRequestsList = async (~body: postFollowingRequestsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingRequestsListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsListRequestSchema)
  let response = await fetch(
    ~url="/following/requests/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingRequestsListResponseSchema)
}

type postFollowingRequestsSentRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postFollowingRequestsSentRequestSchema = S.object(s => {
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postFollowingRequestsSentResponse_1 = {
  id: string,
  follower: KokonectLinkComponentSchemas.UserLite.t,
  followee: KokonectLinkComponentSchemas.UserLite.t,
}

type postFollowingRequestsSentResponse = array<postFollowingRequestsSentResponse_1>

let postFollowingRequestsSentResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    follower: s.field("follower", KokonectLinkComponentSchemas.UserLite.schema),
    followee: s.field("followee", KokonectLinkComponentSchemas.UserLite.schema),
  })

let postFollowingRequestsSentResponseSchema = S.array(postFollowingRequestsSentResponse_1Schema)

/**
following/requests/sent

No description provided.

**Credential required**: *Yes* / **Permission**: *read:following*
*/
let postFollowingRequestsSent = async (~body: postFollowingRequestsSentRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingRequestsSentResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsSentRequestSchema)
  let response = await fetch(
    ~url="/following/requests/sent",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingRequestsSentResponseSchema)
}

type postFollowingUpdateRequest = {
  userId: string,
  notify: option<string>,
  withReplies: option<bool>,
}

let postFollowingUpdateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    notify: s.field("notify", S.option(S.string)),
    withReplies: s.field("withReplies", S.option(S.bool)),
  })

type postFollowingUpdateResponse = KokonectLinkComponentSchemas.UserLite.t

let postFollowingUpdateResponseSchema = KokonectLinkComponentSchemas.UserLite.schema

/**
following/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingUpdate = async (~body: postFollowingUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingUpdateRequestSchema)
  let response = await fetch(
    ~url="/following/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingUpdateResponseSchema)
}
