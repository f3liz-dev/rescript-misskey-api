// SPDX-License-Identifier: MIT
// kokonect-link API for charts
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type getChartsFederationRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let getChartsFederationRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type getChartsFederationResponse = {
  deliveredInstances: array<float>,
  inboxInstances: array<float>,
  stalled: array<float>,
  sub: array<float>,
  pub: array<float>,
  pubsub: array<float>,
  subActive: array<float>,
  pubActive: array<float>,
  software: array<float>,
}

let getChartsFederationResponseSchema = S.object(s => {
    deliveredInstances: s.field("deliveredInstances", S.array(S.float)),
    inboxInstances: s.field("inboxInstances", S.array(S.float)),
    stalled: s.field("stalled", S.array(S.float)),
    sub: s.field("sub", S.array(S.float)),
    pub: s.field("pub", S.array(S.float)),
    pubsub: s.field("pubsub", S.array(S.float)),
    subActive: s.field("subActive", S.array(S.float)),
    pubActive: s.field("pubActive", S.array(S.float)),
    software: s.field("software", S.array(S.float)),
  })

/**
 * charts/federation
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsFederation = (~body: getChartsFederationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsFederationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsFederationRequestSchema)
  
  fetch(
    ~url="/charts/federation",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsFederationResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsFederationRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let postChartsFederationRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type postChartsFederationResponse = {
  deliveredInstances: array<float>,
  inboxInstances: array<float>,
  stalled: array<float>,
  sub: array<float>,
  pub: array<float>,
  pubsub: array<float>,
  subActive: array<float>,
  pubActive: array<float>,
  software: array<float>,
}

let postChartsFederationResponseSchema = S.object(s => {
    deliveredInstances: s.field("deliveredInstances", S.array(S.float)),
    inboxInstances: s.field("inboxInstances", S.array(S.float)),
    stalled: s.field("stalled", S.array(S.float)),
    sub: s.field("sub", S.array(S.float)),
    pub: s.field("pub", S.array(S.float)),
    pubsub: s.field("pubsub", S.array(S.float)),
    subActive: s.field("subActive", S.array(S.float)),
    pubActive: s.field("pubActive", S.array(S.float)),
    software: s.field("software", S.array(S.float)),
  })

/**
 * charts/federation
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsFederation = (~body: postChartsFederationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsFederationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsFederationRequestSchema)
  
  fetch(
    ~url="/charts/federation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsFederationResponseSchema)
  validatedResponse
->Promise.resolve
  })
}
