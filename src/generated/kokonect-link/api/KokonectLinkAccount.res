// kokonect-link API for account
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postBlockingCreateRequest = {
  userId: string,
}

let postBlockingCreateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postBlockingCreateResponse = KokonectLinkComponentSchemas.UserDetailedNotMe.t

let postBlockingCreateResponseSchema = KokonectLinkComponentSchemas.UserDetailedNotMe.schema

/**
 * blocking/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:blocks*
 */
let postBlockingCreate = (~body: postBlockingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBlockingCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingCreateRequestSchema)
  fetch(
    ~url="/blocking/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postBlockingCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postBlockingDeleteRequest = {
  userId: string,
}

let postBlockingDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postBlockingDeleteResponse = KokonectLinkComponentSchemas.UserDetailedNotMe.t

let postBlockingDeleteResponseSchema = KokonectLinkComponentSchemas.UserDetailedNotMe.schema

/**
 * blocking/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:blocks*
 */
let postBlockingDelete = (~body: postBlockingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBlockingDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingDeleteRequestSchema)
  fetch(
    ~url="/blocking/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postBlockingDeleteResponseSchema)
  value
    ->Promise.resolve
  })
}

type postBlockingListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postBlockingListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postBlockingListResponse = array<KokonectLinkComponentSchemas.Blocking.t>

let postBlockingListResponseSchema = S.array(KokonectLinkComponentSchemas.Blocking.schema)

/**
 * blocking/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:blocks*
 */
let postBlockingList = (~body: postBlockingListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBlockingListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingListRequestSchema)
  fetch(
    ~url="/blocking/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postBlockingListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postClipsNotesRequest = {
  clipId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  search: option<JSON.t>,
}

let postClipsNotesRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    search: s.fieldOr("search", S.nullableAsOption(S.json), None),
  })

type postClipsNotesResponse = array<KokonectLinkComponentSchemas.Note.t>

let postClipsNotesResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
 * clips/notes
 *
 * No description provided.
 *
 * **Credential required**: *No* / **Permission**: *read:account*
 */
let postClipsNotes = (~body: postClipsNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsNotesRequestSchema)
  fetch(
    ~url="/clips/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postClipsNotesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFlashMyRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postFlashMyRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postFlashMyResponse = array<KokonectLinkComponentSchemas.Flash.t>

let postFlashMyResponseSchema = S.array(KokonectLinkComponentSchemas.Flash.schema)

/**
 * flash/my
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:flash*
 */
let postFlashMy = (~body: postFlashMyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashMyResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashMyRequestSchema)
  fetch(
    ~url="/flash/my",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFlashMyResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFlashMyLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  search: option<JSON.t>,
}

let postFlashMyLikesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    search: s.fieldOr("search", S.nullableAsOption(S.json), None),
  })

type postFlashMyLikesResponse = array<{
  id: string,
  flash: KokonectLinkComponentSchemas.Flash.t,
}>

let postFlashMyLikesResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    flash: s.field("flash", KokonectLinkComponentSchemas.Flash.schema),
  }))

/**
 * flash/my-likes
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:flash-likes*
 */
let postFlashMyLikes = (~body: postFlashMyLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashMyLikesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashMyLikesRequestSchema)
  fetch(
    ~url="/flash/my-likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFlashMyLikesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIResponse = KokonectLinkComponentSchemas.MeDetailed.t

let postIResponseSchema = KokonectLinkComponentSchemas.MeDetailed.schema

/**
 * i
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postI = (~body as _, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIResponse> => {

  fetch(
    ~url="/i",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIAutoDeleteSettingsResponse = {
  autoDeleteNotesAfterDays: JSON.t,
  autoDeleteKeepFavorites: bool,
}

let postIAutoDeleteSettingsResponseSchema = S.object(s => {
    autoDeleteNotesAfterDays: s.field("autoDeleteNotesAfterDays", S.json),
    autoDeleteKeepFavorites: s.field("autoDeleteKeepFavorites", S.bool),
  })

/**
 * i/auto-delete-settings
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIAutoDeleteSettings = (~body as _, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIAutoDeleteSettingsResponse> => {

  fetch(
    ~url="/i/auto-delete-settings",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIAutoDeleteSettingsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIFavoritesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postIFavoritesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postIFavoritesResponse = array<KokonectLinkComponentSchemas.NoteFavorite.t>

let postIFavoritesResponseSchema = S.array(KokonectLinkComponentSchemas.NoteFavorite.schema)

/**
 * i/favorites
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:favorites*
 */
let postIFavorites = (~body: postIFavoritesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIFavoritesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIFavoritesRequestSchema)
  fetch(
    ~url="/i/favorites",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIFavoritesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIFollowersServersResponse = {
  servers: array<{
  host: string,
  name: JSON.t,
  followersCount: float,
}>,
}

let postIFollowersServersResponseSchema = S.object(s => {
    servers: s.field("servers", S.array(S.object(s => {
    host: s.field("host", S.string),
    name: s.field("name", S.json),
    followersCount: s.field("followersCount", S.float),
  }))),
  })

/**
 * i/followers-servers
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:following*
 */
let postIFollowersServers = (~body as _, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIFollowersServersResponse> => {

  fetch(
    ~url="/i/followers-servers",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIFollowersServersResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIGalleryLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postIGalleryLikesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postIGalleryLikesResponse = array<{
  id: string,
  post: KokonectLinkComponentSchemas.GalleryPost.t,
}>

let postIGalleryLikesResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    post: s.field("post", KokonectLinkComponentSchemas.GalleryPost.schema),
  }))

/**
 * i/gallery/likes
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:gallery-likes*
 */
let postIGalleryLikes = (~body: postIGalleryLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIGalleryLikesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIGalleryLikesRequestSchema)
  fetch(
    ~url="/i/gallery/likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIGalleryLikesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIGalleryPostsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postIGalleryPostsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postIGalleryPostsResponse = array<KokonectLinkComponentSchemas.GalleryPost.t>

let postIGalleryPostsResponseSchema = S.array(KokonectLinkComponentSchemas.GalleryPost.schema)

/**
 * i/gallery/posts
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:gallery*
 */
let postIGalleryPosts = (~body: postIGalleryPostsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIGalleryPostsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIGalleryPostsRequestSchema)
  fetch(
    ~url="/i/gallery/posts",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIGalleryPostsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postINotificationsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  markAsRead: option<bool>,
  includeTypes: option<array<string>>,
  excludeTypes: option<array<string>>,
}

let postINotificationsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    markAsRead: s.fieldOr("markAsRead", S.nullableAsOption(S.bool), None),
    includeTypes: s.fieldOr("includeTypes", S.nullableAsOption(S.array(S.string)), None),
    excludeTypes: s.fieldOr("excludeTypes", S.nullableAsOption(S.array(S.string)), None),
  })

type postINotificationsResponse = array<KokonectLinkComponentSchemas.Notification.t>

let postINotificationsResponseSchema = S.array(KokonectLinkComponentSchemas.Notification.schema)

/**
 * i/notifications
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:notifications*
 */
let postINotifications = (~body: postINotificationsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postINotificationsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postINotificationsRequestSchema)
  fetch(
    ~url="/i/notifications",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postINotificationsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postINotificationsGroupedRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  markAsRead: option<bool>,
  includeTypes: option<array<string>>,
  excludeTypes: option<array<string>>,
}

let postINotificationsGroupedRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    markAsRead: s.fieldOr("markAsRead", S.nullableAsOption(S.bool), None),
    includeTypes: s.fieldOr("includeTypes", S.nullableAsOption(S.array(S.string)), None),
    excludeTypes: s.fieldOr("excludeTypes", S.nullableAsOption(S.array(S.string)), None),
  })

type postINotificationsGroupedResponse = array<KokonectLinkComponentSchemas.Notification.t>

let postINotificationsGroupedResponseSchema = S.array(KokonectLinkComponentSchemas.Notification.schema)

/**
 * i/notifications-grouped
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:notifications*
 */
let postINotificationsGrouped = (~body: postINotificationsGroupedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postINotificationsGroupedResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postINotificationsGroupedRequestSchema)
  fetch(
    ~url="/i/notifications-grouped",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postINotificationsGroupedResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIPageLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postIPageLikesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postIPageLikesResponse = array<{
  id: string,
  page: KokonectLinkComponentSchemas.Page.t,
}>

let postIPageLikesResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    page: s.field("page", KokonectLinkComponentSchemas.Page.schema),
  }))

/**
 * i/page-likes
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:page-likes*
 */
let postIPageLikes = (~body: postIPageLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIPageLikesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPageLikesRequestSchema)
  fetch(
    ~url="/i/page-likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIPageLikesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIPagesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postIPagesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postIPagesResponse = array<KokonectLinkComponentSchemas.Page.t>

let postIPagesResponseSchema = S.array(KokonectLinkComponentSchemas.Page.schema)

/**
 * i/pages
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:pages*
 */
let postIPages = (~body: postIPagesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIPagesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPagesRequestSchema)
  fetch(
    ~url="/i/pages",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIPagesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIPinRequest = {
  noteId: string,
}

let postIPinRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postIPinResponse = KokonectLinkComponentSchemas.MeDetailed.t

let postIPinResponseSchema = KokonectLinkComponentSchemas.MeDetailed.schema

/**
 * i/pin
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIPin = (~body: postIPinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIPinResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPinRequestSchema)
  fetch(
    ~url="/i/pin",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIPinResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIUnpinRequest = {
  noteId: string,
}

let postIUnpinRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postIUnpinResponse = KokonectLinkComponentSchemas.MeDetailed.t

let postIUnpinResponseSchema = KokonectLinkComponentSchemas.MeDetailed.schema

/**
 * i/unpin
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIUnpin = (~body: postIUnpinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIUnpinResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUnpinRequestSchema)
  fetch(
    ~url="/i/unpin",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIUnpinResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIUpdateRequest = {
  name: option<JSON.t>,
  description: option<JSON.t>,
  followedMessage: option<JSON.t>,
  location: option<JSON.t>,
  birthday: option<JSON.t>,
  lang: option<JSON.t>,
  avatarId: option<JSON.t>,
  avatarDecorations: option<array<{
  id: string,
  angle: option<JSON.t>,
  flipH: option<JSON.t>,
  offsetX: option<JSON.t>,
  offsetY: option<JSON.t>,
  scale: option<JSON.t>,
  opacity: option<JSON.t>,
}>>,
  bannerId: option<JSON.t>,
  fields: option<array<{
  name: string,
  value: string,
}>>,
  isLocked: option<bool>,
  isExplorable: option<bool>,
  hideOnlineStatus: option<bool>,
  publicReactions: option<bool>,
  carefulBot: option<bool>,
  autoAcceptFollowed: option<bool>,
  noCrawle: option<bool>,
  preventAiLearning: option<bool>,
  requireSigninToViewContents: option<bool>,
  makeNotesFollowersOnlyBefore: option<JSON.t>,
  makeNotesHiddenBefore: option<JSON.t>,
  isBot: option<bool>,
  isCat: option<bool>,
  injectFeaturedNote: option<bool>,
  receiveAnnouncementEmail: option<bool>,
  alwaysMarkNsfw: option<bool>,
  autoSensitive: option<bool>,
  followingVisibility: option<string>,
  followersVisibility: option<string>,
  chatScope: option<string>,
  pinnedPageId: option<JSON.t>,
  mutedWords: option<array<array<string>>>,
  hardMutedWords: option<array<array<string>>>,
  mutedInstances: option<array<string>>,
  notificationRecieveConfig: option<{
  note: option<JSON.t>,
  follow: option<JSON.t>,
  mention: option<JSON.t>,
  reply: option<JSON.t>,
  renote: option<JSON.t>,
  quote: option<JSON.t>,
  reaction: option<JSON.t>,
  pollEnded: option<JSON.t>,
  scheduledNotePosted: option<JSON.t>,
  scheduledNotePostFailed: option<JSON.t>,
  receiveFollowRequest: option<JSON.t>,
  followRequestAccepted: option<JSON.t>,
  groupInvited: option<JSON.t>,
  roleAssigned: option<JSON.t>,
  chatRoomInvitationReceived: option<JSON.t>,
  achievementEarned: option<JSON.t>,
  app: option<JSON.t>,
  test: option<JSON.t>,
}>,
  emailNotificationTypes: option<array<string>>,
  alsoKnownAs: option<array<string>>,
  setFederationAvatarShape: option<JSON.t>,
  isSquareAvatars: option<JSON.t>,
}

let postIUpdateRequestSchema = S.object(s => {
    name: s.fieldOr("name", S.nullableAsOption(S.json), None),
    description: s.fieldOr("description", S.nullableAsOption(S.json), None),
    followedMessage: s.fieldOr("followedMessage", S.nullableAsOption(S.json), None),
    location: s.fieldOr("location", S.nullableAsOption(S.json), None),
    birthday: s.fieldOr("birthday", S.nullableAsOption(S.json), None),
    lang: s.fieldOr("lang", S.nullableAsOption(S.json), None),
    avatarId: s.fieldOr("avatarId", S.nullableAsOption(S.json), None),
    avatarDecorations: s.fieldOr("avatarDecorations", S.nullableAsOption(S.array(S.object(s => {
    id: s.field("id", S.string),
    angle: s.fieldOr("angle", S.nullableAsOption(S.json), None),
    flipH: s.fieldOr("flipH", S.nullableAsOption(S.json), None),
    offsetX: s.fieldOr("offsetX", S.nullableAsOption(S.json), None),
    offsetY: s.fieldOr("offsetY", S.nullableAsOption(S.json), None),
    scale: s.fieldOr("scale", S.nullableAsOption(S.json), None),
    opacity: s.fieldOr("opacity", S.nullableAsOption(S.json), None),
  }))), None),
    bannerId: s.fieldOr("bannerId", S.nullableAsOption(S.json), None),
    fields: s.fieldOr("fields", S.nullableAsOption(S.array(S.object(s => {
    name: s.field("name", S.string),
    value: s.field("value", S.string),
  }))), None),
    isLocked: s.fieldOr("isLocked", S.nullableAsOption(S.bool), None),
    isExplorable: s.fieldOr("isExplorable", S.nullableAsOption(S.bool), None),
    hideOnlineStatus: s.fieldOr("hideOnlineStatus", S.nullableAsOption(S.bool), None),
    publicReactions: s.fieldOr("publicReactions", S.nullableAsOption(S.bool), None),
    carefulBot: s.fieldOr("carefulBot", S.nullableAsOption(S.bool), None),
    autoAcceptFollowed: s.fieldOr("autoAcceptFollowed", S.nullableAsOption(S.bool), None),
    noCrawle: s.fieldOr("noCrawle", S.nullableAsOption(S.bool), None),
    preventAiLearning: s.fieldOr("preventAiLearning", S.nullableAsOption(S.bool), None),
    requireSigninToViewContents: s.fieldOr("requireSigninToViewContents", S.nullableAsOption(S.bool), None),
    makeNotesFollowersOnlyBefore: s.fieldOr("makeNotesFollowersOnlyBefore", S.nullableAsOption(S.json), None),
    makeNotesHiddenBefore: s.fieldOr("makeNotesHiddenBefore", S.nullableAsOption(S.json), None),
    isBot: s.fieldOr("isBot", S.nullableAsOption(S.bool), None),
    isCat: s.fieldOr("isCat", S.nullableAsOption(S.bool), None),
    injectFeaturedNote: s.fieldOr("injectFeaturedNote", S.nullableAsOption(S.bool), None),
    receiveAnnouncementEmail: s.fieldOr("receiveAnnouncementEmail", S.nullableAsOption(S.bool), None),
    alwaysMarkNsfw: s.fieldOr("alwaysMarkNsfw", S.nullableAsOption(S.bool), None),
    autoSensitive: s.fieldOr("autoSensitive", S.nullableAsOption(S.bool), None),
    followingVisibility: s.fieldOr("followingVisibility", S.nullableAsOption(S.string), None),
    followersVisibility: s.fieldOr("followersVisibility", S.nullableAsOption(S.string), None),
    chatScope: s.fieldOr("chatScope", S.nullableAsOption(S.string), None),
    pinnedPageId: s.fieldOr("pinnedPageId", S.nullableAsOption(S.json), None),
    mutedWords: s.fieldOr("mutedWords", S.nullableAsOption(S.array(S.array(S.string))), None),
    hardMutedWords: s.fieldOr("hardMutedWords", S.nullableAsOption(S.array(S.array(S.string))), None),
    mutedInstances: s.fieldOr("mutedInstances", S.nullableAsOption(S.array(S.string)), None),
    notificationRecieveConfig: s.fieldOr("notificationRecieveConfig", S.nullableAsOption(S.object(s => {
    note: s.fieldOr("note", S.nullableAsOption(S.json), None),
    follow: s.fieldOr("follow", S.nullableAsOption(S.json), None),
    mention: s.fieldOr("mention", S.nullableAsOption(S.json), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.json), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.json), None),
    quote: s.fieldOr("quote", S.nullableAsOption(S.json), None),
    reaction: s.fieldOr("reaction", S.nullableAsOption(S.json), None),
    pollEnded: s.fieldOr("pollEnded", S.nullableAsOption(S.json), None),
    scheduledNotePosted: s.fieldOr("scheduledNotePosted", S.nullableAsOption(S.json), None),
    scheduledNotePostFailed: s.fieldOr("scheduledNotePostFailed", S.nullableAsOption(S.json), None),
    receiveFollowRequest: s.fieldOr("receiveFollowRequest", S.nullableAsOption(S.json), None),
    followRequestAccepted: s.fieldOr("followRequestAccepted", S.nullableAsOption(S.json), None),
    groupInvited: s.fieldOr("groupInvited", S.nullableAsOption(S.json), None),
    roleAssigned: s.fieldOr("roleAssigned", S.nullableAsOption(S.json), None),
    chatRoomInvitationReceived: s.fieldOr("chatRoomInvitationReceived", S.nullableAsOption(S.json), None),
    achievementEarned: s.fieldOr("achievementEarned", S.nullableAsOption(S.json), None),
    app: s.fieldOr("app", S.nullableAsOption(S.json), None),
    test: s.fieldOr("test", S.nullableAsOption(S.json), None),
  })), None),
    emailNotificationTypes: s.fieldOr("emailNotificationTypes", S.nullableAsOption(S.array(S.string)), None),
    alsoKnownAs: s.fieldOr("alsoKnownAs", S.nullableAsOption(S.array(S.string)), None),
    setFederationAvatarShape: s.fieldOr("setFederationAvatarShape", S.nullableAsOption(S.json), None),
    isSquareAvatars: s.fieldOr("isSquareAvatars", S.nullableAsOption(S.json), None),
  })

type postIUpdateResponse = KokonectLinkComponentSchemas.MeDetailed.t

let postIUpdateResponseSchema = KokonectLinkComponentSchemas.MeDetailed.schema

/**
 * i/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIUpdate = (~body: postIUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateRequestSchema)
  fetch(
    ~url="/i/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIUpdateAutoDeleteSettingsRequest = {
  autoDeleteNotesAfterDays: option<JSON.t>,
  autoDeleteKeepFavorites: option<bool>,
}

let postIUpdateAutoDeleteSettingsRequestSchema = S.object(s => {
    autoDeleteNotesAfterDays: s.fieldOr("autoDeleteNotesAfterDays", S.nullableAsOption(S.json), None),
    autoDeleteKeepFavorites: s.fieldOr("autoDeleteKeepFavorites", S.nullableAsOption(S.bool), None),
  })

type postIUpdateAutoDeleteSettingsResponse = unit

/**
 * i/update-auto-delete-settings
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIUpdateAutoDeleteSettings = (~body: postIUpdateAutoDeleteSettingsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIUpdateAutoDeleteSettingsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateAutoDeleteSettingsRequestSchema)
  fetch(
    ~url="/i/update-auto-delete-settings",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIUserGroupInvitesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIUserGroupInvitesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postIUserGroupInvitesResponse = array<{
  id: string,
  group: KokonectLinkComponentSchemas.UserGroup.t,
}>

let postIUserGroupInvitesResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    group: s.field("group", KokonectLinkComponentSchemas.UserGroup.schema),
  }))

/**
 * i/user-group-invites
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:user-groups*
 */
let postIUserGroupInvites = (~body: postIUserGroupInvitesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIUserGroupInvitesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUserGroupInvitesRequestSchema)
  fetch(
    ~url="/i/user-group-invites",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIUserGroupInvitesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postMuteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postMuteListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postMuteListResponse = array<KokonectLinkComponentSchemas.Muting.t>

let postMuteListResponseSchema = S.array(KokonectLinkComponentSchemas.Muting.schema)

/**
 * mute/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:mutes*
 */
let postMuteList = (~body: postMuteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMuteListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMuteListRequestSchema)
  fetch(
    ~url="/mute/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postMuteListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postRenoteMuteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postRenoteMuteListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postRenoteMuteListResponse = array<KokonectLinkComponentSchemas.RenoteMuting.t>

let postRenoteMuteListResponseSchema = S.array(KokonectLinkComponentSchemas.RenoteMuting.schema)

/**
 * renote-mute/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:mutes*
 */
let postRenoteMuteList = (~body: postRenoteMuteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRenoteMuteListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postRenoteMuteListRequestSchema)
  fetch(
    ~url="/renote-mute/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postRenoteMuteListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postVerifyEmailRequest = {
  code: string,
}

let postVerifyEmailRequestSchema = S.object(s => {
    code: s.field("code", S.string),
  })

type postVerifyEmailResponse = unit

/**
 * verify-email
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postVerifyEmail = (~body: postVerifyEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postVerifyEmailResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postVerifyEmailRequestSchema)
  fetch(
    ~url="/verify-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}
