// kokonect-link API for account
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postBlockingCreateRequest = {
  userId: string,
}

let postBlockingCreateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postBlockingCreateResponse = KokonectLinkComponentSchemas.UserDetailedNotMe.t

let postBlockingCreateResponseSchema = KokonectLinkComponentSchemas.UserDetailedNotMe.schema

/**
blocking/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:blocks*
*/
let postBlockingCreate = async (~body: postBlockingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postBlockingCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingCreateRequestSchema)
  let response = await fetch(
    ~url="/blocking/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postBlockingCreateResponseSchema)
}

type postBlockingDeleteRequest = {
  userId: string,
}

let postBlockingDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postBlockingDeleteResponse = KokonectLinkComponentSchemas.UserDetailedNotMe.t

let postBlockingDeleteResponseSchema = KokonectLinkComponentSchemas.UserDetailedNotMe.schema

/**
blocking/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:blocks*
*/
let postBlockingDelete = async (~body: postBlockingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postBlockingDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingDeleteRequestSchema)
  let response = await fetch(
    ~url="/blocking/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postBlockingDeleteResponseSchema)
}

type postBlockingListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postBlockingListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postBlockingListResponse = array<KokonectLinkComponentSchemas.Blocking.t>

let postBlockingListResponseSchema = S.array(KokonectLinkComponentSchemas.Blocking.schema)

/**
blocking/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:blocks*
*/
let postBlockingList = async (~body: postBlockingListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postBlockingListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingListRequestSchema)
  let response = await fetch(
    ~url="/blocking/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postBlockingListResponseSchema)
}

type postClipsNotesRequest = {
  clipId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  search: option<string>,
}

let postClipsNotesRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    search: s.field("search", S.option(S.string->S.min(1)->S.max(100))),
  })

type postClipsNotesResponse = array<KokonectLinkComponentSchemas.Note.t>

let postClipsNotesResponseSchema = S.array(KokonectLinkComponentSchemas.Note.schema)

/**
clips/notes

No description provided.

**Credential required**: *No* / **Permission**: *read:account*
*/
let postClipsNotes = async (~body: postClipsNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postClipsNotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsNotesRequestSchema)
  let response = await fetch(
    ~url="/clips/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postClipsNotesResponseSchema)
}

type postFlashMyRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postFlashMyRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postFlashMyResponse = array<KokonectLinkComponentSchemas.Flash.t>

let postFlashMyResponseSchema = S.array(KokonectLinkComponentSchemas.Flash.schema)

/**
flash/my

No description provided.

**Credential required**: *Yes* / **Permission**: *read:flash*
*/
let postFlashMy = async (~body: postFlashMyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFlashMyResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashMyRequestSchema)
  let response = await fetch(
    ~url="/flash/my",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFlashMyResponseSchema)
}

type postFlashMyLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  search: option<string>,
}

let postFlashMyLikesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    search: s.field("search", S.option(S.string->S.min(1)->S.max(100))),
  })

type postFlashMyLikesResponse_1 = {
  id: string,
  flash: KokonectLinkComponentSchemas.Flash.t,
}

type postFlashMyLikesResponse = array<postFlashMyLikesResponse_1>

let postFlashMyLikesResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    flash: s.field("flash", KokonectLinkComponentSchemas.Flash.schema),
  })

let postFlashMyLikesResponseSchema = S.array(postFlashMyLikesResponse_1Schema)

/**
flash/my-likes

No description provided.

**Credential required**: *Yes* / **Permission**: *read:flash-likes*
*/
let postFlashMyLikes = async (~body: postFlashMyLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFlashMyLikesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashMyLikesRequestSchema)
  let response = await fetch(
    ~url="/flash/my-likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFlashMyLikesResponseSchema)
}

type postIResponse = KokonectLinkComponentSchemas.MeDetailed.t

let postIResponseSchema = KokonectLinkComponentSchemas.MeDetailed.schema

/**
i

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postI = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIResponse => {

  let response = await fetch(
    ~url="/i",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postIResponseSchema)
}

type postIAutoDeleteSettingsResponse = {
  autoDeleteNotesAfterDays: option<float>,
  autoDeleteKeepFavorites: bool,
}

let postIAutoDeleteSettingsResponseSchema = S.object(s => {
    autoDeleteNotesAfterDays: s.field("autoDeleteNotesAfterDays", S.nullableAsOption(S.float)),
    autoDeleteKeepFavorites: s.field("autoDeleteKeepFavorites", S.bool),
  })

/**
i/auto-delete-settings

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postIAutoDeleteSettings = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIAutoDeleteSettingsResponse => {

  let response = await fetch(
    ~url="/i/auto-delete-settings",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postIAutoDeleteSettingsResponseSchema)
}

type postIFavoritesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postIFavoritesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postIFavoritesResponse = array<KokonectLinkComponentSchemas.NoteFavorite.t>

let postIFavoritesResponseSchema = S.array(KokonectLinkComponentSchemas.NoteFavorite.schema)

/**
i/favorites

No description provided.

**Credential required**: *Yes* / **Permission**: *read:favorites*
*/
let postIFavorites = async (~body: postIFavoritesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIFavoritesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIFavoritesRequestSchema)
  let response = await fetch(
    ~url="/i/favorites",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIFavoritesResponseSchema)
}

type postIFollowersServersResponse_1 = {
  host: string,
  name: option<string>,
  followersCount: float,
}

type postIFollowersServersResponse = {
  servers: array<postIFollowersServersResponse_1>,
}

let postIFollowersServersResponse_1Schema = S.object(s => {
    host: s.field("host", S.string),
    name: s.field("name", S.nullableAsOption(S.string)),
    followersCount: s.field("followersCount", S.float),
  })

let postIFollowersServersResponseSchema = S.object(s => {
    servers: s.field("servers", S.array(postIFollowersServersResponse_1Schema)),
  })

/**
i/followers-servers

No description provided.

**Credential required**: *Yes* / **Permission**: *read:following*
*/
let postIFollowersServers = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIFollowersServersResponse => {

  let response = await fetch(
    ~url="/i/followers-servers",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postIFollowersServersResponseSchema)
}

type postIGalleryLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postIGalleryLikesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postIGalleryLikesResponse_1 = {
  id: string,
  post: KokonectLinkComponentSchemas.GalleryPost.t,
}

type postIGalleryLikesResponse = array<postIGalleryLikesResponse_1>

let postIGalleryLikesResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    post: s.field("post", KokonectLinkComponentSchemas.GalleryPost.schema),
  })

let postIGalleryLikesResponseSchema = S.array(postIGalleryLikesResponse_1Schema)

/**
i/gallery/likes

No description provided.

**Credential required**: *Yes* / **Permission**: *read:gallery-likes*
*/
let postIGalleryLikes = async (~body: postIGalleryLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIGalleryLikesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIGalleryLikesRequestSchema)
  let response = await fetch(
    ~url="/i/gallery/likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIGalleryLikesResponseSchema)
}

type postIGalleryPostsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postIGalleryPostsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postIGalleryPostsResponse = array<KokonectLinkComponentSchemas.GalleryPost.t>

let postIGalleryPostsResponseSchema = S.array(KokonectLinkComponentSchemas.GalleryPost.schema)

/**
i/gallery/posts

No description provided.

**Credential required**: *Yes* / **Permission**: *read:gallery*
*/
let postIGalleryPosts = async (~body: postIGalleryPostsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIGalleryPostsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIGalleryPostsRequestSchema)
  let response = await fetch(
    ~url="/i/gallery/posts",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIGalleryPostsResponseSchema)
}

type postINotificationsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  markAsRead: option<bool>,
  includeTypes: option<array<string>>,
  excludeTypes: option<array<string>>,
}

let postINotificationsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    markAsRead: s.field("markAsRead", S.option(S.bool)),
    includeTypes: s.field("includeTypes", S.option(S.array(S.string))),
    excludeTypes: s.field("excludeTypes", S.option(S.array(S.string))),
  })

type postINotificationsResponse = array<KokonectLinkComponentSchemas.Notification.t>

let postINotificationsResponseSchema = S.array(KokonectLinkComponentSchemas.Notification.schema)

/**
i/notifications

No description provided.

**Credential required**: *Yes* / **Permission**: *read:notifications*
*/
let postINotifications = async (~body: postINotificationsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postINotificationsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postINotificationsRequestSchema)
  let response = await fetch(
    ~url="/i/notifications",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postINotificationsResponseSchema)
}

type postINotificationsGroupedRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  markAsRead: option<bool>,
  includeTypes: option<array<string>>,
  excludeTypes: option<array<string>>,
}

let postINotificationsGroupedRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    markAsRead: s.field("markAsRead", S.option(S.bool)),
    includeTypes: s.field("includeTypes", S.option(S.array(S.string))),
    excludeTypes: s.field("excludeTypes", S.option(S.array(S.string))),
  })

type postINotificationsGroupedResponse = array<KokonectLinkComponentSchemas.Notification.t>

let postINotificationsGroupedResponseSchema = S.array(KokonectLinkComponentSchemas.Notification.schema)

/**
i/notifications-grouped

No description provided.

**Credential required**: *Yes* / **Permission**: *read:notifications*
*/
let postINotificationsGrouped = async (~body: postINotificationsGroupedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postINotificationsGroupedResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postINotificationsGroupedRequestSchema)
  let response = await fetch(
    ~url="/i/notifications-grouped",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postINotificationsGroupedResponseSchema)
}

type postIPageLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postIPageLikesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postIPageLikesResponse_1 = {
  id: string,
  page: KokonectLinkComponentSchemas.Page.t,
}

type postIPageLikesResponse = array<postIPageLikesResponse_1>

let postIPageLikesResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    page: s.field("page", KokonectLinkComponentSchemas.Page.schema),
  })

let postIPageLikesResponseSchema = S.array(postIPageLikesResponse_1Schema)

/**
i/page-likes

No description provided.

**Credential required**: *Yes* / **Permission**: *read:page-likes*
*/
let postIPageLikes = async (~body: postIPageLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIPageLikesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPageLikesRequestSchema)
  let response = await fetch(
    ~url="/i/page-likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIPageLikesResponseSchema)
}

type postIPagesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postIPagesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postIPagesResponse = array<KokonectLinkComponentSchemas.Page.t>

let postIPagesResponseSchema = S.array(KokonectLinkComponentSchemas.Page.schema)

/**
i/pages

No description provided.

**Credential required**: *Yes* / **Permission**: *read:pages*
*/
let postIPages = async (~body: postIPagesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIPagesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPagesRequestSchema)
  let response = await fetch(
    ~url="/i/pages",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIPagesResponseSchema)
}

type postIPinRequest = {
  noteId: string,
}

let postIPinRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postIPinResponse = KokonectLinkComponentSchemas.MeDetailed.t

let postIPinResponseSchema = KokonectLinkComponentSchemas.MeDetailed.schema

/**
i/pin

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIPin = async (~body: postIPinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIPinResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPinRequestSchema)
  let response = await fetch(
    ~url="/i/pin",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIPinResponseSchema)
}

type postIUnpinRequest = {
  noteId: string,
}

let postIUnpinRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postIUnpinResponse = KokonectLinkComponentSchemas.MeDetailed.t

let postIUnpinResponseSchema = KokonectLinkComponentSchemas.MeDetailed.schema

/**
i/unpin

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIUnpin = async (~body: postIUnpinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIUnpinResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUnpinRequestSchema)
  let response = await fetch(
    ~url="/i/unpin",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIUnpinResponseSchema)
}

type postIUpdateRequest_3 = {
  note: option<dict<JSON.t>>,
  follow: option<dict<JSON.t>>,
  mention: option<dict<JSON.t>>,
  reply: option<dict<JSON.t>>,
  renote: option<dict<JSON.t>>,
  quote: option<dict<JSON.t>>,
  reaction: option<dict<JSON.t>>,
  pollEnded: option<dict<JSON.t>>,
  scheduledNotePosted: option<dict<JSON.t>>,
  scheduledNotePostFailed: option<dict<JSON.t>>,
  receiveFollowRequest: option<dict<JSON.t>>,
  followRequestAccepted: option<dict<JSON.t>>,
  groupInvited: option<dict<JSON.t>>,
  roleAssigned: option<dict<JSON.t>>,
  chatRoomInvitationReceived: option<dict<JSON.t>>,
  achievementEarned: option<dict<JSON.t>>,
  app: option<dict<JSON.t>>,
  test: option<dict<JSON.t>>,
}

type postIUpdateRequest_2 = {
  name: string,
  value: string,
}

type postIUpdateRequest_1 = {
  id: string,
  angle: option<float>,
  flipH: option<bool>,
  offsetX: option<float>,
  offsetY: option<float>,
  scale: option<float>,
  opacity: option<float>,
}

type postIUpdateRequest = {
  name: option<string>,
  description: option<string>,
  followedMessage: option<string>,
  location: option<string>,
  birthday: option<string>,
  lang: option<string>,
  avatarId: option<string>,
  avatarDecorations: option<array<postIUpdateRequest_1>>,
  bannerId: option<string>,
  fields: option<array<postIUpdateRequest_2>>,
  isLocked: option<bool>,
  isExplorable: option<bool>,
  hideOnlineStatus: option<bool>,
  publicReactions: option<bool>,
  carefulBot: option<bool>,
  autoAcceptFollowed: option<bool>,
  noCrawle: option<bool>,
  preventAiLearning: option<bool>,
  requireSigninToViewContents: option<bool>,
  makeNotesFollowersOnlyBefore: option<int>,
  makeNotesHiddenBefore: option<int>,
  isBot: option<bool>,
  isCat: option<bool>,
  injectFeaturedNote: option<bool>,
  receiveAnnouncementEmail: option<bool>,
  alwaysMarkNsfw: option<bool>,
  autoSensitive: option<bool>,
  followingVisibility: option<string>,
  followersVisibility: option<string>,
  chatScope: option<string>,
  pinnedPageId: option<string>,
  mutedWords: option<array<array<string>>>,
  hardMutedWords: option<array<array<string>>>,
  mutedInstances: option<array<string>>,
  notificationRecieveConfig: option<postIUpdateRequest_3>,
  emailNotificationTypes: option<array<string>>,
  alsoKnownAs: option<array<string>>,
  setFederationAvatarShape: option<bool>,
  isSquareAvatars: option<bool>,
}

let postIUpdateRequest_3Schema = S.object(s => {
    note: s.field("note", S.option(S.dict(S.json))),
    follow: s.field("follow", S.option(S.dict(S.json))),
    mention: s.field("mention", S.option(S.dict(S.json))),
    reply: s.field("reply", S.option(S.dict(S.json))),
    renote: s.field("renote", S.option(S.dict(S.json))),
    quote: s.field("quote", S.option(S.dict(S.json))),
    reaction: s.field("reaction", S.option(S.dict(S.json))),
    pollEnded: s.field("pollEnded", S.option(S.dict(S.json))),
    scheduledNotePosted: s.field("scheduledNotePosted", S.option(S.dict(S.json))),
    scheduledNotePostFailed: s.field("scheduledNotePostFailed", S.option(S.dict(S.json))),
    receiveFollowRequest: s.field("receiveFollowRequest", S.option(S.dict(S.json))),
    followRequestAccepted: s.field("followRequestAccepted", S.option(S.dict(S.json))),
    groupInvited: s.field("groupInvited", S.option(S.dict(S.json))),
    roleAssigned: s.field("roleAssigned", S.option(S.dict(S.json))),
    chatRoomInvitationReceived: s.field("chatRoomInvitationReceived", S.option(S.dict(S.json))),
    achievementEarned: s.field("achievementEarned", S.option(S.dict(S.json))),
    app: s.field("app", S.option(S.dict(S.json))),
    test: s.field("test", S.option(S.dict(S.json))),
  })

let postIUpdateRequest_2Schema = S.object(s => {
    name: s.field("name", S.string),
    value: s.field("value", S.string),
  })

let postIUpdateRequest_1Schema = S.object(s => {
    id: s.field("id", S.string),
    angle: s.field("angle", S.option(S.float->S.min(0)->S.max(0))),
    flipH: s.field("flipH", S.option(S.bool)),
    offsetX: s.field("offsetX", S.option(S.float->S.min(0)->S.max(0))),
    offsetY: s.field("offsetY", S.option(S.float->S.min(0)->S.max(0))),
    scale: s.field("scale", S.option(S.float->S.min(0)->S.max(1))),
    opacity: s.field("opacity", S.option(S.float->S.min(0)->S.max(1))),
  })

let postIUpdateRequestSchema = S.object(s => {
    name: s.field("name", S.option(S.string->S.min(1)->S.max(50))),
    description: s.field("description", S.option(S.string->S.min(1)->S.max(1500))),
    followedMessage: s.field("followedMessage", S.option(S.string->S.min(1)->S.max(256))),
    location: s.field("location", S.option(S.string->S.min(1)->S.max(50))),
    birthday: s.field("birthday", S.option(S.string->S.pattern(/^([0-9]{4})-([0-9]{2})-([0-9]{2})$/))),
    lang: s.field("lang", S.option(S.string)),
    avatarId: s.field("avatarId", S.option(S.string)),
    avatarDecorations: s.field("avatarDecorations", S.option(S.array(postIUpdateRequest_1Schema))),
    bannerId: s.field("bannerId", S.option(S.string)),
    fields: s.field("fields", S.option(S.array(postIUpdateRequest_2Schema))),
    isLocked: s.field("isLocked", S.option(S.bool)),
    isExplorable: s.field("isExplorable", S.option(S.bool)),
    hideOnlineStatus: s.field("hideOnlineStatus", S.option(S.bool)),
    publicReactions: s.field("publicReactions", S.option(S.bool)),
    carefulBot: s.field("carefulBot", S.option(S.bool)),
    autoAcceptFollowed: s.field("autoAcceptFollowed", S.option(S.bool)),
    noCrawle: s.field("noCrawle", S.option(S.bool)),
    preventAiLearning: s.field("preventAiLearning", S.option(S.bool)),
    requireSigninToViewContents: s.field("requireSigninToViewContents", S.option(S.bool)),
    makeNotesFollowersOnlyBefore: s.field("makeNotesFollowersOnlyBefore", S.option(S.int)),
    makeNotesHiddenBefore: s.field("makeNotesHiddenBefore", S.option(S.int)),
    isBot: s.field("isBot", S.option(S.bool)),
    isCat: s.field("isCat", S.option(S.bool)),
    injectFeaturedNote: s.field("injectFeaturedNote", S.option(S.bool)),
    receiveAnnouncementEmail: s.field("receiveAnnouncementEmail", S.option(S.bool)),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.option(S.bool)),
    autoSensitive: s.field("autoSensitive", S.option(S.bool)),
    followingVisibility: s.field("followingVisibility", S.option(S.string)),
    followersVisibility: s.field("followersVisibility", S.option(S.string)),
    chatScope: s.field("chatScope", S.option(S.string)),
    pinnedPageId: s.field("pinnedPageId", S.option(S.string)),
    mutedWords: s.field("mutedWords", S.option(S.array(S.array(S.string)))),
    hardMutedWords: s.field("hardMutedWords", S.option(S.array(S.array(S.string)))),
    mutedInstances: s.field("mutedInstances", S.option(S.array(S.string))),
    notificationRecieveConfig: s.field("notificationRecieveConfig", S.option(postIUpdateRequest_3Schema)),
    emailNotificationTypes: s.field("emailNotificationTypes", S.option(S.array(S.string))),
    alsoKnownAs: s.field("alsoKnownAs", S.option(S.array(S.string))),
    setFederationAvatarShape: s.field("setFederationAvatarShape", S.option(S.bool)),
    isSquareAvatars: s.field("isSquareAvatars", S.option(S.bool)),
  })

type postIUpdateResponse = KokonectLinkComponentSchemas.MeDetailed.t

let postIUpdateResponseSchema = KokonectLinkComponentSchemas.MeDetailed.schema

/**
i/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIUpdate = async (~body: postIUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateRequestSchema)
  let response = await fetch(
    ~url="/i/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIUpdateResponseSchema)
}

type postIUpdateAutoDeleteSettingsRequest = {
  autoDeleteNotesAfterDays: option<float>,
  autoDeleteKeepFavorites: option<bool>,
}

let postIUpdateAutoDeleteSettingsRequestSchema = S.object(s => {
    autoDeleteNotesAfterDays: s.field("autoDeleteNotesAfterDays", S.option(S.float->S.min(1)->S.max(3650))),
    autoDeleteKeepFavorites: s.field("autoDeleteKeepFavorites", S.option(S.bool)),
  })

type postIUpdateAutoDeleteSettingsResponse = unit

/**
i/update-auto-delete-settings

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIUpdateAutoDeleteSettings = async (~body: postIUpdateAutoDeleteSettingsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIUpdateAutoDeleteSettingsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateAutoDeleteSettingsRequestSchema)
  let response = await fetch(
    ~url="/i/update-auto-delete-settings",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIUserGroupInvitesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIUserGroupInvitesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postIUserGroupInvitesResponse_1 = {
  id: string,
  group: KokonectLinkComponentSchemas.UserGroup.t,
}

type postIUserGroupInvitesResponse = array<postIUserGroupInvitesResponse_1>

let postIUserGroupInvitesResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    group: s.field("group", KokonectLinkComponentSchemas.UserGroup.schema),
  })

let postIUserGroupInvitesResponseSchema = S.array(postIUserGroupInvitesResponse_1Schema)

/**
i/user-group-invites

No description provided.

**Credential required**: *Yes* / **Permission**: *read:user-groups*
*/
let postIUserGroupInvites = async (~body: postIUserGroupInvitesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIUserGroupInvitesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUserGroupInvitesRequestSchema)
  let response = await fetch(
    ~url="/i/user-group-invites",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIUserGroupInvitesResponseSchema)
}

type postMuteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postMuteListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postMuteListResponse = array<KokonectLinkComponentSchemas.Muting.t>

let postMuteListResponseSchema = S.array(KokonectLinkComponentSchemas.Muting.schema)

/**
mute/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:mutes*
*/
let postMuteList = async (~body: postMuteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postMuteListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMuteListRequestSchema)
  let response = await fetch(
    ~url="/mute/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postMuteListResponseSchema)
}

type postRenoteMuteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postRenoteMuteListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postRenoteMuteListResponse = array<KokonectLinkComponentSchemas.RenoteMuting.t>

let postRenoteMuteListResponseSchema = S.array(KokonectLinkComponentSchemas.RenoteMuting.schema)

/**
renote-mute/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:mutes*
*/
let postRenoteMuteList = async (~body: postRenoteMuteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postRenoteMuteListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postRenoteMuteListRequestSchema)
  let response = await fetch(
    ~url="/renote-mute/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postRenoteMuteListResponseSchema)
}

type postVerifyEmailRequest = {
  code: string,
}

let postVerifyEmailRequestSchema = S.object(s => {
    code: s.field("code", S.string),
  })

type postVerifyEmailResponse = unit

/**
verify-email

No description provided.

**Credential required**: *No*
*/
let postVerifyEmail = async (~body: postVerifyEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postVerifyEmailResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postVerifyEmailRequestSchema)
  let response = await fetch(
    ~url="/verify-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}
