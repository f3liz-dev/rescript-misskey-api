// kokonect-link API for default
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postIClaimAchievementRequest = {
  name: string,
}

let postIClaimAchievementRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type postIClaimAchievementResponse = unit

/**
i/claim-achievement

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIClaimAchievement = async (~body: postIClaimAchievementRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIClaimAchievementResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIClaimAchievementRequestSchema)
  let response = await fetch(
    ~url="/i/claim-achievement",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIRevokeTokenRequest_1 = {
  token: option<string>,
}

type postIRevokeTokenRequest = postIRevokeTokenRequest_1

let postIRevokeTokenRequest_1Schema = S.object(s => {
    token: s.field("token", S.nullableAsOption(S.string)),
  })

let postIRevokeTokenRequestSchema = postIRevokeTokenRequest_1Schema

type postIRevokeTokenResponse = unit

/**
i/revoke-token

No description provided.

**Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIRevokeToken = async (~body: postIRevokeTokenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIRevokeTokenResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRevokeTokenRequestSchema)
  let response = await fetch(
    ~url="/i/revoke-token",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postISigninHistoryRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postISigninHistoryRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postISigninHistoryResponse = array<KokonectLinkComponentSchemas.Signin.t>

let postISigninHistoryResponseSchema = S.array(KokonectLinkComponentSchemas.Signin.schema)

/**
i/signin-history

No description provided.

**Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postISigninHistory = async (~body: postISigninHistoryRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postISigninHistoryResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postISigninHistoryRequestSchema)
  let response = await fetch(
    ~url="/i/signin-history",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postISigninHistoryResponseSchema)
}

type postITruncateAccountRequest = {
  password: string,
  token: option<string>,
}

let postITruncateAccountRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.field("token", S.option(S.string)),
  })

type postITruncateAccountResponse = unit

/**
i/truncate-account

No description provided.

**Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postITruncateAccount = async (~body: postITruncateAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postITruncateAccountResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postITruncateAccountRequestSchema)
  let response = await fetch(
    ~url="/i/truncate-account",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIUpdateEmailRequest = {
  password: string,
  email: option<string>,
  token: option<string>,
}

let postIUpdateEmailRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    email: s.field("email", S.option(S.string)),
    token: s.field("token", S.option(S.string)),
  })

type postIUpdateEmailResponse = KokonectLinkComponentSchemas.MeDetailed.t

let postIUpdateEmailResponseSchema = KokonectLinkComponentSchemas.MeDetailed.schema

/**
i/update-email

No description provided.

**Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIUpdateEmail = async (~body: postIUpdateEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIUpdateEmailResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateEmailRequestSchema)
  let response = await fetch(
    ~url="/i/update-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIUpdateEmailResponseSchema)
}

type postReversiGamesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  my: option<bool>,
}

let postReversiGamesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    my: s.field("my", S.option(S.bool)),
  })

type postReversiGamesResponse = array<KokonectLinkComponentSchemas.ReversiGameLite.t>

let postReversiGamesResponseSchema = S.array(KokonectLinkComponentSchemas.ReversiGameLite.schema)

/**
reversi/games

No description provided.

**Credential required**: *No*
*/
let postReversiGames = async (~body: postReversiGamesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postReversiGamesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiGamesRequestSchema)
  let response = await fetch(
    ~url="/reversi/games",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postReversiGamesResponseSchema)
}

type postReversiMatchRequest = {
  userId: option<string>,
  noIrregularRules: option<bool>,
  multiple: option<bool>,
}

let postReversiMatchRequestSchema = S.object(s => {
    userId: s.field("userId", S.option(S.string)),
    noIrregularRules: s.field("noIrregularRules", S.option(S.bool)),
    multiple: s.field("multiple", S.option(S.bool)),
  })

type postReversiMatchResponse = KokonectLinkComponentSchemas.ReversiGameDetailed.t

let postReversiMatchResponseSchema = KokonectLinkComponentSchemas.ReversiGameDetailed.schema

/**
reversi/match

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postReversiMatch = async (~body: postReversiMatchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postReversiMatchResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiMatchRequestSchema)
  let response = await fetch(
    ~url="/reversi/match",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postReversiMatchResponseSchema)
}

type postReversiShowGameRequest = {
  gameId: string,
}

let postReversiShowGameRequestSchema = S.object(s => {
    gameId: s.field("gameId", S.string),
  })

type postReversiShowGameResponse = KokonectLinkComponentSchemas.ReversiGameDetailed.t

let postReversiShowGameResponseSchema = KokonectLinkComponentSchemas.ReversiGameDetailed.schema

/**
reversi/show-game

No description provided.

**Credential required**: *No*
*/
let postReversiShowGame = async (~body: postReversiShowGameRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postReversiShowGameResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiShowGameRequestSchema)
  let response = await fetch(
    ~url="/reversi/show-game",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postReversiShowGameResponseSchema)
}

type postReversiVerifyRequest = {
  gameId: string,
  crc32: string,
}

let postReversiVerifyRequestSchema = S.object(s => {
    gameId: s.field("gameId", S.string),
    crc32: s.field("crc32", S.string),
  })

type postReversiVerifyResponse = {
  desynced: bool,
  game: option<KokonectLinkComponentSchemas.ReversiGameDetailed.t>,
}

let postReversiVerifyResponseSchema = S.object(s => {
    desynced: s.field("desynced", S.bool),
    game: s.field("game", S.option(KokonectLinkComponentSchemas.ReversiGameDetailed.schema)),
  })

/**
reversi/verify

No description provided.

**Credential required**: *No*
*/
let postReversiVerify = async (~body: postReversiVerifyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postReversiVerifyResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiVerifyRequestSchema)
  let response = await fetch(
    ~url="/reversi/verify",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postReversiVerifyResponseSchema)
}

type postUsersListsCreateFromPublicRequest = {
  name: string,
  listId: string,
}

let postUsersListsCreateFromPublicRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
    listId: s.field("listId", S.string),
  })

type postUsersListsCreateFromPublicResponse = KokonectLinkComponentSchemas.UserList.t

let postUsersListsCreateFromPublicResponseSchema = KokonectLinkComponentSchemas.UserList.schema

/**
users/lists/create-from-public

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postUsersListsCreateFromPublic = async (~body: postUsersListsCreateFromPublicRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersListsCreateFromPublicResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsCreateFromPublicRequestSchema)
  let response = await fetch(
    ~url="/users/lists/create-from-public",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersListsCreateFromPublicResponseSchema)
}
