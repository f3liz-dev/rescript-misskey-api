// SPDX-License-Identifier: MIT
// kokonect-link API for default
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type postIClaimAchievementRequest = {
  name: string,
}

let postIClaimAchievementRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type postIClaimAchievementResponse = unit

/**
 * i/claim-achievement
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIClaimAchievement = (~body: postIClaimAchievementRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIClaimAchievementResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIClaimAchievementRequestSchema)
  
  fetch(
    ~url="/i/claim-achievement",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postIRevokeTokenRequest = JSON.t

let postIRevokeTokenRequestSchema = S.json

type postIRevokeTokenResponse = unit

/**
 * i/revoke-token
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIRevokeToken = (~body: postIRevokeTokenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRevokeTokenResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRevokeTokenRequestSchema)
  
  fetch(
    ~url="/i/revoke-token",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postISigninHistoryRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postISigninHistoryRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postISigninHistoryResponse = array<KokonectLinkComponentSchemas.Signin.t>

let postISigninHistoryResponseSchema = S.array(KokonectLinkComponentSchemas.Signin.schema)

/**
 * i/signin-history
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postISigninHistory = (~body: postISigninHistoryRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postISigninHistoryResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postISigninHistoryRequestSchema)
  
  fetch(
    ~url="/i/signin-history",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postISigninHistoryResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postITruncateAccountRequest = {
  password: string,
  token: option<JSON.t>,
}

let postITruncateAccountRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.fieldOr("token", S.nullableAsOption(S.json), None),
  })

type postITruncateAccountResponse = unit

/**
 * i/truncate-account
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postITruncateAccount = (~body: postITruncateAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postITruncateAccountResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postITruncateAccountRequestSchema)
  
  fetch(
    ~url="/i/truncate-account",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postIUpdateEmailRequest = {
  password: string,
  email: option<JSON.t>,
  token: option<JSON.t>,
}

let postIUpdateEmailRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    email: s.fieldOr("email", S.nullableAsOption(S.json), None),
    token: s.fieldOr("token", S.nullableAsOption(S.json), None),
  })

type postIUpdateEmailResponse = KokonectLinkComponentSchemas.MeDetailed.t

let postIUpdateEmailResponseSchema = KokonectLinkComponentSchemas.MeDetailed.schema

/**
 * i/update-email
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the cherrypick mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIUpdateEmail = (~body: postIUpdateEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIUpdateEmailResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateEmailRequestSchema)
  
  fetch(
    ~url="/i/update-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postIUpdateEmailResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postReversiGamesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  my: option<bool>,
}

let postReversiGamesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    my: s.fieldOr("my", S.nullableAsOption(S.bool), None),
  })

type postReversiGamesResponse = array<KokonectLinkComponentSchemas.ReversiGameLite.t>

let postReversiGamesResponseSchema = S.array(KokonectLinkComponentSchemas.ReversiGameLite.schema)

/**
 * reversi/games
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postReversiGames = (~body: postReversiGamesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiGamesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiGamesRequestSchema)
  
  fetch(
    ~url="/reversi/games",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postReversiGamesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postReversiMatchRequest = {
  userId: option<JSON.t>,
  noIrregularRules: option<bool>,
  multiple: option<bool>,
}

let postReversiMatchRequestSchema = S.object(s => {
    userId: s.fieldOr("userId", S.nullableAsOption(S.json), None),
    noIrregularRules: s.fieldOr("noIrregularRules", S.nullableAsOption(S.bool), None),
    multiple: s.fieldOr("multiple", S.nullableAsOption(S.bool), None),
  })

type postReversiMatchResponse = KokonectLinkComponentSchemas.ReversiGameDetailed.t

let postReversiMatchResponseSchema = KokonectLinkComponentSchemas.ReversiGameDetailed.schema

/**
 * reversi/match
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postReversiMatch = (~body: postReversiMatchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiMatchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiMatchRequestSchema)
  
  fetch(
    ~url="/reversi/match",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postReversiMatchResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postReversiShowGameRequest = {
  gameId: string,
}

let postReversiShowGameRequestSchema = S.object(s => {
    gameId: s.field("gameId", S.string),
  })

type postReversiShowGameResponse = KokonectLinkComponentSchemas.ReversiGameDetailed.t

let postReversiShowGameResponseSchema = KokonectLinkComponentSchemas.ReversiGameDetailed.schema

/**
 * reversi/show-game
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postReversiShowGame = (~body: postReversiShowGameRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiShowGameResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiShowGameRequestSchema)
  
  fetch(
    ~url="/reversi/show-game",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postReversiShowGameResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postReversiVerifyRequest = {
  gameId: string,
  crc32: string,
}

let postReversiVerifyRequestSchema = S.object(s => {
    gameId: s.field("gameId", S.string),
    crc32: s.field("crc32", S.string),
  })

type postReversiVerifyResponse = {
  desynced: bool,
  game: option<JSON.t>,
}

let postReversiVerifyResponseSchema = S.object(s => {
    desynced: s.field("desynced", S.bool),
    game: s.fieldOr("game", S.nullableAsOption(S.json), None),
  })

/**
 * reversi/verify
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postReversiVerify = (~body: postReversiVerifyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiVerifyResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiVerifyRequestSchema)
  
  fetch(
    ~url="/reversi/verify",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postReversiVerifyResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postUsersListsCreateFromPublicRequest = {
  name: string,
  listId: string,
}

let postUsersListsCreateFromPublicRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
    listId: s.field("listId", S.string),
  })

type postUsersListsCreateFromPublicResponse = KokonectLinkComponentSchemas.UserList.t

let postUsersListsCreateFromPublicResponseSchema = KokonectLinkComponentSchemas.UserList.schema

/**
 * users/lists/create-from-public
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postUsersListsCreateFromPublic = (~body: postUsersListsCreateFromPublicRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsCreateFromPublicResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsCreateFromPublicRequestSchema)
  
  fetch(
    ~url="/users/lists/create-from-public",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postUsersListsCreateFromPublicResponseSchema)
  validatedResponse
->Promise.resolve
  })
}
