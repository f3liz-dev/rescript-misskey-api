// kokonect-link API for federation
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postFederationFollowersRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postFederationFollowersRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postFederationFollowersResponse = array<KokonectLinkComponentSchemas.Following.t>

let postFederationFollowersResponseSchema = S.array(KokonectLinkComponentSchemas.Following.schema)

/**
federation/followers

No description provided.

**Credential required**: *No*
*/
let postFederationFollowers = async (~body: postFederationFollowersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationFollowersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationFollowersRequestSchema)
  let response = await fetch(
    ~url="/federation/followers",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFederationFollowersResponseSchema)
}

type postFederationFollowingRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postFederationFollowingRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postFederationFollowingResponse = array<KokonectLinkComponentSchemas.Following.t>

let postFederationFollowingResponseSchema = S.array(KokonectLinkComponentSchemas.Following.schema)

/**
federation/following

No description provided.

**Credential required**: *No*
*/
let postFederationFollowing = async (~body: postFederationFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationFollowingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationFollowingRequestSchema)
  let response = await fetch(
    ~url="/federation/following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFederationFollowingResponseSchema)
}

type getFederationRemoteSoftwareRequest = {
  blocked: option<bool>,
  notResponding: option<bool>,
  suspended: option<bool>,
  silenced: option<bool>,
  federating: option<bool>,
  subscribing: option<bool>,
  publishing: option<bool>,
  quarantined: option<bool>,
}

let getFederationRemoteSoftwareRequestSchema = S.object(s => {
    blocked: s.field("blocked", S.option(S.bool)),
    notResponding: s.field("notResponding", S.option(S.bool)),
    suspended: s.field("suspended", S.option(S.bool)),
    silenced: s.field("silenced", S.option(S.bool)),
    federating: s.field("federating", S.option(S.bool)),
    subscribing: s.field("subscribing", S.option(S.bool)),
    publishing: s.field("publishing", S.option(S.bool)),
    quarantined: s.field("quarantined", S.option(S.bool)),
  })

type getFederationRemoteSoftwareResponse_1 = {
  softwareName: string,
  color: option<string>,
  count: int,
}

type getFederationRemoteSoftwareResponse = array<getFederationRemoteSoftwareResponse_1>

let getFederationRemoteSoftwareResponse_1Schema = S.object(s => {
    softwareName: s.field("softwareName", S.string),
    color: s.field("color", S.nullableAsOption(S.string)),
    count: s.field("count", S.int),
  })

let getFederationRemoteSoftwareResponseSchema = S.array(getFederationRemoteSoftwareResponse_1Schema)

/**
federation/remote-software

No description provided.

**Credential required**: *No*
*/
let getFederationRemoteSoftware = async (~body: getFederationRemoteSoftwareRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getFederationRemoteSoftwareResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getFederationRemoteSoftwareRequestSchema)
  let response = await fetch(
    ~url="/federation/remote-software",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getFederationRemoteSoftwareResponseSchema)
}

type postFederationRemoteSoftwareRequest = {
  blocked: option<bool>,
  notResponding: option<bool>,
  suspended: option<bool>,
  silenced: option<bool>,
  federating: option<bool>,
  subscribing: option<bool>,
  publishing: option<bool>,
  quarantined: option<bool>,
}

let postFederationRemoteSoftwareRequestSchema = S.object(s => {
    blocked: s.field("blocked", S.option(S.bool)),
    notResponding: s.field("notResponding", S.option(S.bool)),
    suspended: s.field("suspended", S.option(S.bool)),
    silenced: s.field("silenced", S.option(S.bool)),
    federating: s.field("federating", S.option(S.bool)),
    subscribing: s.field("subscribing", S.option(S.bool)),
    publishing: s.field("publishing", S.option(S.bool)),
    quarantined: s.field("quarantined", S.option(S.bool)),
  })

type postFederationRemoteSoftwareResponse_1 = {
  softwareName: string,
  color: option<string>,
  count: int,
}

type postFederationRemoteSoftwareResponse = array<postFederationRemoteSoftwareResponse_1>

let postFederationRemoteSoftwareResponse_1Schema = S.object(s => {
    softwareName: s.field("softwareName", S.string),
    color: s.field("color", S.nullableAsOption(S.string)),
    count: s.field("count", S.int),
  })

let postFederationRemoteSoftwareResponseSchema = S.array(postFederationRemoteSoftwareResponse_1Schema)

/**
federation/remote-software

No description provided.

**Credential required**: *No*
*/
let postFederationRemoteSoftware = async (~body: postFederationRemoteSoftwareRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationRemoteSoftwareResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationRemoteSoftwareRequestSchema)
  let response = await fetch(
    ~url="/federation/remote-software",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFederationRemoteSoftwareResponseSchema)
}

type postFederationShowInstanceRequest = {
  host: string,
}

let postFederationShowInstanceRequestSchema = S.object(s => {
    host: s.field("host", S.string),
  })

type postFederationShowInstanceResponse = option<KokonectLinkComponentSchemas.FederationInstance.t>

let postFederationShowInstanceResponseSchema = S.nullableAsOption(KokonectLinkComponentSchemas.FederationInstance.schema)

/**
federation/show-instance

No description provided.

**Credential required**: *No*
*/
let postFederationShowInstance = async (~body: postFederationShowInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationShowInstanceResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationShowInstanceRequestSchema)
  let response = await fetch(
    ~url="/federation/show-instance",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFederationShowInstanceResponseSchema)
}

type postFederationUsersRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postFederationUsersRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postFederationUsersResponse = array<KokonectLinkComponentSchemas.UserDetailedNotMe.t>

let postFederationUsersResponseSchema = S.array(KokonectLinkComponentSchemas.UserDetailedNotMe.schema)

/**
federation/users

No description provided.

**Credential required**: *No*
*/
let postFederationUsers = async (~body: postFederationUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationUsersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationUsersRequestSchema)
  let response = await fetch(
    ~url="/federation/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFederationUsersResponseSchema)
}
