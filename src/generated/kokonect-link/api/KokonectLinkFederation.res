// SPDX-License-Identifier: MIT
// kokonect-link API for federation
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type postFederationFollowersRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postFederationFollowersRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postFederationFollowersResponse = array<KokonectLinkComponentSchemas.Following.t>

let postFederationFollowersResponseSchema = S.array(KokonectLinkComponentSchemas.Following.schema)

/**
 * federation/followers
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationFollowers = (~body: postFederationFollowersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationFollowersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationFollowersRequestSchema)
  
  fetch(
    ~url="/federation/followers",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFederationFollowersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFederationFollowingRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postFederationFollowingRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postFederationFollowingResponse = array<KokonectLinkComponentSchemas.Following.t>

let postFederationFollowingResponseSchema = S.array(KokonectLinkComponentSchemas.Following.schema)

/**
 * federation/following
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationFollowing = (~body: postFederationFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationFollowingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationFollowingRequestSchema)
  
  fetch(
    ~url="/federation/following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFederationFollowingResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getFederationRemoteSoftwareRequest = {
  blocked: option<JSON.t>,
  notResponding: option<JSON.t>,
  suspended: option<JSON.t>,
  silenced: option<JSON.t>,
  federating: option<JSON.t>,
  subscribing: option<JSON.t>,
  publishing: option<JSON.t>,
  quarantined: option<JSON.t>,
}

let getFederationRemoteSoftwareRequestSchema = S.object(s => {
    blocked: s.fieldOr("blocked", S.nullableAsOption(S.json), None),
    notResponding: s.fieldOr("notResponding", S.nullableAsOption(S.json), None),
    suspended: s.fieldOr("suspended", S.nullableAsOption(S.json), None),
    silenced: s.fieldOr("silenced", S.nullableAsOption(S.json), None),
    federating: s.fieldOr("federating", S.nullableAsOption(S.json), None),
    subscribing: s.fieldOr("subscribing", S.nullableAsOption(S.json), None),
    publishing: s.fieldOr("publishing", S.nullableAsOption(S.json), None),
    quarantined: s.fieldOr("quarantined", S.nullableAsOption(S.json), None),
  })

type getFederationRemoteSoftwareResponse = array<JSON.t>

let getFederationRemoteSoftwareResponseSchema = S.array(S.json)

/**
 * federation/remote-software
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getFederationRemoteSoftware = (~body: getFederationRemoteSoftwareRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getFederationRemoteSoftwareResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getFederationRemoteSoftwareRequestSchema)
  
  fetch(
    ~url="/federation/remote-software",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getFederationRemoteSoftwareResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFederationRemoteSoftwareRequest = {
  blocked: option<JSON.t>,
  notResponding: option<JSON.t>,
  suspended: option<JSON.t>,
  silenced: option<JSON.t>,
  federating: option<JSON.t>,
  subscribing: option<JSON.t>,
  publishing: option<JSON.t>,
  quarantined: option<JSON.t>,
}

let postFederationRemoteSoftwareRequestSchema = S.object(s => {
    blocked: s.fieldOr("blocked", S.nullableAsOption(S.json), None),
    notResponding: s.fieldOr("notResponding", S.nullableAsOption(S.json), None),
    suspended: s.fieldOr("suspended", S.nullableAsOption(S.json), None),
    silenced: s.fieldOr("silenced", S.nullableAsOption(S.json), None),
    federating: s.fieldOr("federating", S.nullableAsOption(S.json), None),
    subscribing: s.fieldOr("subscribing", S.nullableAsOption(S.json), None),
    publishing: s.fieldOr("publishing", S.nullableAsOption(S.json), None),
    quarantined: s.fieldOr("quarantined", S.nullableAsOption(S.json), None),
  })

type postFederationRemoteSoftwareResponse = array<JSON.t>

let postFederationRemoteSoftwareResponseSchema = S.array(S.json)

/**
 * federation/remote-software
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationRemoteSoftware = (~body: postFederationRemoteSoftwareRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationRemoteSoftwareResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationRemoteSoftwareRequestSchema)
  
  fetch(
    ~url="/federation/remote-software",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFederationRemoteSoftwareResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFederationShowInstanceRequest = {
  host: string,
}

let postFederationShowInstanceRequestSchema = S.object(s => {
    host: s.field("host", S.string),
  })

type postFederationShowInstanceResponse = JSON.t

let postFederationShowInstanceResponseSchema = S.json

/**
 * federation/show-instance
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationShowInstance = (~body: postFederationShowInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationShowInstanceResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationShowInstanceRequestSchema)
  
  fetch(
    ~url="/federation/show-instance",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFederationShowInstanceResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFederationUsersRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  limit: option<int>,
}

let postFederationUsersRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postFederationUsersResponse = array<KokonectLinkComponentSchemas.UserDetailedNotMe.t>

let postFederationUsersResponseSchema = S.array(KokonectLinkComponentSchemas.UserDetailedNotMe.schema)

/**
 * federation/users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationUsers = (~body: postFederationUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationUsersRequestSchema)
  
  fetch(
    ~url="/federation/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFederationUsersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}
