// SPDX-License-Identifier: MIT
// Component Schemas - Shared types and validation schemas
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



module Error = {
  type t = {
  error: JSON.t,
}
  
  let schema = S.object(s => {
    error: s.field("error", S.json),
  })
}

module UserLite = {
  type t = {
  id: string,
  name: JSON.t,
  username: string,
  host: JSON.t,
  avatarUrl: string,
  avatarBlurhash: JSON.t,
  avatarDecorations: array<JSON.t>,
  isLocked: bool,
  isBot: option<bool>,
  isCat: option<bool>,
  isProxy: option<bool>,
  requireSigninToViewContents: option<bool>,
  makeNotesFollowersOnlyBefore: option<JSON.t>,
  makeNotesHiddenBefore: option<JSON.t>,
  instance: option<JSON.t>,
  emojis: JSON.t,
  onlineStatus: string,
  badgeRoles: option<array<JSON.t>>,
  setFederationAvatarShape: option<JSON.t>,
  isSquareAvatars: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.json),
    username: s.field("username", S.string),
    host: s.field("host", S.json),
    avatarUrl: s.field("avatarUrl", S.string),
    avatarBlurhash: s.field("avatarBlurhash", S.json),
    avatarDecorations: s.field("avatarDecorations", S.array(S.json)),
    isLocked: s.field("isLocked", S.bool),
    isBot: s.fieldOr("isBot", S.nullableAsOption(S.bool), None),
    isCat: s.fieldOr("isCat", S.nullableAsOption(S.bool), None),
    isProxy: s.fieldOr("isProxy", S.nullableAsOption(S.bool), None),
    requireSigninToViewContents: s.fieldOr("requireSigninToViewContents", S.nullableAsOption(S.bool), None),
    makeNotesFollowersOnlyBefore: s.fieldOr("makeNotesFollowersOnlyBefore", S.nullableAsOption(S.json), None),
    makeNotesHiddenBefore: s.fieldOr("makeNotesHiddenBefore", S.nullableAsOption(S.json), None),
    instance: s.fieldOr("instance", S.nullableAsOption(S.json), None),
    emojis: s.field("emojis", S.json),
    onlineStatus: s.field("onlineStatus", S.string),
    badgeRoles: s.fieldOr("badgeRoles", S.nullableAsOption(S.array(S.json)), None),
    setFederationAvatarShape: s.fieldOr("setFederationAvatarShape", S.nullableAsOption(S.json), None),
    isSquareAvatars: s.fieldOr("isSquareAvatars", S.nullableAsOption(S.json), None),
  })
}

module UserList = {
  type t = {
  id: string,
  createdAt: string,
  name: string,
  userIds: option<array<string>>,
  isPublic: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    userIds: s.fieldOr("userIds", S.nullableAsOption(S.array(S.string)), None),
    isPublic: s.field("isPublic", S.bool),
  })
}

module UserGroup = {
  type t = {
  id: string,
  createdAt: string,
  name: string,
  ownerId: string,
  userIds: option<array<string>>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    ownerId: s.field("ownerId", S.string),
    userIds: s.fieldOr("userIds", S.nullableAsOption(S.array(S.string)), None),
  })
}

module AchievementName = {
  type t = string
  
  let schema = S.string
}

module Ad = {
  type t = {
  id: string,
  expiresAt: string,
  startsAt: string,
  place: string,
  priority: string,
  ratio: float,
  url: string,
  imageUrl: string,
  memo: string,
  dayOfWeek: int,
  isSensitive: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    expiresAt: s.field("expiresAt", S.string),
    startsAt: s.field("startsAt", S.string),
    place: s.field("place", S.string),
    priority: s.field("priority", S.string),
    ratio: s.field("ratio", S.float),
    url: s.field("url", S.string),
    imageUrl: s.field("imageUrl", S.string),
    memo: s.field("memo", S.string),
    dayOfWeek: s.field("dayOfWeek", S.int),
    isSensitive: s.field("isSensitive", S.bool),
  })
}

module Announcement = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: JSON.t,
  text: string,
  title: string,
  imageUrl: JSON.t,
  icon: string,
  display: string,
  needConfirmationToRead: bool,
  silence: bool,
  forYou: bool,
  isRead: option<bool>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.json),
    text: s.field("text", S.string),
    title: s.field("title", S.string),
    imageUrl: s.field("imageUrl", S.json),
    icon: s.field("icon", S.string),
    display: s.field("display", S.string),
    needConfirmationToRead: s.field("needConfirmationToRead", S.bool),
    silence: s.field("silence", S.bool),
    forYou: s.field("forYou", S.bool),
    isRead: s.fieldOr("isRead", S.nullableAsOption(S.bool), None),
  })
}

module App = {
  type t = {
  id: string,
  name: string,
  callbackUrl: JSON.t,
  permission: array<string>,
  secret: option<string>,
  isAuthorized: option<bool>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    callbackUrl: s.field("callbackUrl", S.json),
    permission: s.field("permission", S.array(S.string)),
    secret: s.fieldOr("secret", S.nullableAsOption(S.string), None),
    isAuthorized: s.fieldOr("isAuthorized", S.nullableAsOption(S.bool), None),
  })
}

module Notification = {
  type t = JSON.t
  
  let schema = S.json
}

module DriveFolder = {
  type t = {
  id: string,
  createdAt: string,
  name: string,
  parentId: JSON.t,
  foldersCount: option<float>,
  filesCount: option<float>,
  parent: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    parentId: s.field("parentId", S.json),
    foldersCount: s.fieldOr("foldersCount", S.nullableAsOption(S.float), None),
    filesCount: s.fieldOr("filesCount", S.nullableAsOption(S.float), None),
    parent: s.fieldOr("parent", S.nullableAsOption(S.json), None),
  })
}

module Hashtag = {
  type t = {
  tag: string,
  mentionedUsersCount: float,
  mentionedLocalUsersCount: float,
  mentionedRemoteUsersCount: float,
  attachedUsersCount: float,
  attachedLocalUsersCount: float,
  attachedRemoteUsersCount: float,
}
  
  let schema = S.object(s => {
    tag: s.field("tag", S.string),
    mentionedUsersCount: s.field("mentionedUsersCount", S.float),
    mentionedLocalUsersCount: s.field("mentionedLocalUsersCount", S.float),
    mentionedRemoteUsersCount: s.field("mentionedRemoteUsersCount", S.float),
    attachedUsersCount: s.field("attachedUsersCount", S.float),
    attachedLocalUsersCount: s.field("attachedLocalUsersCount", S.float),
    attachedRemoteUsersCount: s.field("attachedRemoteUsersCount", S.float),
  })
}

module PageBlock = {
  type t = JSON.t
  
  let schema = S.json
}

module QueueCount = {
  type t = {
  waiting: float,
  active: float,
  completed: float,
  failed: float,
  delayed: float,
}
  
  let schema = S.object(s => {
    waiting: s.field("waiting", S.float),
    active: s.field("active", S.float),
    completed: s.field("completed", S.float),
    failed: s.field("failed", S.float),
    delayed: s.field("delayed", S.float),
  })
}

module QueueMetrics = {
  type t = {
  meta: JSON.t,
  data: array<float>,
  count: float,
}
  
  let schema = S.object(s => {
    meta: s.field("meta", S.json),
    data: s.field("data", S.array(S.float)),
    count: s.field("count", S.float),
  })
}

module QueueJob = {
  type t = {
  id: string,
  name: string,
  data: JSON.t,
  opts: JSON.t,
  timestamp: float,
  processedOn: option<float>,
  processedBy: option<string>,
  finishedOn: option<float>,
  progress: JSON.t,
  attempts: float,
  delay: float,
  failedReason: string,
  stacktrace: array<string>,
  returnValue: JSON.t,
  isFailed: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    data: s.field("data", S.json),
    opts: s.field("opts", S.json),
    timestamp: s.field("timestamp", S.float),
    processedOn: s.fieldOr("processedOn", S.nullableAsOption(S.float), None),
    processedBy: s.fieldOr("processedBy", S.nullableAsOption(S.string), None),
    finishedOn: s.fieldOr("finishedOn", S.nullableAsOption(S.float), None),
    progress: s.field("progress", S.json),
    attempts: s.field("attempts", S.float),
    delay: s.field("delay", S.float),
    failedReason: s.field("failedReason", S.string),
    stacktrace: s.field("stacktrace", S.array(S.string)),
    returnValue: s.field("returnValue", S.json),
    isFailed: s.field("isFailed", S.bool),
  })
}

module Antenna = {
  type t = {
  id: string,
  createdAt: string,
  name: string,
  keywords: array<array<string>>,
  excludeKeywords: array<array<string>>,
  src: string,
  userListId: JSON.t,
  userGroupId: JSON.t,
  users: array<string>,
  caseSensitive: bool,
  localOnly: bool,
  excludeBots: bool,
  withReplies: bool,
  withFile: bool,
  isActive: bool,
  hasUnreadNote: bool,
  notify: bool,
  excludeNotesInSensitiveChannel: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    keywords: s.field("keywords", S.array(S.array(S.string))),
    excludeKeywords: s.field("excludeKeywords", S.array(S.array(S.string))),
    src: s.field("src", S.string),
    userListId: s.field("userListId", S.json),
    userGroupId: s.field("userGroupId", S.json),
    users: s.field("users", S.array(S.string)),
    caseSensitive: s.field("caseSensitive", S.bool),
    localOnly: s.field("localOnly", S.bool),
    excludeBots: s.field("excludeBots", S.bool),
    withReplies: s.field("withReplies", S.bool),
    withFile: s.field("withFile", S.bool),
    isActive: s.field("isActive", S.bool),
    hasUnreadNote: s.field("hasUnreadNote", S.bool),
    notify: s.field("notify", S.bool),
    excludeNotesInSensitiveChannel: s.field("excludeNotesInSensitiveChannel", S.bool),
  })
}

module FederationInstance = {
  type t = {
  id: string,
  firstRetrievedAt: string,
  host: string,
  usersCount: float,
  notesCount: float,
  followingCount: float,
  followersCount: float,
  isNotResponding: bool,
  isSuspended: bool,
  suspensionState: string,
  isBlocked: bool,
  softwareName: JSON.t,
  softwareVersion: JSON.t,
  openRegistrations: JSON.t,
  name: JSON.t,
  description: JSON.t,
  maintainerName: JSON.t,
  maintainerEmail: JSON.t,
  isSilenced: bool,
  isMediaSilenced: bool,
  iconUrl: JSON.t,
  faviconUrl: JSON.t,
  themeColor: JSON.t,
  infoUpdatedAt: JSON.t,
  latestRequestReceivedAt: JSON.t,
  moderationNote: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    firstRetrievedAt: s.field("firstRetrievedAt", S.string),
    host: s.field("host", S.string),
    usersCount: s.field("usersCount", S.float),
    notesCount: s.field("notesCount", S.float),
    followingCount: s.field("followingCount", S.float),
    followersCount: s.field("followersCount", S.float),
    isNotResponding: s.field("isNotResponding", S.bool),
    isSuspended: s.field("isSuspended", S.bool),
    suspensionState: s.field("suspensionState", S.string),
    isBlocked: s.field("isBlocked", S.bool),
    softwareName: s.field("softwareName", S.json),
    softwareVersion: s.field("softwareVersion", S.json),
    openRegistrations: s.field("openRegistrations", S.json),
    name: s.field("name", S.json),
    description: s.field("description", S.json),
    maintainerName: s.field("maintainerName", S.json),
    maintainerEmail: s.field("maintainerEmail", S.json),
    isSilenced: s.field("isSilenced", S.bool),
    isMediaSilenced: s.field("isMediaSilenced", S.bool),
    iconUrl: s.field("iconUrl", S.json),
    faviconUrl: s.field("faviconUrl", S.json),
    themeColor: s.field("themeColor", S.json),
    infoUpdatedAt: s.field("infoUpdatedAt", S.json),
    latestRequestReceivedAt: s.field("latestRequestReceivedAt", S.json),
    moderationNote: s.fieldOr("moderationNote", S.nullableAsOption(S.json), None),
  })
}

module EmojiSimple = {
  type t = {
  aliases: array<string>,
  name: string,
  category: JSON.t,
  url: string,
  localOnly: option<bool>,
  isSensitive: option<bool>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
}
  
  let schema = S.object(s => {
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.json),
    url: s.field("url", S.string),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    isSensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
  })
}

module EmojiDetailed = {
  type t = {
  id: string,
  aliases: array<string>,
  name: string,
  category: JSON.t,
  host: JSON.t,
  url: string,
  license: JSON.t,
  isSensitive: bool,
  localOnly: bool,
  roleIdsThatCanBeUsedThisEmojiAsReaction: array<string>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.json),
    host: s.field("host", S.json),
    url: s.field("url", S.string),
    license: s.field("license", S.json),
    isSensitive: s.field("isSensitive", S.bool),
    localOnly: s.field("localOnly", S.bool),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.field("roleIdsThatCanBeUsedThisEmojiAsReaction", S.array(S.string)),
  })
}

module EmojiDetailedAdmin = {
  type t = {
  id: string,
  updatedAt: JSON.t,
  name: string,
  host: JSON.t,
  publicUrl: string,
  originalUrl: string,
  uri: JSON.t,
  @as("type") type_: JSON.t,
  aliases: array<string>,
  category: JSON.t,
  license: JSON.t,
  localOnly: bool,
  isSensitive: bool,
  roleIdsThatCanBeUsedThisEmojiAsReaction: array<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    updatedAt: s.field("updatedAt", S.json),
    name: s.field("name", S.string),
    host: s.field("host", S.json),
    publicUrl: s.field("publicUrl", S.string),
    originalUrl: s.field("originalUrl", S.string),
    uri: s.field("uri", S.json),
    type_: s.field("type", S.json),
    aliases: s.field("aliases", S.array(S.string)),
    category: s.field("category", S.json),
    license: s.field("license", S.json),
    localOnly: s.field("localOnly", S.bool),
    isSensitive: s.field("isSensitive", S.bool),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.field("roleIdsThatCanBeUsedThisEmojiAsReaction", S.array(S.json)),
  })
}

module Signin = {
  type t = {
  id: string,
  createdAt: string,
  ip: string,
  headers: JSON.t,
  success: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    ip: s.field("ip", S.string),
    headers: s.field("headers", S.json),
    success: s.field("success", S.bool),
  })
}

module RoleCondFormulaValueIsLocalOrRemote = {
  type t = {
  id: string,
  @as("type") type_: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
  })
}

module RoleCondFormulaValueUserSettingBooleanSchema = {
  type t = {
  id: string,
  @as("type") type_: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
  })
}

module RoleCondFormulaValueAssignedRole = {
  type t = {
  id: string,
  @as("type") type_: string,
  roleId: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    roleId: s.field("roleId", S.string),
  })
}

module RoleCondFormulaValueCreated = {
  type t = {
  id: string,
  @as("type") type_: string,
  sec: float,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    sec: s.field("sec", S.float),
  })
}

module RoleCondFormulaFollowersOrFollowingOrNotes = {
  type t = {
  id: string,
  @as("type") type_: string,
  value: float,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    value: s.field("value", S.float),
  })
}

module RoleCondFormulaValue = {
  type t = JSON.t
  
  let schema = S.json
}

module RoleLite = {
  type t = {
  id: string,
  name: string,
  color: JSON.t,
  iconUrl: JSON.t,
  description: string,
  isModerator: bool,
  isAdministrator: bool,
  displayOrder: int,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    color: s.field("color", S.json),
    iconUrl: s.field("iconUrl", S.json),
    description: s.field("description", S.string),
    isModerator: s.field("isModerator", S.bool),
    isAdministrator: s.field("isAdministrator", S.bool),
    displayOrder: s.field("displayOrder", S.int),
  })
}

module RolePolicies = {
  type t = {
  gtlAvailable: bool,
  ltlAvailable: bool,
  btlAvailable: bool,
  canPublicNote: bool,
  mentionLimit: int,
  canInvite: bool,
  inviteLimit: int,
  inviteLimitCycle: int,
  inviteExpirationTime: int,
  canManageCustomEmojis: bool,
  canManageAvatarDecorations: bool,
  canSearchNotes: bool,
  canSearchUsers: bool,
  canUseTranslator: bool,
  canUseAutoTranslate: bool,
  canHideAds: bool,
  driveCapacityMb: int,
  maxFileSizeMb: int,
  uploadableFileTypes: array<string>,
  alwaysMarkNsfw: bool,
  canUpdateBioMedia: bool,
  pinLimit: int,
  antennaLimit: int,
  wordMuteLimit: int,
  webhookLimit: int,
  clipLimit: int,
  noteEachClipsLimit: int,
  userListLimit: int,
  userEachUserListsLimit: int,
  rateLimitFactor: int,
  avatarDecorationLimit: int,
  canImportAntennas: bool,
  canImportBlocking: bool,
  canImportFollowing: bool,
  canImportMuting: bool,
  canImportUserLists: bool,
  canEditNote: bool,
  canSetFederationAvatarShape: bool,
  chatAvailability: string,
  noteDraftLimit: int,
  scheduledNoteLimit: int,
  watermarkAvailable: bool,
}
  
  let schema = S.object(s => {
    gtlAvailable: s.field("gtlAvailable", S.bool),
    ltlAvailable: s.field("ltlAvailable", S.bool),
    btlAvailable: s.field("btlAvailable", S.bool),
    canPublicNote: s.field("canPublicNote", S.bool),
    mentionLimit: s.field("mentionLimit", S.int),
    canInvite: s.field("canInvite", S.bool),
    inviteLimit: s.field("inviteLimit", S.int),
    inviteLimitCycle: s.field("inviteLimitCycle", S.int),
    inviteExpirationTime: s.field("inviteExpirationTime", S.int),
    canManageCustomEmojis: s.field("canManageCustomEmojis", S.bool),
    canManageAvatarDecorations: s.field("canManageAvatarDecorations", S.bool),
    canSearchNotes: s.field("canSearchNotes", S.bool),
    canSearchUsers: s.field("canSearchUsers", S.bool),
    canUseTranslator: s.field("canUseTranslator", S.bool),
    canUseAutoTranslate: s.field("canUseAutoTranslate", S.bool),
    canHideAds: s.field("canHideAds", S.bool),
    driveCapacityMb: s.field("driveCapacityMb", S.int),
    maxFileSizeMb: s.field("maxFileSizeMb", S.int),
    uploadableFileTypes: s.field("uploadableFileTypes", S.array(S.string)),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.bool),
    canUpdateBioMedia: s.field("canUpdateBioMedia", S.bool),
    pinLimit: s.field("pinLimit", S.int),
    antennaLimit: s.field("antennaLimit", S.int),
    wordMuteLimit: s.field("wordMuteLimit", S.int),
    webhookLimit: s.field("webhookLimit", S.int),
    clipLimit: s.field("clipLimit", S.int),
    noteEachClipsLimit: s.field("noteEachClipsLimit", S.int),
    userListLimit: s.field("userListLimit", S.int),
    userEachUserListsLimit: s.field("userEachUserListsLimit", S.int),
    rateLimitFactor: s.field("rateLimitFactor", S.int),
    avatarDecorationLimit: s.field("avatarDecorationLimit", S.int),
    canImportAntennas: s.field("canImportAntennas", S.bool),
    canImportBlocking: s.field("canImportBlocking", S.bool),
    canImportFollowing: s.field("canImportFollowing", S.bool),
    canImportMuting: s.field("canImportMuting", S.bool),
    canImportUserLists: s.field("canImportUserLists", S.bool),
    canEditNote: s.field("canEditNote", S.bool),
    canSetFederationAvatarShape: s.field("canSetFederationAvatarShape", S.bool),
    chatAvailability: s.field("chatAvailability", S.string),
    noteDraftLimit: s.field("noteDraftLimit", S.int),
    scheduledNoteLimit: s.field("scheduledNoteLimit", S.int),
    watermarkAvailable: s.field("watermarkAvailable", S.bool),
  })
}

module MetaDetailedOnly = {
  type t = {
  features: option<JSON.t>,
  proxyAccountName: JSON.t,
  requireSetup: bool,
  cacheRemoteFiles: bool,
  cacheRemoteSensitiveFiles: bool,
}
  
  let schema = S.object(s => {
    features: s.fieldOr("features", S.nullableAsOption(S.json), None),
    proxyAccountName: s.field("proxyAccountName", S.json),
    requireSetup: s.field("requireSetup", S.bool),
    cacheRemoteFiles: s.field("cacheRemoteFiles", S.bool),
    cacheRemoteSensitiveFiles: s.field("cacheRemoteSensitiveFiles", S.bool),
  })
}

module UserWebhook = {
  type t = {
  id: string,
  userId: string,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
  active: bool,
  latestSentAt: JSON.t,
  latestStatus: JSON.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    userId: s.field("userId", S.string),
    name: s.field("name", S.string),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
    active: s.field("active", S.bool),
    latestSentAt: s.field("latestSentAt", S.json),
    latestStatus: s.field("latestStatus", S.json),
  })
}

module SystemWebhook = {
  type t = {
  id: string,
  isActive: bool,
  updatedAt: string,
  latestSentAt: JSON.t,
  latestStatus: JSON.t,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    updatedAt: s.field("updatedAt", S.string),
    latestSentAt: s.field("latestSentAt", S.json),
    latestStatus: s.field("latestStatus", S.json),
    name: s.field("name", S.string),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
  })
}

module NoteReaction = {
  type t = {
  id: string,
  createdAt: string,
  user: UserLite.t,
  @as("type") type_: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    user: s.field("user", UserLite.schema),
    type_: s.field("type", S.string),
  })
}

module InviteCode = {
  type t = {
  id: string,
  code: string,
  expiresAt: JSON.t,
  createdAt: string,
  createdBy: JSON.t,
  usedBy: JSON.t,
  usedAt: JSON.t,
  used: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    code: s.field("code", S.string),
    expiresAt: s.field("expiresAt", S.json),
    createdAt: s.field("createdAt", S.string),
    createdBy: s.field("createdBy", S.json),
    usedBy: s.field("usedBy", S.json),
    usedAt: s.field("usedAt", S.json),
    used: s.field("used", S.bool),
  })
}

module Clip = {
  type t = {
  id: string,
  createdAt: string,
  lastClippedAt: JSON.t,
  userId: string,
  user: UserLite.t,
  name: string,
  description: JSON.t,
  isPublic: bool,
  favoritedCount: float,
  isFavorited: option<bool>,
  notesCount: option<int>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    lastClippedAt: s.field("lastClippedAt", S.json),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    name: s.field("name", S.string),
    description: s.field("description", S.json),
    isPublic: s.field("isPublic", S.bool),
    favoritedCount: s.field("favoritedCount", S.float),
    isFavorited: s.fieldOr("isFavorited", S.nullableAsOption(S.bool), None),
    notesCount: s.fieldOr("notesCount", S.nullableAsOption(S.int), None),
  })
}

module Flash = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: string,
  userId: string,
  user: UserLite.t,
  title: string,
  summary: string,
  script: string,
  visibility: string,
  likedCount: float,
  isLiked: option<bool>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    title: s.field("title", S.string),
    summary: s.field("summary", S.string),
    script: s.field("script", S.string),
    visibility: s.field("visibility", S.string),
    likedCount: s.field("likedCount", S.float),
    isLiked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
  })
}

module ReversiGameLite = {
  type t = {
  id: string,
  createdAt: string,
  startedAt: JSON.t,
  endedAt: JSON.t,
  isStarted: bool,
  isEnded: bool,
  user1Id: string,
  user2Id: string,
  user1: UserLite.t,
  user2: UserLite.t,
  winnerId: JSON.t,
  winner: JSON.t,
  surrenderedUserId: JSON.t,
  timeoutUserId: JSON.t,
  black: JSON.t,
  bw: string,
  noIrregularRules: bool,
  isLlotheo: bool,
  canPutEverywhere: bool,
  loopedBoard: bool,
  timeLimitForEachTurn: float,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    startedAt: s.field("startedAt", S.json),
    endedAt: s.field("endedAt", S.json),
    isStarted: s.field("isStarted", S.bool),
    isEnded: s.field("isEnded", S.bool),
    user1Id: s.field("user1Id", S.string),
    user2Id: s.field("user2Id", S.string),
    user1: s.field("user1", UserLite.schema),
    user2: s.field("user2", UserLite.schema),
    winnerId: s.field("winnerId", S.json),
    winner: s.field("winner", S.json),
    surrenderedUserId: s.field("surrenderedUserId", S.json),
    timeoutUserId: s.field("timeoutUserId", S.json),
    black: s.field("black", S.json),
    bw: s.field("bw", S.string),
    noIrregularRules: s.field("noIrregularRules", S.bool),
    isLlotheo: s.field("isLlotheo", S.bool),
    canPutEverywhere: s.field("canPutEverywhere", S.bool),
    loopedBoard: s.field("loopedBoard", S.bool),
    timeLimitForEachTurn: s.field("timeLimitForEachTurn", S.float),
  })
}

module ReversiGameDetailed = {
  type t = {
  id: string,
  createdAt: string,
  startedAt: JSON.t,
  endedAt: JSON.t,
  isStarted: bool,
  isEnded: bool,
  form1: JSON.t,
  form2: JSON.t,
  user1Ready: bool,
  user2Ready: bool,
  user1Id: string,
  user2Id: string,
  user1: UserLite.t,
  user2: UserLite.t,
  winnerId: JSON.t,
  winner: JSON.t,
  surrenderedUserId: JSON.t,
  timeoutUserId: JSON.t,
  black: JSON.t,
  bw: string,
  noIrregularRules: bool,
  isLlotheo: bool,
  canPutEverywhere: bool,
  loopedBoard: bool,
  timeLimitForEachTurn: float,
  logs: array<array<float>>,
  map: array<string>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    startedAt: s.field("startedAt", S.json),
    endedAt: s.field("endedAt", S.json),
    isStarted: s.field("isStarted", S.bool),
    isEnded: s.field("isEnded", S.bool),
    form1: s.field("form1", S.json),
    form2: s.field("form2", S.json),
    user1Ready: s.field("user1Ready", S.bool),
    user2Ready: s.field("user2Ready", S.bool),
    user1Id: s.field("user1Id", S.string),
    user2Id: s.field("user2Id", S.string),
    user1: s.field("user1", UserLite.schema),
    user2: s.field("user2", UserLite.schema),
    winnerId: s.field("winnerId", S.json),
    winner: s.field("winner", S.json),
    surrenderedUserId: s.field("surrenderedUserId", S.json),
    timeoutUserId: s.field("timeoutUserId", S.json),
    black: s.field("black", S.json),
    bw: s.field("bw", S.string),
    noIrregularRules: s.field("noIrregularRules", S.bool),
    isLlotheo: s.field("isLlotheo", S.bool),
    canPutEverywhere: s.field("canPutEverywhere", S.bool),
    loopedBoard: s.field("loopedBoard", S.bool),
    timeLimitForEachTurn: s.field("timeLimitForEachTurn", S.float),
    logs: s.field("logs", S.array(S.array(S.float))),
    map: s.field("map", S.array(S.string)),
  })
}

module ChatRoom = {
  type t = {
  id: string,
  createdAt: string,
  ownerId: string,
  owner: UserLite.t,
  name: string,
  description: string,
  isMuted: option<bool>,
  invitationExists: option<bool>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    ownerId: s.field("ownerId", S.string),
    owner: s.field("owner", UserLite.schema),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    isMuted: s.fieldOr("isMuted", S.nullableAsOption(S.bool), None),
    invitationExists: s.fieldOr("invitationExists", S.nullableAsOption(S.bool), None),
  })
}

module Achievement = {
  type t = {
  name: AchievementName.t,
  unlockedAt: float,
}
  
  let schema = S.object(s => {
    name: s.field("name", AchievementName.schema),
    unlockedAt: s.field("unlockedAt", S.float),
  })
}

module DriveFile = {
  type t = {
  id: string,
  createdAt: string,
  name: string,
  @as("type") type_: string,
  md5: string,
  size: float,
  isSensitive: bool,
  blurhash: JSON.t,
  properties: JSON.t,
  url: string,
  thumbnailUrl: JSON.t,
  comment: JSON.t,
  folderId: JSON.t,
  folder: option<JSON.t>,
  userId: JSON.t,
  user: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    type_: s.field("type", S.string),
    md5: s.field("md5", S.string),
    size: s.field("size", S.float),
    isSensitive: s.field("isSensitive", S.bool),
    blurhash: s.field("blurhash", S.json),
    properties: s.field("properties", S.json),
    url: s.field("url", S.string),
    thumbnailUrl: s.field("thumbnailUrl", S.json),
    comment: s.field("comment", S.json),
    folderId: s.field("folderId", S.json),
    folder: s.fieldOr("folder", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.json),
    user: s.fieldOr("user", S.nullableAsOption(S.json), None),
  })
}

module RoleCondFormulaLogics = {
  type t = {
  id: string,
  @as("type") type_: string,
  values: array<RoleCondFormulaValue.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    values: s.field("values", S.array(RoleCondFormulaValue.schema)),
  })
}

module RoleCondFormulaValueNot = {
  type t = {
  id: string,
  @as("type") type_: string,
  value: RoleCondFormulaValue.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    value: s.field("value", RoleCondFormulaValue.schema),
  })
}

module Role = {
  type t = JSON.t
  
  let schema = S.json
}

module MetaLite = {
  type t = {
  maintainerName: JSON.t,
  maintainerEmail: JSON.t,
  version: string,
  basedMisskeyVersion: string,
  providesTarball: bool,
  name: JSON.t,
  shortName: JSON.t,
  uri: string,
  description: JSON.t,
  langs: array<string>,
  tosUrl: JSON.t,
  repositoryUrl: JSON.t,
  feedbackUrl: JSON.t,
  defaultDarkTheme: JSON.t,
  defaultLightTheme: JSON.t,
  clientOptions: JSON.t,
  disableRegistration: bool,
  emailRequiredForSignup: bool,
  enableHcaptcha: bool,
  hcaptchaSiteKey: JSON.t,
  enableMcaptcha: bool,
  mcaptchaSiteKey: JSON.t,
  mcaptchaInstanceUrl: JSON.t,
  enableRecaptcha: bool,
  recaptchaSiteKey: JSON.t,
  enableTurnstile: bool,
  turnstileSiteKey: JSON.t,
  enableTestcaptcha: bool,
  googleAnalyticsMeasurementId: JSON.t,
  swPublickey: JSON.t,
  mascotImageUrl: string,
  bannerUrl: JSON.t,
  serverErrorImageUrl: JSON.t,
  infoImageUrl: JSON.t,
  notFoundImageUrl: JSON.t,
  youBlockedImageUrl: JSON.t,
  iconUrl: JSON.t,
  maxNoteTextLength: float,
  ads: array<JSON.t>,
  trustedLinkUrlPatterns: array<string>,
  notesPerOneAd: float,
  enableEmail: bool,
  enableServiceWorker: bool,
  translatorAvailable: bool,
  sentryForFrontend: JSON.t,
  mediaProxy: string,
  enableUrlPreview: bool,
  backgroundImageUrl: JSON.t,
  impressumUrl: JSON.t,
  logoImageUrl: JSON.t,
  privacyPolicyUrl: JSON.t,
  inquiryUrl: JSON.t,
  serverRules: array<string>,
  themeColor: JSON.t,
  policies: RolePolicies.t,
  noteSearchableScope: string,
  maxFileSize: float,
  federation: string,
  disableRegistrationWhenInactive: bool,
  disablePublicNoteWhenInactive: bool,
  moderatorInactivityLimitDays: float,
  customRobotsTxt: JSON.t,
}
  
  let schema = S.object(s => {
    maintainerName: s.field("maintainerName", S.json),
    maintainerEmail: s.field("maintainerEmail", S.json),
    version: s.field("version", S.string),
    basedMisskeyVersion: s.field("basedMisskeyVersion", S.string),
    providesTarball: s.field("providesTarball", S.bool),
    name: s.field("name", S.json),
    shortName: s.field("shortName", S.json),
    uri: s.field("uri", S.string),
    description: s.field("description", S.json),
    langs: s.field("langs", S.array(S.string)),
    tosUrl: s.field("tosUrl", S.json),
    repositoryUrl: s.field("repositoryUrl", S.json),
    feedbackUrl: s.field("feedbackUrl", S.json),
    defaultDarkTheme: s.field("defaultDarkTheme", S.json),
    defaultLightTheme: s.field("defaultLightTheme", S.json),
    clientOptions: s.field("clientOptions", S.json),
    disableRegistration: s.field("disableRegistration", S.bool),
    emailRequiredForSignup: s.field("emailRequiredForSignup", S.bool),
    enableHcaptcha: s.field("enableHcaptcha", S.bool),
    hcaptchaSiteKey: s.field("hcaptchaSiteKey", S.json),
    enableMcaptcha: s.field("enableMcaptcha", S.bool),
    mcaptchaSiteKey: s.field("mcaptchaSiteKey", S.json),
    mcaptchaInstanceUrl: s.field("mcaptchaInstanceUrl", S.json),
    enableRecaptcha: s.field("enableRecaptcha", S.bool),
    recaptchaSiteKey: s.field("recaptchaSiteKey", S.json),
    enableTurnstile: s.field("enableTurnstile", S.bool),
    turnstileSiteKey: s.field("turnstileSiteKey", S.json),
    enableTestcaptcha: s.field("enableTestcaptcha", S.bool),
    googleAnalyticsMeasurementId: s.field("googleAnalyticsMeasurementId", S.json),
    swPublickey: s.field("swPublickey", S.json),
    mascotImageUrl: s.field("mascotImageUrl", S.string),
    bannerUrl: s.field("bannerUrl", S.json),
    serverErrorImageUrl: s.field("serverErrorImageUrl", S.json),
    infoImageUrl: s.field("infoImageUrl", S.json),
    notFoundImageUrl: s.field("notFoundImageUrl", S.json),
    youBlockedImageUrl: s.field("youBlockedImageUrl", S.json),
    iconUrl: s.field("iconUrl", S.json),
    maxNoteTextLength: s.field("maxNoteTextLength", S.float),
    ads: s.field("ads", S.array(S.json)),
    trustedLinkUrlPatterns: s.field("trustedLinkUrlPatterns", S.array(S.string)),
    notesPerOneAd: s.field("notesPerOneAd", S.float),
    enableEmail: s.field("enableEmail", S.bool),
    enableServiceWorker: s.field("enableServiceWorker", S.bool),
    translatorAvailable: s.field("translatorAvailable", S.bool),
    sentryForFrontend: s.field("sentryForFrontend", S.json),
    mediaProxy: s.field("mediaProxy", S.string),
    enableUrlPreview: s.field("enableUrlPreview", S.bool),
    backgroundImageUrl: s.field("backgroundImageUrl", S.json),
    impressumUrl: s.field("impressumUrl", S.json),
    logoImageUrl: s.field("logoImageUrl", S.json),
    privacyPolicyUrl: s.field("privacyPolicyUrl", S.json),
    inquiryUrl: s.field("inquiryUrl", S.json),
    serverRules: s.field("serverRules", S.array(S.string)),
    themeColor: s.field("themeColor", S.json),
    policies: s.field("policies", RolePolicies.schema),
    noteSearchableScope: s.field("noteSearchableScope", S.string),
    maxFileSize: s.field("maxFileSize", S.float),
    federation: s.field("federation", S.string),
    disableRegistrationWhenInactive: s.field("disableRegistrationWhenInactive", S.bool),
    disablePublicNoteWhenInactive: s.field("disablePublicNoteWhenInactive", S.bool),
    moderatorInactivityLimitDays: s.field("moderatorInactivityLimitDays", S.float),
    customRobotsTxt: s.field("customRobotsTxt", S.json),
  })
}

module AbuseReportNotificationRecipient = {
  type t = {
  id: string,
  isActive: bool,
  updatedAt: string,
  name: string,
  @as("method") method_: string,
  userId: option<string>,
  user: option<UserLite.t>,
  systemWebhookId: option<string>,
  systemWebhook: option<SystemWebhook.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    updatedAt: s.field("updatedAt", S.string),
    name: s.field("name", S.string),
    method_: s.field("method", S.string),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    user: s.fieldOr("user", S.nullableAsOption(UserLite.schema), None),
    systemWebhookId: s.fieldOr("systemWebhookId", S.nullableAsOption(S.string), None),
    systemWebhook: s.fieldOr("systemWebhook", S.nullableAsOption(SystemWebhook.schema), None),
  })
}

module ChatRoomInvitation = {
  type t = {
  id: string,
  createdAt: string,
  userId: string,
  user: UserLite.t,
  roomId: string,
  room: ChatRoom.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    roomId: s.field("roomId", S.string),
    room: s.field("room", ChatRoom.schema),
  })
}

module ChatRoomMembership = {
  type t = {
  id: string,
  createdAt: string,
  userId: string,
  user: option<UserLite.t>,
  roomId: string,
  room: option<ChatRoom.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.string),
    user: s.fieldOr("user", S.nullableAsOption(UserLite.schema), None),
    roomId: s.field("roomId", S.string),
    room: s.fieldOr("room", S.nullableAsOption(ChatRoom.schema), None),
  })
}

module MeDetailedOnly = {
  type t = {
  avatarId: JSON.t,
  bannerId: JSON.t,
  followedMessage: JSON.t,
  isModerator: bool,
  isAdmin: bool,
  injectFeaturedNote: bool,
  receiveAnnouncementEmail: bool,
  alwaysMarkNsfw: bool,
  autoSensitive: bool,
  carefulBot: bool,
  autoAcceptFollowed: bool,
  noCrawle: bool,
  preventAiLearning: bool,
  isExplorable: bool,
  isDeleted: bool,
  twoFactorBackupCodesStock: string,
  hideOnlineStatus: bool,
  hasUnreadSpecifiedNotes: bool,
  hasUnreadMentions: bool,
  hasUnreadAnnouncement: bool,
  unreadAnnouncements: array<Announcement.t>,
  hasUnreadAntenna: bool,
  hasUnreadChannel: bool,
  hasUnreadChatMessages: bool,
  hasUnreadNotification: bool,
  hasPendingReceivedFollowRequest: bool,
  unreadNotificationsCount: float,
  mutedWords: array<array<string>>,
  hardMutedWords: array<array<string>>,
  mutedInstances: array<string>,
  notificationRecieveConfig: JSON.t,
  emailNotificationTypes: array<string>,
  achievements: array<Achievement.t>,
  loggedInDays: float,
  policies: RolePolicies.t,
  twoFactorEnabled: bool,
  usePasswordLessLogin: bool,
  securityKeys: bool,
  email: option<JSON.t>,
  emailVerified: option<JSON.t>,
  securityKeysList: option<array<JSON.t>>,
  autoDeleteNotesAfterDays: JSON.t,
  autoDeleteKeepFavorites: bool,
}
  
  let schema = S.object(s => {
    avatarId: s.field("avatarId", S.json),
    bannerId: s.field("bannerId", S.json),
    followedMessage: s.field("followedMessage", S.json),
    isModerator: s.field("isModerator", S.bool),
    isAdmin: s.field("isAdmin", S.bool),
    injectFeaturedNote: s.field("injectFeaturedNote", S.bool),
    receiveAnnouncementEmail: s.field("receiveAnnouncementEmail", S.bool),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.bool),
    autoSensitive: s.field("autoSensitive", S.bool),
    carefulBot: s.field("carefulBot", S.bool),
    autoAcceptFollowed: s.field("autoAcceptFollowed", S.bool),
    noCrawle: s.field("noCrawle", S.bool),
    preventAiLearning: s.field("preventAiLearning", S.bool),
    isExplorable: s.field("isExplorable", S.bool),
    isDeleted: s.field("isDeleted", S.bool),
    twoFactorBackupCodesStock: s.field("twoFactorBackupCodesStock", S.string),
    hideOnlineStatus: s.field("hideOnlineStatus", S.bool),
    hasUnreadSpecifiedNotes: s.field("hasUnreadSpecifiedNotes", S.bool),
    hasUnreadMentions: s.field("hasUnreadMentions", S.bool),
    hasUnreadAnnouncement: s.field("hasUnreadAnnouncement", S.bool),
    unreadAnnouncements: s.field("unreadAnnouncements", S.array(Announcement.schema)),
    hasUnreadAntenna: s.field("hasUnreadAntenna", S.bool),
    hasUnreadChannel: s.field("hasUnreadChannel", S.bool),
    hasUnreadChatMessages: s.field("hasUnreadChatMessages", S.bool),
    hasUnreadNotification: s.field("hasUnreadNotification", S.bool),
    hasPendingReceivedFollowRequest: s.field("hasPendingReceivedFollowRequest", S.bool),
    unreadNotificationsCount: s.field("unreadNotificationsCount", S.float),
    mutedWords: s.field("mutedWords", S.array(S.array(S.string))),
    hardMutedWords: s.field("hardMutedWords", S.array(S.array(S.string))),
    mutedInstances: s.field("mutedInstances", S.array(S.string)),
    notificationRecieveConfig: s.field("notificationRecieveConfig", S.json),
    emailNotificationTypes: s.field("emailNotificationTypes", S.array(S.string)),
    achievements: s.field("achievements", S.array(Achievement.schema)),
    loggedInDays: s.field("loggedInDays", S.float),
    policies: s.field("policies", RolePolicies.schema),
    twoFactorEnabled: s.field("twoFactorEnabled", S.bool),
    usePasswordLessLogin: s.field("usePasswordLessLogin", S.bool),
    securityKeys: s.field("securityKeys", S.bool),
    email: s.fieldOr("email", S.nullableAsOption(S.json), None),
    emailVerified: s.fieldOr("emailVerified", S.nullableAsOption(S.json), None),
    securityKeysList: s.fieldOr("securityKeysList", S.nullableAsOption(S.array(S.json)), None),
    autoDeleteNotesAfterDays: s.field("autoDeleteNotesAfterDays", S.json),
    autoDeleteKeepFavorites: s.field("autoDeleteKeepFavorites", S.bool),
  })
}

module Note = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: option<JSON.t>,
  updatedAtHistory: option<JSON.t>,
  deletedAt: option<JSON.t>,
  text: JSON.t,
  cw: option<JSON.t>,
  userId: string,
  user: UserLite.t,
  replyId: option<JSON.t>,
  renoteId: option<JSON.t>,
  reply: option<JSON.t>,
  renote: option<JSON.t>,
  disableRightClick: option<bool>,
  isHidden: option<bool>,
  visibility: string,
  mentions: option<array<string>>,
  visibleUserIds: option<array<string>>,
  fileIds: option<array<string>>,
  files: option<array<DriveFile.t>>,
  tags: option<array<string>>,
  poll: option<JSON.t>,
  emojis: option<JSON.t>,
  event: option<JSON.t>,
  channelId: option<JSON.t>,
  channel: option<JSON.t>,
  localOnly: option<bool>,
  reactionAcceptance: JSON.t,
  reactionEmojis: JSON.t,
  reactions: JSON.t,
  reactionCount: float,
  renoteCount: float,
  repliesCount: float,
  uri: option<string>,
  url: option<string>,
  reactionAndUserPairCache: option<array<string>>,
  clippedCount: option<float>,
  hasPoll: option<bool>,
  myReaction: option<JSON.t>,
  deleteAt: option<JSON.t>,
  deliveryTargets: option<JSON.t>,
  hasDeliveryTargets: bool,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.fieldOr("updatedAt", S.nullableAsOption(S.json), None),
    updatedAtHistory: s.fieldOr("updatedAtHistory", S.nullableAsOption(S.json), None),
    deletedAt: s.fieldOr("deletedAt", S.nullableAsOption(S.json), None),
    text: s.field("text", S.json),
    cw: s.fieldOr("cw", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    replyId: s.fieldOr("replyId", S.nullableAsOption(S.json), None),
    renoteId: s.fieldOr("renoteId", S.nullableAsOption(S.json), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.json), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.json), None),
    disableRightClick: s.fieldOr("disableRightClick", S.nullableAsOption(S.bool), None),
    isHidden: s.fieldOr("isHidden", S.nullableAsOption(S.bool), None),
    visibility: s.field("visibility", S.string),
    mentions: s.fieldOr("mentions", S.nullableAsOption(S.array(S.string)), None),
    visibleUserIds: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
    fileIds: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    files: s.fieldOr("files", S.nullableAsOption(S.array(DriveFile.schema)), None),
    tags: s.fieldOr("tags", S.nullableAsOption(S.array(S.string)), None),
    poll: s.fieldOr("poll", S.nullableAsOption(S.json), None),
    emojis: s.fieldOr("emojis", S.nullableAsOption(S.json), None),
    event: s.fieldOr("event", S.nullableAsOption(S.json), None),
    channelId: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
    channel: s.fieldOr("channel", S.nullableAsOption(S.json), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    reactionAcceptance: s.field("reactionAcceptance", S.json),
    reactionEmojis: s.field("reactionEmojis", S.json),
    reactions: s.field("reactions", S.json),
    reactionCount: s.field("reactionCount", S.float),
    renoteCount: s.field("renoteCount", S.float),
    repliesCount: s.field("repliesCount", S.float),
    uri: s.fieldOr("uri", S.nullableAsOption(S.string), None),
    url: s.fieldOr("url", S.nullableAsOption(S.string), None),
    reactionAndUserPairCache: s.fieldOr("reactionAndUserPairCache", S.nullableAsOption(S.array(S.string)), None),
    clippedCount: s.fieldOr("clippedCount", S.nullableAsOption(S.float), None),
    hasPoll: s.fieldOr("hasPoll", S.nullableAsOption(S.bool), None),
    myReaction: s.fieldOr("myReaction", S.nullableAsOption(S.json), None),
    deleteAt: s.fieldOr("deleteAt", S.nullableAsOption(S.json), None),
    deliveryTargets: s.fieldOr("deliveryTargets", S.nullableAsOption(S.json), None),
    hasDeliveryTargets: s.field("hasDeliveryTargets", S.bool),
  })
}

module Page = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: string,
  userId: string,
  user: UserLite.t,
  content: array<PageBlock.t>,
  variables: array<JSON.t>,
  title: string,
  name: string,
  summary: JSON.t,
  hideTitleWhenPinned: bool,
  alignCenter: bool,
  font: string,
  script: string,
  eyeCatchingImageId: JSON.t,
  eyeCatchingImage: JSON.t,
  attachedFiles: array<DriveFile.t>,
  likedCount: float,
  isLiked: option<bool>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    content: s.field("content", S.array(PageBlock.schema)),
    variables: s.field("variables", S.array(S.json)),
    title: s.field("title", S.string),
    name: s.field("name", S.string),
    summary: s.field("summary", S.json),
    hideTitleWhenPinned: s.field("hideTitleWhenPinned", S.bool),
    alignCenter: s.field("alignCenter", S.bool),
    font: s.field("font", S.string),
    script: s.field("script", S.string),
    eyeCatchingImageId: s.field("eyeCatchingImageId", S.json),
    eyeCatchingImage: s.field("eyeCatchingImage", S.json),
    attachedFiles: s.field("attachedFiles", S.array(DriveFile.schema)),
    likedCount: s.field("likedCount", S.float),
    isLiked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
  })
}

module GalleryPost = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: string,
  userId: string,
  user: UserLite.t,
  title: string,
  description: JSON.t,
  fileIds: option<array<string>>,
  files: option<array<DriveFile.t>>,
  tags: option<array<string>>,
  isSensitive: bool,
  likedCount: float,
  isLiked: option<bool>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    title: s.field("title", S.string),
    description: s.field("description", S.json),
    fileIds: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    files: s.fieldOr("files", S.nullableAsOption(S.array(DriveFile.schema)), None),
    tags: s.fieldOr("tags", S.nullableAsOption(S.array(S.string)), None),
    isSensitive: s.field("isSensitive", S.bool),
    likedCount: s.field("likedCount", S.float),
    isLiked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
  })
}

module ChatMessage = {
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  fromUser: UserLite.t,
  toUserId: option<JSON.t>,
  toUser: option<JSON.t>,
  toRoomId: option<JSON.t>,
  toRoom: option<JSON.t>,
  text: option<JSON.t>,
  fileId: option<JSON.t>,
  file: option<JSON.t>,
  isRead: option<bool>,
  reactions: array<JSON.t>,
  emojis: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    fromUser: s.field("fromUser", UserLite.schema),
    toUserId: s.fieldOr("toUserId", S.nullableAsOption(S.json), None),
    toUser: s.fieldOr("toUser", S.nullableAsOption(S.json), None),
    toRoomId: s.fieldOr("toRoomId", S.nullableAsOption(S.json), None),
    toRoom: s.fieldOr("toRoom", S.nullableAsOption(S.json), None),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    isRead: s.fieldOr("isRead", S.nullableAsOption(S.bool), None),
    reactions: s.field("reactions", S.array(S.json)),
    emojis: s.fieldOr("emojis", S.nullableAsOption(S.json), None),
  })
}

module ChatMessageLite = {
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  fromUser: option<UserLite.t>,
  toUserId: option<JSON.t>,
  toRoomId: option<JSON.t>,
  text: option<JSON.t>,
  fileId: option<JSON.t>,
  file: option<JSON.t>,
  reactions: array<JSON.t>,
  emojis: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    fromUser: s.fieldOr("fromUser", S.nullableAsOption(UserLite.schema), None),
    toUserId: s.fieldOr("toUserId", S.nullableAsOption(S.json), None),
    toRoomId: s.fieldOr("toRoomId", S.nullableAsOption(S.json), None),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    reactions: s.field("reactions", S.array(S.json)),
    emojis: s.fieldOr("emojis", S.nullableAsOption(S.json), None),
  })
}

module ChatMessageLiteFor1on1 = {
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  toUserId: string,
  text: option<JSON.t>,
  fileId: option<JSON.t>,
  file: option<JSON.t>,
  reactions: array<JSON.t>,
  emojis: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    toUserId: s.field("toUserId", S.string),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    reactions: s.field("reactions", S.array(S.json)),
    emojis: s.fieldOr("emojis", S.nullableAsOption(S.json), None),
  })
}

module ChatMessageLiteForRoom = {
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  fromUser: UserLite.t,
  toRoomId: string,
  text: option<JSON.t>,
  fileId: option<JSON.t>,
  file: option<JSON.t>,
  reactions: array<JSON.t>,
  emojis: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    fromUser: s.field("fromUser", UserLite.schema),
    toRoomId: s.field("toRoomId", S.string),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    reactions: s.field("reactions", S.array(S.json)),
    emojis: s.fieldOr("emojis", S.nullableAsOption(S.json), None),
  })
}

module NoteHistory = {
  type t = {
  id: string,
  noteId: string,
  createdAt: string,
  updatedAt: string,
  userId: string,
  text: JSON.t,
  cw: option<JSON.t>,
  poll: option<JSON.t>,
  event: option<JSON.t>,
  fileIds: option<array<string>>,
  files: option<array<DriveFile.t>>,
  visibility: string,
  visibleUserIds: option<array<string>>,
  emojis: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    noteId: s.field("noteId", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    userId: s.field("userId", S.string),
    text: s.field("text", S.json),
    cw: s.fieldOr("cw", S.nullableAsOption(S.json), None),
    poll: s.fieldOr("poll", S.nullableAsOption(S.json), None),
    event: s.fieldOr("event", S.nullableAsOption(S.json), None),
    fileIds: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    files: s.fieldOr("files", S.nullableAsOption(S.array(DriveFile.schema)), None),
    visibility: s.field("visibility", S.string),
    visibleUserIds: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
    emojis: s.fieldOr("emojis", S.nullableAsOption(S.json), None),
  })
}

module MetaDetailed = {
  type t = MetaDetailedOnly.t
  
  let schema = MetaDetailedOnly.schema
}

module NoteDraft = {
  type t = {
  id: string,
  createdAt: string,
  text: JSON.t,
  cw: JSON.t,
  userId: string,
  user: UserLite.t,
  replyId: JSON.t,
  renoteId: JSON.t,
  reply: option<JSON.t>,
  renote: option<JSON.t>,
  disableRightClick: option<bool>,
  visibility: string,
  visibleUserIds: array<string>,
  fileIds: array<string>,
  files: option<array<DriveFile.t>>,
  hashtag: JSON.t,
  poll: JSON.t,
  event: option<JSON.t>,
  channelId: JSON.t,
  channel: option<JSON.t>,
  localOnly: bool,
  reactionAcceptance: JSON.t,
  scheduledAt: JSON.t,
  isActuallyScheduled: bool,
  deleteAt: option<JSON.t>,
  deliveryTargets: option<JSON.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    text: s.field("text", S.json),
    cw: s.field("cw", S.json),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    replyId: s.field("replyId", S.json),
    renoteId: s.field("renoteId", S.json),
    reply: s.fieldOr("reply", S.nullableAsOption(S.json), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.json), None),
    disableRightClick: s.fieldOr("disableRightClick", S.nullableAsOption(S.bool), None),
    visibility: s.field("visibility", S.string),
    visibleUserIds: s.field("visibleUserIds", S.array(S.string)),
    fileIds: s.field("fileIds", S.array(S.string)),
    files: s.fieldOr("files", S.nullableAsOption(S.array(DriveFile.schema)), None),
    hashtag: s.field("hashtag", S.json),
    poll: s.field("poll", S.json),
    event: s.fieldOr("event", S.nullableAsOption(S.json), None),
    channelId: s.field("channelId", S.json),
    channel: s.fieldOr("channel", S.nullableAsOption(S.json), None),
    localOnly: s.field("localOnly", S.bool),
    reactionAcceptance: s.field("reactionAcceptance", S.json),
    scheduledAt: s.field("scheduledAt", S.json),
    isActuallyScheduled: s.field("isActuallyScheduled", S.bool),
    deleteAt: s.fieldOr("deleteAt", S.nullableAsOption(S.json), None),
    deliveryTargets: s.fieldOr("deliveryTargets", S.nullableAsOption(S.json), None),
  })
}

module NoteReactionWithNote = {
  type t = {
  id: string,
  createdAt: string,
  user: UserLite.t,
  @as("type") type_: string,
  note: Note.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    user: s.field("user", UserLite.schema),
    type_: s.field("type", S.string),
    note: s.field("note", Note.schema),
  })
}

module NoteFavorite = {
  type t = {
  id: string,
  createdAt: string,
  note: Note.t,
  noteId: string,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    note: s.field("note", Note.schema),
    noteId: s.field("noteId", S.string),
  })
}

module Channel = {
  type t = {
  id: string,
  createdAt: string,
  lastNotedAt: JSON.t,
  name: string,
  description: JSON.t,
  userId: JSON.t,
  bannerUrl: JSON.t,
  pinnedNoteIds: array<string>,
  color: string,
  isArchived: bool,
  usersCount: float,
  notesCount: float,
  isSensitive: bool,
  allowRenoteToExternal: bool,
  isFollowing: option<bool>,
  isFavorited: option<bool>,
  pinnedNotes: option<array<Note.t>>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    lastNotedAt: s.field("lastNotedAt", S.json),
    name: s.field("name", S.string),
    description: s.field("description", S.json),
    userId: s.field("userId", S.json),
    bannerUrl: s.field("bannerUrl", S.json),
    pinnedNoteIds: s.field("pinnedNoteIds", S.array(S.string)),
    color: s.field("color", S.string),
    isArchived: s.field("isArchived", S.bool),
    usersCount: s.field("usersCount", S.float),
    notesCount: s.field("notesCount", S.float),
    isSensitive: s.field("isSensitive", S.bool),
    allowRenoteToExternal: s.field("allowRenoteToExternal", S.bool),
    isFollowing: s.fieldOr("isFollowing", S.nullableAsOption(S.bool), None),
    isFavorited: s.fieldOr("isFavorited", S.nullableAsOption(S.bool), None),
    pinnedNotes: s.fieldOr("pinnedNotes", S.nullableAsOption(S.array(Note.schema)), None),
  })
}

module UserDetailedNotMeOnly = {
  type t = {
  url: JSON.t,
  uri: JSON.t,
  movedTo: JSON.t,
  alsoKnownAs: JSON.t,
  createdAt: string,
  updatedAt: JSON.t,
  lastFetchedAt: JSON.t,
  bannerUrl: JSON.t,
  bannerBlurhash: JSON.t,
  isSilenced: bool,
  isSuspended: bool,
  description: JSON.t,
  location: JSON.t,
  birthday: JSON.t,
  lang: JSON.t,
  fields: array<JSON.t>,
  verifiedLinks: array<string>,
  followersCount: float,
  followingCount: float,
  notesCount: float,
  pinnedNoteIds: array<string>,
  pinnedNotes: array<Note.t>,
  pinnedPageId: JSON.t,
  pinnedPage: JSON.t,
  publicReactions: bool,
  followingVisibility: string,
  followersVisibility: string,
  chatScope: string,
  canChat: bool,
  roles: array<RoleLite.t>,
  followedMessage: option<JSON.t>,
  memo: JSON.t,
  moderationNote: option<string>,
  twoFactorEnabled: option<bool>,
  usePasswordLessLogin: option<bool>,
  securityKeys: option<bool>,
  isFollowing: option<bool>,
  isFollowed: option<bool>,
  hasPendingFollowRequestFromYou: option<bool>,
  hasPendingFollowRequestToYou: option<bool>,
  isBlocking: option<bool>,
  isBlocked: option<bool>,
  isMuted: option<bool>,
  isRenoteMuted: option<bool>,
  notify: option<string>,
  withReplies: option<bool>,
}
  
  let schema = S.object(s => {
    url: s.field("url", S.json),
    uri: s.field("uri", S.json),
    movedTo: s.field("movedTo", S.json),
    alsoKnownAs: s.field("alsoKnownAs", S.json),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.json),
    lastFetchedAt: s.field("lastFetchedAt", S.json),
    bannerUrl: s.field("bannerUrl", S.json),
    bannerBlurhash: s.field("bannerBlurhash", S.json),
    isSilenced: s.field("isSilenced", S.bool),
    isSuspended: s.field("isSuspended", S.bool),
    description: s.field("description", S.json),
    location: s.field("location", S.json),
    birthday: s.field("birthday", S.json),
    lang: s.field("lang", S.json),
    fields: s.field("fields", S.array(S.json)),
    verifiedLinks: s.field("verifiedLinks", S.array(S.string)),
    followersCount: s.field("followersCount", S.float),
    followingCount: s.field("followingCount", S.float),
    notesCount: s.field("notesCount", S.float),
    pinnedNoteIds: s.field("pinnedNoteIds", S.array(S.string)),
    pinnedNotes: s.field("pinnedNotes", S.array(Note.schema)),
    pinnedPageId: s.field("pinnedPageId", S.json),
    pinnedPage: s.field("pinnedPage", S.json),
    publicReactions: s.field("publicReactions", S.bool),
    followingVisibility: s.field("followingVisibility", S.string),
    followersVisibility: s.field("followersVisibility", S.string),
    chatScope: s.field("chatScope", S.string),
    canChat: s.field("canChat", S.bool),
    roles: s.field("roles", S.array(RoleLite.schema)),
    followedMessage: s.fieldOr("followedMessage", S.nullableAsOption(S.json), None),
    memo: s.field("memo", S.json),
    moderationNote: s.fieldOr("moderationNote", S.nullableAsOption(S.string), None),
    twoFactorEnabled: s.fieldOr("twoFactorEnabled", S.nullableAsOption(S.bool), None),
    usePasswordLessLogin: s.fieldOr("usePasswordLessLogin", S.nullableAsOption(S.bool), None),
    securityKeys: s.fieldOr("securityKeys", S.nullableAsOption(S.bool), None),
    isFollowing: s.fieldOr("isFollowing", S.nullableAsOption(S.bool), None),
    isFollowed: s.fieldOr("isFollowed", S.nullableAsOption(S.bool), None),
    hasPendingFollowRequestFromYou: s.fieldOr("hasPendingFollowRequestFromYou", S.nullableAsOption(S.bool), None),
    hasPendingFollowRequestToYou: s.fieldOr("hasPendingFollowRequestToYou", S.nullableAsOption(S.bool), None),
    isBlocking: s.fieldOr("isBlocking", S.nullableAsOption(S.bool), None),
    isBlocked: s.fieldOr("isBlocked", S.nullableAsOption(S.bool), None),
    isMuted: s.fieldOr("isMuted", S.nullableAsOption(S.bool), None),
    isRenoteMuted: s.fieldOr("isRenoteMuted", S.nullableAsOption(S.bool), None),
    notify: s.fieldOr("notify", S.nullableAsOption(S.string), None),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
  })
}

module UserDetailedNotMe = {
  type t = UserDetailedNotMeOnly.t
  
  let schema = UserDetailedNotMeOnly.schema
}

module MeDetailed = {
  type t = MeDetailedOnly.t
  
  let schema = MeDetailedOnly.schema
}

module Following = {
  type t = {
  id: string,
  createdAt: string,
  followeeId: string,
  followerId: string,
  followee: option<UserDetailedNotMe.t>,
  follower: option<UserDetailedNotMe.t>,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    followeeId: s.field("followeeId", S.string),
    followerId: s.field("followerId", S.string),
    followee: s.fieldOr("followee", S.nullableAsOption(UserDetailedNotMe.schema), None),
    follower: s.fieldOr("follower", S.nullableAsOption(UserDetailedNotMe.schema), None),
  })
}

module Muting = {
  type t = {
  id: string,
  createdAt: string,
  expiresAt: JSON.t,
  muteeId: string,
  mutee: UserDetailedNotMe.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    expiresAt: s.field("expiresAt", S.json),
    muteeId: s.field("muteeId", S.string),
    mutee: s.field("mutee", UserDetailedNotMe.schema),
  })
}

module RenoteMuting = {
  type t = {
  id: string,
  createdAt: string,
  muteeId: string,
  mutee: UserDetailedNotMe.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    muteeId: s.field("muteeId", S.string),
    mutee: s.field("mutee", UserDetailedNotMe.schema),
  })
}

module Blocking = {
  type t = {
  id: string,
  createdAt: string,
  blockeeId: string,
  blockee: UserDetailedNotMe.t,
}
  
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    blockeeId: s.field("blockeeId", S.string),
    blockee: s.field("blockee", UserDetailedNotMe.schema),
  })
}

module UserDetailed = {
  type t = JSON.t
  
  let schema = S.json
}

module User = {
  type t = JSON.t
  
  let schema = S.json
}
