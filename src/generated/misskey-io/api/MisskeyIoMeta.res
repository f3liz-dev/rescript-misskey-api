// misskey-io API for meta
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postAdminMetaResponse = {
  cacheRemoteFiles: bool,
  cacheRemoteSensitiveFiles: bool,
  emailRequiredForSignup: bool,
  enableHcaptcha: bool,
  hcaptchaSiteKey: option<string>,
  enableMcaptcha: bool,
  mcaptchaSiteKey: option<string>,
  mcaptchaInstanceUrl: option<string>,
  enableRecaptcha: bool,
  recaptchaSiteKey: option<string>,
  enableTurnstile: bool,
  turnstileSiteKey: option<string>,
  googleAnalyticsId: option<string>,
  swPublickey: option<string>,
  mascotImageUrl: option<string>,
  bannerUrl: option<string>,
  serverErrorImageUrl: option<string>,
  infoImageUrl: option<string>,
  notFoundImageUrl: option<string>,
  iconUrl: option<string>,
  @as("app192IconUrl") app192iconUrl: option<string>,
  @as("app512IconUrl") app512iconUrl: option<string>,
  enableEmail: bool,
  enableServiceWorker: bool,
  translatorAvailable: bool,
  silencedHosts: option<array<string>>,
  sensitiveMediaHosts: option<array<string>>,
  pinnedUsers: array<string>,
  hiddenTags: array<string>,
  blockedHosts: array<string>,
  blockedRemoteCustomEmojis: array<string>,
  sensitiveWords: array<string>,
  prohibitedWords: array<string>,
  bannedEmailDomains: option<array<string>>,
  preservedUsernames: array<string>,
  hcaptchaSecretKey: option<string>,
  mcaptchaSecretKey: option<string>,
  recaptchaSecretKey: option<string>,
  turnstileSecretKey: option<string>,
  sensitiveMediaDetection: string,
  sensitiveMediaDetectionSensitivity: string,
  setSensitiveFlagAutomatically: bool,
  enableSensitiveMediaDetectionForVideos: bool,
  proxyAccountId: string,
  email: option<string>,
  smtpSecure: bool,
  smtpHost: option<string>,
  smtpPort: option<float>,
  smtpUser: option<string>,
  smtpPass: option<string>,
  swPrivateKey: option<string>,
  useObjectStorage: bool,
  objectStorageBaseUrl: option<string>,
  objectStorageBucket: option<string>,
  objectStoragePrefix: option<string>,
  objectStorageEndpoint: option<string>,
  objectStorageRegion: option<string>,
  objectStoragePort: option<float>,
  objectStorageAccessKey: option<string>,
  objectStorageSecretKey: option<string>,
  @as("objectStorageUseSSL") objectStorageUseSsl: bool,
  objectStorageUseProxy: bool,
  objectStorageSetPublicRead: bool,
  enableIpLogging: bool,
  enableActiveEmailValidation: bool,
  enableVerifymailApi: bool,
  verifymailAuthKey: option<string>,
  enableTruemailApi: bool,
  truemailInstance: option<string>,
  truemailAuthKey: option<string>,
  enableChartsForRemoteUser: bool,
  enableChartsForFederatedInstances: bool,
  enableServerMachineStats: bool,
  enableIdenticonGeneration: bool,
  manifestJsonOverride: string,
  policies: dict<JSON.t>,
  enableFanoutTimeline: bool,
  enableFanoutTimelineDbFallback: bool,
  perLocalUserUserTimelineCacheMax: float,
  perRemoteUserUserTimelineCacheMax: float,
  perUserHomeTimelineCacheMax: float,
  perUserListTimelineCacheMax: float,
  notesPerOneAd: float,
  wellKnownWebsites: array<string>,
  urlPreviewDenyList: array<string>,
  featuredGameChannels: array<string>,
  backgroundImageUrl: option<string>,
  deeplAuthKey: option<string>,
  deeplIsPro: bool,
  defaultDarkTheme: option<string>,
  defaultLightTheme: option<string>,
  description: option<string>,
  dimensions: float,
  disableRegistration: bool,
  impressumUrl: option<string>,
  maintainerEmail: option<string>,
  maintainerName: option<string>,
  name: option<string>,
  shortName: option<string>,
  @as("objectStorageS3ForcePathStyle") objectStorageS3forcePathStyle: bool,
  privacyPolicyUrl: option<string>,
  repositoryUrl: option<string>,
  summalyProxy: option<string>,
  themeColor: option<string>,
  tosUrl: option<string>,
  uri: string,
  version: string,
  urlPreviewEnabled: bool,
  urlPreviewTimeout: float,
  urlPreviewMaximumContentLength: float,
  urlPreviewRequireContentLength: bool,
  urlPreviewUserAgent: option<string>,
  urlPreviewSummaryProxyUrl: option<string>,
  federation: string,
  federationHosts: array<string>,
  prohibitedWordsForNameOfUser: array<string>,
  inquiryUrl: option<string>,
}

let postAdminMetaResponseSchema = S.object(s => {
    cacheRemoteFiles: s.field("cacheRemoteFiles", S.bool),
    cacheRemoteSensitiveFiles: s.field("cacheRemoteSensitiveFiles", S.bool),
    emailRequiredForSignup: s.field("emailRequiredForSignup", S.bool),
    enableHcaptcha: s.field("enableHcaptcha", S.bool),
    hcaptchaSiteKey: s.field("hcaptchaSiteKey", S.nullableAsOption(S.string)),
    enableMcaptcha: s.field("enableMcaptcha", S.bool),
    mcaptchaSiteKey: s.field("mcaptchaSiteKey", S.nullableAsOption(S.string)),
    mcaptchaInstanceUrl: s.field("mcaptchaInstanceUrl", S.nullableAsOption(S.string)),
    enableRecaptcha: s.field("enableRecaptcha", S.bool),
    recaptchaSiteKey: s.field("recaptchaSiteKey", S.nullableAsOption(S.string)),
    enableTurnstile: s.field("enableTurnstile", S.bool),
    turnstileSiteKey: s.field("turnstileSiteKey", S.nullableAsOption(S.string)),
    googleAnalyticsId: s.field("googleAnalyticsId", S.nullableAsOption(S.string)),
    swPublickey: s.field("swPublickey", S.nullableAsOption(S.string)),
    mascotImageUrl: s.field("mascotImageUrl", S.nullableAsOption(S.string)),
    bannerUrl: s.field("bannerUrl", S.nullableAsOption(S.string)),
    serverErrorImageUrl: s.field("serverErrorImageUrl", S.nullableAsOption(S.string)),
    infoImageUrl: s.field("infoImageUrl", S.nullableAsOption(S.string)),
    notFoundImageUrl: s.field("notFoundImageUrl", S.nullableAsOption(S.string)),
    iconUrl: s.field("iconUrl", S.nullableAsOption(S.string)),
    app192iconUrl: s.field("app192IconUrl", S.nullableAsOption(S.string)),
    app512iconUrl: s.field("app512IconUrl", S.nullableAsOption(S.string)),
    enableEmail: s.field("enableEmail", S.bool),
    enableServiceWorker: s.field("enableServiceWorker", S.bool),
    translatorAvailable: s.field("translatorAvailable", S.bool),
    silencedHosts: s.field("silencedHosts", S.option(S.array(S.string))),
    sensitiveMediaHosts: s.field("sensitiveMediaHosts", S.option(S.array(S.string))),
    pinnedUsers: s.field("pinnedUsers", S.array(S.string)),
    hiddenTags: s.field("hiddenTags", S.array(S.string)),
    blockedHosts: s.field("blockedHosts", S.array(S.string)),
    blockedRemoteCustomEmojis: s.field("blockedRemoteCustomEmojis", S.array(S.string)),
    sensitiveWords: s.field("sensitiveWords", S.array(S.string)),
    prohibitedWords: s.field("prohibitedWords", S.array(S.string)),
    bannedEmailDomains: s.field("bannedEmailDomains", S.option(S.array(S.string))),
    preservedUsernames: s.field("preservedUsernames", S.array(S.string)),
    hcaptchaSecretKey: s.field("hcaptchaSecretKey", S.nullableAsOption(S.string)),
    mcaptchaSecretKey: s.field("mcaptchaSecretKey", S.nullableAsOption(S.string)),
    recaptchaSecretKey: s.field("recaptchaSecretKey", S.nullableAsOption(S.string)),
    turnstileSecretKey: s.field("turnstileSecretKey", S.nullableAsOption(S.string)),
    sensitiveMediaDetection: s.field("sensitiveMediaDetection", S.string),
    sensitiveMediaDetectionSensitivity: s.field("sensitiveMediaDetectionSensitivity", S.string),
    setSensitiveFlagAutomatically: s.field("setSensitiveFlagAutomatically", S.bool),
    enableSensitiveMediaDetectionForVideos: s.field("enableSensitiveMediaDetectionForVideos", S.bool),
    proxyAccountId: s.field("proxyAccountId", S.string),
    email: s.field("email", S.nullableAsOption(S.string)),
    smtpSecure: s.field("smtpSecure", S.bool),
    smtpHost: s.field("smtpHost", S.nullableAsOption(S.string)),
    smtpPort: s.field("smtpPort", S.nullableAsOption(S.float)),
    smtpUser: s.field("smtpUser", S.nullableAsOption(S.string)),
    smtpPass: s.field("smtpPass", S.nullableAsOption(S.string)),
    swPrivateKey: s.field("swPrivateKey", S.nullableAsOption(S.string)),
    useObjectStorage: s.field("useObjectStorage", S.bool),
    objectStorageBaseUrl: s.field("objectStorageBaseUrl", S.nullableAsOption(S.string)),
    objectStorageBucket: s.field("objectStorageBucket", S.nullableAsOption(S.string)),
    objectStoragePrefix: s.field("objectStoragePrefix", S.nullableAsOption(S.string)),
    objectStorageEndpoint: s.field("objectStorageEndpoint", S.nullableAsOption(S.string)),
    objectStorageRegion: s.field("objectStorageRegion", S.nullableAsOption(S.string)),
    objectStoragePort: s.field("objectStoragePort", S.nullableAsOption(S.float)),
    objectStorageAccessKey: s.field("objectStorageAccessKey", S.nullableAsOption(S.string)),
    objectStorageSecretKey: s.field("objectStorageSecretKey", S.nullableAsOption(S.string)),
    objectStorageUseSsl: s.field("objectStorageUseSSL", S.bool),
    objectStorageUseProxy: s.field("objectStorageUseProxy", S.bool),
    objectStorageSetPublicRead: s.field("objectStorageSetPublicRead", S.bool),
    enableIpLogging: s.field("enableIpLogging", S.bool),
    enableActiveEmailValidation: s.field("enableActiveEmailValidation", S.bool),
    enableVerifymailApi: s.field("enableVerifymailApi", S.bool),
    verifymailAuthKey: s.field("verifymailAuthKey", S.nullableAsOption(S.string)),
    enableTruemailApi: s.field("enableTruemailApi", S.bool),
    truemailInstance: s.field("truemailInstance", S.nullableAsOption(S.string)),
    truemailAuthKey: s.field("truemailAuthKey", S.nullableAsOption(S.string)),
    enableChartsForRemoteUser: s.field("enableChartsForRemoteUser", S.bool),
    enableChartsForFederatedInstances: s.field("enableChartsForFederatedInstances", S.bool),
    enableServerMachineStats: s.field("enableServerMachineStats", S.bool),
    enableIdenticonGeneration: s.field("enableIdenticonGeneration", S.bool),
    manifestJsonOverride: s.field("manifestJsonOverride", S.string),
    policies: s.field("policies", S.dict(S.json)),
    enableFanoutTimeline: s.field("enableFanoutTimeline", S.bool),
    enableFanoutTimelineDbFallback: s.field("enableFanoutTimelineDbFallback", S.bool),
    perLocalUserUserTimelineCacheMax: s.field("perLocalUserUserTimelineCacheMax", S.float),
    perRemoteUserUserTimelineCacheMax: s.field("perRemoteUserUserTimelineCacheMax", S.float),
    perUserHomeTimelineCacheMax: s.field("perUserHomeTimelineCacheMax", S.float),
    perUserListTimelineCacheMax: s.field("perUserListTimelineCacheMax", S.float),
    notesPerOneAd: s.field("notesPerOneAd", S.float),
    wellKnownWebsites: s.field("wellKnownWebsites", S.array(S.string)),
    urlPreviewDenyList: s.field("urlPreviewDenyList", S.array(S.string)),
    featuredGameChannels: s.field("featuredGameChannels", S.array(S.string)),
    backgroundImageUrl: s.field("backgroundImageUrl", S.nullableAsOption(S.string)),
    deeplAuthKey: s.field("deeplAuthKey", S.nullableAsOption(S.string)),
    deeplIsPro: s.field("deeplIsPro", S.bool),
    defaultDarkTheme: s.field("defaultDarkTheme", S.nullableAsOption(S.string)),
    defaultLightTheme: s.field("defaultLightTheme", S.nullableAsOption(S.string)),
    description: s.field("description", S.nullableAsOption(S.string)),
    dimensions: s.field("dimensions", S.float->S.min(1)),
    disableRegistration: s.field("disableRegistration", S.bool),
    impressumUrl: s.field("impressumUrl", S.nullableAsOption(S.string)),
    maintainerEmail: s.field("maintainerEmail", S.nullableAsOption(S.string)),
    maintainerName: s.field("maintainerName", S.nullableAsOption(S.string)),
    name: s.field("name", S.nullableAsOption(S.string)),
    shortName: s.field("shortName", S.nullableAsOption(S.string)),
    objectStorageS3forcePathStyle: s.field("objectStorageS3ForcePathStyle", S.bool),
    privacyPolicyUrl: s.field("privacyPolicyUrl", S.nullableAsOption(S.string)),
    repositoryUrl: s.field("repositoryUrl", S.nullableAsOption(S.string)),
    summalyProxy: s.field("summalyProxy", S.nullableAsOption(S.string)),
    themeColor: s.field("themeColor", S.nullableAsOption(S.string)),
    tosUrl: s.field("tosUrl", S.nullableAsOption(S.string)),
    uri: s.field("uri", S.string),
    version: s.field("version", S.string),
    urlPreviewEnabled: s.field("urlPreviewEnabled", S.bool),
    urlPreviewTimeout: s.field("urlPreviewTimeout", S.float),
    urlPreviewMaximumContentLength: s.field("urlPreviewMaximumContentLength", S.float),
    urlPreviewRequireContentLength: s.field("urlPreviewRequireContentLength", S.bool),
    urlPreviewUserAgent: s.field("urlPreviewUserAgent", S.nullableAsOption(S.string)),
    urlPreviewSummaryProxyUrl: s.field("urlPreviewSummaryProxyUrl", S.nullableAsOption(S.string)),
    federation: s.field("federation", S.string),
    federationHosts: s.field("federationHosts", S.array(S.string)),
    prohibitedWordsForNameOfUser: s.field("prohibitedWordsForNameOfUser", S.array(S.string)),
    inquiryUrl: s.field("inquiryUrl", S.nullableAsOption(S.string)),
  })

/**
 * admin/meta
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:meta*
 */
let postAdminMeta = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminMetaResponse> => {

  fetch(
    ~url="/admin/meta",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminMetaResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAnnouncementRequest = {
  announcementId: string,
}

let postAnnouncementRequestSchema = S.object(s => {
    announcementId: s.field("announcementId", S.string),
  })

type postAnnouncementResponse = MisskeyIoComponentSchemas.Announcement.t

let postAnnouncementResponseSchema = MisskeyIoComponentSchemas.Announcement.schema

/**
 * announcement
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAnnouncement = (~body: postAnnouncementRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementRequestSchema)
  fetch(
    ~url="/announcement",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAnnouncementResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAnnouncementsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  offset: option<int>,
  isActive: option<bool>,
}

let postAnnouncementsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    offset: s.field("offset", S.option(S.int)),
    isActive: s.field("isActive", S.option(S.bool)),
  })

type postAnnouncementsResponse = array<MisskeyIoComponentSchemas.Announcement.t>

let postAnnouncementsResponseSchema = S.array(MisskeyIoComponentSchemas.Announcement.schema)

/**
 * announcements
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAnnouncements = (~body: postAnnouncementsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementsRequestSchema)
  fetch(
    ~url="/announcements",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAnnouncementsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAnnouncementsShowRequest = {
  announcementId: string,
}

let postAnnouncementsShowRequestSchema = S.object(s => {
    announcementId: s.field("announcementId", S.string),
  })

type postAnnouncementsShowResponse = MisskeyIoComponentSchemas.Announcement.t

let postAnnouncementsShowResponseSchema = MisskeyIoComponentSchemas.Announcement.schema

/**
 * announcements/show
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAnnouncementsShow = (~body: postAnnouncementsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementsShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementsShowRequestSchema)
  fetch(
    ~url="/announcements/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAnnouncementsShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type getEmojiRequest = {
  name: string,
}

let getEmojiRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type getEmojiResponse = MisskeyIoComponentSchemas.EmojiDetailed.t

let getEmojiResponseSchema = MisskeyIoComponentSchemas.EmojiDetailed.schema

/**
 * emoji
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getEmoji = (~body: getEmojiRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getEmojiResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getEmojiRequestSchema)
  fetch(
    ~url="/emoji",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getEmojiResponseSchema)
  value
    ->Promise.resolve
  })
}

type postEmojiRequest = {
  name: string,
}

let postEmojiRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type postEmojiResponse = MisskeyIoComponentSchemas.EmojiDetailed.t

let postEmojiResponseSchema = MisskeyIoComponentSchemas.EmojiDetailed.schema

/**
 * emoji
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEmoji = (~body: postEmojiRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEmojiResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postEmojiRequestSchema)
  fetch(
    ~url="/emoji",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postEmojiResponseSchema)
  value
    ->Promise.resolve
  })
}

type getEmojisResponse = {
  emojis: array<MisskeyIoComponentSchemas.EmojiSimple.t>,
}

let getEmojisResponseSchema = S.object(s => {
    emojis: s.field("emojis", S.array(MisskeyIoComponentSchemas.EmojiSimple.schema)),
  })

/**
 * emojis
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getEmojis = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getEmojisResponse> => {

  fetch(
    ~url="/emojis",
    ~method_="GET",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getEmojisResponseSchema)
  value
    ->Promise.resolve
  })
}

type postEmojisResponse = {
  emojis: array<MisskeyIoComponentSchemas.EmojiSimple.t>,
}

let postEmojisResponseSchema = S.object(s => {
    emojis: s.field("emojis", S.array(MisskeyIoComponentSchemas.EmojiSimple.schema)),
  })

/**
 * emojis
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEmojis = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEmojisResponse> => {

  fetch(
    ~url="/emojis",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postEmojisResponseSchema)
  value
    ->Promise.resolve
  })
}

type postEndpointRequest = {
  endpoint: string,
}

let postEndpointRequestSchema = S.object(s => {
    endpoint: s.field("endpoint", S.string),
  })

type postEndpointResponse_2 = {
  name: string,
  @as("type") type_: string,
}

type postEndpointResponse_1 = {
  params: array<postEndpointResponse_2>,
}

type postEndpointResponse = option<postEndpointResponse_1>

let postEndpointResponse_2Schema = S.object(s => {
    name: s.field("name", S.string),
    type_: s.field("type", S.string),
  })

let postEndpointResponse_1Schema = S.object(s => {
    params: s.field("params", S.array(postEndpointResponse_2Schema)),
  })

let postEndpointResponseSchema = S.nullableAsOption(postEndpointResponse_1Schema)

/**
 * endpoint
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEndpoint = (~body: postEndpointRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEndpointResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postEndpointRequestSchema)
  fetch(
    ~url="/endpoint",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postEndpointResponseSchema)
  value
    ->Promise.resolve
  })
}

type postEndpointsResponse = array<string>

let postEndpointsResponseSchema = S.array(S.string)

/**
 * endpoints
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEndpoints = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEndpointsResponse> => {

  fetch(
    ~url="/endpoints",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postEndpointsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFetchExternalResourcesRequest = {
  url: string,
  hash: string,
}

let postFetchExternalResourcesRequestSchema = S.object(s => {
    url: s.field("url", S.string),
    hash: s.field("hash", S.string),
  })

type postFetchExternalResourcesResponse = {
  @as("type") type_: string,
  data: string,
}

let postFetchExternalResourcesResponseSchema = S.object(s => {
    type_: s.field("type", S.string),
    data: s.field("data", S.string),
  })

/**
 * fetch-external-resources
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postFetchExternalResources = (~body: postFetchExternalResourcesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFetchExternalResourcesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFetchExternalResourcesRequestSchema)
  fetch(
    ~url="/fetch-external-resources",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFetchExternalResourcesResponseSchema)
  value
    ->Promise.resolve
  })
}

type getFetchRssRequest = {
  url: string,
}

let getFetchRssRequestSchema = S.object(s => {
    url: s.field("url", S.string),
  })

type getFetchRssResponse_6 = {
  name: option<string>,
  email: option<string>,
}

type getFetchRssResponse_5 = {
  url: string,
  length: option<float>,
  @as("type") type_: option<string>,
}

type getFetchRssResponse_4 = {
  image: option<string>,
  owner: option<getFetchRssResponse_6>,
  author: option<string>,
  summary: option<string>,
  explicit: option<string>,
  categories: option<array<string>>,
  keywords: option<array<string>>,
}

type getFetchRssResponse_3 = {
  link: option<string>,
  guid: option<string>,
  title: option<string>,
  pubDate: option<string>,
  creator: option<string>,
  summary: option<string>,
  content: option<string>,
  isoDate: option<string>,
  categories: option<array<string>>,
  contentSnippet: option<string>,
  enclosure: option<getFetchRssResponse_5>,
}

type getFetchRssResponse_2 = {
  self: option<string>,
  first: option<string>,
  next: option<string>,
  last: option<string>,
  prev: option<string>,
}

type getFetchRssResponse_1 = {
  link: option<string>,
  url: string,
  title: option<string>,
}

type getFetchRssResponse = {
  image: option<getFetchRssResponse_1>,
  paginationLinks: option<getFetchRssResponse_2>,
  link: option<string>,
  title: option<string>,
  items: array<getFetchRssResponse_3>,
  feedUrl: option<string>,
  description: option<string>,
  itunes: option<getFetchRssResponse_4>,
}

let getFetchRssResponse_6Schema = S.object(s => {
    name: s.field("name", S.option(S.string)),
    email: s.field("email", S.option(S.string)),
  })

let getFetchRssResponse_5Schema = S.object(s => {
    url: s.field("url", S.string),
    length: s.field("length", S.option(S.float)),
    type_: s.field("type", S.option(S.string)),
  })

let getFetchRssResponse_4Schema = S.object(s => {
    image: s.field("image", S.option(S.string)),
    owner: s.field("owner", S.option(getFetchRssResponse_6Schema)),
    author: s.field("author", S.option(S.string)),
    summary: s.field("summary", S.option(S.string)),
    explicit: s.field("explicit", S.option(S.string)),
    categories: s.field("categories", S.option(S.array(S.string))),
    keywords: s.field("keywords", S.option(S.array(S.string))),
  })

let getFetchRssResponse_3Schema = S.object(s => {
    link: s.field("link", S.option(S.string)),
    guid: s.field("guid", S.option(S.string)),
    title: s.field("title", S.option(S.string)),
    pubDate: s.field("pubDate", S.option(S.string)),
    creator: s.field("creator", S.option(S.string)),
    summary: s.field("summary", S.option(S.string)),
    content: s.field("content", S.option(S.string)),
    isoDate: s.field("isoDate", S.option(S.string)),
    categories: s.field("categories", S.option(S.array(S.string))),
    contentSnippet: s.field("contentSnippet", S.option(S.string)),
    enclosure: s.field("enclosure", S.option(getFetchRssResponse_5Schema)),
  })

let getFetchRssResponse_2Schema = S.object(s => {
    self: s.field("self", S.option(S.string)),
    first: s.field("first", S.option(S.string)),
    next: s.field("next", S.option(S.string)),
    last: s.field("last", S.option(S.string)),
    prev: s.field("prev", S.option(S.string)),
  })

let getFetchRssResponse_1Schema = S.object(s => {
    link: s.field("link", S.option(S.string)),
    url: s.field("url", S.string),
    title: s.field("title", S.option(S.string)),
  })

let getFetchRssResponseSchema = S.object(s => {
    image: s.field("image", S.option(getFetchRssResponse_1Schema)),
    paginationLinks: s.field("paginationLinks", S.option(getFetchRssResponse_2Schema)),
    link: s.field("link", S.option(S.string)),
    title: s.field("title", S.option(S.string)),
    items: s.field("items", S.array(getFetchRssResponse_3Schema)),
    feedUrl: s.field("feedUrl", S.option(S.string)),
    description: s.field("description", S.option(S.string)),
    itunes: s.field("itunes", S.option(getFetchRssResponse_4Schema)),
  })

/**
 * fetch-rss
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getFetchRss = (~body: getFetchRssRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getFetchRssResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getFetchRssRequestSchema)
  fetch(
    ~url="/fetch-rss",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getFetchRssResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFetchRssRequest = {
  url: string,
}

let postFetchRssRequestSchema = S.object(s => {
    url: s.field("url", S.string),
  })

type postFetchRssResponse_6 = {
  name: option<string>,
  email: option<string>,
}

type postFetchRssResponse_5 = {
  url: string,
  length: option<float>,
  @as("type") type_: option<string>,
}

type postFetchRssResponse_4 = {
  image: option<string>,
  owner: option<postFetchRssResponse_6>,
  author: option<string>,
  summary: option<string>,
  explicit: option<string>,
  categories: option<array<string>>,
  keywords: option<array<string>>,
}

type postFetchRssResponse_3 = {
  link: option<string>,
  guid: option<string>,
  title: option<string>,
  pubDate: option<string>,
  creator: option<string>,
  summary: option<string>,
  content: option<string>,
  isoDate: option<string>,
  categories: option<array<string>>,
  contentSnippet: option<string>,
  enclosure: option<postFetchRssResponse_5>,
}

type postFetchRssResponse_2 = {
  self: option<string>,
  first: option<string>,
  next: option<string>,
  last: option<string>,
  prev: option<string>,
}

type postFetchRssResponse_1 = {
  link: option<string>,
  url: string,
  title: option<string>,
}

type postFetchRssResponse = {
  image: option<postFetchRssResponse_1>,
  paginationLinks: option<postFetchRssResponse_2>,
  link: option<string>,
  title: option<string>,
  items: array<postFetchRssResponse_3>,
  feedUrl: option<string>,
  description: option<string>,
  itunes: option<postFetchRssResponse_4>,
}

let postFetchRssResponse_6Schema = S.object(s => {
    name: s.field("name", S.option(S.string)),
    email: s.field("email", S.option(S.string)),
  })

let postFetchRssResponse_5Schema = S.object(s => {
    url: s.field("url", S.string),
    length: s.field("length", S.option(S.float)),
    type_: s.field("type", S.option(S.string)),
  })

let postFetchRssResponse_4Schema = S.object(s => {
    image: s.field("image", S.option(S.string)),
    owner: s.field("owner", S.option(postFetchRssResponse_6Schema)),
    author: s.field("author", S.option(S.string)),
    summary: s.field("summary", S.option(S.string)),
    explicit: s.field("explicit", S.option(S.string)),
    categories: s.field("categories", S.option(S.array(S.string))),
    keywords: s.field("keywords", S.option(S.array(S.string))),
  })

let postFetchRssResponse_3Schema = S.object(s => {
    link: s.field("link", S.option(S.string)),
    guid: s.field("guid", S.option(S.string)),
    title: s.field("title", S.option(S.string)),
    pubDate: s.field("pubDate", S.option(S.string)),
    creator: s.field("creator", S.option(S.string)),
    summary: s.field("summary", S.option(S.string)),
    content: s.field("content", S.option(S.string)),
    isoDate: s.field("isoDate", S.option(S.string)),
    categories: s.field("categories", S.option(S.array(S.string))),
    contentSnippet: s.field("contentSnippet", S.option(S.string)),
    enclosure: s.field("enclosure", S.option(postFetchRssResponse_5Schema)),
  })

let postFetchRssResponse_2Schema = S.object(s => {
    self: s.field("self", S.option(S.string)),
    first: s.field("first", S.option(S.string)),
    next: s.field("next", S.option(S.string)),
    last: s.field("last", S.option(S.string)),
    prev: s.field("prev", S.option(S.string)),
  })

let postFetchRssResponse_1Schema = S.object(s => {
    link: s.field("link", S.option(S.string)),
    url: s.field("url", S.string),
    title: s.field("title", S.option(S.string)),
  })

let postFetchRssResponseSchema = S.object(s => {
    image: s.field("image", S.option(postFetchRssResponse_1Schema)),
    paginationLinks: s.field("paginationLinks", S.option(postFetchRssResponse_2Schema)),
    link: s.field("link", S.option(S.string)),
    title: s.field("title", S.option(S.string)),
    items: s.field("items", S.array(postFetchRssResponse_3Schema)),
    feedUrl: s.field("feedUrl", S.option(S.string)),
    description: s.field("description", S.option(S.string)),
    itunes: s.field("itunes", S.option(postFetchRssResponse_4Schema)),
  })

/**
 * fetch-rss
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFetchRss = (~body: postFetchRssRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFetchRssResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFetchRssRequestSchema)
  fetch(
    ~url="/fetch-rss",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFetchRssResponseSchema)
  value
    ->Promise.resolve
  })
}

type getGetOnlineUsersCountResponse = {
  count: float,
}

let getGetOnlineUsersCountResponseSchema = S.object(s => {
    count: s.field("count", S.float),
  })

/**
 * get-online-users-count
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getGetOnlineUsersCount = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getGetOnlineUsersCountResponse> => {

  fetch(
    ~url="/get-online-users-count",
    ~method_="GET",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getGetOnlineUsersCountResponseSchema)
  value
    ->Promise.resolve
  })
}

type postGetOnlineUsersCountResponse = {
  count: float,
}

let postGetOnlineUsersCountResponseSchema = S.object(s => {
    count: s.field("count", S.float),
  })

/**
 * get-online-users-count
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postGetOnlineUsersCount = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGetOnlineUsersCountResponse> => {

  fetch(
    ~url="/get-online-users-count",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postGetOnlineUsersCountResponseSchema)
  value
    ->Promise.resolve
  })
}

type postInviteCreateResponse = MisskeyIoComponentSchemas.InviteCode.t

let postInviteCreateResponseSchema = MisskeyIoComponentSchemas.InviteCode.schema

/**
 * invite/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:invite-codes*
 */
let postInviteCreate = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteCreateResponse> => {

  fetch(
    ~url="/invite/create",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postInviteCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postInviteDeleteRequest = {
  inviteId: string,
}

let postInviteDeleteRequestSchema = S.object(s => {
    inviteId: s.field("inviteId", S.string),
  })

type postInviteDeleteResponse = unit

/**
 * invite/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:invite-codes*
 */
let postInviteDelete = (~body: postInviteDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postInviteDeleteRequestSchema)
  fetch(
    ~url="/invite/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postInviteLimitResponse = {
  remaining: option<int>,
}

let postInviteLimitResponseSchema = S.object(s => {
    remaining: s.field("remaining", S.nullableAsOption(S.int)),
  })

/**
 * invite/limit
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:invite-codes*
 */
let postInviteLimit = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteLimitResponse> => {

  fetch(
    ~url="/invite/limit",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postInviteLimitResponseSchema)
  value
    ->Promise.resolve
  })
}

type postInviteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postInviteListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postInviteListResponse = array<MisskeyIoComponentSchemas.InviteCode.t>

let postInviteListResponseSchema = S.array(MisskeyIoComponentSchemas.InviteCode.schema)

/**
 * invite/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:invite-codes*
 */
let postInviteList = (~body: postInviteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postInviteListRequestSchema)
  fetch(
    ~url="/invite/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postInviteListResponseSchema)
  value
    ->Promise.resolve
  })
}

type getMetaRequest = {
  detail: option<bool>,
}

let getMetaRequestSchema = S.object(s => {
    detail: s.field("detail", S.option(S.bool)),
  })

type getMetaResponse = dict<JSON.t>

let getMetaResponseSchema = S.dict(S.json)

/**
 * meta
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getMeta = (~body: getMetaRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getMetaResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getMetaRequestSchema)
  fetch(
    ~url="/meta",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getMetaResponseSchema)
  value
    ->Promise.resolve
  })
}

type postMetaRequest = {
  detail: option<bool>,
}

let postMetaRequestSchema = S.object(s => {
    detail: s.field("detail", S.option(S.bool)),
  })

type postMetaResponse = dict<JSON.t>

let postMetaResponseSchema = S.dict(S.json)

/**
 * meta
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postMeta = (~body: postMetaRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMetaResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMetaRequestSchema)
  fetch(
    ~url="/meta",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postMetaResponseSchema)
  value
    ->Promise.resolve
  })
}

type postPingResponse = {
  pong: float,
}

let postPingResponseSchema = S.object(s => {
    pong: s.field("pong", S.float),
  })

/**
 * ping
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postPing = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPingResponse> => {

  fetch(
    ~url="/ping",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postPingResponseSchema)
  value
    ->Promise.resolve
  })
}

type getStatsResponse = {
  notesCount: float,
  originalNotesCount: float,
  usersCount: float,
  originalUsersCount: float,
  instances: float,
  driveUsageLocal: float,
  driveUsageRemote: float,
}

let getStatsResponseSchema = S.object(s => {
    notesCount: s.field("notesCount", S.float),
    originalNotesCount: s.field("originalNotesCount", S.float),
    usersCount: s.field("usersCount", S.float),
    originalUsersCount: s.field("originalUsersCount", S.float),
    instances: s.field("instances", S.float),
    driveUsageLocal: s.field("driveUsageLocal", S.float),
    driveUsageRemote: s.field("driveUsageRemote", S.float),
  })

/**
 * stats
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getStats = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getStatsResponse> => {

  fetch(
    ~url="/stats",
    ~method_="GET",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getStatsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postStatsResponse = {
  notesCount: float,
  originalNotesCount: float,
  usersCount: float,
  originalUsersCount: float,
  instances: float,
  driveUsageLocal: float,
  driveUsageRemote: float,
}

let postStatsResponseSchema = S.object(s => {
    notesCount: s.field("notesCount", S.float),
    originalNotesCount: s.field("originalNotesCount", S.float),
    usersCount: s.field("usersCount", S.float),
    originalUsersCount: s.field("originalUsersCount", S.float),
    instances: s.field("instances", S.float),
    driveUsageLocal: s.field("driveUsageLocal", S.float),
    driveUsageRemote: s.field("driveUsageRemote", S.float),
  })

/**
 * stats
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postStats = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postStatsResponse> => {

  fetch(
    ~url="/stats",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postStatsResponseSchema)
  value
    ->Promise.resolve
  })
}
