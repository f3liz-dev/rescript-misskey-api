// SPDX-License-Identifier: MIT
// misskey-io API for meta
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type postAdminMetaResponse = {
  cacheRemoteFiles: bool,
  cacheRemoteSensitiveFiles: bool,
  emailRequiredForSignup: bool,
  enableHcaptcha: bool,
  hcaptchaSiteKey: JSON.t,
  enableMcaptcha: bool,
  mcaptchaSiteKey: JSON.t,
  mcaptchaInstanceUrl: JSON.t,
  enableRecaptcha: bool,
  recaptchaSiteKey: JSON.t,
  enableTurnstile: bool,
  turnstileSiteKey: JSON.t,
  googleAnalyticsId: JSON.t,
  swPublickey: JSON.t,
  mascotImageUrl: JSON.t,
  bannerUrl: JSON.t,
  serverErrorImageUrl: JSON.t,
  infoImageUrl: JSON.t,
  notFoundImageUrl: JSON.t,
  iconUrl: JSON.t,
  app192IconUrl: JSON.t,
  app512IconUrl: JSON.t,
  enableEmail: bool,
  enableServiceWorker: bool,
  translatorAvailable: bool,
  silencedHosts: option<array<string>>,
  sensitiveMediaHosts: option<array<string>>,
  pinnedUsers: array<string>,
  hiddenTags: array<string>,
  blockedHosts: array<string>,
  blockedRemoteCustomEmojis: array<string>,
  sensitiveWords: array<string>,
  prohibitedWords: array<string>,
  bannedEmailDomains: option<array<string>>,
  preservedUsernames: array<string>,
  hcaptchaSecretKey: JSON.t,
  mcaptchaSecretKey: JSON.t,
  recaptchaSecretKey: JSON.t,
  turnstileSecretKey: JSON.t,
  sensitiveMediaDetection: string,
  sensitiveMediaDetectionSensitivity: string,
  setSensitiveFlagAutomatically: bool,
  enableSensitiveMediaDetectionForVideos: bool,
  proxyAccountId: string,
  email: JSON.t,
  smtpSecure: bool,
  smtpHost: JSON.t,
  smtpPort: JSON.t,
  smtpUser: JSON.t,
  smtpPass: JSON.t,
  swPrivateKey: JSON.t,
  useObjectStorage: bool,
  objectStorageBaseUrl: JSON.t,
  objectStorageBucket: JSON.t,
  objectStoragePrefix: JSON.t,
  objectStorageEndpoint: JSON.t,
  objectStorageRegion: JSON.t,
  objectStoragePort: JSON.t,
  objectStorageAccessKey: JSON.t,
  objectStorageSecretKey: JSON.t,
  objectStorageUseSSL: bool,
  objectStorageUseProxy: bool,
  objectStorageSetPublicRead: bool,
  enableIpLogging: bool,
  enableActiveEmailValidation: bool,
  enableVerifymailApi: bool,
  verifymailAuthKey: JSON.t,
  enableTruemailApi: bool,
  truemailInstance: JSON.t,
  truemailAuthKey: JSON.t,
  enableChartsForRemoteUser: bool,
  enableChartsForFederatedInstances: bool,
  enableServerMachineStats: bool,
  enableIdenticonGeneration: bool,
  manifestJsonOverride: string,
  policies: JSON.t,
  enableFanoutTimeline: bool,
  enableFanoutTimelineDbFallback: bool,
  perLocalUserUserTimelineCacheMax: float,
  perRemoteUserUserTimelineCacheMax: float,
  perUserHomeTimelineCacheMax: float,
  perUserListTimelineCacheMax: float,
  notesPerOneAd: float,
  wellKnownWebsites: array<string>,
  urlPreviewDenyList: array<string>,
  featuredGameChannels: array<string>,
  backgroundImageUrl: JSON.t,
  deeplAuthKey: JSON.t,
  deeplIsPro: bool,
  defaultDarkTheme: JSON.t,
  defaultLightTheme: JSON.t,
  description: JSON.t,
  dimensions: float,
  disableRegistration: bool,
  impressumUrl: JSON.t,
  maintainerEmail: JSON.t,
  maintainerName: JSON.t,
  name: JSON.t,
  shortName: JSON.t,
  objectStorageS3ForcePathStyle: bool,
  privacyPolicyUrl: JSON.t,
  repositoryUrl: JSON.t,
  summalyProxy: JSON.t,
  themeColor: JSON.t,
  tosUrl: JSON.t,
  uri: string,
  version: string,
  urlPreviewEnabled: bool,
  urlPreviewTimeout: float,
  urlPreviewMaximumContentLength: float,
  urlPreviewRequireContentLength: bool,
  urlPreviewUserAgent: JSON.t,
  urlPreviewSummaryProxyUrl: JSON.t,
  federation: string,
  federationHosts: array<string>,
  prohibitedWordsForNameOfUser: array<string>,
  inquiryUrl: JSON.t,
}

let postAdminMetaResponseSchema = S.object(s => {
    cacheRemoteFiles: s.field("cacheRemoteFiles", S.bool),
    cacheRemoteSensitiveFiles: s.field("cacheRemoteSensitiveFiles", S.bool),
    emailRequiredForSignup: s.field("emailRequiredForSignup", S.bool),
    enableHcaptcha: s.field("enableHcaptcha", S.bool),
    hcaptchaSiteKey: s.field("hcaptchaSiteKey", S.json),
    enableMcaptcha: s.field("enableMcaptcha", S.bool),
    mcaptchaSiteKey: s.field("mcaptchaSiteKey", S.json),
    mcaptchaInstanceUrl: s.field("mcaptchaInstanceUrl", S.json),
    enableRecaptcha: s.field("enableRecaptcha", S.bool),
    recaptchaSiteKey: s.field("recaptchaSiteKey", S.json),
    enableTurnstile: s.field("enableTurnstile", S.bool),
    turnstileSiteKey: s.field("turnstileSiteKey", S.json),
    googleAnalyticsId: s.field("googleAnalyticsId", S.json),
    swPublickey: s.field("swPublickey", S.json),
    mascotImageUrl: s.field("mascotImageUrl", S.json),
    bannerUrl: s.field("bannerUrl", S.json),
    serverErrorImageUrl: s.field("serverErrorImageUrl", S.json),
    infoImageUrl: s.field("infoImageUrl", S.json),
    notFoundImageUrl: s.field("notFoundImageUrl", S.json),
    iconUrl: s.field("iconUrl", S.json),
    app192IconUrl: s.field("app192IconUrl", S.json),
    app512IconUrl: s.field("app512IconUrl", S.json),
    enableEmail: s.field("enableEmail", S.bool),
    enableServiceWorker: s.field("enableServiceWorker", S.bool),
    translatorAvailable: s.field("translatorAvailable", S.bool),
    silencedHosts: s.fieldOr("silencedHosts", S.nullableAsOption(S.array(S.string)), None),
    sensitiveMediaHosts: s.fieldOr("sensitiveMediaHosts", S.nullableAsOption(S.array(S.string)), None),
    pinnedUsers: s.field("pinnedUsers", S.array(S.string)),
    hiddenTags: s.field("hiddenTags", S.array(S.string)),
    blockedHosts: s.field("blockedHosts", S.array(S.string)),
    blockedRemoteCustomEmojis: s.field("blockedRemoteCustomEmojis", S.array(S.string)),
    sensitiveWords: s.field("sensitiveWords", S.array(S.string)),
    prohibitedWords: s.field("prohibitedWords", S.array(S.string)),
    bannedEmailDomains: s.fieldOr("bannedEmailDomains", S.nullableAsOption(S.array(S.string)), None),
    preservedUsernames: s.field("preservedUsernames", S.array(S.string)),
    hcaptchaSecretKey: s.field("hcaptchaSecretKey", S.json),
    mcaptchaSecretKey: s.field("mcaptchaSecretKey", S.json),
    recaptchaSecretKey: s.field("recaptchaSecretKey", S.json),
    turnstileSecretKey: s.field("turnstileSecretKey", S.json),
    sensitiveMediaDetection: s.field("sensitiveMediaDetection", S.string),
    sensitiveMediaDetectionSensitivity: s.field("sensitiveMediaDetectionSensitivity", S.string),
    setSensitiveFlagAutomatically: s.field("setSensitiveFlagAutomatically", S.bool),
    enableSensitiveMediaDetectionForVideos: s.field("enableSensitiveMediaDetectionForVideos", S.bool),
    proxyAccountId: s.field("proxyAccountId", S.string),
    email: s.field("email", S.json),
    smtpSecure: s.field("smtpSecure", S.bool),
    smtpHost: s.field("smtpHost", S.json),
    smtpPort: s.field("smtpPort", S.json),
    smtpUser: s.field("smtpUser", S.json),
    smtpPass: s.field("smtpPass", S.json),
    swPrivateKey: s.field("swPrivateKey", S.json),
    useObjectStorage: s.field("useObjectStorage", S.bool),
    objectStorageBaseUrl: s.field("objectStorageBaseUrl", S.json),
    objectStorageBucket: s.field("objectStorageBucket", S.json),
    objectStoragePrefix: s.field("objectStoragePrefix", S.json),
    objectStorageEndpoint: s.field("objectStorageEndpoint", S.json),
    objectStorageRegion: s.field("objectStorageRegion", S.json),
    objectStoragePort: s.field("objectStoragePort", S.json),
    objectStorageAccessKey: s.field("objectStorageAccessKey", S.json),
    objectStorageSecretKey: s.field("objectStorageSecretKey", S.json),
    objectStorageUseSSL: s.field("objectStorageUseSSL", S.bool),
    objectStorageUseProxy: s.field("objectStorageUseProxy", S.bool),
    objectStorageSetPublicRead: s.field("objectStorageSetPublicRead", S.bool),
    enableIpLogging: s.field("enableIpLogging", S.bool),
    enableActiveEmailValidation: s.field("enableActiveEmailValidation", S.bool),
    enableVerifymailApi: s.field("enableVerifymailApi", S.bool),
    verifymailAuthKey: s.field("verifymailAuthKey", S.json),
    enableTruemailApi: s.field("enableTruemailApi", S.bool),
    truemailInstance: s.field("truemailInstance", S.json),
    truemailAuthKey: s.field("truemailAuthKey", S.json),
    enableChartsForRemoteUser: s.field("enableChartsForRemoteUser", S.bool),
    enableChartsForFederatedInstances: s.field("enableChartsForFederatedInstances", S.bool),
    enableServerMachineStats: s.field("enableServerMachineStats", S.bool),
    enableIdenticonGeneration: s.field("enableIdenticonGeneration", S.bool),
    manifestJsonOverride: s.field("manifestJsonOverride", S.string),
    policies: s.field("policies", S.json),
    enableFanoutTimeline: s.field("enableFanoutTimeline", S.bool),
    enableFanoutTimelineDbFallback: s.field("enableFanoutTimelineDbFallback", S.bool),
    perLocalUserUserTimelineCacheMax: s.field("perLocalUserUserTimelineCacheMax", S.float),
    perRemoteUserUserTimelineCacheMax: s.field("perRemoteUserUserTimelineCacheMax", S.float),
    perUserHomeTimelineCacheMax: s.field("perUserHomeTimelineCacheMax", S.float),
    perUserListTimelineCacheMax: s.field("perUserListTimelineCacheMax", S.float),
    notesPerOneAd: s.field("notesPerOneAd", S.float),
    wellKnownWebsites: s.field("wellKnownWebsites", S.array(S.string)),
    urlPreviewDenyList: s.field("urlPreviewDenyList", S.array(S.string)),
    featuredGameChannels: s.field("featuredGameChannels", S.array(S.string)),
    backgroundImageUrl: s.field("backgroundImageUrl", S.json),
    deeplAuthKey: s.field("deeplAuthKey", S.json),
    deeplIsPro: s.field("deeplIsPro", S.bool),
    defaultDarkTheme: s.field("defaultDarkTheme", S.json),
    defaultLightTheme: s.field("defaultLightTheme", S.json),
    description: s.field("description", S.json),
    dimensions: s.field("dimensions", S.float->S.min(1)),
    disableRegistration: s.field("disableRegistration", S.bool),
    impressumUrl: s.field("impressumUrl", S.json),
    maintainerEmail: s.field("maintainerEmail", S.json),
    maintainerName: s.field("maintainerName", S.json),
    name: s.field("name", S.json),
    shortName: s.field("shortName", S.json),
    objectStorageS3ForcePathStyle: s.field("objectStorageS3ForcePathStyle", S.bool),
    privacyPolicyUrl: s.field("privacyPolicyUrl", S.json),
    repositoryUrl: s.field("repositoryUrl", S.json),
    summalyProxy: s.field("summalyProxy", S.json),
    themeColor: s.field("themeColor", S.json),
    tosUrl: s.field("tosUrl", S.json),
    uri: s.field("uri", S.string),
    version: s.field("version", S.string),
    urlPreviewEnabled: s.field("urlPreviewEnabled", S.bool),
    urlPreviewTimeout: s.field("urlPreviewTimeout", S.float),
    urlPreviewMaximumContentLength: s.field("urlPreviewMaximumContentLength", S.float),
    urlPreviewRequireContentLength: s.field("urlPreviewRequireContentLength", S.bool),
    urlPreviewUserAgent: s.field("urlPreviewUserAgent", S.json),
    urlPreviewSummaryProxyUrl: s.field("urlPreviewSummaryProxyUrl", S.json),
    federation: s.field("federation", S.string),
    federationHosts: s.field("federationHosts", S.array(S.string)),
    prohibitedWordsForNameOfUser: s.field("prohibitedWordsForNameOfUser", S.array(S.string)),
    inquiryUrl: s.field("inquiryUrl", S.json),
  })

/**
 * admin/meta
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:meta*
 */
let postAdminMeta = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminMetaResponse> => {
  
  fetch(
    ~url="/admin/meta",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postAdminMetaResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postAnnouncementRequest = {
  announcementId: string,
}

let postAnnouncementRequestSchema = S.object(s => {
    announcementId: s.field("announcementId", S.string),
  })

type postAnnouncementResponse = MisskeyIoComponentSchemas.Announcement.t

let postAnnouncementResponseSchema = MisskeyIoComponentSchemas.Announcement.schema

/**
 * announcement
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAnnouncement = (~body: postAnnouncementRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementRequestSchema)
  
  fetch(
    ~url="/announcement",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postAnnouncementResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postAnnouncementsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  offset: option<int>,
  isActive: option<bool>,
}

let postAnnouncementsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    isActive: s.fieldOr("isActive", S.nullableAsOption(S.bool), None),
  })

type postAnnouncementsResponse = array<MisskeyIoComponentSchemas.Announcement.t>

let postAnnouncementsResponseSchema = S.array(MisskeyIoComponentSchemas.Announcement.schema)

/**
 * announcements
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAnnouncements = (~body: postAnnouncementsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementsRequestSchema)
  
  fetch(
    ~url="/announcements",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postAnnouncementsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postAnnouncementsShowRequest = {
  announcementId: string,
}

let postAnnouncementsShowRequestSchema = S.object(s => {
    announcementId: s.field("announcementId", S.string),
  })

type postAnnouncementsShowResponse = MisskeyIoComponentSchemas.Announcement.t

let postAnnouncementsShowResponseSchema = MisskeyIoComponentSchemas.Announcement.schema

/**
 * announcements/show
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAnnouncementsShow = (~body: postAnnouncementsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAnnouncementsShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAnnouncementsShowRequestSchema)
  
  fetch(
    ~url="/announcements/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postAnnouncementsShowResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getEmojiRequest = {
  name: string,
}

let getEmojiRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type getEmojiResponse = MisskeyIoComponentSchemas.EmojiDetailed.t

let getEmojiResponseSchema = MisskeyIoComponentSchemas.EmojiDetailed.schema

/**
 * emoji
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getEmoji = (~body: getEmojiRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getEmojiResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getEmojiRequestSchema)
  
  fetch(
    ~url="/emoji",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getEmojiResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postEmojiRequest = {
  name: string,
}

let postEmojiRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type postEmojiResponse = MisskeyIoComponentSchemas.EmojiDetailed.t

let postEmojiResponseSchema = MisskeyIoComponentSchemas.EmojiDetailed.schema

/**
 * emoji
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEmoji = (~body: postEmojiRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEmojiResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postEmojiRequestSchema)
  
  fetch(
    ~url="/emoji",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postEmojiResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getEmojisResponse = {
  emojis: array<MisskeyIoComponentSchemas.EmojiSimple.t>,
}

let getEmojisResponseSchema = S.object(s => {
    emojis: s.field("emojis", S.array(MisskeyIoComponentSchemas.EmojiSimple.schema)),
  })

/**
 * emojis
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getEmojis = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getEmojisResponse> => {
  
  fetch(
    ~url="/emojis",
    ~method_="GET",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getEmojisResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postEmojisResponse = {
  emojis: array<MisskeyIoComponentSchemas.EmojiSimple.t>,
}

let postEmojisResponseSchema = S.object(s => {
    emojis: s.field("emojis", S.array(MisskeyIoComponentSchemas.EmojiSimple.schema)),
  })

/**
 * emojis
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEmojis = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEmojisResponse> => {
  
  fetch(
    ~url="/emojis",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postEmojisResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postEndpointRequest = {
  endpoint: string,
}

let postEndpointRequestSchema = S.object(s => {
    endpoint: s.field("endpoint", S.string),
  })

type postEndpointResponse = JSON.t

let postEndpointResponseSchema = S.json

/**
 * endpoint
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEndpoint = (~body: postEndpointRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEndpointResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postEndpointRequestSchema)
  
  fetch(
    ~url="/endpoint",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postEndpointResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postEndpointsResponse = array<string>

let postEndpointsResponseSchema = S.array(S.string)

/**
 * endpoints
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEndpoints = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEndpointsResponse> => {
  
  fetch(
    ~url="/endpoints",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postEndpointsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFetchExternalResourcesRequest = {
  url: string,
  hash: string,
}

let postFetchExternalResourcesRequestSchema = S.object(s => {
    url: s.field("url", S.string),
    hash: s.field("hash", S.string),
  })

type postFetchExternalResourcesResponse = {
  @as("type") type_: string,
  data: string,
}

let postFetchExternalResourcesResponseSchema = S.object(s => {
    type_: s.field("type", S.string),
    data: s.field("data", S.string),
  })

/**
 * fetch-external-resources
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postFetchExternalResources = (~body: postFetchExternalResourcesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFetchExternalResourcesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFetchExternalResourcesRequestSchema)
  
  fetch(
    ~url="/fetch-external-resources",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFetchExternalResourcesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getFetchRssRequest = {
  url: string,
}

let getFetchRssRequestSchema = S.object(s => {
    url: s.field("url", S.string),
  })

type getFetchRssResponse = {
  image: option<JSON.t>,
  paginationLinks: option<JSON.t>,
  link: option<string>,
  title: option<string>,
  items: array<JSON.t>,
  feedUrl: option<string>,
  description: option<string>,
  itunes: option<JSON.t>,
}

let getFetchRssResponseSchema = S.object(s => {
    image: s.fieldOr("image", S.nullableAsOption(S.json), None),
    paginationLinks: s.fieldOr("paginationLinks", S.nullableAsOption(S.json), None),
    link: s.fieldOr("link", S.nullableAsOption(S.string), None),
    title: s.fieldOr("title", S.nullableAsOption(S.string), None),
    items: s.field("items", S.array(S.json)),
    feedUrl: s.fieldOr("feedUrl", S.nullableAsOption(S.string), None),
    description: s.fieldOr("description", S.nullableAsOption(S.string), None),
    itunes: s.fieldOr("itunes", S.nullableAsOption(S.json), None),
  })

/**
 * fetch-rss
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getFetchRss = (~body: getFetchRssRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getFetchRssResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getFetchRssRequestSchema)
  
  fetch(
    ~url="/fetch-rss",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getFetchRssResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFetchRssRequest = {
  url: string,
}

let postFetchRssRequestSchema = S.object(s => {
    url: s.field("url", S.string),
  })

type postFetchRssResponse = {
  image: option<JSON.t>,
  paginationLinks: option<JSON.t>,
  link: option<string>,
  title: option<string>,
  items: array<JSON.t>,
  feedUrl: option<string>,
  description: option<string>,
  itunes: option<JSON.t>,
}

let postFetchRssResponseSchema = S.object(s => {
    image: s.fieldOr("image", S.nullableAsOption(S.json), None),
    paginationLinks: s.fieldOr("paginationLinks", S.nullableAsOption(S.json), None),
    link: s.fieldOr("link", S.nullableAsOption(S.string), None),
    title: s.fieldOr("title", S.nullableAsOption(S.string), None),
    items: s.field("items", S.array(S.json)),
    feedUrl: s.fieldOr("feedUrl", S.nullableAsOption(S.string), None),
    description: s.fieldOr("description", S.nullableAsOption(S.string), None),
    itunes: s.fieldOr("itunes", S.nullableAsOption(S.json), None),
  })

/**
 * fetch-rss
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFetchRss = (~body: postFetchRssRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFetchRssResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFetchRssRequestSchema)
  
  fetch(
    ~url="/fetch-rss",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFetchRssResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getGetOnlineUsersCountResponse = {
  count: float,
}

let getGetOnlineUsersCountResponseSchema = S.object(s => {
    count: s.field("count", S.float),
  })

/**
 * get-online-users-count
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getGetOnlineUsersCount = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getGetOnlineUsersCountResponse> => {
  
  fetch(
    ~url="/get-online-users-count",
    ~method_="GET",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getGetOnlineUsersCountResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postGetOnlineUsersCountResponse = {
  count: float,
}

let postGetOnlineUsersCountResponseSchema = S.object(s => {
    count: s.field("count", S.float),
  })

/**
 * get-online-users-count
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postGetOnlineUsersCount = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGetOnlineUsersCountResponse> => {
  
  fetch(
    ~url="/get-online-users-count",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postGetOnlineUsersCountResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postInviteCreateResponse = MisskeyIoComponentSchemas.InviteCode.t

let postInviteCreateResponseSchema = MisskeyIoComponentSchemas.InviteCode.schema

/**
 * invite/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:invite-codes*
 */
let postInviteCreate = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteCreateResponse> => {
  
  fetch(
    ~url="/invite/create",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postInviteCreateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postInviteDeleteRequest = {
  inviteId: string,
}

let postInviteDeleteRequestSchema = S.object(s => {
    inviteId: s.field("inviteId", S.string),
  })

type postInviteDeleteResponse = unit

/**
 * invite/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:invite-codes*
 */
let postInviteDelete = (~body: postInviteDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postInviteDeleteRequestSchema)
  
  fetch(
    ~url="/invite/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postInviteLimitResponse = {
  remaining: JSON.t,
}

let postInviteLimitResponseSchema = S.object(s => {
    remaining: s.field("remaining", S.json),
  })

/**
 * invite/limit
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:invite-codes*
 */
let postInviteLimit = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteLimitResponse> => {
  
  fetch(
    ~url="/invite/limit",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postInviteLimitResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postInviteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postInviteListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postInviteListResponse = array<MisskeyIoComponentSchemas.InviteCode.t>

let postInviteListResponseSchema = S.array(MisskeyIoComponentSchemas.InviteCode.schema)

/**
 * invite/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:invite-codes*
 */
let postInviteList = (~body: postInviteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postInviteListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postInviteListRequestSchema)
  
  fetch(
    ~url="/invite/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postInviteListResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getMetaRequest = {
  detail: option<bool>,
}

let getMetaRequestSchema = S.object(s => {
    detail: s.fieldOr("detail", S.nullableAsOption(S.bool), None),
  })

type getMetaResponse = JSON.t

let getMetaResponseSchema = S.json

/**
 * meta
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getMeta = (~body: getMetaRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getMetaResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getMetaRequestSchema)
  
  fetch(
    ~url="/meta",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getMetaResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postMetaRequest = {
  detail: option<bool>,
}

let postMetaRequestSchema = S.object(s => {
    detail: s.fieldOr("detail", S.nullableAsOption(S.bool), None),
  })

type postMetaResponse = JSON.t

let postMetaResponseSchema = S.json

/**
 * meta
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postMeta = (~body: postMetaRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMetaResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMetaRequestSchema)
  
  fetch(
    ~url="/meta",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postMetaResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postPingResponse = {
  pong: float,
}

let postPingResponseSchema = S.object(s => {
    pong: s.field("pong", S.float),
  })

/**
 * ping
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postPing = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPingResponse> => {
  
  fetch(
    ~url="/ping",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postPingResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getStatsResponse = {
  notesCount: float,
  originalNotesCount: float,
  usersCount: float,
  originalUsersCount: float,
  instances: float,
  driveUsageLocal: float,
  driveUsageRemote: float,
}

let getStatsResponseSchema = S.object(s => {
    notesCount: s.field("notesCount", S.float),
    originalNotesCount: s.field("originalNotesCount", S.float),
    usersCount: s.field("usersCount", S.float),
    originalUsersCount: s.field("originalUsersCount", S.float),
    instances: s.field("instances", S.float),
    driveUsageLocal: s.field("driveUsageLocal", S.float),
    driveUsageRemote: s.field("driveUsageRemote", S.float),
  })

/**
 * stats
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getStats = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getStatsResponse> => {
  
  fetch(
    ~url="/stats",
    ~method_="GET",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getStatsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postStatsResponse = {
  notesCount: float,
  originalNotesCount: float,
  usersCount: float,
  originalUsersCount: float,
  instances: float,
  driveUsageLocal: float,
  driveUsageRemote: float,
}

let postStatsResponseSchema = S.object(s => {
    notesCount: s.field("notesCount", S.float),
    originalNotesCount: s.field("originalNotesCount", S.float),
    usersCount: s.field("usersCount", S.float),
    originalUsersCount: s.field("originalUsersCount", S.float),
    instances: s.field("instances", S.float),
    driveUsageLocal: s.field("driveUsageLocal", S.float),
    driveUsageRemote: s.field("driveUsageRemote", S.float),
  })

/**
 * stats
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postStats = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postStatsResponse> => {
  
  fetch(
    ~url="/stats",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postStatsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}
