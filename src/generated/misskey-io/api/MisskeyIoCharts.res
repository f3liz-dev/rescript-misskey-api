// SPDX-License-Identifier: MIT
// misskey-io API for charts
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type getChartsActiveUsersRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let getChartsActiveUsersRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type getChartsActiveUsersResponse = {
  readWrite: array<float>,
  read: array<float>,
  write: array<float>,
  registeredWithinWeek: array<float>,
  registeredWithinMonth: array<float>,
  registeredWithinYear: array<float>,
  registeredOutsideWeek: array<float>,
  registeredOutsideMonth: array<float>,
  registeredOutsideYear: array<float>,
}

let getChartsActiveUsersResponseSchema = S.object(s => {
    readWrite: s.field("readWrite", S.array(S.float)),
    read: s.field("read", S.array(S.float)),
    write: s.field("write", S.array(S.float)),
    registeredWithinWeek: s.field("registeredWithinWeek", S.array(S.float)),
    registeredWithinMonth: s.field("registeredWithinMonth", S.array(S.float)),
    registeredWithinYear: s.field("registeredWithinYear", S.array(S.float)),
    registeredOutsideWeek: s.field("registeredOutsideWeek", S.array(S.float)),
    registeredOutsideMonth: s.field("registeredOutsideMonth", S.array(S.float)),
    registeredOutsideYear: s.field("registeredOutsideYear", S.array(S.float)),
  })

/**
 * charts/active-users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsActiveUsers = (~body: getChartsActiveUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsActiveUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsActiveUsersRequestSchema)
  
  fetch(
    ~url="/charts/active-users",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsActiveUsersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsActiveUsersRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let postChartsActiveUsersRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type postChartsActiveUsersResponse = {
  readWrite: array<float>,
  read: array<float>,
  write: array<float>,
  registeredWithinWeek: array<float>,
  registeredWithinMonth: array<float>,
  registeredWithinYear: array<float>,
  registeredOutsideWeek: array<float>,
  registeredOutsideMonth: array<float>,
  registeredOutsideYear: array<float>,
}

let postChartsActiveUsersResponseSchema = S.object(s => {
    readWrite: s.field("readWrite", S.array(S.float)),
    read: s.field("read", S.array(S.float)),
    write: s.field("write", S.array(S.float)),
    registeredWithinWeek: s.field("registeredWithinWeek", S.array(S.float)),
    registeredWithinMonth: s.field("registeredWithinMonth", S.array(S.float)),
    registeredWithinYear: s.field("registeredWithinYear", S.array(S.float)),
    registeredOutsideWeek: s.field("registeredOutsideWeek", S.array(S.float)),
    registeredOutsideMonth: s.field("registeredOutsideMonth", S.array(S.float)),
    registeredOutsideYear: s.field("registeredOutsideYear", S.array(S.float)),
  })

/**
 * charts/active-users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsActiveUsers = (~body: postChartsActiveUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsActiveUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsActiveUsersRequestSchema)
  
  fetch(
    ~url="/charts/active-users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsActiveUsersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getChartsApRequestRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let getChartsApRequestRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type getChartsApRequestResponse = {
  deliverFailed: array<float>,
  deliverSucceeded: array<float>,
  inboxReceived: array<float>,
}

let getChartsApRequestResponseSchema = S.object(s => {
    deliverFailed: s.field("deliverFailed", S.array(S.float)),
    deliverSucceeded: s.field("deliverSucceeded", S.array(S.float)),
    inboxReceived: s.field("inboxReceived", S.array(S.float)),
  })

/**
 * charts/ap-request
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsApRequest = (~body: getChartsApRequestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsApRequestResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsApRequestRequestSchema)
  
  fetch(
    ~url="/charts/ap-request",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsApRequestResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsApRequestRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let postChartsApRequestRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type postChartsApRequestResponse = {
  deliverFailed: array<float>,
  deliverSucceeded: array<float>,
  inboxReceived: array<float>,
}

let postChartsApRequestResponseSchema = S.object(s => {
    deliverFailed: s.field("deliverFailed", S.array(S.float)),
    deliverSucceeded: s.field("deliverSucceeded", S.array(S.float)),
    inboxReceived: s.field("inboxReceived", S.array(S.float)),
  })

/**
 * charts/ap-request
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsApRequest = (~body: postChartsApRequestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsApRequestResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsApRequestRequestSchema)
  
  fetch(
    ~url="/charts/ap-request",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsApRequestResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getChartsDriveRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let getChartsDriveRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type getChartsDriveResponse = {
  local: JSON.t,
  remote: JSON.t,
}

let getChartsDriveResponseSchema = S.object(s => {
    local: s.field("local", S.json),
    remote: s.field("remote", S.json),
  })

/**
 * charts/drive
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsDrive = (~body: getChartsDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsDriveResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsDriveRequestSchema)
  
  fetch(
    ~url="/charts/drive",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsDriveResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsDriveRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let postChartsDriveRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type postChartsDriveResponse = {
  local: JSON.t,
  remote: JSON.t,
}

let postChartsDriveResponseSchema = S.object(s => {
    local: s.field("local", S.json),
    remote: s.field("remote", S.json),
  })

/**
 * charts/drive
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsDrive = (~body: postChartsDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsDriveResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsDriveRequestSchema)
  
  fetch(
    ~url="/charts/drive",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsDriveResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getChartsFederationRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let getChartsFederationRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type getChartsFederationResponse = {
  deliveredInstances: array<float>,
  inboxInstances: array<float>,
  stalled: array<float>,
  sub: array<float>,
  pub: array<float>,
  pubsub: array<float>,
  subActive: array<float>,
  pubActive: array<float>,
}

let getChartsFederationResponseSchema = S.object(s => {
    deliveredInstances: s.field("deliveredInstances", S.array(S.float)),
    inboxInstances: s.field("inboxInstances", S.array(S.float)),
    stalled: s.field("stalled", S.array(S.float)),
    sub: s.field("sub", S.array(S.float)),
    pub: s.field("pub", S.array(S.float)),
    pubsub: s.field("pubsub", S.array(S.float)),
    subActive: s.field("subActive", S.array(S.float)),
    pubActive: s.field("pubActive", S.array(S.float)),
  })

/**
 * charts/federation
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsFederation = (~body: getChartsFederationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsFederationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsFederationRequestSchema)
  
  fetch(
    ~url="/charts/federation",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsFederationResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsFederationRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let postChartsFederationRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type postChartsFederationResponse = {
  deliveredInstances: array<float>,
  inboxInstances: array<float>,
  stalled: array<float>,
  sub: array<float>,
  pub: array<float>,
  pubsub: array<float>,
  subActive: array<float>,
  pubActive: array<float>,
}

let postChartsFederationResponseSchema = S.object(s => {
    deliveredInstances: s.field("deliveredInstances", S.array(S.float)),
    inboxInstances: s.field("inboxInstances", S.array(S.float)),
    stalled: s.field("stalled", S.array(S.float)),
    sub: s.field("sub", S.array(S.float)),
    pub: s.field("pub", S.array(S.float)),
    pubsub: s.field("pubsub", S.array(S.float)),
    subActive: s.field("subActive", S.array(S.float)),
    pubActive: s.field("pubActive", S.array(S.float)),
  })

/**
 * charts/federation
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsFederation = (~body: postChartsFederationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsFederationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsFederationRequestSchema)
  
  fetch(
    ~url="/charts/federation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsFederationResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getChartsInstanceRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  host: string,
}

let getChartsInstanceRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    host: s.field("host", S.string),
  })

type getChartsInstanceResponse = {
  requests: JSON.t,
  notes: JSON.t,
  users: JSON.t,
  following: JSON.t,
  followers: JSON.t,
  drive: JSON.t,
}

let getChartsInstanceResponseSchema = S.object(s => {
    requests: s.field("requests", S.json),
    notes: s.field("notes", S.json),
    users: s.field("users", S.json),
    following: s.field("following", S.json),
    followers: s.field("followers", S.json),
    drive: s.field("drive", S.json),
  })

/**
 * charts/instance
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsInstance = (~body: getChartsInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsInstanceResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsInstanceRequestSchema)
  
  fetch(
    ~url="/charts/instance",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsInstanceResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsInstanceRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  host: string,
}

let postChartsInstanceRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    host: s.field("host", S.string),
  })

type postChartsInstanceResponse = {
  requests: JSON.t,
  notes: JSON.t,
  users: JSON.t,
  following: JSON.t,
  followers: JSON.t,
  drive: JSON.t,
}

let postChartsInstanceResponseSchema = S.object(s => {
    requests: s.field("requests", S.json),
    notes: s.field("notes", S.json),
    users: s.field("users", S.json),
    following: s.field("following", S.json),
    followers: s.field("followers", S.json),
    drive: s.field("drive", S.json),
  })

/**
 * charts/instance
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsInstance = (~body: postChartsInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsInstanceResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsInstanceRequestSchema)
  
  fetch(
    ~url="/charts/instance",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsInstanceResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getChartsNotesRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let getChartsNotesRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type getChartsNotesResponse = {
  local: JSON.t,
  remote: JSON.t,
}

let getChartsNotesResponseSchema = S.object(s => {
    local: s.field("local", S.json),
    remote: s.field("remote", S.json),
  })

/**
 * charts/notes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsNotes = (~body: getChartsNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsNotesRequestSchema)
  
  fetch(
    ~url="/charts/notes",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsNotesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsNotesRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let postChartsNotesRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type postChartsNotesResponse = {
  local: JSON.t,
  remote: JSON.t,
}

let postChartsNotesResponseSchema = S.object(s => {
    local: s.field("local", S.json),
    remote: s.field("remote", S.json),
  })

/**
 * charts/notes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsNotes = (~body: postChartsNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsNotesRequestSchema)
  
  fetch(
    ~url="/charts/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsNotesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getChartsUserDriveRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  userId: string,
}

let getChartsUserDriveRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
  })

type getChartsUserDriveResponse = {
  totalCount: array<float>,
  totalSize: array<float>,
  incCount: array<float>,
  incSize: array<float>,
  decCount: array<float>,
  decSize: array<float>,
}

let getChartsUserDriveResponseSchema = S.object(s => {
    totalCount: s.field("totalCount", S.array(S.float)),
    totalSize: s.field("totalSize", S.array(S.float)),
    incCount: s.field("incCount", S.array(S.float)),
    incSize: s.field("incSize", S.array(S.float)),
    decCount: s.field("decCount", S.array(S.float)),
    decSize: s.field("decSize", S.array(S.float)),
  })

/**
 * charts/user/drive
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsUserDrive = (~body: getChartsUserDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUserDriveResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserDriveRequestSchema)
  
  fetch(
    ~url="/charts/user/drive",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsUserDriveResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsUserDriveRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  userId: string,
}

let postChartsUserDriveRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
  })

type postChartsUserDriveResponse = {
  totalCount: array<float>,
  totalSize: array<float>,
  incCount: array<float>,
  incSize: array<float>,
  decCount: array<float>,
  decSize: array<float>,
}

let postChartsUserDriveResponseSchema = S.object(s => {
    totalCount: s.field("totalCount", S.array(S.float)),
    totalSize: s.field("totalSize", S.array(S.float)),
    incCount: s.field("incCount", S.array(S.float)),
    incSize: s.field("incSize", S.array(S.float)),
    decCount: s.field("decCount", S.array(S.float)),
    decSize: s.field("decSize", S.array(S.float)),
  })

/**
 * charts/user/drive
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsUserDrive = (~body: postChartsUserDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUserDriveResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserDriveRequestSchema)
  
  fetch(
    ~url="/charts/user/drive",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsUserDriveResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getChartsUserFollowingRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  userId: string,
}

let getChartsUserFollowingRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
  })

type getChartsUserFollowingResponse = {
  local: JSON.t,
  remote: JSON.t,
}

let getChartsUserFollowingResponseSchema = S.object(s => {
    local: s.field("local", S.json),
    remote: s.field("remote", S.json),
  })

/**
 * charts/user/following
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsUserFollowing = (~body: getChartsUserFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUserFollowingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserFollowingRequestSchema)
  
  fetch(
    ~url="/charts/user/following",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsUserFollowingResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsUserFollowingRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  userId: string,
}

let postChartsUserFollowingRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
  })

type postChartsUserFollowingResponse = {
  local: JSON.t,
  remote: JSON.t,
}

let postChartsUserFollowingResponseSchema = S.object(s => {
    local: s.field("local", S.json),
    remote: s.field("remote", S.json),
  })

/**
 * charts/user/following
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsUserFollowing = (~body: postChartsUserFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUserFollowingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserFollowingRequestSchema)
  
  fetch(
    ~url="/charts/user/following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsUserFollowingResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getChartsUserNotesRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  userId: string,
}

let getChartsUserNotesRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
  })

type getChartsUserNotesResponse = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
  diffs: JSON.t,
}

let getChartsUserNotesResponseSchema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
    diffs: s.field("diffs", S.json),
  })

/**
 * charts/user/notes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsUserNotes = (~body: getChartsUserNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUserNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserNotesRequestSchema)
  
  fetch(
    ~url="/charts/user/notes",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsUserNotesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsUserNotesRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  userId: string,
}

let postChartsUserNotesRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
  })

type postChartsUserNotesResponse = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
  diffs: JSON.t,
}

let postChartsUserNotesResponseSchema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
    diffs: s.field("diffs", S.json),
  })

/**
 * charts/user/notes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsUserNotes = (~body: postChartsUserNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUserNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserNotesRequestSchema)
  
  fetch(
    ~url="/charts/user/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsUserNotesResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getChartsUserPvRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  userId: string,
}

let getChartsUserPvRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
  })

type getChartsUserPvResponse = {
  upv: JSON.t,
  pv: JSON.t,
}

let getChartsUserPvResponseSchema = S.object(s => {
    upv: s.field("upv", S.json),
    pv: s.field("pv", S.json),
  })

/**
 * charts/user/pv
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsUserPv = (~body: getChartsUserPvRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUserPvResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserPvRequestSchema)
  
  fetch(
    ~url="/charts/user/pv",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsUserPvResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsUserPvRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  userId: string,
}

let postChartsUserPvRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
  })

type postChartsUserPvResponse = {
  upv: JSON.t,
  pv: JSON.t,
}

let postChartsUserPvResponseSchema = S.object(s => {
    upv: s.field("upv", S.json),
    pv: s.field("pv", S.json),
  })

/**
 * charts/user/pv
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsUserPv = (~body: postChartsUserPvRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUserPvResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserPvRequestSchema)
  
  fetch(
    ~url="/charts/user/pv",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsUserPvResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getChartsUserReactionsRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  userId: string,
}

let getChartsUserReactionsRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
  })

type getChartsUserReactionsResponse = {
  local: JSON.t,
  remote: JSON.t,
}

let getChartsUserReactionsResponseSchema = S.object(s => {
    local: s.field("local", S.json),
    remote: s.field("remote", S.json),
  })

/**
 * charts/user/reactions
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsUserReactions = (~body: getChartsUserReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUserReactionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserReactionsRequestSchema)
  
  fetch(
    ~url="/charts/user/reactions",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsUserReactionsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsUserReactionsRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
  userId: string,
}

let postChartsUserReactionsRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
  })

type postChartsUserReactionsResponse = {
  local: JSON.t,
  remote: JSON.t,
}

let postChartsUserReactionsResponseSchema = S.object(s => {
    local: s.field("local", S.json),
    remote: s.field("remote", S.json),
  })

/**
 * charts/user/reactions
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsUserReactions = (~body: postChartsUserReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUserReactionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserReactionsRequestSchema)
  
  fetch(
    ~url="/charts/user/reactions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsUserReactionsResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type getChartsUsersRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let getChartsUsersRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type getChartsUsersResponse = {
  local: JSON.t,
  remote: JSON.t,
}

let getChartsUsersResponseSchema = S.object(s => {
    local: s.field("local", S.json),
    remote: s.field("remote", S.json),
  })

/**
 * charts/users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getChartsUsers = (~body: getChartsUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getChartsUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUsersRequestSchema)
  
  fetch(
    ~url="/charts/users",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(getChartsUsersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postChartsUsersRequest = {
  span: string,
  limit: option<int>,
  offset: option<JSON.t>,
}

let postChartsUsersRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(500)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.json), None),
  })

type postChartsUsersResponse = {
  local: JSON.t,
  remote: JSON.t,
}

let postChartsUsersResponseSchema = S.object(s => {
    local: s.field("local", S.json),
    remote: s.field("remote", S.json),
  })

/**
 * charts/users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postChartsUsers = (~body: postChartsUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChartsUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUsersRequestSchema)
  
  fetch(
    ~url="/charts/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postChartsUsersResponseSchema)
  validatedResponse
->Promise.resolve
  })
}
