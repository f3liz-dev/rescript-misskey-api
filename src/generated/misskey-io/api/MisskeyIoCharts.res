// misskey-io API for charts
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type getChartsActiveUsersRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let getChartsActiveUsersRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type getChartsActiveUsersResponse = {
  readWrite: array<float>,
  read: array<float>,
  write: array<float>,
  registeredWithinWeek: array<float>,
  registeredWithinMonth: array<float>,
  registeredWithinYear: array<float>,
  registeredOutsideWeek: array<float>,
  registeredOutsideMonth: array<float>,
  registeredOutsideYear: array<float>,
}

let getChartsActiveUsersResponseSchema = S.object(s => {
    readWrite: s.field("readWrite", S.array(S.float)),
    read: s.field("read", S.array(S.float)),
    write: s.field("write", S.array(S.float)),
    registeredWithinWeek: s.field("registeredWithinWeek", S.array(S.float)),
    registeredWithinMonth: s.field("registeredWithinMonth", S.array(S.float)),
    registeredWithinYear: s.field("registeredWithinYear", S.array(S.float)),
    registeredOutsideWeek: s.field("registeredOutsideWeek", S.array(S.float)),
    registeredOutsideMonth: s.field("registeredOutsideMonth", S.array(S.float)),
    registeredOutsideYear: s.field("registeredOutsideYear", S.array(S.float)),
  })

/**
charts/active-users

No description provided.

**Credential required**: *No*
*/
let getChartsActiveUsers = async (~body: getChartsActiveUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsActiveUsersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsActiveUsersRequestSchema)
  let response = await fetch(
    ~url="/charts/active-users",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsActiveUsersResponseSchema)
}

type postChartsActiveUsersRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let postChartsActiveUsersRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type postChartsActiveUsersResponse = {
  readWrite: array<float>,
  read: array<float>,
  write: array<float>,
  registeredWithinWeek: array<float>,
  registeredWithinMonth: array<float>,
  registeredWithinYear: array<float>,
  registeredOutsideWeek: array<float>,
  registeredOutsideMonth: array<float>,
  registeredOutsideYear: array<float>,
}

let postChartsActiveUsersResponseSchema = S.object(s => {
    readWrite: s.field("readWrite", S.array(S.float)),
    read: s.field("read", S.array(S.float)),
    write: s.field("write", S.array(S.float)),
    registeredWithinWeek: s.field("registeredWithinWeek", S.array(S.float)),
    registeredWithinMonth: s.field("registeredWithinMonth", S.array(S.float)),
    registeredWithinYear: s.field("registeredWithinYear", S.array(S.float)),
    registeredOutsideWeek: s.field("registeredOutsideWeek", S.array(S.float)),
    registeredOutsideMonth: s.field("registeredOutsideMonth", S.array(S.float)),
    registeredOutsideYear: s.field("registeredOutsideYear", S.array(S.float)),
  })

/**
charts/active-users

No description provided.

**Credential required**: *No*
*/
let postChartsActiveUsers = async (~body: postChartsActiveUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsActiveUsersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsActiveUsersRequestSchema)
  let response = await fetch(
    ~url="/charts/active-users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsActiveUsersResponseSchema)
}

type getChartsApRequestRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let getChartsApRequestRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type getChartsApRequestResponse = {
  deliverFailed: array<float>,
  deliverSucceeded: array<float>,
  inboxReceived: array<float>,
}

let getChartsApRequestResponseSchema = S.object(s => {
    deliverFailed: s.field("deliverFailed", S.array(S.float)),
    deliverSucceeded: s.field("deliverSucceeded", S.array(S.float)),
    inboxReceived: s.field("inboxReceived", S.array(S.float)),
  })

/**
charts/ap-request

No description provided.

**Credential required**: *No*
*/
let getChartsApRequest = async (~body: getChartsApRequestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsApRequestResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsApRequestRequestSchema)
  let response = await fetch(
    ~url="/charts/ap-request",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsApRequestResponseSchema)
}

type postChartsApRequestRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let postChartsApRequestRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type postChartsApRequestResponse = {
  deliverFailed: array<float>,
  deliverSucceeded: array<float>,
  inboxReceived: array<float>,
}

let postChartsApRequestResponseSchema = S.object(s => {
    deliverFailed: s.field("deliverFailed", S.array(S.float)),
    deliverSucceeded: s.field("deliverSucceeded", S.array(S.float)),
    inboxReceived: s.field("inboxReceived", S.array(S.float)),
  })

/**
charts/ap-request

No description provided.

**Credential required**: *No*
*/
let postChartsApRequest = async (~body: postChartsApRequestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsApRequestResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsApRequestRequestSchema)
  let response = await fetch(
    ~url="/charts/ap-request",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsApRequestResponseSchema)
}

type getChartsDriveRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let getChartsDriveRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type getChartsDriveResponse_1 = {
  incCount: array<float>,
  incSize: array<float>,
  decCount: array<float>,
  decSize: array<float>,
}

type getChartsDriveResponse = {
  local: getChartsDriveResponse_1,
  remote: getChartsDriveResponse_1,
}

let getChartsDriveResponse_1Schema = S.object(s => {
    incCount: s.field("incCount", S.array(S.float)),
    incSize: s.field("incSize", S.array(S.float)),
    decCount: s.field("decCount", S.array(S.float)),
    decSize: s.field("decSize", S.array(S.float)),
  })

let getChartsDriveResponseSchema = S.object(s => {
    local: s.field("local", getChartsDriveResponse_1Schema),
    remote: s.field("remote", getChartsDriveResponse_1Schema),
  })

/**
charts/drive

No description provided.

**Credential required**: *No*
*/
let getChartsDrive = async (~body: getChartsDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsDriveResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsDriveRequestSchema)
  let response = await fetch(
    ~url="/charts/drive",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsDriveResponseSchema)
}

type postChartsDriveRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let postChartsDriveRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type postChartsDriveResponse_1 = {
  incCount: array<float>,
  incSize: array<float>,
  decCount: array<float>,
  decSize: array<float>,
}

type postChartsDriveResponse = {
  local: postChartsDriveResponse_1,
  remote: postChartsDriveResponse_1,
}

let postChartsDriveResponse_1Schema = S.object(s => {
    incCount: s.field("incCount", S.array(S.float)),
    incSize: s.field("incSize", S.array(S.float)),
    decCount: s.field("decCount", S.array(S.float)),
    decSize: s.field("decSize", S.array(S.float)),
  })

let postChartsDriveResponseSchema = S.object(s => {
    local: s.field("local", postChartsDriveResponse_1Schema),
    remote: s.field("remote", postChartsDriveResponse_1Schema),
  })

/**
charts/drive

No description provided.

**Credential required**: *No*
*/
let postChartsDrive = async (~body: postChartsDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsDriveResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsDriveRequestSchema)
  let response = await fetch(
    ~url="/charts/drive",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsDriveResponseSchema)
}

type getChartsFederationRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let getChartsFederationRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type getChartsFederationResponse = {
  deliveredInstances: array<float>,
  inboxInstances: array<float>,
  stalled: array<float>,
  sub: array<float>,
  pub: array<float>,
  pubsub: array<float>,
  subActive: array<float>,
  pubActive: array<float>,
}

let getChartsFederationResponseSchema = S.object(s => {
    deliveredInstances: s.field("deliveredInstances", S.array(S.float)),
    inboxInstances: s.field("inboxInstances", S.array(S.float)),
    stalled: s.field("stalled", S.array(S.float)),
    sub: s.field("sub", S.array(S.float)),
    pub: s.field("pub", S.array(S.float)),
    pubsub: s.field("pubsub", S.array(S.float)),
    subActive: s.field("subActive", S.array(S.float)),
    pubActive: s.field("pubActive", S.array(S.float)),
  })

/**
charts/federation

No description provided.

**Credential required**: *No*
*/
let getChartsFederation = async (~body: getChartsFederationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsFederationResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsFederationRequestSchema)
  let response = await fetch(
    ~url="/charts/federation",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsFederationResponseSchema)
}

type postChartsFederationRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let postChartsFederationRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type postChartsFederationResponse = {
  deliveredInstances: array<float>,
  inboxInstances: array<float>,
  stalled: array<float>,
  sub: array<float>,
  pub: array<float>,
  pubsub: array<float>,
  subActive: array<float>,
  pubActive: array<float>,
}

let postChartsFederationResponseSchema = S.object(s => {
    deliveredInstances: s.field("deliveredInstances", S.array(S.float)),
    inboxInstances: s.field("inboxInstances", S.array(S.float)),
    stalled: s.field("stalled", S.array(S.float)),
    sub: s.field("sub", S.array(S.float)),
    pub: s.field("pub", S.array(S.float)),
    pubsub: s.field("pubsub", S.array(S.float)),
    subActive: s.field("subActive", S.array(S.float)),
    pubActive: s.field("pubActive", S.array(S.float)),
  })

/**
charts/federation

No description provided.

**Credential required**: *No*
*/
let postChartsFederation = async (~body: postChartsFederationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsFederationResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsFederationRequestSchema)
  let response = await fetch(
    ~url="/charts/federation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsFederationResponseSchema)
}

type getChartsInstanceRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  host: string,
}

let getChartsInstanceRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    host: s.field("host", S.string),
  })

type getChartsInstanceResponse_5 = {
  normal: array<float>,
  reply: array<float>,
  renote: array<float>,
  withFile: array<float>,
}

type getChartsInstanceResponse_4 = {
  totalFiles: array<float>,
  incFiles: array<float>,
  decFiles: array<float>,
  incUsage: array<float>,
  decUsage: array<float>,
}

type getChartsInstanceResponse_3 = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
}

type getChartsInstanceResponse_2 = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
  diffs: getChartsInstanceResponse_5,
}

type getChartsInstanceResponse_1 = {
  failed: array<float>,
  succeeded: array<float>,
  received: array<float>,
}

type getChartsInstanceResponse = {
  requests: getChartsInstanceResponse_1,
  notes: getChartsInstanceResponse_2,
  users: getChartsInstanceResponse_3,
  following: getChartsInstanceResponse_3,
  followers: getChartsInstanceResponse_3,
  drive: getChartsInstanceResponse_4,
}

let getChartsInstanceResponse_5Schema = S.object(s => {
    normal: s.field("normal", S.array(S.float)),
    reply: s.field("reply", S.array(S.float)),
    renote: s.field("renote", S.array(S.float)),
    withFile: s.field("withFile", S.array(S.float)),
  })

let getChartsInstanceResponse_4Schema = S.object(s => {
    totalFiles: s.field("totalFiles", S.array(S.float)),
    incFiles: s.field("incFiles", S.array(S.float)),
    decFiles: s.field("decFiles", S.array(S.float)),
    incUsage: s.field("incUsage", S.array(S.float)),
    decUsage: s.field("decUsage", S.array(S.float)),
  })

let getChartsInstanceResponse_3Schema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
  })

let getChartsInstanceResponse_2Schema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
    diffs: s.field("diffs", getChartsInstanceResponse_5Schema),
  })

let getChartsInstanceResponse_1Schema = S.object(s => {
    failed: s.field("failed", S.array(S.float)),
    succeeded: s.field("succeeded", S.array(S.float)),
    received: s.field("received", S.array(S.float)),
  })

let getChartsInstanceResponseSchema = S.object(s => {
    requests: s.field("requests", getChartsInstanceResponse_1Schema),
    notes: s.field("notes", getChartsInstanceResponse_2Schema),
    users: s.field("users", getChartsInstanceResponse_3Schema),
    following: s.field("following", getChartsInstanceResponse_3Schema),
    followers: s.field("followers", getChartsInstanceResponse_3Schema),
    drive: s.field("drive", getChartsInstanceResponse_4Schema),
  })

/**
charts/instance

No description provided.

**Credential required**: *No*
*/
let getChartsInstance = async (~body: getChartsInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsInstanceResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsInstanceRequestSchema)
  let response = await fetch(
    ~url="/charts/instance",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsInstanceResponseSchema)
}

type postChartsInstanceRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  host: string,
}

let postChartsInstanceRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    host: s.field("host", S.string),
  })

type postChartsInstanceResponse_5 = {
  normal: array<float>,
  reply: array<float>,
  renote: array<float>,
  withFile: array<float>,
}

type postChartsInstanceResponse_4 = {
  totalFiles: array<float>,
  incFiles: array<float>,
  decFiles: array<float>,
  incUsage: array<float>,
  decUsage: array<float>,
}

type postChartsInstanceResponse_3 = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
}

type postChartsInstanceResponse_2 = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
  diffs: postChartsInstanceResponse_5,
}

type postChartsInstanceResponse_1 = {
  failed: array<float>,
  succeeded: array<float>,
  received: array<float>,
}

type postChartsInstanceResponse = {
  requests: postChartsInstanceResponse_1,
  notes: postChartsInstanceResponse_2,
  users: postChartsInstanceResponse_3,
  following: postChartsInstanceResponse_3,
  followers: postChartsInstanceResponse_3,
  drive: postChartsInstanceResponse_4,
}

let postChartsInstanceResponse_5Schema = S.object(s => {
    normal: s.field("normal", S.array(S.float)),
    reply: s.field("reply", S.array(S.float)),
    renote: s.field("renote", S.array(S.float)),
    withFile: s.field("withFile", S.array(S.float)),
  })

let postChartsInstanceResponse_4Schema = S.object(s => {
    totalFiles: s.field("totalFiles", S.array(S.float)),
    incFiles: s.field("incFiles", S.array(S.float)),
    decFiles: s.field("decFiles", S.array(S.float)),
    incUsage: s.field("incUsage", S.array(S.float)),
    decUsage: s.field("decUsage", S.array(S.float)),
  })

let postChartsInstanceResponse_3Schema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
  })

let postChartsInstanceResponse_2Schema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
    diffs: s.field("diffs", postChartsInstanceResponse_5Schema),
  })

let postChartsInstanceResponse_1Schema = S.object(s => {
    failed: s.field("failed", S.array(S.float)),
    succeeded: s.field("succeeded", S.array(S.float)),
    received: s.field("received", S.array(S.float)),
  })

let postChartsInstanceResponseSchema = S.object(s => {
    requests: s.field("requests", postChartsInstanceResponse_1Schema),
    notes: s.field("notes", postChartsInstanceResponse_2Schema),
    users: s.field("users", postChartsInstanceResponse_3Schema),
    following: s.field("following", postChartsInstanceResponse_3Schema),
    followers: s.field("followers", postChartsInstanceResponse_3Schema),
    drive: s.field("drive", postChartsInstanceResponse_4Schema),
  })

/**
charts/instance

No description provided.

**Credential required**: *No*
*/
let postChartsInstance = async (~body: postChartsInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsInstanceResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsInstanceRequestSchema)
  let response = await fetch(
    ~url="/charts/instance",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsInstanceResponseSchema)
}

type getChartsNotesRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let getChartsNotesRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type getChartsNotesResponse_2 = {
  normal: array<float>,
  reply: array<float>,
  renote: array<float>,
  withFile: array<float>,
}

type getChartsNotesResponse_1 = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
  diffs: getChartsNotesResponse_2,
}

type getChartsNotesResponse = {
  local: getChartsNotesResponse_1,
  remote: getChartsNotesResponse_1,
}

let getChartsNotesResponse_2Schema = S.object(s => {
    normal: s.field("normal", S.array(S.float)),
    reply: s.field("reply", S.array(S.float)),
    renote: s.field("renote", S.array(S.float)),
    withFile: s.field("withFile", S.array(S.float)),
  })

let getChartsNotesResponse_1Schema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
    diffs: s.field("diffs", getChartsNotesResponse_2Schema),
  })

let getChartsNotesResponseSchema = S.object(s => {
    local: s.field("local", getChartsNotesResponse_1Schema),
    remote: s.field("remote", getChartsNotesResponse_1Schema),
  })

/**
charts/notes

No description provided.

**Credential required**: *No*
*/
let getChartsNotes = async (~body: getChartsNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsNotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsNotesRequestSchema)
  let response = await fetch(
    ~url="/charts/notes",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsNotesResponseSchema)
}

type postChartsNotesRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let postChartsNotesRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type postChartsNotesResponse_2 = {
  normal: array<float>,
  reply: array<float>,
  renote: array<float>,
  withFile: array<float>,
}

type postChartsNotesResponse_1 = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
  diffs: postChartsNotesResponse_2,
}

type postChartsNotesResponse = {
  local: postChartsNotesResponse_1,
  remote: postChartsNotesResponse_1,
}

let postChartsNotesResponse_2Schema = S.object(s => {
    normal: s.field("normal", S.array(S.float)),
    reply: s.field("reply", S.array(S.float)),
    renote: s.field("renote", S.array(S.float)),
    withFile: s.field("withFile", S.array(S.float)),
  })

let postChartsNotesResponse_1Schema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
    diffs: s.field("diffs", postChartsNotesResponse_2Schema),
  })

let postChartsNotesResponseSchema = S.object(s => {
    local: s.field("local", postChartsNotesResponse_1Schema),
    remote: s.field("remote", postChartsNotesResponse_1Schema),
  })

/**
charts/notes

No description provided.

**Credential required**: *No*
*/
let postChartsNotes = async (~body: postChartsNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsNotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsNotesRequestSchema)
  let response = await fetch(
    ~url="/charts/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsNotesResponseSchema)
}

type getChartsUserDriveRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  userId: string,
}

let getChartsUserDriveRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    userId: s.field("userId", S.string),
  })

type getChartsUserDriveResponse = {
  totalCount: array<float>,
  totalSize: array<float>,
  incCount: array<float>,
  incSize: array<float>,
  decCount: array<float>,
  decSize: array<float>,
}

let getChartsUserDriveResponseSchema = S.object(s => {
    totalCount: s.field("totalCount", S.array(S.float)),
    totalSize: s.field("totalSize", S.array(S.float)),
    incCount: s.field("incCount", S.array(S.float)),
    incSize: s.field("incSize", S.array(S.float)),
    decCount: s.field("decCount", S.array(S.float)),
    decSize: s.field("decSize", S.array(S.float)),
  })

/**
charts/user/drive

No description provided.

**Credential required**: *No*
*/
let getChartsUserDrive = async (~body: getChartsUserDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsUserDriveResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserDriveRequestSchema)
  let response = await fetch(
    ~url="/charts/user/drive",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsUserDriveResponseSchema)
}

type postChartsUserDriveRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  userId: string,
}

let postChartsUserDriveRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    userId: s.field("userId", S.string),
  })

type postChartsUserDriveResponse = {
  totalCount: array<float>,
  totalSize: array<float>,
  incCount: array<float>,
  incSize: array<float>,
  decCount: array<float>,
  decSize: array<float>,
}

let postChartsUserDriveResponseSchema = S.object(s => {
    totalCount: s.field("totalCount", S.array(S.float)),
    totalSize: s.field("totalSize", S.array(S.float)),
    incCount: s.field("incCount", S.array(S.float)),
    incSize: s.field("incSize", S.array(S.float)),
    decCount: s.field("decCount", S.array(S.float)),
    decSize: s.field("decSize", S.array(S.float)),
  })

/**
charts/user/drive

No description provided.

**Credential required**: *No*
*/
let postChartsUserDrive = async (~body: postChartsUserDriveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsUserDriveResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserDriveRequestSchema)
  let response = await fetch(
    ~url="/charts/user/drive",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsUserDriveResponseSchema)
}

type getChartsUserFollowingRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  userId: string,
}

let getChartsUserFollowingRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    userId: s.field("userId", S.string),
  })

type getChartsUserFollowingResponse_2 = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
}

type getChartsUserFollowingResponse_1 = {
  followings: getChartsUserFollowingResponse_2,
  followers: getChartsUserFollowingResponse_2,
}

type getChartsUserFollowingResponse = {
  local: getChartsUserFollowingResponse_1,
  remote: getChartsUserFollowingResponse_1,
}

let getChartsUserFollowingResponse_2Schema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
  })

let getChartsUserFollowingResponse_1Schema = S.object(s => {
    followings: s.field("followings", getChartsUserFollowingResponse_2Schema),
    followers: s.field("followers", getChartsUserFollowingResponse_2Schema),
  })

let getChartsUserFollowingResponseSchema = S.object(s => {
    local: s.field("local", getChartsUserFollowingResponse_1Schema),
    remote: s.field("remote", getChartsUserFollowingResponse_1Schema),
  })

/**
charts/user/following

No description provided.

**Credential required**: *No*
*/
let getChartsUserFollowing = async (~body: getChartsUserFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsUserFollowingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserFollowingRequestSchema)
  let response = await fetch(
    ~url="/charts/user/following",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsUserFollowingResponseSchema)
}

type postChartsUserFollowingRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  userId: string,
}

let postChartsUserFollowingRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    userId: s.field("userId", S.string),
  })

type postChartsUserFollowingResponse_2 = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
}

type postChartsUserFollowingResponse_1 = {
  followings: postChartsUserFollowingResponse_2,
  followers: postChartsUserFollowingResponse_2,
}

type postChartsUserFollowingResponse = {
  local: postChartsUserFollowingResponse_1,
  remote: postChartsUserFollowingResponse_1,
}

let postChartsUserFollowingResponse_2Schema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
  })

let postChartsUserFollowingResponse_1Schema = S.object(s => {
    followings: s.field("followings", postChartsUserFollowingResponse_2Schema),
    followers: s.field("followers", postChartsUserFollowingResponse_2Schema),
  })

let postChartsUserFollowingResponseSchema = S.object(s => {
    local: s.field("local", postChartsUserFollowingResponse_1Schema),
    remote: s.field("remote", postChartsUserFollowingResponse_1Schema),
  })

/**
charts/user/following

No description provided.

**Credential required**: *No*
*/
let postChartsUserFollowing = async (~body: postChartsUserFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsUserFollowingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserFollowingRequestSchema)
  let response = await fetch(
    ~url="/charts/user/following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsUserFollowingResponseSchema)
}

type getChartsUserNotesRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  userId: string,
}

let getChartsUserNotesRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    userId: s.field("userId", S.string),
  })

type getChartsUserNotesResponse_1 = {
  normal: array<float>,
  reply: array<float>,
  renote: array<float>,
  withFile: array<float>,
}

type getChartsUserNotesResponse = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
  diffs: getChartsUserNotesResponse_1,
}

let getChartsUserNotesResponse_1Schema = S.object(s => {
    normal: s.field("normal", S.array(S.float)),
    reply: s.field("reply", S.array(S.float)),
    renote: s.field("renote", S.array(S.float)),
    withFile: s.field("withFile", S.array(S.float)),
  })

let getChartsUserNotesResponseSchema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
    diffs: s.field("diffs", getChartsUserNotesResponse_1Schema),
  })

/**
charts/user/notes

No description provided.

**Credential required**: *No*
*/
let getChartsUserNotes = async (~body: getChartsUserNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsUserNotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserNotesRequestSchema)
  let response = await fetch(
    ~url="/charts/user/notes",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsUserNotesResponseSchema)
}

type postChartsUserNotesRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  userId: string,
}

let postChartsUserNotesRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    userId: s.field("userId", S.string),
  })

type postChartsUserNotesResponse_1 = {
  normal: array<float>,
  reply: array<float>,
  renote: array<float>,
  withFile: array<float>,
}

type postChartsUserNotesResponse = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
  diffs: postChartsUserNotesResponse_1,
}

let postChartsUserNotesResponse_1Schema = S.object(s => {
    normal: s.field("normal", S.array(S.float)),
    reply: s.field("reply", S.array(S.float)),
    renote: s.field("renote", S.array(S.float)),
    withFile: s.field("withFile", S.array(S.float)),
  })

let postChartsUserNotesResponseSchema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
    diffs: s.field("diffs", postChartsUserNotesResponse_1Schema),
  })

/**
charts/user/notes

No description provided.

**Credential required**: *No*
*/
let postChartsUserNotes = async (~body: postChartsUserNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsUserNotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserNotesRequestSchema)
  let response = await fetch(
    ~url="/charts/user/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsUserNotesResponseSchema)
}

type getChartsUserPvRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  userId: string,
}

let getChartsUserPvRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    userId: s.field("userId", S.string),
  })

type getChartsUserPvResponse_1 = {
  user: array<float>,
  visitor: array<float>,
}

type getChartsUserPvResponse = {
  upv: getChartsUserPvResponse_1,
  pv: getChartsUserPvResponse_1,
}

let getChartsUserPvResponse_1Schema = S.object(s => {
    user: s.field("user", S.array(S.float)),
    visitor: s.field("visitor", S.array(S.float)),
  })

let getChartsUserPvResponseSchema = S.object(s => {
    upv: s.field("upv", getChartsUserPvResponse_1Schema),
    pv: s.field("pv", getChartsUserPvResponse_1Schema),
  })

/**
charts/user/pv

No description provided.

**Credential required**: *No*
*/
let getChartsUserPv = async (~body: getChartsUserPvRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsUserPvResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserPvRequestSchema)
  let response = await fetch(
    ~url="/charts/user/pv",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsUserPvResponseSchema)
}

type postChartsUserPvRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  userId: string,
}

let postChartsUserPvRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    userId: s.field("userId", S.string),
  })

type postChartsUserPvResponse_1 = {
  user: array<float>,
  visitor: array<float>,
}

type postChartsUserPvResponse = {
  upv: postChartsUserPvResponse_1,
  pv: postChartsUserPvResponse_1,
}

let postChartsUserPvResponse_1Schema = S.object(s => {
    user: s.field("user", S.array(S.float)),
    visitor: s.field("visitor", S.array(S.float)),
  })

let postChartsUserPvResponseSchema = S.object(s => {
    upv: s.field("upv", postChartsUserPvResponse_1Schema),
    pv: s.field("pv", postChartsUserPvResponse_1Schema),
  })

/**
charts/user/pv

No description provided.

**Credential required**: *No*
*/
let postChartsUserPv = async (~body: postChartsUserPvRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsUserPvResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserPvRequestSchema)
  let response = await fetch(
    ~url="/charts/user/pv",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsUserPvResponseSchema)
}

type getChartsUserReactionsRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  userId: string,
}

let getChartsUserReactionsRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    userId: s.field("userId", S.string),
  })

type getChartsUserReactionsResponse_1 = {
  count: array<float>,
}

type getChartsUserReactionsResponse = {
  local: getChartsUserReactionsResponse_1,
  remote: getChartsUserReactionsResponse_1,
}

let getChartsUserReactionsResponse_1Schema = S.object(s => {
    count: s.field("count", S.array(S.float)),
  })

let getChartsUserReactionsResponseSchema = S.object(s => {
    local: s.field("local", getChartsUserReactionsResponse_1Schema),
    remote: s.field("remote", getChartsUserReactionsResponse_1Schema),
  })

/**
charts/user/reactions

No description provided.

**Credential required**: *No*
*/
let getChartsUserReactions = async (~body: getChartsUserReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsUserReactionsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUserReactionsRequestSchema)
  let response = await fetch(
    ~url="/charts/user/reactions",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsUserReactionsResponseSchema)
}

type postChartsUserReactionsRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
  userId: string,
}

let postChartsUserReactionsRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
    userId: s.field("userId", S.string),
  })

type postChartsUserReactionsResponse_1 = {
  count: array<float>,
}

type postChartsUserReactionsResponse = {
  local: postChartsUserReactionsResponse_1,
  remote: postChartsUserReactionsResponse_1,
}

let postChartsUserReactionsResponse_1Schema = S.object(s => {
    count: s.field("count", S.array(S.float)),
  })

let postChartsUserReactionsResponseSchema = S.object(s => {
    local: s.field("local", postChartsUserReactionsResponse_1Schema),
    remote: s.field("remote", postChartsUserReactionsResponse_1Schema),
  })

/**
charts/user/reactions

No description provided.

**Credential required**: *No*
*/
let postChartsUserReactions = async (~body: postChartsUserReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsUserReactionsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUserReactionsRequestSchema)
  let response = await fetch(
    ~url="/charts/user/reactions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsUserReactionsResponseSchema)
}

type getChartsUsersRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let getChartsUsersRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type getChartsUsersResponse_1 = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
}

type getChartsUsersResponse = {
  local: getChartsUsersResponse_1,
  remote: getChartsUsersResponse_1,
}

let getChartsUsersResponse_1Schema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
  })

let getChartsUsersResponseSchema = S.object(s => {
    local: s.field("local", getChartsUsersResponse_1Schema),
    remote: s.field("remote", getChartsUsersResponse_1Schema),
  })

/**
charts/users

No description provided.

**Credential required**: *No*
*/
let getChartsUsers = async (~body: getChartsUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getChartsUsersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getChartsUsersRequestSchema)
  let response = await fetch(
    ~url="/charts/users",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getChartsUsersResponseSchema)
}

type postChartsUsersRequest = {
  span: string,
  limit: option<int>,
  offset: option<int>,
}

let postChartsUsersRequestSchema = S.object(s => {
    span: s.field("span", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(500))),
    offset: s.field("offset", S.option(S.int)),
  })

type postChartsUsersResponse_1 = {
  total: array<float>,
  inc: array<float>,
  dec: array<float>,
}

type postChartsUsersResponse = {
  local: postChartsUsersResponse_1,
  remote: postChartsUsersResponse_1,
}

let postChartsUsersResponse_1Schema = S.object(s => {
    total: s.field("total", S.array(S.float)),
    inc: s.field("inc", S.array(S.float)),
    dec: s.field("dec", S.array(S.float)),
  })

let postChartsUsersResponseSchema = S.object(s => {
    local: s.field("local", postChartsUsersResponse_1Schema),
    remote: s.field("remote", postChartsUsersResponse_1Schema),
  })

/**
charts/users

No description provided.

**Credential required**: *No*
*/
let postChartsUsers = async (~body: postChartsUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChartsUsersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChartsUsersRequestSchema)
  let response = await fetch(
    ~url="/charts/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChartsUsersResponseSchema)
}
