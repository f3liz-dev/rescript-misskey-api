// misskey-io API for federation
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postApGetRequest = {
  uri: string,
}

let postApGetRequestSchema = S.object(s => {
    uri: s.field("uri", S.string),
  })

type postApGetResponse = dict<JSON.t>

let postApGetResponseSchema = S.dict(S.json)

/**
ap/get

No description provided.

**Credential required**: *Yes* / **Permission**: *read:federation*
*/
let postApGet = async (~body: postApGetRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postApGetResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postApGetRequestSchema)
  let response = await fetch(
    ~url="/ap/get",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postApGetResponseSchema)
}

type postApShowRequest = {
  uri: string,
}

let postApShowRequestSchema = S.object(s => {
    uri: s.field("uri", S.string),
  })

type postApShowResponse_1 = {
  @as("type") type_: string,
  @as("object") object_: MisskeyIoComponentSchemas.Note.t,
}

type postApShowResponse = postApShowResponse_1

let postApShowResponse_1Schema = S.object(s => {
    type_: s.field("type", S.string),
    object_: s.field("object", MisskeyIoComponentSchemas.Note.schema),
  })

let postApShowResponseSchema = postApShowResponse_1Schema

/**
ap/show

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postApShow = async (~body: postApShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postApShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postApShowRequestSchema)
  let response = await fetch(
    ~url="/ap/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postApShowResponseSchema)
}

type postFederationFollowersRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postFederationFollowersRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postFederationFollowersResponse = array<MisskeyIoComponentSchemas.Following.t>

let postFederationFollowersResponseSchema = S.array(MisskeyIoComponentSchemas.Following.schema)

/**
federation/followers

No description provided.

**Credential required**: *No*
*/
let postFederationFollowers = async (~body: postFederationFollowersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationFollowersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationFollowersRequestSchema)
  let response = await fetch(
    ~url="/federation/followers",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFederationFollowersResponseSchema)
}

type postFederationFollowingRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postFederationFollowingRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postFederationFollowingResponse = array<MisskeyIoComponentSchemas.Following.t>

let postFederationFollowingResponseSchema = S.array(MisskeyIoComponentSchemas.Following.schema)

/**
federation/following

No description provided.

**Credential required**: *No*
*/
let postFederationFollowing = async (~body: postFederationFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationFollowingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationFollowingRequestSchema)
  let response = await fetch(
    ~url="/federation/following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFederationFollowingResponseSchema)
}

type getFederationInstancesRequest = {
  host: option<string>,
  blocked: option<bool>,
  notResponding: option<bool>,
  suspended: option<bool>,
  silenced: option<bool>,
  federating: option<bool>,
  subscribing: option<bool>,
  publishing: option<bool>,
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
}

let getFederationInstancesRequestSchema = S.object(s => {
    host: s.field("host", S.option(S.string)),
    blocked: s.field("blocked", S.option(S.bool)),
    notResponding: s.field("notResponding", S.option(S.bool)),
    suspended: s.field("suspended", S.option(S.bool)),
    silenced: s.field("silenced", S.option(S.bool)),
    federating: s.field("federating", S.option(S.bool)),
    subscribing: s.field("subscribing", S.option(S.bool)),
    publishing: s.field("publishing", S.option(S.bool)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(30))),
    offset: s.field("offset", S.option(S.int)),
    sort: s.field("sort", S.option(S.string)),
  })

type getFederationInstancesResponse = array<MisskeyIoComponentSchemas.FederationInstance.t>

let getFederationInstancesResponseSchema = S.array(MisskeyIoComponentSchemas.FederationInstance.schema)

/**
federation/instances

No description provided.

**Credential required**: *No*
*/
let getFederationInstances = async (~body: getFederationInstancesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getFederationInstancesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getFederationInstancesRequestSchema)
  let response = await fetch(
    ~url="/federation/instances",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getFederationInstancesResponseSchema)
}

type postFederationInstancesRequest = {
  host: option<string>,
  blocked: option<bool>,
  notResponding: option<bool>,
  suspended: option<bool>,
  silenced: option<bool>,
  federating: option<bool>,
  subscribing: option<bool>,
  publishing: option<bool>,
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
}

let postFederationInstancesRequestSchema = S.object(s => {
    host: s.field("host", S.option(S.string)),
    blocked: s.field("blocked", S.option(S.bool)),
    notResponding: s.field("notResponding", S.option(S.bool)),
    suspended: s.field("suspended", S.option(S.bool)),
    silenced: s.field("silenced", S.option(S.bool)),
    federating: s.field("federating", S.option(S.bool)),
    subscribing: s.field("subscribing", S.option(S.bool)),
    publishing: s.field("publishing", S.option(S.bool)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(30))),
    offset: s.field("offset", S.option(S.int)),
    sort: s.field("sort", S.option(S.string)),
  })

type postFederationInstancesResponse = array<MisskeyIoComponentSchemas.FederationInstance.t>

let postFederationInstancesResponseSchema = S.array(MisskeyIoComponentSchemas.FederationInstance.schema)

/**
federation/instances

No description provided.

**Credential required**: *No*
*/
let postFederationInstances = async (~body: postFederationInstancesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationInstancesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationInstancesRequestSchema)
  let response = await fetch(
    ~url="/federation/instances",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFederationInstancesResponseSchema)
}

type postFederationShowInstanceRequest = {
  host: string,
}

let postFederationShowInstanceRequestSchema = S.object(s => {
    host: s.field("host", S.string),
  })

type postFederationShowInstanceResponse = option<MisskeyIoComponentSchemas.FederationInstance.t>

let postFederationShowInstanceResponseSchema = S.nullableAsOption(MisskeyIoComponentSchemas.FederationInstance.schema)

/**
federation/show-instance

No description provided.

**Credential required**: *No*
*/
let postFederationShowInstance = async (~body: postFederationShowInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationShowInstanceResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationShowInstanceRequestSchema)
  let response = await fetch(
    ~url="/federation/show-instance",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFederationShowInstanceResponseSchema)
}

type getFederationStatsRequest = {
  limit: option<int>,
}

let getFederationStatsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type getFederationStatsResponse = {
  topSubInstances: array<MisskeyIoComponentSchemas.FederationInstance.t>,
  otherFollowersCount: float,
  topPubInstances: array<MisskeyIoComponentSchemas.FederationInstance.t>,
  otherFollowingCount: float,
}

let getFederationStatsResponseSchema = S.object(s => {
    topSubInstances: s.field("topSubInstances", S.array(MisskeyIoComponentSchemas.FederationInstance.schema)),
    otherFollowersCount: s.field("otherFollowersCount", S.float),
    topPubInstances: s.field("topPubInstances", S.array(MisskeyIoComponentSchemas.FederationInstance.schema)),
    otherFollowingCount: s.field("otherFollowingCount", S.float),
  })

/**
federation/stats

No description provided.

**Credential required**: *No*
*/
let getFederationStats = async (~body: getFederationStatsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getFederationStatsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getFederationStatsRequestSchema)
  let response = await fetch(
    ~url="/federation/stats",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getFederationStatsResponseSchema)
}

type postFederationStatsRequest = {
  limit: option<int>,
}

let postFederationStatsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postFederationStatsResponse = {
  topSubInstances: array<MisskeyIoComponentSchemas.FederationInstance.t>,
  otherFollowersCount: float,
  topPubInstances: array<MisskeyIoComponentSchemas.FederationInstance.t>,
  otherFollowingCount: float,
}

let postFederationStatsResponseSchema = S.object(s => {
    topSubInstances: s.field("topSubInstances", S.array(MisskeyIoComponentSchemas.FederationInstance.schema)),
    otherFollowersCount: s.field("otherFollowersCount", S.float),
    topPubInstances: s.field("topPubInstances", S.array(MisskeyIoComponentSchemas.FederationInstance.schema)),
    otherFollowingCount: s.field("otherFollowingCount", S.float),
  })

/**
federation/stats

No description provided.

**Credential required**: *No*
*/
let postFederationStats = async (~body: postFederationStatsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationStatsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationStatsRequestSchema)
  let response = await fetch(
    ~url="/federation/stats",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFederationStatsResponseSchema)
}

type postFederationUpdateRemoteUserRequest = {
  userId: string,
}

let postFederationUpdateRemoteUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFederationUpdateRemoteUserResponse = unit

/**
federation/update-remote-user

No description provided.

**Credential required**: *No*
*/
let postFederationUpdateRemoteUser = async (~body: postFederationUpdateRemoteUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationUpdateRemoteUserResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationUpdateRemoteUserRequestSchema)
  let response = await fetch(
    ~url="/federation/update-remote-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postFederationUsersRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postFederationUsersRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postFederationUsersResponse = array<MisskeyIoComponentSchemas.UserDetailedNotMe.t>

let postFederationUsersResponseSchema = S.array(MisskeyIoComponentSchemas.UserDetailedNotMe.schema)

/**
federation/users

No description provided.

**Credential required**: *No*
*/
let postFederationUsers = async (~body: postFederationUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFederationUsersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationUsersRequestSchema)
  let response = await fetch(
    ~url="/federation/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFederationUsersResponseSchema)
}
