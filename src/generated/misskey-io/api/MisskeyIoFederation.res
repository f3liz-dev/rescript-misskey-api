// misskey-io API for federation
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postApGetRequest = {
  uri: string,
}

let postApGetRequestSchema = S.object(s => {
    uri: s.field("uri", S.string),
  })

type postApGetResponse = dict<JSON.t>

let postApGetResponseSchema = S.dict(S.json)

/**
 * ap/get
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:federation*
 */
let postApGet = (~body: postApGetRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postApGetResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postApGetRequestSchema)
  fetch(
    ~url="/ap/get",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postApGetResponseSchema)
  value
    ->Promise.resolve
  })
}

type postApShowRequest = {
  uri: string,
}

let postApShowRequestSchema = S.object(s => {
    uri: s.field("uri", S.string),
  })

type postApShowResponse_1 = {
  @as("type") type_: string,
  @as("object") object_: MisskeyIoComponentSchemas.Note.t,
}

type postApShowResponse = postApShowResponse_1

let postApShowResponse_1Schema = S.object(s => {
    type_: s.field("type", S.string),
    object_: s.field("object", MisskeyIoComponentSchemas.Note.schema),
  })

let postApShowResponseSchema = postApShowResponse_1Schema

/**
 * ap/show
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postApShow = (~body: postApShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postApShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postApShowRequestSchema)
  fetch(
    ~url="/ap/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postApShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFederationFollowersRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postFederationFollowersRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postFederationFollowersResponse = array<MisskeyIoComponentSchemas.Following.t>

let postFederationFollowersResponseSchema = S.array(MisskeyIoComponentSchemas.Following.schema)

/**
 * federation/followers
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationFollowers = (~body: postFederationFollowersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationFollowersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationFollowersRequestSchema)
  fetch(
    ~url="/federation/followers",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFederationFollowersResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFederationFollowingRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postFederationFollowingRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postFederationFollowingResponse = array<MisskeyIoComponentSchemas.Following.t>

let postFederationFollowingResponseSchema = S.array(MisskeyIoComponentSchemas.Following.schema)

/**
 * federation/following
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationFollowing = (~body: postFederationFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationFollowingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationFollowingRequestSchema)
  fetch(
    ~url="/federation/following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFederationFollowingResponseSchema)
  value
    ->Promise.resolve
  })
}

type getFederationInstancesRequest = {
  host: option<string>,
  blocked: option<bool>,
  notResponding: option<bool>,
  suspended: option<bool>,
  silenced: option<bool>,
  federating: option<bool>,
  subscribing: option<bool>,
  publishing: option<bool>,
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
}

let getFederationInstancesRequestSchema = S.object(s => {
    host: s.fieldOr("host", S.nullableAsOption(S.string), None),
    blocked: s.fieldOr("blocked", S.nullableAsOption(S.bool), None),
    notResponding: s.fieldOr("notResponding", S.nullableAsOption(S.bool), None),
    suspended: s.fieldOr("suspended", S.nullableAsOption(S.bool), None),
    silenced: s.fieldOr("silenced", S.nullableAsOption(S.bool), None),
    federating: s.fieldOr("federating", S.nullableAsOption(S.bool), None),
    subscribing: s.fieldOr("subscribing", S.nullableAsOption(S.bool), None),
    publishing: s.fieldOr("publishing", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(30)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
  })

type getFederationInstancesResponse = array<MisskeyIoComponentSchemas.FederationInstance.t>

let getFederationInstancesResponseSchema = S.array(MisskeyIoComponentSchemas.FederationInstance.schema)

/**
 * federation/instances
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getFederationInstances = (~body: getFederationInstancesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getFederationInstancesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getFederationInstancesRequestSchema)
  fetch(
    ~url="/federation/instances",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getFederationInstancesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFederationInstancesRequest = {
  host: option<string>,
  blocked: option<bool>,
  notResponding: option<bool>,
  suspended: option<bool>,
  silenced: option<bool>,
  federating: option<bool>,
  subscribing: option<bool>,
  publishing: option<bool>,
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
}

let postFederationInstancesRequestSchema = S.object(s => {
    host: s.fieldOr("host", S.nullableAsOption(S.string), None),
    blocked: s.fieldOr("blocked", S.nullableAsOption(S.bool), None),
    notResponding: s.fieldOr("notResponding", S.nullableAsOption(S.bool), None),
    suspended: s.fieldOr("suspended", S.nullableAsOption(S.bool), None),
    silenced: s.fieldOr("silenced", S.nullableAsOption(S.bool), None),
    federating: s.fieldOr("federating", S.nullableAsOption(S.bool), None),
    subscribing: s.fieldOr("subscribing", S.nullableAsOption(S.bool), None),
    publishing: s.fieldOr("publishing", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(30)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
  })

type postFederationInstancesResponse = array<MisskeyIoComponentSchemas.FederationInstance.t>

let postFederationInstancesResponseSchema = S.array(MisskeyIoComponentSchemas.FederationInstance.schema)

/**
 * federation/instances
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationInstances = (~body: postFederationInstancesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationInstancesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationInstancesRequestSchema)
  fetch(
    ~url="/federation/instances",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFederationInstancesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFederationShowInstanceRequest = {
  host: string,
}

let postFederationShowInstanceRequestSchema = S.object(s => {
    host: s.field("host", S.string),
  })

type postFederationShowInstanceResponse = option<MisskeyIoComponentSchemas.FederationInstance.t>

let postFederationShowInstanceResponseSchema = S.nullableAsOption(MisskeyIoComponentSchemas.FederationInstance.schema)

/**
 * federation/show-instance
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationShowInstance = (~body: postFederationShowInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationShowInstanceResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationShowInstanceRequestSchema)
  fetch(
    ~url="/federation/show-instance",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFederationShowInstanceResponseSchema)
  value
    ->Promise.resolve
  })
}

type getFederationStatsRequest = {
  limit: option<int>,
}

let getFederationStatsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type getFederationStatsResponse = {
  topSubInstances: array<MisskeyIoComponentSchemas.FederationInstance.t>,
  otherFollowersCount: float,
  topPubInstances: array<MisskeyIoComponentSchemas.FederationInstance.t>,
  otherFollowingCount: float,
}

let getFederationStatsResponseSchema = S.object(s => {
    topSubInstances: s.field("topSubInstances", S.array(MisskeyIoComponentSchemas.FederationInstance.schema)),
    otherFollowersCount: s.field("otherFollowersCount", S.float),
    topPubInstances: s.field("topPubInstances", S.array(MisskeyIoComponentSchemas.FederationInstance.schema)),
    otherFollowingCount: s.field("otherFollowingCount", S.float),
  })

/**
 * federation/stats
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getFederationStats = (~body: getFederationStatsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getFederationStatsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getFederationStatsRequestSchema)
  fetch(
    ~url="/federation/stats",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getFederationStatsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFederationStatsRequest = {
  limit: option<int>,
}

let postFederationStatsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postFederationStatsResponse = {
  topSubInstances: array<MisskeyIoComponentSchemas.FederationInstance.t>,
  otherFollowersCount: float,
  topPubInstances: array<MisskeyIoComponentSchemas.FederationInstance.t>,
  otherFollowingCount: float,
}

let postFederationStatsResponseSchema = S.object(s => {
    topSubInstances: s.field("topSubInstances", S.array(MisskeyIoComponentSchemas.FederationInstance.schema)),
    otherFollowersCount: s.field("otherFollowersCount", S.float),
    topPubInstances: s.field("topPubInstances", S.array(MisskeyIoComponentSchemas.FederationInstance.schema)),
    otherFollowingCount: s.field("otherFollowingCount", S.float),
  })

/**
 * federation/stats
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationStats = (~body: postFederationStatsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationStatsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationStatsRequestSchema)
  fetch(
    ~url="/federation/stats",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFederationStatsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFederationUpdateRemoteUserRequest = {
  userId: string,
}

let postFederationUpdateRemoteUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFederationUpdateRemoteUserResponse = unit

/**
 * federation/update-remote-user
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationUpdateRemoteUser = (~body: postFederationUpdateRemoteUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationUpdateRemoteUserResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationUpdateRemoteUserRequestSchema)
  fetch(
    ~url="/federation/update-remote-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postFederationUsersRequest = {
  host: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postFederationUsersRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postFederationUsersResponse = array<MisskeyIoComponentSchemas.UserDetailedNotMe.t>

let postFederationUsersResponseSchema = S.array(MisskeyIoComponentSchemas.UserDetailedNotMe.schema)

/**
 * federation/users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFederationUsers = (~body: postFederationUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFederationUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFederationUsersRequestSchema)
  fetch(
    ~url="/federation/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFederationUsersResponseSchema)
  value
    ->Promise.resolve
  })
}
