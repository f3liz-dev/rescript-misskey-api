// misskey-io API for clips
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postClipsCreateRequest = {
  name: string,
  isPublic: option<bool>,
  description: option<string>,
}

let postClipsCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
    isPublic: s.field("isPublic", S.option(S.bool)),
    description: s.field("description", S.option(S.string->S.max(2048))),
  })

type postClipsCreateResponse = MisskeyIoComponentSchemas.Clip.t

let postClipsCreateResponseSchema = MisskeyIoComponentSchemas.Clip.schema

/**
clips/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postClipsCreate = async (~body: postClipsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postClipsCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsCreateRequestSchema)
  let response = await fetch(
    ~url="/clips/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postClipsCreateResponseSchema)
}

type postClipsDeleteRequest = {
  clipId: string,
}

let postClipsDeleteRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
  })

type postClipsDeleteResponse = unit

/**
clips/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postClipsDelete = async (~body: postClipsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postClipsDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsDeleteRequestSchema)
  let response = await fetch(
    ~url="/clips/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postClipsListResponse = array<MisskeyIoComponentSchemas.Clip.t>

let postClipsListResponseSchema = S.array(MisskeyIoComponentSchemas.Clip.schema)

/**
clips/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postClipsList = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postClipsListResponse => {

  let response = await fetch(
    ~url="/clips/list",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postClipsListResponseSchema)
}

type postClipsShowRequest = {
  clipId: string,
}

let postClipsShowRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
  })

type postClipsShowResponse = MisskeyIoComponentSchemas.Clip.t

let postClipsShowResponseSchema = MisskeyIoComponentSchemas.Clip.schema

/**
clips/show

No description provided.

**Credential required**: *No* / **Permission**: *read:account*
*/
let postClipsShow = async (~body: postClipsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postClipsShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsShowRequestSchema)
  let response = await fetch(
    ~url="/clips/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postClipsShowResponseSchema)
}

type postClipsUpdateRequest = {
  clipId: string,
  name: option<string>,
  isPublic: option<bool>,
  description: option<string>,
}

let postClipsUpdateRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
    name: s.field("name", S.option(S.string->S.min(1)->S.max(100))),
    isPublic: s.field("isPublic", S.option(S.bool)),
    description: s.field("description", S.option(S.string->S.max(2048))),
  })

type postClipsUpdateResponse = MisskeyIoComponentSchemas.Clip.t

let postClipsUpdateResponseSchema = MisskeyIoComponentSchemas.Clip.schema

/**
clips/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postClipsUpdate = async (~body: postClipsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postClipsUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsUpdateRequestSchema)
  let response = await fetch(
    ~url="/clips/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postClipsUpdateResponseSchema)
}

type postNotesClipsRequest = {
  noteId: string,
}

let postNotesClipsRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesClipsResponse = array<MisskeyIoComponentSchemas.Clip.t>

let postNotesClipsResponseSchema = S.array(MisskeyIoComponentSchemas.Clip.schema)

/**
notes/clips

No description provided.

**Credential required**: *No*
*/
let postNotesClips = async (~body: postNotesClipsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesClipsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesClipsRequestSchema)
  let response = await fetch(
    ~url="/notes/clips",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesClipsResponseSchema)
}
