// misskey-io API for clips
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postClipsCreateRequest = {
  name: string,
  isPublic: option<bool>,
  description: option<JSON.t>,
}

let postClipsCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
    isPublic: s.fieldOr("isPublic", S.nullableAsOption(S.bool), None),
    description: s.fieldOr("description", S.nullableAsOption(S.json), None),
  })

type postClipsCreateResponse = MisskeyIoComponentSchemas.Clip.t

let postClipsCreateResponseSchema = MisskeyIoComponentSchemas.Clip.schema

/**
 * clips/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postClipsCreate = (~body: postClipsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsCreateRequestSchema)
  fetch(
    ~url="/clips/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postClipsCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postClipsDeleteRequest = {
  clipId: string,
}

let postClipsDeleteRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
  })

type postClipsDeleteResponse = unit

/**
 * clips/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postClipsDelete = (~body: postClipsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsDeleteRequestSchema)
  fetch(
    ~url="/clips/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postClipsListResponse = array<MisskeyIoComponentSchemas.Clip.t>

let postClipsListResponseSchema = S.array(MisskeyIoComponentSchemas.Clip.schema)

/**
 * clips/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postClipsList = (~body as _, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsListResponse> => {

  fetch(
    ~url="/clips/list",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postClipsListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postClipsShowRequest = {
  clipId: string,
}

let postClipsShowRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
  })

type postClipsShowResponse = MisskeyIoComponentSchemas.Clip.t

let postClipsShowResponseSchema = MisskeyIoComponentSchemas.Clip.schema

/**
 * clips/show
 *
 * No description provided.
 *
 * **Credential required**: *No* / **Permission**: *read:account*
 */
let postClipsShow = (~body: postClipsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsShowRequestSchema)
  fetch(
    ~url="/clips/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postClipsShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postClipsUpdateRequest = {
  clipId: string,
  name: option<string>,
  isPublic: option<bool>,
  description: option<JSON.t>,
}

let postClipsUpdateRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.max(100)), None),
    isPublic: s.fieldOr("isPublic", S.nullableAsOption(S.bool), None),
    description: s.fieldOr("description", S.nullableAsOption(S.json), None),
  })

type postClipsUpdateResponse = MisskeyIoComponentSchemas.Clip.t

let postClipsUpdateResponseSchema = MisskeyIoComponentSchemas.Clip.schema

/**
 * clips/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postClipsUpdate = (~body: postClipsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsUpdateRequestSchema)
  fetch(
    ~url="/clips/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postClipsUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesClipsRequest = {
  noteId: string,
}

let postNotesClipsRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesClipsResponse = array<MisskeyIoComponentSchemas.Clip.t>

let postNotesClipsResponseSchema = S.array(MisskeyIoComponentSchemas.Clip.schema)

/**
 * notes/clips
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postNotesClips = (~body: postNotesClipsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesClipsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesClipsRequestSchema)
  fetch(
    ~url="/notes/clips",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesClipsResponseSchema)
  value
    ->Promise.resolve
  })
}
