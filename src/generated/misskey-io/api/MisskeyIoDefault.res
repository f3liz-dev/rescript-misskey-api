// misskey-io API for default
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postAdminEmojiImportZipRequest = {
  fileId: string,
}

let postAdminEmojiImportZipRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
  })

type postAdminEmojiImportZipResponse = unit

/**
admin/emoji/import-zip

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postAdminEmojiImportZip = async (~body: postAdminEmojiImportZipRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiImportZipResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiImportZipRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/import-zip",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type getBubbleGameRankingRequest = {
  gameMode: string,
}

let getBubbleGameRankingRequestSchema = S.object(s => {
    gameMode: s.field("gameMode", S.string),
  })

type getBubbleGameRankingResponse_1 = {
  id: string,
  score: int,
  user: option<dict<JSON.t>>,
}

type getBubbleGameRankingResponse = array<getBubbleGameRankingResponse_1>

let getBubbleGameRankingResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    score: s.field("score", S.int),
    user: s.field("user", S.option(S.dict(S.json))),
  })

let getBubbleGameRankingResponseSchema = S.array(getBubbleGameRankingResponse_1Schema)

/**
bubble-game/ranking

No description provided.

**Credential required**: *No*
*/
let getBubbleGameRanking = async (~body: getBubbleGameRankingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getBubbleGameRankingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getBubbleGameRankingRequestSchema)
  let response = await fetch(
    ~url="/bubble-game/ranking",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getBubbleGameRankingResponseSchema)
}

type postBubbleGameRankingRequest = {
  gameMode: string,
}

let postBubbleGameRankingRequestSchema = S.object(s => {
    gameMode: s.field("gameMode", S.string),
  })

type postBubbleGameRankingResponse_1 = {
  id: string,
  score: int,
  user: option<dict<JSON.t>>,
}

type postBubbleGameRankingResponse = array<postBubbleGameRankingResponse_1>

let postBubbleGameRankingResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    score: s.field("score", S.int),
    user: s.field("user", S.option(S.dict(S.json))),
  })

let postBubbleGameRankingResponseSchema = S.array(postBubbleGameRankingResponse_1Schema)

/**
bubble-game/ranking

No description provided.

**Credential required**: *No*
*/
let postBubbleGameRanking = async (~body: postBubbleGameRankingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postBubbleGameRankingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBubbleGameRankingRequestSchema)
  let response = await fetch(
    ~url="/bubble-game/ranking",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postBubbleGameRankingResponseSchema)
}

type postBubbleGameRegisterRequest = {
  score: int,
  seed: string,
  logs: array<array<float>>,
  gameMode: string,
  gameVersion: int,
}

let postBubbleGameRegisterRequestSchema = S.object(s => {
    score: s.field("score", S.int->S.min(0)),
    seed: s.field("seed", S.string->S.min(1)->S.max(1024)),
    logs: s.field("logs", S.array(S.array(S.float))),
    gameMode: s.field("gameMode", S.string),
    gameVersion: s.field("gameVersion", S.int),
  })

type postBubbleGameRegisterResponse = unit

/**
bubble-game/register

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postBubbleGameRegister = async (~body: postBubbleGameRegisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postBubbleGameRegisterResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBubbleGameRegisterRequestSchema)
  let response = await fetch(
    ~url="/bubble-game/register",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postExportCustomEmojisResponse = unit

/**
export-custom-emojis

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postExportCustomEmojis = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postExportCustomEmojisResponse => {

  let response = await fetch(
    ~url="/export-custom-emojis",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postI2faDoneRequest = {
  token: string,
}

let postI2faDoneRequestSchema = S.object(s => {
    token: s.field("token", S.string),
  })

type postI2faDoneResponse = {
  backupCodes: array<string>,
}

let postI2faDoneResponseSchema = S.object(s => {
    backupCodes: s.field("backupCodes", S.array(S.string)),
  })

/**
i/2fa/done

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postI2faDone = async (~body: postI2faDoneRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postI2faDoneResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faDoneRequestSchema)
  let response = await fetch(
    ~url="/i/2fa/done",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postI2faDoneResponseSchema)
}

type postI2faKeyDoneRequest = {
  password: string,
  token: option<string>,
  name: string,
  credential: dict<JSON.t>,
}

let postI2faKeyDoneRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.field("token", S.option(S.string)),
    name: s.field("name", S.string->S.min(1)->S.max(30)),
    credential: s.field("credential", S.dict(S.json)),
  })

type postI2faKeyDoneResponse = {
  id: string,
  name: string,
}

let postI2faKeyDoneResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
  })

/**
i/2fa/key-done

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postI2faKeyDone = async (~body: postI2faKeyDoneRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postI2faKeyDoneResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faKeyDoneRequestSchema)
  let response = await fetch(
    ~url="/i/2fa/key-done",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postI2faKeyDoneResponseSchema)
}

type postI2faPasswordLessRequest = {
  value: bool,
}

let postI2faPasswordLessRequestSchema = S.object(s => {
    value: s.field("value", S.bool),
  })

type postI2faPasswordLessResponse = unit

/**
i/2fa/password-less

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postI2faPasswordLess = async (~body: postI2faPasswordLessRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postI2faPasswordLessResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faPasswordLessRequestSchema)
  let response = await fetch(
    ~url="/i/2fa/password-less",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postI2faRegisterRequest = {
  password: string,
  token: option<string>,
}

let postI2faRegisterRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.field("token", S.option(S.string)),
  })

type postI2faRegisterResponse = {
  qr: string,
  url: string,
  secret: string,
  label: string,
  issuer: string,
}

let postI2faRegisterResponseSchema = S.object(s => {
    qr: s.field("qr", S.string),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
    label: s.field("label", S.string),
    issuer: s.field("issuer", S.string),
  })

/**
i/2fa/register

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postI2faRegister = async (~body: postI2faRegisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postI2faRegisterResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faRegisterRequestSchema)
  let response = await fetch(
    ~url="/i/2fa/register",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postI2faRegisterResponseSchema)
}

type postI2faRegisterKeyRequest = {
  password: string,
  token: option<string>,
}

let postI2faRegisterKeyRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.field("token", S.option(S.string)),
  })

type postI2faRegisterKeyResponse_5 = {
  appid: option<string>,
  credProps: option<bool>,
  hmacCreateSecret: option<bool>,
}

type postI2faRegisterKeyResponse_4 = {
  authenticatorAttachment: string,
  requireResidentKey: bool,
  userVerification: string,
}

type postI2faRegisterKeyResponse_3 = {
  @as("type") type_: string,
  alg: float,
}

type postI2faRegisterKeyResponse_2 = {
  id: string,
  name: string,
  displayName: string,
}

type postI2faRegisterKeyResponse_1 = {
  id: option<string>,
}

type postI2faRegisterKeyResponse = {
  rp: postI2faRegisterKeyResponse_1,
  user: postI2faRegisterKeyResponse_2,
  challenge: string,
  pubKeyCredParams: array<postI2faRegisterKeyResponse_3>,
  timeout: option<float>,
  excludeCredentials: option<JSON.t>,
  authenticatorSelection: option<postI2faRegisterKeyResponse_4>,
  attestation: option<string>,
  extensions: option<postI2faRegisterKeyResponse_5>,
}

let postI2faRegisterKeyResponse_5Schema = S.object(s => {
    appid: s.field("appid", S.nullableAsOption(S.string)),
    credProps: s.field("credProps", S.nullableAsOption(S.bool)),
    hmacCreateSecret: s.field("hmacCreateSecret", S.nullableAsOption(S.bool)),
  })

let postI2faRegisterKeyResponse_4Schema = S.object(s => {
    authenticatorAttachment: s.field("authenticatorAttachment", S.string),
    requireResidentKey: s.field("requireResidentKey", S.bool),
    userVerification: s.field("userVerification", S.string),
  })

let postI2faRegisterKeyResponse_3Schema = S.object(s => {
    type_: s.field("type", S.string),
    alg: s.field("alg", S.float),
  })

let postI2faRegisterKeyResponse_2Schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    displayName: s.field("displayName", S.string),
  })

let postI2faRegisterKeyResponse_1Schema = S.object(s => {
    id: s.field("id", S.option(S.string)),
  })

let postI2faRegisterKeyResponseSchema = S.object(s => {
    rp: s.field("rp", postI2faRegisterKeyResponse_1Schema),
    user: s.field("user", postI2faRegisterKeyResponse_2Schema),
    challenge: s.field("challenge", S.string),
    pubKeyCredParams: s.field("pubKeyCredParams", S.array(postI2faRegisterKeyResponse_3Schema)),
    timeout: s.field("timeout", S.nullableAsOption(S.float)),
    excludeCredentials: s.field("excludeCredentials", S.nullableAsOption(S.json)),
    authenticatorSelection: s.field("authenticatorSelection", S.nullableAsOption(postI2faRegisterKeyResponse_4Schema)),
    attestation: s.field("attestation", S.nullableAsOption(S.string)),
    extensions: s.field("extensions", S.nullableAsOption(postI2faRegisterKeyResponse_5Schema)),
  })

/**
i/2fa/register-key

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postI2faRegisterKey = async (~body: postI2faRegisterKeyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postI2faRegisterKeyResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faRegisterKeyRequestSchema)
  let response = await fetch(
    ~url="/i/2fa/register-key",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postI2faRegisterKeyResponseSchema)
}

type postI2faRemoveKeyRequest = {
  password: string,
  token: option<string>,
  credentialId: string,
}

let postI2faRemoveKeyRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.field("token", S.option(S.string)),
    credentialId: s.field("credentialId", S.string),
  })

type postI2faRemoveKeyResponse = unit

/**
i/2fa/remove-key

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postI2faRemoveKey = async (~body: postI2faRemoveKeyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postI2faRemoveKeyResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faRemoveKeyRequestSchema)
  let response = await fetch(
    ~url="/i/2fa/remove-key",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postI2faUnregisterRequest = {
  password: string,
  token: option<string>,
}

let postI2faUnregisterRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.field("token", S.option(S.string)),
  })

type postI2faUnregisterResponse = unit

/**
i/2fa/unregister

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postI2faUnregister = async (~body: postI2faUnregisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postI2faUnregisterResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faUnregisterRequestSchema)
  let response = await fetch(
    ~url="/i/2fa/unregister",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postI2faUpdateKeyRequest = {
  name: string,
  credentialId: string,
}

let postI2faUpdateKeyRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(30)),
    credentialId: s.field("credentialId", S.string),
  })

type postI2faUpdateKeyResponse = unit

/**
i/2fa/update-key

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postI2faUpdateKey = async (~body: postI2faUpdateKeyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postI2faUpdateKeyResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faUpdateKeyRequestSchema)
  let response = await fetch(
    ~url="/i/2fa/update-key",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIAppsRequest = {
  sort: option<string>,
}

let postIAppsRequestSchema = S.object(s => {
    sort: s.field("sort", S.option(S.string)),
  })

type postIAppsResponse_1 = {
  id: string,
  name: option<string>,
  createdAt: string,
  lastUsedAt: option<string>,
  permission: array<string>,
}

type postIAppsResponse = array<postIAppsResponse_1>

let postIAppsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.option(S.string)),
    createdAt: s.field("createdAt", S.string),
    lastUsedAt: s.field("lastUsedAt", S.option(S.string)),
    permission: s.field("permission", S.array(S.string)),
  })

let postIAppsResponseSchema = S.array(postIAppsResponse_1Schema)

/**
i/apps

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIApps = async (~body: postIAppsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIAppsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIAppsRequestSchema)
  let response = await fetch(
    ~url="/i/apps",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIAppsResponseSchema)
}

type postIAuthorizedAppsRequest = {
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
}

let postIAuthorizedAppsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
    sort: s.field("sort", S.option(S.string)),
  })

type postIAuthorizedAppsResponse_1 = {
  id: string,
  name: string,
  callbackUrl: option<string>,
  permission: array<string>,
  isAuthorized: option<bool>,
}

type postIAuthorizedAppsResponse = array<postIAuthorizedAppsResponse_1>

let postIAuthorizedAppsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    callbackUrl: s.field("callbackUrl", S.nullableAsOption(S.string)),
    permission: s.field("permission", S.array(S.string)),
    isAuthorized: s.field("isAuthorized", S.option(S.bool)),
  })

let postIAuthorizedAppsResponseSchema = S.array(postIAuthorizedAppsResponse_1Schema)

/**
i/authorized-apps

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIAuthorizedApps = async (~body: postIAuthorizedAppsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIAuthorizedAppsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIAuthorizedAppsRequestSchema)
  let response = await fetch(
    ~url="/i/authorized-apps",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIAuthorizedAppsResponseSchema)
}

type postIChangePasswordRequest = {
  currentPassword: string,
  newPassword: string,
  token: option<string>,
}

let postIChangePasswordRequestSchema = S.object(s => {
    currentPassword: s.field("currentPassword", S.string),
    newPassword: s.field("newPassword", S.string->S.min(1)),
    token: s.field("token", S.option(S.string)),
  })

type postIChangePasswordResponse = unit

/**
i/change-password

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIChangePassword = async (~body: postIChangePasswordRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIChangePasswordResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIChangePasswordRequestSchema)
  let response = await fetch(
    ~url="/i/change-password",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIClaimAchievementRequest = {
  name: string,
}

let postIClaimAchievementRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type postIClaimAchievementResponse = unit

/**
i/claim-achievement

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIClaimAchievement = async (~body: postIClaimAchievementRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIClaimAchievementResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIClaimAchievementRequestSchema)
  let response = await fetch(
    ~url="/i/claim-achievement",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIDeleteAccountRequest = {
  password: string,
  token: option<string>,
}

let postIDeleteAccountRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.field("token", S.option(S.string)),
  })

type postIDeleteAccountResponse = unit

/**
i/delete-account

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIDeleteAccount = async (~body: postIDeleteAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIDeleteAccountResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIDeleteAccountRequestSchema)
  let response = await fetch(
    ~url="/i/delete-account",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIExportAntennasResponse = unit

/**
i/export-antennas

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIExportAntennas = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIExportAntennasResponse => {

  let response = await fetch(
    ~url="/i/export-antennas",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postIExportBlockingResponse = unit

/**
i/export-blocking

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIExportBlocking = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIExportBlockingResponse => {

  let response = await fetch(
    ~url="/i/export-blocking",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postIExportClipsResponse = unit

/**
i/export-clips

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIExportClips = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIExportClipsResponse => {

  let response = await fetch(
    ~url="/i/export-clips",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postIExportFavoritesResponse = unit

/**
i/export-favorites

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIExportFavorites = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIExportFavoritesResponse => {

  let response = await fetch(
    ~url="/i/export-favorites",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postIExportFollowingRequest = {
  excludeMuting: option<bool>,
  excludeInactive: option<bool>,
}

let postIExportFollowingRequestSchema = S.object(s => {
    excludeMuting: s.field("excludeMuting", S.option(S.bool)),
    excludeInactive: s.field("excludeInactive", S.option(S.bool)),
  })

type postIExportFollowingResponse = unit

/**
i/export-following

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIExportFollowing = async (~body: postIExportFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIExportFollowingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIExportFollowingRequestSchema)
  let response = await fetch(
    ~url="/i/export-following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIExportMuteResponse = unit

/**
i/export-mute

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIExportMute = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIExportMuteResponse => {

  let response = await fetch(
    ~url="/i/export-mute",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postIExportNotesResponse = unit

/**
i/export-notes

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIExportNotes = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIExportNotesResponse => {

  let response = await fetch(
    ~url="/i/export-notes",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postIExportUserListsResponse = unit

/**
i/export-user-lists

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIExportUserLists = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIExportUserListsResponse => {

  let response = await fetch(
    ~url="/i/export-user-lists",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postIImportAntennasRequest = {
  fileId: string,
}

let postIImportAntennasRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
  })

type postIImportAntennasResponse = unit

/**
i/import-antennas

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIImportAntennas = async (~body: postIImportAntennasRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIImportAntennasResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportAntennasRequestSchema)
  let response = await fetch(
    ~url="/i/import-antennas",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIImportBlockingRequest = {
  fileId: string,
}

let postIImportBlockingRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
  })

type postIImportBlockingResponse = unit

/**
i/import-blocking

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIImportBlocking = async (~body: postIImportBlockingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIImportBlockingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportBlockingRequestSchema)
  let response = await fetch(
    ~url="/i/import-blocking",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIImportFollowingRequest = {
  fileId: string,
  withReplies: option<bool>,
}

let postIImportFollowingRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
    withReplies: s.field("withReplies", S.option(S.bool)),
  })

type postIImportFollowingResponse = unit

/**
i/import-following

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIImportFollowing = async (~body: postIImportFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIImportFollowingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportFollowingRequestSchema)
  let response = await fetch(
    ~url="/i/import-following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIImportMutingRequest = {
  fileId: string,
}

let postIImportMutingRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
  })

type postIImportMutingResponse = unit

/**
i/import-muting

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIImportMuting = async (~body: postIImportMutingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIImportMutingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportMutingRequestSchema)
  let response = await fetch(
    ~url="/i/import-muting",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIImportUserListsRequest = {
  fileId: string,
}

let postIImportUserListsRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
  })

type postIImportUserListsResponse = unit

/**
i/import-user-lists

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIImportUserLists = async (~body: postIImportUserListsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIImportUserListsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportUserListsRequestSchema)
  let response = await fetch(
    ~url="/i/import-user-lists",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIRegenerateTokenRequest = {
  password: string,
}

let postIRegenerateTokenRequestSchema = S.object(s => {
    password: s.field("password", S.string),
  })

type postIRegenerateTokenResponse = unit

/**
i/regenerate-token

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIRegenerateToken = async (~body: postIRegenerateTokenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIRegenerateTokenResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegenerateTokenRequestSchema)
  let response = await fetch(
    ~url="/i/regenerate-token",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIRegistryGetRequest = {
  key: string,
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryGetRequestSchema = S.object(s => {
    key: s.field("key", S.string),
    scope: s.field("scope", S.array(S.string->S.pattern(/^[a-zA-Z0-9_]+$/))),
    domain: s.field("domain", S.option(S.string)),
  })

type postIRegistryGetResponse = dict<JSON.t>

let postIRegistryGetResponseSchema = S.dict(S.json)

/**
i/registry/get

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postIRegistryGet = async (~body: postIRegistryGetRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIRegistryGetResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryGetRequestSchema)
  let response = await fetch(
    ~url="/i/registry/get",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIRegistryGetResponseSchema)
}

type postIRegistryGetAllRequest = {
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryGetAllRequestSchema = S.object(s => {
    scope: s.field("scope", S.array(S.string->S.pattern(/^[a-zA-Z0-9_]+$/))),
    domain: s.field("domain", S.option(S.string)),
  })

type postIRegistryGetAllResponse = dict<JSON.t>

let postIRegistryGetAllResponseSchema = S.dict(S.json)

/**
i/registry/get-all

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postIRegistryGetAll = async (~body: postIRegistryGetAllRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIRegistryGetAllResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryGetAllRequestSchema)
  let response = await fetch(
    ~url="/i/registry/get-all",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIRegistryGetAllResponseSchema)
}

type postIRegistryGetDetailRequest = {
  key: string,
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryGetDetailRequestSchema = S.object(s => {
    key: s.field("key", S.string),
    scope: s.field("scope", S.array(S.string->S.pattern(/^[a-zA-Z0-9_]+$/))),
    domain: s.field("domain", S.option(S.string)),
  })

type postIRegistryGetDetailResponse = {
  updatedAt: string,
  value: JSON.t,
}

let postIRegistryGetDetailResponseSchema = S.object(s => {
    updatedAt: s.field("updatedAt", S.string),
    value: s.field("value", S.json),
  })

/**
i/registry/get-detail

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postIRegistryGetDetail = async (~body: postIRegistryGetDetailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIRegistryGetDetailResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryGetDetailRequestSchema)
  let response = await fetch(
    ~url="/i/registry/get-detail",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIRegistryGetDetailResponseSchema)
}

type postIRegistryKeysRequest = {
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryKeysRequestSchema = S.object(s => {
    scope: s.field("scope", S.array(S.string->S.pattern(/^[a-zA-Z0-9_]+$/))),
    domain: s.field("domain", S.option(S.string)),
  })

type postIRegistryKeysResponse = array<string>

let postIRegistryKeysResponseSchema = S.array(S.string)

/**
i/registry/keys

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postIRegistryKeys = async (~body: postIRegistryKeysRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIRegistryKeysResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryKeysRequestSchema)
  let response = await fetch(
    ~url="/i/registry/keys",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIRegistryKeysResponseSchema)
}

type postIRegistryKeysWithTypeRequest = {
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryKeysWithTypeRequestSchema = S.object(s => {
    scope: s.field("scope", S.array(S.string->S.pattern(/^[a-zA-Z0-9_]+$/))),
    domain: s.field("domain", S.option(S.string)),
  })

type postIRegistryKeysWithTypeResponse = dict<JSON.t>

let postIRegistryKeysWithTypeResponseSchema = S.dict(S.json)

/**
i/registry/keys-with-type

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postIRegistryKeysWithType = async (~body: postIRegistryKeysWithTypeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIRegistryKeysWithTypeResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryKeysWithTypeRequestSchema)
  let response = await fetch(
    ~url="/i/registry/keys-with-type",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIRegistryKeysWithTypeResponseSchema)
}

type postIRegistryRemoveRequest = {
  key: string,
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryRemoveRequestSchema = S.object(s => {
    key: s.field("key", S.string),
    scope: s.field("scope", S.array(S.string->S.pattern(/^[a-zA-Z0-9_]+$/))),
    domain: s.field("domain", S.option(S.string)),
  })

type postIRegistryRemoveResponse = unit

/**
i/registry/remove

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIRegistryRemove = async (~body: postIRegistryRemoveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIRegistryRemoveResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryRemoveRequestSchema)
  let response = await fetch(
    ~url="/i/registry/remove",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIRegistryScopesWithDomainResponse_1 = {
  scopes: array<array<string>>,
  domain: option<string>,
}

type postIRegistryScopesWithDomainResponse = array<postIRegistryScopesWithDomainResponse_1>

let postIRegistryScopesWithDomainResponse_1Schema = S.object(s => {
    scopes: s.field("scopes", S.array(S.array(S.string))),
    domain: s.field("domain", S.nullableAsOption(S.string)),
  })

let postIRegistryScopesWithDomainResponseSchema = S.array(postIRegistryScopesWithDomainResponse_1Schema)

/**
i/registry/scopes-with-domain

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIRegistryScopesWithDomain = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIRegistryScopesWithDomainResponse => {

  let response = await fetch(
    ~url="/i/registry/scopes-with-domain",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postIRegistryScopesWithDomainResponseSchema)
}

type postIRegistrySetRequest = {
  key: string,
  value: JSON.t,
  scope: array<string>,
  domain: option<string>,
}

let postIRegistrySetRequestSchema = S.object(s => {
    key: s.field("key", S.string->S.min(1)),
    value: s.field("value", S.json),
    scope: s.field("scope", S.array(S.string->S.pattern(/^[a-zA-Z0-9_]+$/))),
    domain: s.field("domain", S.option(S.string)),
  })

type postIRegistrySetResponse = unit

/**
i/registry/set

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIRegistrySet = async (~body: postIRegistrySetRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIRegistrySetResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistrySetRequestSchema)
  let response = await fetch(
    ~url="/i/registry/set",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIRevokeTokenRequest = {
  tokenId: option<string>,
  token: option<string>,
}

let postIRevokeTokenRequestSchema = S.object(s => {
    tokenId: s.field("tokenId", S.option(S.string)),
    token: s.field("token", S.option(S.string)),
  })

type postIRevokeTokenResponse = unit

/**
i/revoke-token

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIRevokeToken = async (~body: postIRevokeTokenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIRevokeTokenResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRevokeTokenRequestSchema)
  let response = await fetch(
    ~url="/i/revoke-token",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postISigninHistoryRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postISigninHistoryRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postISigninHistoryResponse = array<MisskeyIoComponentSchemas.Signin.t>

let postISigninHistoryResponseSchema = S.array(MisskeyIoComponentSchemas.Signin.schema)

/**
i/signin-history

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postISigninHistory = async (~body: postISigninHistoryRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postISigninHistoryResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postISigninHistoryRequestSchema)
  let response = await fetch(
    ~url="/i/signin-history",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postISigninHistoryResponseSchema)
}

type postIUpdateEmailRequest = {
  password: string,
  email: option<string>,
  token: option<string>,
}

let postIUpdateEmailRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    email: s.field("email", S.option(S.string)),
    token: s.field("token", S.option(S.string)),
  })

type postIUpdateEmailResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postIUpdateEmailResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
i/update-email

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postIUpdateEmail = async (~body: postIUpdateEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIUpdateEmailResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateEmailRequestSchema)
  let response = await fetch(
    ~url="/i/update-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIUpdateEmailResponseSchema)
}

type postPagePushRequest = {
  pageId: string,
  event: string,
  var: option<JSON.t>,
}

let postPagePushRequestSchema = S.object(s => {
    pageId: s.field("pageId", S.string),
    event: s.field("event", S.string),
    var: s.field("var", S.option(S.json)),
  })

type postPagePushResponse = unit

/**
page-push

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postPagePush = async (~body: postPagePushRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postPagePushResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagePushRequestSchema)
  let response = await fetch(
    ~url="/page-push",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postReversiCancelMatchRequest = {
  userId: option<string>,
}

let postReversiCancelMatchRequestSchema = S.object(s => {
    userId: s.field("userId", S.option(S.string)),
  })

type postReversiCancelMatchResponse = unit

/**
reversi/cancel-match

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postReversiCancelMatch = async (~body: postReversiCancelMatchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postReversiCancelMatchResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiCancelMatchRequestSchema)
  let response = await fetch(
    ~url="/reversi/cancel-match",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postReversiGamesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  my: option<bool>,
}

let postReversiGamesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    my: s.field("my", S.option(S.bool)),
  })

type postReversiGamesResponse = array<MisskeyIoComponentSchemas.ReversiGameLite.t>

let postReversiGamesResponseSchema = S.array(MisskeyIoComponentSchemas.ReversiGameLite.schema)

/**
reversi/games

No description provided.

**Credential required**: *No*
*/
let postReversiGames = async (~body: postReversiGamesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postReversiGamesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiGamesRequestSchema)
  let response = await fetch(
    ~url="/reversi/games",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postReversiGamesResponseSchema)
}

type postReversiInvitationsResponse = array<MisskeyIoComponentSchemas.UserLite.t>

let postReversiInvitationsResponseSchema = S.array(MisskeyIoComponentSchemas.UserLite.schema)

/**
reversi/invitations

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postReversiInvitations = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postReversiInvitationsResponse => {

  let response = await fetch(
    ~url="/reversi/invitations",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postReversiInvitationsResponseSchema)
}

type postReversiMatchRequest = {
  userId: option<string>,
  noIrregularRules: option<bool>,
  multiple: option<bool>,
}

let postReversiMatchRequestSchema = S.object(s => {
    userId: s.field("userId", S.option(S.string)),
    noIrregularRules: s.field("noIrregularRules", S.option(S.bool)),
    multiple: s.field("multiple", S.option(S.bool)),
  })

type postReversiMatchResponse = dict<JSON.t>

let postReversiMatchResponseSchema = S.dict(S.json)

/**
reversi/match

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postReversiMatch = async (~body: postReversiMatchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postReversiMatchResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiMatchRequestSchema)
  let response = await fetch(
    ~url="/reversi/match",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postReversiMatchResponseSchema)
}

type postReversiShowGameRequest = {
  gameId: string,
}

let postReversiShowGameRequestSchema = S.object(s => {
    gameId: s.field("gameId", S.string),
  })

type postReversiShowGameResponse = MisskeyIoComponentSchemas.ReversiGameDetailed.t

let postReversiShowGameResponseSchema = MisskeyIoComponentSchemas.ReversiGameDetailed.schema

/**
reversi/show-game

No description provided.

**Credential required**: *No*
*/
let postReversiShowGame = async (~body: postReversiShowGameRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postReversiShowGameResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiShowGameRequestSchema)
  let response = await fetch(
    ~url="/reversi/show-game",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postReversiShowGameResponseSchema)
}

type postReversiSurrenderRequest = {
  gameId: string,
}

let postReversiSurrenderRequestSchema = S.object(s => {
    gameId: s.field("gameId", S.string),
  })

type postReversiSurrenderResponse = unit

/**
reversi/surrender

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postReversiSurrender = async (~body: postReversiSurrenderRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postReversiSurrenderResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiSurrenderRequestSchema)
  let response = await fetch(
    ~url="/reversi/surrender",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postReversiVerifyRequest = {
  gameId: string,
  crc32: string,
}

let postReversiVerifyRequestSchema = S.object(s => {
    gameId: s.field("gameId", S.string),
    crc32: s.field("crc32", S.string),
  })

type postReversiVerifyResponse = {
  desynced: bool,
  game: option<MisskeyIoComponentSchemas.ReversiGameDetailed.t>,
}

let postReversiVerifyResponseSchema = S.object(s => {
    desynced: s.field("desynced", S.bool),
    game: s.field("game", S.option(MisskeyIoComponentSchemas.ReversiGameDetailed.schema)),
  })

/**
reversi/verify

No description provided.

**Credential required**: *No*
*/
let postReversiVerify = async (~body: postReversiVerifyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postReversiVerifyResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiVerifyRequestSchema)
  let response = await fetch(
    ~url="/reversi/verify",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postReversiVerifyResponseSchema)
}

type postUsersAchievementsRequest = {
  userId: string,
}

let postUsersAchievementsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postUsersAchievementsResponse_1 = {
  name: string,
  unlockedAt: float,
}

type postUsersAchievementsResponse = array<postUsersAchievementsResponse_1>

let postUsersAchievementsResponse_1Schema = S.object(s => {
    name: s.field("name", S.string),
    unlockedAt: s.field("unlockedAt", S.float),
  })

let postUsersAchievementsResponseSchema = S.array(postUsersAchievementsResponse_1Schema)

/**
users/achievements

No description provided.

**Credential required**: *No*
*/
let postUsersAchievements = async (~body: postUsersAchievementsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersAchievementsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersAchievementsRequestSchema)
  let response = await fetch(
    ~url="/users/achievements",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersAchievementsResponseSchema)
}

type postUsersListsCreateFromPublicRequest = {
  name: string,
  listId: string,
}

let postUsersListsCreateFromPublicRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
    listId: s.field("listId", S.string),
  })

type postUsersListsCreateFromPublicResponse = MisskeyIoComponentSchemas.UserList.t

let postUsersListsCreateFromPublicResponseSchema = MisskeyIoComponentSchemas.UserList.schema

/**
users/lists/create-from-public

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postUsersListsCreateFromPublic = async (~body: postUsersListsCreateFromPublicRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersListsCreateFromPublicResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsCreateFromPublicRequestSchema)
  let response = await fetch(
    ~url="/users/lists/create-from-public",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersListsCreateFromPublicResponseSchema)
}

type postUsersListsFavoriteRequest = {
  listId: string,
}

let postUsersListsFavoriteRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
  })

type postUsersListsFavoriteResponse = unit

/**
users/lists/favorite

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postUsersListsFavorite = async (~body: postUsersListsFavoriteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersListsFavoriteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsFavoriteRequestSchema)
  let response = await fetch(
    ~url="/users/lists/favorite",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postUsersListsUnfavoriteRequest = {
  listId: string,
}

let postUsersListsUnfavoriteRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
  })

type postUsersListsUnfavoriteResponse = unit

/**
users/lists/unfavorite

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postUsersListsUnfavorite = async (~body: postUsersListsUnfavoriteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersListsUnfavoriteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsUnfavoriteRequestSchema)
  let response = await fetch(
    ~url="/users/lists/unfavorite",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}
