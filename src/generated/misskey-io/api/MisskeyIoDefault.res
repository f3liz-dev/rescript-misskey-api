// misskey-io API for default
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postAdminEmojiImportZipRequest = {
  fileId: string,
}

let postAdminEmojiImportZipRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
  })

type postAdminEmojiImportZipResponse = unit

/**
 * admin/emoji/import-zip
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postAdminEmojiImportZip = (~body: postAdminEmojiImportZipRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiImportZipResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiImportZipRequestSchema)
  fetch(
    ~url="/admin/emoji/import-zip",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type getBubbleGameRankingRequest = {
  gameMode: string,
}

let getBubbleGameRankingRequestSchema = S.object(s => {
    gameMode: s.field("gameMode", S.string),
  })

type getBubbleGameRankingResponse_1 = {
  id: string,
  score: int,
  user: option<dict<JSON.t>>,
}

type getBubbleGameRankingResponse = array<getBubbleGameRankingResponse_1>

let getBubbleGameRankingResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    score: s.field("score", S.int),
    user: s.fieldOr("user", S.nullableAsOption(S.dict(S.json)), None),
  })

let getBubbleGameRankingResponseSchema = S.array(getBubbleGameRankingResponse_1Schema)

/**
 * bubble-game/ranking
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getBubbleGameRanking = (~body: getBubbleGameRankingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getBubbleGameRankingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getBubbleGameRankingRequestSchema)
  fetch(
    ~url="/bubble-game/ranking",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getBubbleGameRankingResponseSchema)
  value
    ->Promise.resolve
  })
}

type postBubbleGameRankingRequest = {
  gameMode: string,
}

let postBubbleGameRankingRequestSchema = S.object(s => {
    gameMode: s.field("gameMode", S.string),
  })

type postBubbleGameRankingResponse_1 = {
  id: string,
  score: int,
  user: option<dict<JSON.t>>,
}

type postBubbleGameRankingResponse = array<postBubbleGameRankingResponse_1>

let postBubbleGameRankingResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    score: s.field("score", S.int),
    user: s.fieldOr("user", S.nullableAsOption(S.dict(S.json)), None),
  })

let postBubbleGameRankingResponseSchema = S.array(postBubbleGameRankingResponse_1Schema)

/**
 * bubble-game/ranking
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postBubbleGameRanking = (~body: postBubbleGameRankingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBubbleGameRankingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBubbleGameRankingRequestSchema)
  fetch(
    ~url="/bubble-game/ranking",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postBubbleGameRankingResponseSchema)
  value
    ->Promise.resolve
  })
}

type postBubbleGameRegisterRequest = {
  score: int,
  seed: string,
  logs: array<array<float>>,
  gameMode: string,
  gameVersion: int,
}

let postBubbleGameRegisterRequestSchema = S.object(s => {
    score: s.field("score", S.int->S.min(0)),
    seed: s.field("seed", S.string->S.min(1)->S.max(1024)),
    logs: s.field("logs", S.array(S.array(S.float))),
    gameMode: s.field("gameMode", S.string),
    gameVersion: s.field("gameVersion", S.int),
  })

type postBubbleGameRegisterResponse = unit

/**
 * bubble-game/register
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postBubbleGameRegister = (~body: postBubbleGameRegisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBubbleGameRegisterResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBubbleGameRegisterRequestSchema)
  fetch(
    ~url="/bubble-game/register",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postExportCustomEmojisResponse = unit

/**
 * export-custom-emojis
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postExportCustomEmojis = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postExportCustomEmojisResponse> => {

  fetch(
    ~url="/export-custom-emojis",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postI2faDoneRequest = {
  token: string,
}

let postI2faDoneRequestSchema = S.object(s => {
    token: s.field("token", S.string),
  })

type postI2faDoneResponse = {
  backupCodes: array<string>,
}

let postI2faDoneResponseSchema = S.object(s => {
    backupCodes: s.field("backupCodes", S.array(S.string)),
  })

/**
 * i/2fa/done
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postI2faDone = (~body: postI2faDoneRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faDoneResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faDoneRequestSchema)
  fetch(
    ~url="/i/2fa/done",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postI2faDoneResponseSchema)
  value
    ->Promise.resolve
  })
}

type postI2faKeyDoneRequest = {
  password: string,
  token: option<string>,
  name: string,
  credential: dict<JSON.t>,
}

let postI2faKeyDoneRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.fieldOr("token", S.nullableAsOption(S.string), None),
    name: s.field("name", S.string->S.min(1)->S.max(30)),
    credential: s.field("credential", S.dict(S.json)),
  })

type postI2faKeyDoneResponse = {
  id: string,
  name: string,
}

let postI2faKeyDoneResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
  })

/**
 * i/2fa/key-done
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postI2faKeyDone = (~body: postI2faKeyDoneRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faKeyDoneResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faKeyDoneRequestSchema)
  fetch(
    ~url="/i/2fa/key-done",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postI2faKeyDoneResponseSchema)
  value
    ->Promise.resolve
  })
}

type postI2faPasswordLessRequest = {
  value: bool,
}

let postI2faPasswordLessRequestSchema = S.object(s => {
    value: s.field("value", S.bool),
  })

type postI2faPasswordLessResponse = unit

/**
 * i/2fa/password-less
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postI2faPasswordLess = (~body: postI2faPasswordLessRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faPasswordLessResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faPasswordLessRequestSchema)
  fetch(
    ~url="/i/2fa/password-less",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postI2faRegisterRequest = {
  password: string,
  token: option<string>,
}

let postI2faRegisterRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.fieldOr("token", S.nullableAsOption(S.string), None),
  })

type postI2faRegisterResponse = {
  qr: string,
  url: string,
  secret: string,
  label: string,
  issuer: string,
}

let postI2faRegisterResponseSchema = S.object(s => {
    qr: s.field("qr", S.string),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
    label: s.field("label", S.string),
    issuer: s.field("issuer", S.string),
  })

/**
 * i/2fa/register
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postI2faRegister = (~body: postI2faRegisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faRegisterResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faRegisterRequestSchema)
  fetch(
    ~url="/i/2fa/register",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postI2faRegisterResponseSchema)
  value
    ->Promise.resolve
  })
}

type postI2faRegisterKeyRequest = {
  password: string,
  token: option<string>,
}

let postI2faRegisterKeyRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.fieldOr("token", S.nullableAsOption(S.string), None),
  })

type postI2faRegisterKeyResponse_5 = {
  appid: option<string>,
  credProps: option<bool>,
  hmacCreateSecret: option<bool>,
}

type postI2faRegisterKeyResponse_4 = {
  authenticatorAttachment: string,
  requireResidentKey: bool,
  userVerification: string,
}

type postI2faRegisterKeyResponse_3 = {
  @as("type") type_: string,
  alg: float,
}

type postI2faRegisterKeyResponse_2 = {
  id: string,
  name: string,
  displayName: string,
}

type postI2faRegisterKeyResponse_1 = {
  id: option<string>,
}

type postI2faRegisterKeyResponse = {
  rp: postI2faRegisterKeyResponse_1,
  user: postI2faRegisterKeyResponse_2,
  challenge: string,
  pubKeyCredParams: array<postI2faRegisterKeyResponse_3>,
  timeout: option<float>,
  excludeCredentials: option<JSON.t>,
  authenticatorSelection: option<postI2faRegisterKeyResponse_4>,
  attestation: option<string>,
  extensions: option<postI2faRegisterKeyResponse_5>,
}

let postI2faRegisterKeyResponse_5Schema = S.object(s => {
    appid: s.field("appid", S.nullableAsOption(S.string)),
    credProps: s.field("credProps", S.nullableAsOption(S.bool)),
    hmacCreateSecret: s.field("hmacCreateSecret", S.nullableAsOption(S.bool)),
  })

let postI2faRegisterKeyResponse_4Schema = S.object(s => {
    authenticatorAttachment: s.field("authenticatorAttachment", S.string),
    requireResidentKey: s.field("requireResidentKey", S.bool),
    userVerification: s.field("userVerification", S.string),
  })

let postI2faRegisterKeyResponse_3Schema = S.object(s => {
    type_: s.field("type", S.string),
    alg: s.field("alg", S.float),
  })

let postI2faRegisterKeyResponse_2Schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    displayName: s.field("displayName", S.string),
  })

let postI2faRegisterKeyResponse_1Schema = S.object(s => {
    id: s.fieldOr("id", S.nullableAsOption(S.string), None),
  })

let postI2faRegisterKeyResponseSchema = S.object(s => {
    rp: s.field("rp", postI2faRegisterKeyResponse_1Schema),
    user: s.field("user", postI2faRegisterKeyResponse_2Schema),
    challenge: s.field("challenge", S.string),
    pubKeyCredParams: s.field("pubKeyCredParams", S.array(postI2faRegisterKeyResponse_3Schema)),
    timeout: s.field("timeout", S.nullableAsOption(S.float)),
    excludeCredentials: s.field("excludeCredentials", S.nullableAsOption(S.json)),
    authenticatorSelection: s.field("authenticatorSelection", S.nullableAsOption(postI2faRegisterKeyResponse_4Schema)),
    attestation: s.field("attestation", S.nullableAsOption(S.string)),
    extensions: s.field("extensions", S.nullableAsOption(postI2faRegisterKeyResponse_5Schema)),
  })

/**
 * i/2fa/register-key
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postI2faRegisterKey = (~body: postI2faRegisterKeyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faRegisterKeyResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faRegisterKeyRequestSchema)
  fetch(
    ~url="/i/2fa/register-key",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postI2faRegisterKeyResponseSchema)
  value
    ->Promise.resolve
  })
}

type postI2faRemoveKeyRequest = {
  password: string,
  token: option<string>,
  credentialId: string,
}

let postI2faRemoveKeyRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.fieldOr("token", S.nullableAsOption(S.string), None),
    credentialId: s.field("credentialId", S.string),
  })

type postI2faRemoveKeyResponse = unit

/**
 * i/2fa/remove-key
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postI2faRemoveKey = (~body: postI2faRemoveKeyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faRemoveKeyResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faRemoveKeyRequestSchema)
  fetch(
    ~url="/i/2fa/remove-key",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postI2faUnregisterRequest = {
  password: string,
  token: option<string>,
}

let postI2faUnregisterRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.fieldOr("token", S.nullableAsOption(S.string), None),
  })

type postI2faUnregisterResponse = unit

/**
 * i/2fa/unregister
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postI2faUnregister = (~body: postI2faUnregisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faUnregisterResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faUnregisterRequestSchema)
  fetch(
    ~url="/i/2fa/unregister",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postI2faUpdateKeyRequest = {
  name: string,
  credentialId: string,
}

let postI2faUpdateKeyRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(30)),
    credentialId: s.field("credentialId", S.string),
  })

type postI2faUpdateKeyResponse = unit

/**
 * i/2fa/update-key
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postI2faUpdateKey = (~body: postI2faUpdateKeyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postI2faUpdateKeyResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postI2faUpdateKeyRequestSchema)
  fetch(
    ~url="/i/2fa/update-key",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIAppsRequest = {
  sort: option<string>,
}

let postIAppsRequestSchema = S.object(s => {
    sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
  })

type postIAppsResponse_1 = {
  id: string,
  name: option<string>,
  createdAt: string,
  lastUsedAt: option<string>,
  permission: array<string>,
}

type postIAppsResponse = array<postIAppsResponse_1>

let postIAppsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    createdAt: s.field("createdAt", S.string),
    lastUsedAt: s.fieldOr("lastUsedAt", S.nullableAsOption(S.string), None),
    permission: s.field("permission", S.array(S.string)),
  })

let postIAppsResponseSchema = S.array(postIAppsResponse_1Schema)

/**
 * i/apps
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIApps = (~body: postIAppsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIAppsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIAppsRequestSchema)
  fetch(
    ~url="/i/apps",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIAppsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIAuthorizedAppsRequest = {
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
}

let postIAuthorizedAppsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
  })

type postIAuthorizedAppsResponse_1 = {
  id: string,
  name: string,
  callbackUrl: option<string>,
  permission: array<string>,
  isAuthorized: option<bool>,
}

type postIAuthorizedAppsResponse = array<postIAuthorizedAppsResponse_1>

let postIAuthorizedAppsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    callbackUrl: s.field("callbackUrl", S.nullableAsOption(S.string)),
    permission: s.field("permission", S.array(S.string)),
    isAuthorized: s.fieldOr("isAuthorized", S.nullableAsOption(S.bool), None),
  })

let postIAuthorizedAppsResponseSchema = S.array(postIAuthorizedAppsResponse_1Schema)

/**
 * i/authorized-apps
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIAuthorizedApps = (~body: postIAuthorizedAppsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIAuthorizedAppsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIAuthorizedAppsRequestSchema)
  fetch(
    ~url="/i/authorized-apps",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIAuthorizedAppsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIChangePasswordRequest = {
  currentPassword: string,
  newPassword: string,
  token: option<string>,
}

let postIChangePasswordRequestSchema = S.object(s => {
    currentPassword: s.field("currentPassword", S.string),
    newPassword: s.field("newPassword", S.string->S.min(1)),
    token: s.fieldOr("token", S.nullableAsOption(S.string), None),
  })

type postIChangePasswordResponse = unit

/**
 * i/change-password
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIChangePassword = (~body: postIChangePasswordRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIChangePasswordResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIChangePasswordRequestSchema)
  fetch(
    ~url="/i/change-password",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIClaimAchievementRequest = {
  name: string,
}

let postIClaimAchievementRequestSchema = S.object(s => {
    name: s.field("name", S.string),
  })

type postIClaimAchievementResponse = unit

/**
 * i/claim-achievement
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIClaimAchievement = (~body: postIClaimAchievementRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIClaimAchievementResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIClaimAchievementRequestSchema)
  fetch(
    ~url="/i/claim-achievement",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIDeleteAccountRequest = {
  password: string,
  token: option<string>,
}

let postIDeleteAccountRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    token: s.fieldOr("token", S.nullableAsOption(S.string), None),
  })

type postIDeleteAccountResponse = unit

/**
 * i/delete-account
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIDeleteAccount = (~body: postIDeleteAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIDeleteAccountResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIDeleteAccountRequestSchema)
  fetch(
    ~url="/i/delete-account",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIExportAntennasResponse = unit

/**
 * i/export-antennas
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIExportAntennas = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportAntennasResponse> => {

  fetch(
    ~url="/i/export-antennas",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIExportBlockingResponse = unit

/**
 * i/export-blocking
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIExportBlocking = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportBlockingResponse> => {

  fetch(
    ~url="/i/export-blocking",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIExportClipsResponse = unit

/**
 * i/export-clips
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIExportClips = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportClipsResponse> => {

  fetch(
    ~url="/i/export-clips",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIExportFavoritesResponse = unit

/**
 * i/export-favorites
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIExportFavorites = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportFavoritesResponse> => {

  fetch(
    ~url="/i/export-favorites",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIExportFollowingRequest = {
  excludeMuting: option<bool>,
  excludeInactive: option<bool>,
}

let postIExportFollowingRequestSchema = S.object(s => {
    excludeMuting: s.fieldOr("excludeMuting", S.nullableAsOption(S.bool), None),
    excludeInactive: s.fieldOr("excludeInactive", S.nullableAsOption(S.bool), None),
  })

type postIExportFollowingResponse = unit

/**
 * i/export-following
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIExportFollowing = (~body: postIExportFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportFollowingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIExportFollowingRequestSchema)
  fetch(
    ~url="/i/export-following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIExportMuteResponse = unit

/**
 * i/export-mute
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIExportMute = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportMuteResponse> => {

  fetch(
    ~url="/i/export-mute",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIExportNotesResponse = unit

/**
 * i/export-notes
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIExportNotes = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportNotesResponse> => {

  fetch(
    ~url="/i/export-notes",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIExportUserListsResponse = unit

/**
 * i/export-user-lists
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIExportUserLists = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIExportUserListsResponse> => {

  fetch(
    ~url="/i/export-user-lists",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIImportAntennasRequest = {
  fileId: string,
}

let postIImportAntennasRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
  })

type postIImportAntennasResponse = unit

/**
 * i/import-antennas
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIImportAntennas = (~body: postIImportAntennasRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIImportAntennasResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportAntennasRequestSchema)
  fetch(
    ~url="/i/import-antennas",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIImportBlockingRequest = {
  fileId: string,
}

let postIImportBlockingRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
  })

type postIImportBlockingResponse = unit

/**
 * i/import-blocking
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIImportBlocking = (~body: postIImportBlockingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIImportBlockingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportBlockingRequestSchema)
  fetch(
    ~url="/i/import-blocking",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIImportFollowingRequest = {
  fileId: string,
  withReplies: option<bool>,
}

let postIImportFollowingRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
  })

type postIImportFollowingResponse = unit

/**
 * i/import-following
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIImportFollowing = (~body: postIImportFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIImportFollowingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportFollowingRequestSchema)
  fetch(
    ~url="/i/import-following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIImportMutingRequest = {
  fileId: string,
}

let postIImportMutingRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
  })

type postIImportMutingResponse = unit

/**
 * i/import-muting
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIImportMuting = (~body: postIImportMutingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIImportMutingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportMutingRequestSchema)
  fetch(
    ~url="/i/import-muting",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIImportUserListsRequest = {
  fileId: string,
}

let postIImportUserListsRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
  })

type postIImportUserListsResponse = unit

/**
 * i/import-user-lists
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIImportUserLists = (~body: postIImportUserListsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIImportUserListsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIImportUserListsRequestSchema)
  fetch(
    ~url="/i/import-user-lists",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIRegenerateTokenRequest = {
  password: string,
}

let postIRegenerateTokenRequestSchema = S.object(s => {
    password: s.field("password", S.string),
  })

type postIRegenerateTokenResponse = unit

/**
 * i/regenerate-token
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIRegenerateToken = (~body: postIRegenerateTokenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegenerateTokenResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegenerateTokenRequestSchema)
  fetch(
    ~url="/i/regenerate-token",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIRegistryGetRequest = {
  key: string,
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryGetRequestSchema = S.object(s => {
    key: s.field("key", S.string),
    scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
    domain: s.fieldOr("domain", S.nullableAsOption(S.string), None),
  })

type postIRegistryGetResponse = dict<JSON.t>

let postIRegistryGetResponseSchema = S.dict(S.json)

/**
 * i/registry/get
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIRegistryGet = (~body: postIRegistryGetRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryGetResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryGetRequestSchema)
  fetch(
    ~url="/i/registry/get",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIRegistryGetResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIRegistryGetAllRequest = {
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryGetAllRequestSchema = S.object(s => {
    scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
    domain: s.fieldOr("domain", S.nullableAsOption(S.string), None),
  })

type postIRegistryGetAllResponse = dict<JSON.t>

let postIRegistryGetAllResponseSchema = S.dict(S.json)

/**
 * i/registry/get-all
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIRegistryGetAll = (~body: postIRegistryGetAllRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryGetAllResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryGetAllRequestSchema)
  fetch(
    ~url="/i/registry/get-all",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIRegistryGetAllResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIRegistryGetDetailRequest = {
  key: string,
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryGetDetailRequestSchema = S.object(s => {
    key: s.field("key", S.string),
    scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
    domain: s.fieldOr("domain", S.nullableAsOption(S.string), None),
  })

type postIRegistryGetDetailResponse = {
  updatedAt: string,
  value: JSON.t,
}

let postIRegistryGetDetailResponseSchema = S.object(s => {
    updatedAt: s.field("updatedAt", S.string),
    value: s.field("value", S.json),
  })

/**
 * i/registry/get-detail
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIRegistryGetDetail = (~body: postIRegistryGetDetailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryGetDetailResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryGetDetailRequestSchema)
  fetch(
    ~url="/i/registry/get-detail",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIRegistryGetDetailResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIRegistryKeysRequest = {
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryKeysRequestSchema = S.object(s => {
    scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
    domain: s.fieldOr("domain", S.nullableAsOption(S.string), None),
  })

type postIRegistryKeysResponse = array<string>

let postIRegistryKeysResponseSchema = S.array(S.string)

/**
 * i/registry/keys
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIRegistryKeys = (~body: postIRegistryKeysRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryKeysResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryKeysRequestSchema)
  fetch(
    ~url="/i/registry/keys",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIRegistryKeysResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIRegistryKeysWithTypeRequest = {
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryKeysWithTypeRequestSchema = S.object(s => {
    scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
    domain: s.fieldOr("domain", S.nullableAsOption(S.string), None),
  })

type postIRegistryKeysWithTypeResponse = dict<JSON.t>

let postIRegistryKeysWithTypeResponseSchema = S.dict(S.json)

/**
 * i/registry/keys-with-type
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIRegistryKeysWithType = (~body: postIRegistryKeysWithTypeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryKeysWithTypeResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryKeysWithTypeRequestSchema)
  fetch(
    ~url="/i/registry/keys-with-type",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIRegistryKeysWithTypeResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIRegistryRemoveRequest = {
  key: string,
  scope: array<string>,
  domain: option<string>,
}

let postIRegistryRemoveRequestSchema = S.object(s => {
    key: s.field("key", S.string),
    scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
    domain: s.fieldOr("domain", S.nullableAsOption(S.string), None),
  })

type postIRegistryRemoveResponse = unit

/**
 * i/registry/remove
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIRegistryRemove = (~body: postIRegistryRemoveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryRemoveResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistryRemoveRequestSchema)
  fetch(
    ~url="/i/registry/remove",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIRegistryScopesWithDomainResponse_1 = {
  scopes: array<array<string>>,
  domain: option<string>,
}

type postIRegistryScopesWithDomainResponse = array<postIRegistryScopesWithDomainResponse_1>

let postIRegistryScopesWithDomainResponse_1Schema = S.object(s => {
    scopes: s.field("scopes", S.array(S.array(S.string))),
    domain: s.field("domain", S.nullableAsOption(S.string)),
  })

let postIRegistryScopesWithDomainResponseSchema = S.array(postIRegistryScopesWithDomainResponse_1Schema)

/**
 * i/registry/scopes-with-domain
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIRegistryScopesWithDomain = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistryScopesWithDomainResponse> => {

  fetch(
    ~url="/i/registry/scopes-with-domain",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIRegistryScopesWithDomainResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIRegistrySetRequest = {
  key: string,
  value: JSON.t,
  scope: array<string>,
  domain: option<string>,
}

let postIRegistrySetRequestSchema = S.object(s => {
    key: s.field("key", S.string->S.min(1)),
    value: s.field("value", S.json),
    scope: s.field("scope", S.array(S.string->S.pattern(%re("/^[a-zA-Z0-9_]+$/")))),
    domain: s.fieldOr("domain", S.nullableAsOption(S.string), None),
  })

type postIRegistrySetResponse = unit

/**
 * i/registry/set
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIRegistrySet = (~body: postIRegistrySetRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRegistrySetResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRegistrySetRequestSchema)
  fetch(
    ~url="/i/registry/set",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIRevokeTokenRequest = {
  tokenId: option<string>,
  token: option<string>,
}

let postIRevokeTokenRequestSchema = S.object(s => {
    tokenId: s.fieldOr("tokenId", S.nullableAsOption(S.string), None),
    token: s.fieldOr("token", S.nullableAsOption(S.string), None),
  })

type postIRevokeTokenResponse = unit

/**
 * i/revoke-token
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIRevokeToken = (~body: postIRevokeTokenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIRevokeTokenResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIRevokeTokenRequestSchema)
  fetch(
    ~url="/i/revoke-token",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postISigninHistoryRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postISigninHistoryRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postISigninHistoryResponse = array<MisskeyIoComponentSchemas.Signin.t>

let postISigninHistoryResponseSchema = S.array(MisskeyIoComponentSchemas.Signin.schema)

/**
 * i/signin-history
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postISigninHistory = (~body: postISigninHistoryRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postISigninHistoryResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postISigninHistoryRequestSchema)
  fetch(
    ~url="/i/signin-history",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postISigninHistoryResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIUpdateEmailRequest = {
  password: string,
  email: option<string>,
  token: option<string>,
}

let postIUpdateEmailRequestSchema = S.object(s => {
    password: s.field("password", S.string),
    email: s.fieldOr("email", S.nullableAsOption(S.string), None),
    token: s.fieldOr("token", S.nullableAsOption(S.string), None),
  })

type postIUpdateEmailResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postIUpdateEmailResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
 * i/update-email
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIUpdateEmail = (~body: postIUpdateEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIUpdateEmailResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateEmailRequestSchema)
  fetch(
    ~url="/i/update-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIUpdateEmailResponseSchema)
  value
    ->Promise.resolve
  })
}

type postPagePushRequest = {
  pageId: string,
  event: string,
  var: option<JSON.t>,
}

let postPagePushRequestSchema = S.object(s => {
    pageId: s.field("pageId", S.string),
    event: s.field("event", S.string),
    var: s.fieldOr("var", S.nullableAsOption(S.json), None),
  })

type postPagePushResponse = unit

/**
 * page-push
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postPagePush = (~body: postPagePushRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagePushResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagePushRequestSchema)
  fetch(
    ~url="/page-push",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postReversiCancelMatchRequest = {
  userId: option<string>,
}

let postReversiCancelMatchRequestSchema = S.object(s => {
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
  })

type postReversiCancelMatchResponse = unit

/**
 * reversi/cancel-match
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postReversiCancelMatch = (~body: postReversiCancelMatchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiCancelMatchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiCancelMatchRequestSchema)
  fetch(
    ~url="/reversi/cancel-match",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postReversiGamesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  my: option<bool>,
}

let postReversiGamesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    my: s.fieldOr("my", S.nullableAsOption(S.bool), None),
  })

type postReversiGamesResponse = array<MisskeyIoComponentSchemas.ReversiGameLite.t>

let postReversiGamesResponseSchema = S.array(MisskeyIoComponentSchemas.ReversiGameLite.schema)

/**
 * reversi/games
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postReversiGames = (~body: postReversiGamesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiGamesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiGamesRequestSchema)
  fetch(
    ~url="/reversi/games",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postReversiGamesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postReversiInvitationsResponse = array<MisskeyIoComponentSchemas.UserLite.t>

let postReversiInvitationsResponseSchema = S.array(MisskeyIoComponentSchemas.UserLite.schema)

/**
 * reversi/invitations
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postReversiInvitations = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiInvitationsResponse> => {

  fetch(
    ~url="/reversi/invitations",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postReversiInvitationsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postReversiMatchRequest = {
  userId: option<string>,
  noIrregularRules: option<bool>,
  multiple: option<bool>,
}

let postReversiMatchRequestSchema = S.object(s => {
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    noIrregularRules: s.fieldOr("noIrregularRules", S.nullableAsOption(S.bool), None),
    multiple: s.fieldOr("multiple", S.nullableAsOption(S.bool), None),
  })

type postReversiMatchResponse = dict<JSON.t>

let postReversiMatchResponseSchema = S.dict(S.json)

/**
 * reversi/match
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postReversiMatch = (~body: postReversiMatchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiMatchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiMatchRequestSchema)
  fetch(
    ~url="/reversi/match",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postReversiMatchResponseSchema)
  value
    ->Promise.resolve
  })
}

type postReversiShowGameRequest = {
  gameId: string,
}

let postReversiShowGameRequestSchema = S.object(s => {
    gameId: s.field("gameId", S.string),
  })

type postReversiShowGameResponse = MisskeyIoComponentSchemas.ReversiGameDetailed.t

let postReversiShowGameResponseSchema = MisskeyIoComponentSchemas.ReversiGameDetailed.schema

/**
 * reversi/show-game
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postReversiShowGame = (~body: postReversiShowGameRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiShowGameResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiShowGameRequestSchema)
  fetch(
    ~url="/reversi/show-game",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postReversiShowGameResponseSchema)
  value
    ->Promise.resolve
  })
}

type postReversiSurrenderRequest = {
  gameId: string,
}

let postReversiSurrenderRequestSchema = S.object(s => {
    gameId: s.field("gameId", S.string),
  })

type postReversiSurrenderResponse = unit

/**
 * reversi/surrender
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postReversiSurrender = (~body: postReversiSurrenderRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiSurrenderResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiSurrenderRequestSchema)
  fetch(
    ~url="/reversi/surrender",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postReversiVerifyRequest = {
  gameId: string,
  crc32: string,
}

let postReversiVerifyRequestSchema = S.object(s => {
    gameId: s.field("gameId", S.string),
    crc32: s.field("crc32", S.string),
  })

type postReversiVerifyResponse = {
  desynced: bool,
  game: option<MisskeyIoComponentSchemas.ReversiGameDetailed.t>,
}

let postReversiVerifyResponseSchema = S.object(s => {
    desynced: s.field("desynced", S.bool),
    game: s.fieldOr("game", S.nullableAsOption(MisskeyIoComponentSchemas.ReversiGameDetailed.schema), None),
  })

/**
 * reversi/verify
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postReversiVerify = (~body: postReversiVerifyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postReversiVerifyResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postReversiVerifyRequestSchema)
  fetch(
    ~url="/reversi/verify",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postReversiVerifyResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersAchievementsRequest = {
  userId: string,
}

let postUsersAchievementsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postUsersAchievementsResponse_1 = {
  name: string,
  unlockedAt: float,
}

type postUsersAchievementsResponse = array<postUsersAchievementsResponse_1>

let postUsersAchievementsResponse_1Schema = S.object(s => {
    name: s.field("name", S.string),
    unlockedAt: s.field("unlockedAt", S.float),
  })

let postUsersAchievementsResponseSchema = S.array(postUsersAchievementsResponse_1Schema)

/**
 * users/achievements
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsersAchievements = (~body: postUsersAchievementsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersAchievementsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersAchievementsRequestSchema)
  fetch(
    ~url="/users/achievements",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersAchievementsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersListsCreateFromPublicRequest = {
  name: string,
  listId: string,
}

let postUsersListsCreateFromPublicRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
    listId: s.field("listId", S.string),
  })

type postUsersListsCreateFromPublicResponse = MisskeyIoComponentSchemas.UserList.t

let postUsersListsCreateFromPublicResponseSchema = MisskeyIoComponentSchemas.UserList.schema

/**
 * users/lists/create-from-public
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postUsersListsCreateFromPublic = (~body: postUsersListsCreateFromPublicRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsCreateFromPublicResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsCreateFromPublicRequestSchema)
  fetch(
    ~url="/users/lists/create-from-public",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersListsCreateFromPublicResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersListsFavoriteRequest = {
  listId: string,
}

let postUsersListsFavoriteRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
  })

type postUsersListsFavoriteResponse = unit

/**
 * users/lists/favorite
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postUsersListsFavorite = (~body: postUsersListsFavoriteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsFavoriteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsFavoriteRequestSchema)
  fetch(
    ~url="/users/lists/favorite",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postUsersListsUnfavoriteRequest = {
  listId: string,
}

let postUsersListsUnfavoriteRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
  })

type postUsersListsUnfavoriteResponse = unit

/**
 * users/lists/unfavorite
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postUsersListsUnfavorite = (~body: postUsersListsUnfavoriteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsUnfavoriteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsUnfavoriteRequestSchema)
  fetch(
    ~url="/users/lists/unfavorite",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}
