// misskey-io API for account
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postBlockingCreateRequest = {
  userId: string,
}

let postBlockingCreateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postBlockingCreateResponse = MisskeyIoComponentSchemas.UserDetailedNotMe.t

let postBlockingCreateResponseSchema = MisskeyIoComponentSchemas.UserDetailedNotMe.schema

/**
 * blocking/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:blocks*
 */
let postBlockingCreate = (~body: postBlockingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBlockingCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingCreateRequestSchema)
  fetch(
    ~url="/blocking/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postBlockingCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postBlockingDeleteRequest = {
  userId: string,
}

let postBlockingDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postBlockingDeleteResponse = MisskeyIoComponentSchemas.UserDetailedNotMe.t

let postBlockingDeleteResponseSchema = MisskeyIoComponentSchemas.UserDetailedNotMe.schema

/**
 * blocking/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:blocks*
 */
let postBlockingDelete = (~body: postBlockingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBlockingDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingDeleteRequestSchema)
  fetch(
    ~url="/blocking/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postBlockingDeleteResponseSchema)
  value
    ->Promise.resolve
  })
}

type postBlockingListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postBlockingListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postBlockingListResponse = array<MisskeyIoComponentSchemas.Blocking.t>

let postBlockingListResponseSchema = S.array(MisskeyIoComponentSchemas.Blocking.schema)

/**
 * blocking/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:blocks*
 */
let postBlockingList = (~body: postBlockingListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postBlockingListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingListRequestSchema)
  fetch(
    ~url="/blocking/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postBlockingListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postClipsAddNoteRequest = {
  clipId: string,
  noteId: string,
}

let postClipsAddNoteRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
    noteId: s.field("noteId", S.string),
  })

type postClipsAddNoteResponse = unit

/**
 * clips/add-note
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postClipsAddNote = (~body: postClipsAddNoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsAddNoteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsAddNoteRequestSchema)
  fetch(
    ~url="/clips/add-note",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postClipsMyFavoritesResponse = array<MisskeyIoComponentSchemas.Clip.t>

let postClipsMyFavoritesResponseSchema = S.array(MisskeyIoComponentSchemas.Clip.schema)

/**
 * clips/my-favorites
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:clip-favorite*
 */
let postClipsMyFavorites = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsMyFavoritesResponse> => {

  fetch(
    ~url="/clips/my-favorites",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postClipsMyFavoritesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postClipsNotesRequest = {
  clipId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postClipsNotesRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postClipsNotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postClipsNotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
 * clips/notes
 *
 * No description provided.
 *
 * **Credential required**: *No* / **Permission**: *read:account*
 */
let postClipsNotes = (~body: postClipsNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsNotesRequestSchema)
  fetch(
    ~url="/clips/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postClipsNotesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postClipsRemoveNoteRequest = {
  clipId: string,
  noteId: string,
}

let postClipsRemoveNoteRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
    noteId: s.field("noteId", S.string),
  })

type postClipsRemoveNoteResponse = unit

/**
 * clips/remove-note
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postClipsRemoveNote = (~body: postClipsRemoveNoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postClipsRemoveNoteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsRemoveNoteRequestSchema)
  fetch(
    ~url="/clips/remove-note",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postFlashMyRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postFlashMyRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postFlashMyResponse = array<MisskeyIoComponentSchemas.Flash.t>

let postFlashMyResponseSchema = S.array(MisskeyIoComponentSchemas.Flash.schema)

/**
 * flash/my
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:flash*
 */
let postFlashMy = (~body: postFlashMyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashMyResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashMyRequestSchema)
  fetch(
    ~url="/flash/my",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFlashMyResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFlashMyLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postFlashMyLikesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postFlashMyLikesResponse_1 = {
  id: string,
  flash: MisskeyIoComponentSchemas.Flash.t,
}

type postFlashMyLikesResponse = array<postFlashMyLikesResponse_1>

let postFlashMyLikesResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    flash: s.field("flash", MisskeyIoComponentSchemas.Flash.schema),
  })

let postFlashMyLikesResponseSchema = S.array(postFlashMyLikesResponse_1Schema)

/**
 * flash/my-likes
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:flash-likes*
 */
let postFlashMyLikes = (~body: postFlashMyLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashMyLikesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashMyLikesRequestSchema)
  fetch(
    ~url="/flash/my-likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFlashMyLikesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postIResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
 * i
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postI = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIResponse> => {

  fetch(
    ~url="/i",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIFavoritesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIFavoritesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postIFavoritesResponse = array<MisskeyIoComponentSchemas.NoteFavorite.t>

let postIFavoritesResponseSchema = S.array(MisskeyIoComponentSchemas.NoteFavorite.schema)

/**
 * i/favorites
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:favorites*
 */
let postIFavorites = (~body: postIFavoritesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIFavoritesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIFavoritesRequestSchema)
  fetch(
    ~url="/i/favorites",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIFavoritesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIGalleryLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIGalleryLikesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postIGalleryLikesResponse_1 = {
  id: string,
  post: MisskeyIoComponentSchemas.GalleryPost.t,
}

type postIGalleryLikesResponse = array<postIGalleryLikesResponse_1>

let postIGalleryLikesResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    post: s.field("post", MisskeyIoComponentSchemas.GalleryPost.schema),
  })

let postIGalleryLikesResponseSchema = S.array(postIGalleryLikesResponse_1Schema)

/**
 * i/gallery/likes
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:gallery-likes*
 */
let postIGalleryLikes = (~body: postIGalleryLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIGalleryLikesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIGalleryLikesRequestSchema)
  fetch(
    ~url="/i/gallery/likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIGalleryLikesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIGalleryPostsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIGalleryPostsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postIGalleryPostsResponse = array<MisskeyIoComponentSchemas.GalleryPost.t>

let postIGalleryPostsResponseSchema = S.array(MisskeyIoComponentSchemas.GalleryPost.schema)

/**
 * i/gallery/posts
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:gallery*
 */
let postIGalleryPosts = (~body: postIGalleryPostsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIGalleryPostsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIGalleryPostsRequestSchema)
  fetch(
    ~url="/i/gallery/posts",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIGalleryPostsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postINotificationsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  markAsRead: option<bool>,
  includeTypes: option<array<string>>,
  excludeTypes: option<array<string>>,
}

let postINotificationsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    markAsRead: s.fieldOr("markAsRead", S.nullableAsOption(S.bool), None),
    includeTypes: s.fieldOr("includeTypes", S.nullableAsOption(S.array(S.string)), None),
    excludeTypes: s.fieldOr("excludeTypes", S.nullableAsOption(S.array(S.string)), None),
  })

type postINotificationsResponse = array<MisskeyIoComponentSchemas.Notification.t>

let postINotificationsResponseSchema = S.array(MisskeyIoComponentSchemas.Notification.schema)

/**
 * i/notifications
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:notifications*
 */
let postINotifications = (~body: postINotificationsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postINotificationsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postINotificationsRequestSchema)
  fetch(
    ~url="/i/notifications",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postINotificationsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postINotificationsGroupedRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  markAsRead: option<bool>,
  includeTypes: option<array<string>>,
  excludeTypes: option<array<string>>,
}

let postINotificationsGroupedRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    markAsRead: s.fieldOr("markAsRead", S.nullableAsOption(S.bool), None),
    includeTypes: s.fieldOr("includeTypes", S.nullableAsOption(S.array(S.string)), None),
    excludeTypes: s.fieldOr("excludeTypes", S.nullableAsOption(S.array(S.string)), None),
  })

type postINotificationsGroupedResponse = array<MisskeyIoComponentSchemas.Notification.t>

let postINotificationsGroupedResponseSchema = S.array(MisskeyIoComponentSchemas.Notification.schema)

/**
 * i/notifications-grouped
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:notifications*
 */
let postINotificationsGrouped = (~body: postINotificationsGroupedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postINotificationsGroupedResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postINotificationsGroupedRequestSchema)
  fetch(
    ~url="/i/notifications-grouped",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postINotificationsGroupedResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIPageLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIPageLikesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postIPageLikesResponse_1 = {
  id: string,
  page: MisskeyIoComponentSchemas.Page.t,
}

type postIPageLikesResponse = array<postIPageLikesResponse_1>

let postIPageLikesResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    page: s.field("page", MisskeyIoComponentSchemas.Page.schema),
  })

let postIPageLikesResponseSchema = S.array(postIPageLikesResponse_1Schema)

/**
 * i/page-likes
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:page-likes*
 */
let postIPageLikes = (~body: postIPageLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIPageLikesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPageLikesRequestSchema)
  fetch(
    ~url="/i/page-likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIPageLikesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIPagesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIPagesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postIPagesResponse = array<MisskeyIoComponentSchemas.Page.t>

let postIPagesResponseSchema = S.array(MisskeyIoComponentSchemas.Page.schema)

/**
 * i/pages
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:pages*
 */
let postIPages = (~body: postIPagesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIPagesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPagesRequestSchema)
  fetch(
    ~url="/i/pages",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIPagesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIPinRequest = {
  noteId: string,
}

let postIPinRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postIPinResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postIPinResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
 * i/pin
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIPin = (~body: postIPinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIPinResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPinRequestSchema)
  fetch(
    ~url="/i/pin",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIPinResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIPurgeTimelineCacheRequest = {
  @as("type") type_: string,
  listId: option<string>,
  antennaId: option<string>,
}

let postIPurgeTimelineCacheRequestSchema = S.object(s => {
    type_: s.field("type", S.string),
    listId: s.fieldOr("listId", S.nullableAsOption(S.string), None),
    antennaId: s.fieldOr("antennaId", S.nullableAsOption(S.string), None),
  })

type postIPurgeTimelineCacheResponse = unit

/**
 * i/purge-timeline-cache
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIPurgeTimelineCache = (~body: postIPurgeTimelineCacheRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIPurgeTimelineCacheResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPurgeTimelineCacheRequestSchema)
  fetch(
    ~url="/i/purge-timeline-cache",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIReadAnnouncementRequest = {
  announcementId: string,
}

let postIReadAnnouncementRequestSchema = S.object(s => {
    announcementId: s.field("announcementId", S.string),
  })

type postIReadAnnouncementResponse = unit

/**
 * i/read-announcement
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIReadAnnouncement = (~body: postIReadAnnouncementRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIReadAnnouncementResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIReadAnnouncementRequestSchema)
  fetch(
    ~url="/i/read-announcement",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIUnpinRequest = {
  noteId: string,
}

let postIUnpinRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postIUnpinResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postIUnpinResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
 * i/unpin
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIUnpin = (~body: postIUnpinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIUnpinResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUnpinRequestSchema)
  fetch(
    ~url="/i/unpin",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIUnpinResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIUpdateRequest_5 = {
  url: string,
  fileId: string,
  description: option<string>,
}

type postIUpdateRequest_4 = {
  name: option<string>,
  mutualLinks: array<postIUpdateRequest_5>,
}

type postIUpdateRequest_3 = {
  note: option<dict<JSON.t>>,
  follow: option<dict<JSON.t>>,
  mention: option<dict<JSON.t>>,
  reply: option<dict<JSON.t>>,
  renote: option<dict<JSON.t>>,
  quote: option<dict<JSON.t>>,
  reaction: option<dict<JSON.t>>,
  pollEnded: option<dict<JSON.t>>,
  receiveFollowRequest: option<dict<JSON.t>>,
  followRequestAccepted: option<dict<JSON.t>>,
  roleAssigned: option<dict<JSON.t>>,
  chatRoomInvitationReceived: option<dict<JSON.t>>,
  achievementEarned: option<dict<JSON.t>>,
  app: option<dict<JSON.t>>,
  test: option<dict<JSON.t>>,
}

type postIUpdateRequest_2 = {
  name: string,
  value: string,
}

type postIUpdateRequest_1 = {
  id: string,
  angle: option<float>,
  flipH: option<bool>,
  offsetX: option<float>,
  offsetY: option<float>,
}

type postIUpdateRequest = {
  name: option<string>,
  description: option<string>,
  followedMessage: option<string>,
  location: option<string>,
  birthday: option<string>,
  lang: option<string>,
  postingLang: option<string>,
  viewingLangs: option<array<string>>,
  showMediaInAllLanguages: option<bool>,
  showHashtagsInAllLanguages: option<bool>,
  avatarId: option<string>,
  avatarDecorations: option<array<postIUpdateRequest_1>>,
  bannerId: option<string>,
  fields: option<array<postIUpdateRequest_2>>,
  isLocked: option<bool>,
  isExplorable: option<bool>,
  hideOnlineStatus: option<bool>,
  publicReactions: option<bool>,
  carefulBot: option<bool>,
  autoAcceptFollowed: option<bool>,
  noCrawle: option<bool>,
  preventAiLearning: option<bool>,
  requireSigninToViewContents: option<bool>,
  makeNotesFollowersOnlyBefore: option<int>,
  makeNotesHiddenBefore: option<int>,
  isBot: option<bool>,
  isCat: option<bool>,
  injectFeaturedNote: option<bool>,
  receiveAnnouncementEmail: option<bool>,
  alwaysMarkNsfw: option<bool>,
  autoSensitive: option<bool>,
  followingVisibility: option<string>,
  followersVisibility: option<string>,
  chatScope: option<string>,
  pinnedPageId: option<string>,
  mutedWords: option<array<array<string>>>,
  mutedInstances: option<array<string>>,
  notificationRecieveConfig: option<postIUpdateRequest_3>,
  emailNotificationTypes: option<array<string>>,
  alsoKnownAs: option<array<string>>,
  mutualLinkSections: option<array<postIUpdateRequest_4>>,
}

let postIUpdateRequest_5Schema = S.object(s => {
    url: s.field("url", S.string),
    fileId: s.field("fileId", S.string),
    description: s.fieldOr("description", S.nullableAsOption(S.string), None),
  })

let postIUpdateRequest_4Schema = S.object(s => {
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    mutualLinks: s.field("mutualLinks", S.array(postIUpdateRequest_5Schema)),
  })

let postIUpdateRequest_3Schema = S.object(s => {
    note: s.fieldOr("note", S.nullableAsOption(S.dict(S.json)), None),
    follow: s.fieldOr("follow", S.nullableAsOption(S.dict(S.json)), None),
    mention: s.fieldOr("mention", S.nullableAsOption(S.dict(S.json)), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.dict(S.json)), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.dict(S.json)), None),
    quote: s.fieldOr("quote", S.nullableAsOption(S.dict(S.json)), None),
    reaction: s.fieldOr("reaction", S.nullableAsOption(S.dict(S.json)), None),
    pollEnded: s.fieldOr("pollEnded", S.nullableAsOption(S.dict(S.json)), None),
    receiveFollowRequest: s.fieldOr("receiveFollowRequest", S.nullableAsOption(S.dict(S.json)), None),
    followRequestAccepted: s.fieldOr("followRequestAccepted", S.nullableAsOption(S.dict(S.json)), None),
    roleAssigned: s.fieldOr("roleAssigned", S.nullableAsOption(S.dict(S.json)), None),
    chatRoomInvitationReceived: s.fieldOr("chatRoomInvitationReceived", S.nullableAsOption(S.dict(S.json)), None),
    achievementEarned: s.fieldOr("achievementEarned", S.nullableAsOption(S.dict(S.json)), None),
    app: s.fieldOr("app", S.nullableAsOption(S.dict(S.json)), None),
    test: s.fieldOr("test", S.nullableAsOption(S.dict(S.json)), None),
  })

let postIUpdateRequest_2Schema = S.object(s => {
    name: s.field("name", S.string),
    value: s.field("value", S.string),
  })

let postIUpdateRequest_1Schema = S.object(s => {
    id: s.field("id", S.string),
    angle: s.fieldOr("angle", S.nullableAsOption(S.float->S.min(0)->S.max(0)), None),
    flipH: s.fieldOr("flipH", S.nullableAsOption(S.bool), None),
    offsetX: s.fieldOr("offsetX", S.nullableAsOption(S.float->S.min(0)->S.max(0)), None),
    offsetY: s.fieldOr("offsetY", S.nullableAsOption(S.float->S.min(0)->S.max(0)), None),
  })

let postIUpdateRequestSchema = S.object(s => {
    name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.max(50)), None),
    description: s.fieldOr("description", S.nullableAsOption(S.string->S.min(1)->S.max(1500)), None),
    followedMessage: s.fieldOr("followedMessage", S.nullableAsOption(S.string->S.min(1)->S.max(256)), None),
    location: s.fieldOr("location", S.nullableAsOption(S.string->S.min(1)->S.max(50)), None),
    birthday: s.fieldOr("birthday", S.nullableAsOption(S.string->S.pattern(/^([0-9]{4})-([0-9]{2})-([0-9]{2})$/)), None),
    lang: s.fieldOr("lang", S.nullableAsOption(S.string), None),
    postingLang: s.fieldOr("postingLang", S.nullableAsOption(S.string), None),
    viewingLangs: s.fieldOr("viewingLangs", S.nullableAsOption(S.array(S.string)), None),
    showMediaInAllLanguages: s.fieldOr("showMediaInAllLanguages", S.nullableAsOption(S.bool), None),
    showHashtagsInAllLanguages: s.fieldOr("showHashtagsInAllLanguages", S.nullableAsOption(S.bool), None),
    avatarId: s.fieldOr("avatarId", S.nullableAsOption(S.string), None),
    avatarDecorations: s.fieldOr("avatarDecorations", S.nullableAsOption(S.array(postIUpdateRequest_1Schema)), None),
    bannerId: s.fieldOr("bannerId", S.nullableAsOption(S.string), None),
    fields: s.fieldOr("fields", S.nullableAsOption(S.array(postIUpdateRequest_2Schema)), None),
    isLocked: s.fieldOr("isLocked", S.nullableAsOption(S.bool), None),
    isExplorable: s.fieldOr("isExplorable", S.nullableAsOption(S.bool), None),
    hideOnlineStatus: s.fieldOr("hideOnlineStatus", S.nullableAsOption(S.bool), None),
    publicReactions: s.fieldOr("publicReactions", S.nullableAsOption(S.bool), None),
    carefulBot: s.fieldOr("carefulBot", S.nullableAsOption(S.bool), None),
    autoAcceptFollowed: s.fieldOr("autoAcceptFollowed", S.nullableAsOption(S.bool), None),
    noCrawle: s.fieldOr("noCrawle", S.nullableAsOption(S.bool), None),
    preventAiLearning: s.fieldOr("preventAiLearning", S.nullableAsOption(S.bool), None),
    requireSigninToViewContents: s.fieldOr("requireSigninToViewContents", S.nullableAsOption(S.bool), None),
    makeNotesFollowersOnlyBefore: s.fieldOr("makeNotesFollowersOnlyBefore", S.nullableAsOption(S.int), None),
    makeNotesHiddenBefore: s.fieldOr("makeNotesHiddenBefore", S.nullableAsOption(S.int), None),
    isBot: s.fieldOr("isBot", S.nullableAsOption(S.bool), None),
    isCat: s.fieldOr("isCat", S.nullableAsOption(S.bool), None),
    injectFeaturedNote: s.fieldOr("injectFeaturedNote", S.nullableAsOption(S.bool), None),
    receiveAnnouncementEmail: s.fieldOr("receiveAnnouncementEmail", S.nullableAsOption(S.bool), None),
    alwaysMarkNsfw: s.fieldOr("alwaysMarkNsfw", S.nullableAsOption(S.bool), None),
    autoSensitive: s.fieldOr("autoSensitive", S.nullableAsOption(S.bool), None),
    followingVisibility: s.fieldOr("followingVisibility", S.nullableAsOption(S.string), None),
    followersVisibility: s.fieldOr("followersVisibility", S.nullableAsOption(S.string), None),
    chatScope: s.fieldOr("chatScope", S.nullableAsOption(S.string), None),
    pinnedPageId: s.fieldOr("pinnedPageId", S.nullableAsOption(S.string), None),
    mutedWords: s.fieldOr("mutedWords", S.nullableAsOption(S.array(S.array(S.string))), None),
    mutedInstances: s.fieldOr("mutedInstances", S.nullableAsOption(S.array(S.string)), None),
    notificationRecieveConfig: s.fieldOr("notificationRecieveConfig", S.nullableAsOption(postIUpdateRequest_3Schema), None),
    emailNotificationTypes: s.fieldOr("emailNotificationTypes", S.nullableAsOption(S.array(S.string)), None),
    alsoKnownAs: s.fieldOr("alsoKnownAs", S.nullableAsOption(S.array(S.string)), None),
    mutualLinkSections: s.fieldOr("mutualLinkSections", S.nullableAsOption(S.array(postIUpdateRequest_4Schema)), None),
  })

type postIUpdateResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postIUpdateResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
 * i/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIUpdate = (~body: postIUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateRequestSchema)
  fetch(
    ~url="/i/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postMuteCreateRequest = {
  userId: string,
  expiresAt: option<int>,
}

let postMuteCreateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    expiresAt: s.fieldOr("expiresAt", S.nullableAsOption(S.int), None),
  })

type postMuteCreateResponse = unit

/**
 * mute/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:mutes*
 */
let postMuteCreate = (~body: postMuteCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMuteCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMuteCreateRequestSchema)
  fetch(
    ~url="/mute/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postMuteDeleteRequest = {
  userId: string,
}

let postMuteDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postMuteDeleteResponse = unit

/**
 * mute/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:mutes*
 */
let postMuteDelete = (~body: postMuteDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMuteDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMuteDeleteRequestSchema)
  fetch(
    ~url="/mute/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postMuteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postMuteListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postMuteListResponse = array<MisskeyIoComponentSchemas.Muting.t>

let postMuteListResponseSchema = S.array(MisskeyIoComponentSchemas.Muting.schema)

/**
 * mute/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:mutes*
 */
let postMuteList = (~body: postMuteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMuteListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMuteListRequestSchema)
  fetch(
    ~url="/mute/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postMuteListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postMyAppsRequest = {
  limit: option<int>,
  offset: option<int>,
}

let postMyAppsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
  })

type postMyAppsResponse = array<MisskeyIoComponentSchemas.App.t>

let postMyAppsResponseSchema = S.array(MisskeyIoComponentSchemas.App.schema)

/**
 * my/apps
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postMyApps = (~body: postMyAppsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postMyAppsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMyAppsRequestSchema)
  fetch(
    ~url="/my/apps",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postMyAppsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postRenoteMuteCreateRequest = {
  userId: string,
}

let postRenoteMuteCreateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postRenoteMuteCreateResponse = unit

/**
 * renote-mute/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:mutes*
 */
let postRenoteMuteCreate = (~body: postRenoteMuteCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRenoteMuteCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postRenoteMuteCreateRequestSchema)
  fetch(
    ~url="/renote-mute/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postRenoteMuteDeleteRequest = {
  userId: string,
}

let postRenoteMuteDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postRenoteMuteDeleteResponse = unit

/**
 * renote-mute/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:mutes*
 */
let postRenoteMuteDelete = (~body: postRenoteMuteDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRenoteMuteDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postRenoteMuteDeleteRequestSchema)
  fetch(
    ~url="/renote-mute/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postRenoteMuteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postRenoteMuteListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postRenoteMuteListResponse = array<MisskeyIoComponentSchemas.RenoteMuting.t>

let postRenoteMuteListResponseSchema = S.array(MisskeyIoComponentSchemas.RenoteMuting.schema)

/**
 * renote-mute/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:mutes*
 */
let postRenoteMuteList = (~body: postRenoteMuteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRenoteMuteListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postRenoteMuteListRequestSchema)
  fetch(
    ~url="/renote-mute/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postRenoteMuteListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postSwRegisterRequest = {
  endpoint: string,
  auth: string,
  publickey: string,
  sendReadMessage: option<bool>,
}

let postSwRegisterRequestSchema = S.object(s => {
    endpoint: s.field("endpoint", S.string),
    auth: s.field("auth", S.string),
    publickey: s.field("publickey", S.string),
    sendReadMessage: s.fieldOr("sendReadMessage", S.nullableAsOption(S.bool), None),
  })

type postSwRegisterResponse = {
  state: option<string>,
  key: option<string>,
  userId: string,
  endpoint: string,
  sendReadMessage: bool,
}

let postSwRegisterResponseSchema = S.object(s => {
    state: s.fieldOr("state", S.nullableAsOption(S.string), None),
    key: s.field("key", S.nullableAsOption(S.string)),
    userId: s.field("userId", S.string),
    endpoint: s.field("endpoint", S.string),
    sendReadMessage: s.field("sendReadMessage", S.bool),
  })

/**
 * sw/register
 *
 * Register to receive push notifications.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postSwRegister = (~body: postSwRegisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postSwRegisterResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwRegisterRequestSchema)
  fetch(
    ~url="/sw/register",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postSwRegisterResponseSchema)
  value
    ->Promise.resolve
  })
}

type postSwShowRegistrationRequest = {
  endpoint: string,
}

let postSwShowRegistrationRequestSchema = S.object(s => {
    endpoint: s.field("endpoint", S.string),
  })

type postSwShowRegistrationResponse_1 = {
  userId: string,
  endpoint: string,
  sendReadMessage: bool,
}

type postSwShowRegistrationResponse = option<postSwShowRegistrationResponse_1>

let postSwShowRegistrationResponse_1Schema = S.object(s => {
    userId: s.field("userId", S.string),
    endpoint: s.field("endpoint", S.string),
    sendReadMessage: s.field("sendReadMessage", S.bool),
  })

let postSwShowRegistrationResponseSchema = S.nullableAsOption(postSwShowRegistrationResponse_1Schema)

/**
 * sw/show-registration
 *
 * Check push notification registration exists.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postSwShowRegistration = (~body: postSwShowRegistrationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postSwShowRegistrationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwShowRegistrationRequestSchema)
  fetch(
    ~url="/sw/show-registration",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postSwShowRegistrationResponseSchema)
  value
    ->Promise.resolve
  })
}

type postSwUnregisterRequest = {
  endpoint: string,
}

let postSwUnregisterRequestSchema = S.object(s => {
    endpoint: s.field("endpoint", S.string),
  })

type postSwUnregisterResponse = unit

/**
 * sw/unregister
 *
 * Unregister from receiving push notifications.
 *
 * **Credential required**: *No*
 */
let postSwUnregister = (~body: postSwUnregisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postSwUnregisterResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwUnregisterRequestSchema)
  fetch(
    ~url="/sw/unregister",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postSwUpdateRegistrationRequest = {
  endpoint: string,
  sendReadMessage: option<bool>,
}

let postSwUpdateRegistrationRequestSchema = S.object(s => {
    endpoint: s.field("endpoint", S.string),
    sendReadMessage: s.fieldOr("sendReadMessage", S.nullableAsOption(S.bool), None),
  })

type postSwUpdateRegistrationResponse = {
  userId: string,
  endpoint: string,
  sendReadMessage: bool,
}

let postSwUpdateRegistrationResponseSchema = S.object(s => {
    userId: s.field("userId", S.string),
    endpoint: s.field("endpoint", S.string),
    sendReadMessage: s.field("sendReadMessage", S.bool),
  })

/**
 * sw/update-registration
 *
 * Update push notification registration.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postSwUpdateRegistration = (~body: postSwUpdateRegistrationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postSwUpdateRegistrationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwUpdateRegistrationRequestSchema)
  fetch(
    ~url="/sw/update-registration",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postSwUpdateRegistrationResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersUpdateMemoRequest = {
  userId: string,
  memo: option<string>,
}

let postUsersUpdateMemoRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    memo: s.field("memo", S.nullableAsOption(S.string)),
  })

type postUsersUpdateMemoResponse = unit

/**
 * users/update-memo
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postUsersUpdateMemo = (~body: postUsersUpdateMemoRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersUpdateMemoResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersUpdateMemoRequestSchema)
  fetch(
    ~url="/users/update-memo",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}
