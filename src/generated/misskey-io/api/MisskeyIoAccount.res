// misskey-io API for account
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postBlockingCreateRequest = {
  userId: string,
}

let postBlockingCreateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postBlockingCreateResponse = MisskeyIoComponentSchemas.UserDetailedNotMe.t

let postBlockingCreateResponseSchema = MisskeyIoComponentSchemas.UserDetailedNotMe.schema

/**
blocking/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:blocks*
*/
let postBlockingCreate = async (~body: postBlockingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postBlockingCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingCreateRequestSchema)
  let response = await fetch(
    ~url="/blocking/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postBlockingCreateResponseSchema)
}

type postBlockingDeleteRequest = {
  userId: string,
}

let postBlockingDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postBlockingDeleteResponse = MisskeyIoComponentSchemas.UserDetailedNotMe.t

let postBlockingDeleteResponseSchema = MisskeyIoComponentSchemas.UserDetailedNotMe.schema

/**
blocking/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:blocks*
*/
let postBlockingDelete = async (~body: postBlockingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postBlockingDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingDeleteRequestSchema)
  let response = await fetch(
    ~url="/blocking/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postBlockingDeleteResponseSchema)
}

type postBlockingListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postBlockingListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postBlockingListResponse = array<MisskeyIoComponentSchemas.Blocking.t>

let postBlockingListResponseSchema = S.array(MisskeyIoComponentSchemas.Blocking.schema)

/**
blocking/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:blocks*
*/
let postBlockingList = async (~body: postBlockingListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postBlockingListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postBlockingListRequestSchema)
  let response = await fetch(
    ~url="/blocking/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postBlockingListResponseSchema)
}

type postClipsAddNoteRequest = {
  clipId: string,
  noteId: string,
}

let postClipsAddNoteRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
    noteId: s.field("noteId", S.string),
  })

type postClipsAddNoteResponse = unit

/**
clips/add-note

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postClipsAddNote = async (~body: postClipsAddNoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postClipsAddNoteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsAddNoteRequestSchema)
  let response = await fetch(
    ~url="/clips/add-note",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postClipsMyFavoritesResponse = array<MisskeyIoComponentSchemas.Clip.t>

let postClipsMyFavoritesResponseSchema = S.array(MisskeyIoComponentSchemas.Clip.schema)

/**
clips/my-favorites

No description provided.

**Credential required**: *Yes* / **Permission**: *read:clip-favorite*
*/
let postClipsMyFavorites = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postClipsMyFavoritesResponse => {

  let response = await fetch(
    ~url="/clips/my-favorites",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postClipsMyFavoritesResponseSchema)
}

type postClipsNotesRequest = {
  clipId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postClipsNotesRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postClipsNotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postClipsNotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
clips/notes

No description provided.

**Credential required**: *No* / **Permission**: *read:account*
*/
let postClipsNotes = async (~body: postClipsNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postClipsNotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsNotesRequestSchema)
  let response = await fetch(
    ~url="/clips/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postClipsNotesResponseSchema)
}

type postClipsRemoveNoteRequest = {
  clipId: string,
  noteId: string,
}

let postClipsRemoveNoteRequestSchema = S.object(s => {
    clipId: s.field("clipId", S.string),
    noteId: s.field("noteId", S.string),
  })

type postClipsRemoveNoteResponse = unit

/**
clips/remove-note

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postClipsRemoveNote = async (~body: postClipsRemoveNoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postClipsRemoveNoteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postClipsRemoveNoteRequestSchema)
  let response = await fetch(
    ~url="/clips/remove-note",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postFlashMyRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postFlashMyRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postFlashMyResponse = array<MisskeyIoComponentSchemas.Flash.t>

let postFlashMyResponseSchema = S.array(MisskeyIoComponentSchemas.Flash.schema)

/**
flash/my

No description provided.

**Credential required**: *Yes* / **Permission**: *read:flash*
*/
let postFlashMy = async (~body: postFlashMyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFlashMyResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashMyRequestSchema)
  let response = await fetch(
    ~url="/flash/my",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFlashMyResponseSchema)
}

type postFlashMyLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postFlashMyLikesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postFlashMyLikesResponse_1 = {
  id: string,
  flash: MisskeyIoComponentSchemas.Flash.t,
}

type postFlashMyLikesResponse = array<postFlashMyLikesResponse_1>

let postFlashMyLikesResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    flash: s.field("flash", MisskeyIoComponentSchemas.Flash.schema),
  })

let postFlashMyLikesResponseSchema = S.array(postFlashMyLikesResponse_1Schema)

/**
flash/my-likes

No description provided.

**Credential required**: *Yes* / **Permission**: *read:flash-likes*
*/
let postFlashMyLikes = async (~body: postFlashMyLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFlashMyLikesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashMyLikesRequestSchema)
  let response = await fetch(
    ~url="/flash/my-likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFlashMyLikesResponseSchema)
}

type postIResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postIResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
i

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postI = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIResponse => {

  let response = await fetch(
    ~url="/i",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postIResponseSchema)
}

type postIFavoritesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIFavoritesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postIFavoritesResponse = array<MisskeyIoComponentSchemas.NoteFavorite.t>

let postIFavoritesResponseSchema = S.array(MisskeyIoComponentSchemas.NoteFavorite.schema)

/**
i/favorites

No description provided.

**Credential required**: *Yes* / **Permission**: *read:favorites*
*/
let postIFavorites = async (~body: postIFavoritesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIFavoritesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIFavoritesRequestSchema)
  let response = await fetch(
    ~url="/i/favorites",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIFavoritesResponseSchema)
}

type postIGalleryLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIGalleryLikesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postIGalleryLikesResponse_1 = {
  id: string,
  post: MisskeyIoComponentSchemas.GalleryPost.t,
}

type postIGalleryLikesResponse = array<postIGalleryLikesResponse_1>

let postIGalleryLikesResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    post: s.field("post", MisskeyIoComponentSchemas.GalleryPost.schema),
  })

let postIGalleryLikesResponseSchema = S.array(postIGalleryLikesResponse_1Schema)

/**
i/gallery/likes

No description provided.

**Credential required**: *Yes* / **Permission**: *read:gallery-likes*
*/
let postIGalleryLikes = async (~body: postIGalleryLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIGalleryLikesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIGalleryLikesRequestSchema)
  let response = await fetch(
    ~url="/i/gallery/likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIGalleryLikesResponseSchema)
}

type postIGalleryPostsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIGalleryPostsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postIGalleryPostsResponse = array<MisskeyIoComponentSchemas.GalleryPost.t>

let postIGalleryPostsResponseSchema = S.array(MisskeyIoComponentSchemas.GalleryPost.schema)

/**
i/gallery/posts

No description provided.

**Credential required**: *Yes* / **Permission**: *read:gallery*
*/
let postIGalleryPosts = async (~body: postIGalleryPostsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIGalleryPostsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIGalleryPostsRequestSchema)
  let response = await fetch(
    ~url="/i/gallery/posts",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIGalleryPostsResponseSchema)
}

type postINotificationsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  markAsRead: option<bool>,
  includeTypes: option<array<string>>,
  excludeTypes: option<array<string>>,
}

let postINotificationsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    markAsRead: s.field("markAsRead", S.option(S.bool)),
    includeTypes: s.field("includeTypes", S.option(S.array(S.string))),
    excludeTypes: s.field("excludeTypes", S.option(S.array(S.string))),
  })

type postINotificationsResponse = array<MisskeyIoComponentSchemas.Notification.t>

let postINotificationsResponseSchema = S.array(MisskeyIoComponentSchemas.Notification.schema)

/**
i/notifications

No description provided.

**Credential required**: *Yes* / **Permission**: *read:notifications*
*/
let postINotifications = async (~body: postINotificationsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postINotificationsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postINotificationsRequestSchema)
  let response = await fetch(
    ~url="/i/notifications",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postINotificationsResponseSchema)
}

type postINotificationsGroupedRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  markAsRead: option<bool>,
  includeTypes: option<array<string>>,
  excludeTypes: option<array<string>>,
}

let postINotificationsGroupedRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    markAsRead: s.field("markAsRead", S.option(S.bool)),
    includeTypes: s.field("includeTypes", S.option(S.array(S.string))),
    excludeTypes: s.field("excludeTypes", S.option(S.array(S.string))),
  })

type postINotificationsGroupedResponse = array<MisskeyIoComponentSchemas.Notification.t>

let postINotificationsGroupedResponseSchema = S.array(MisskeyIoComponentSchemas.Notification.schema)

/**
i/notifications-grouped

No description provided.

**Credential required**: *Yes* / **Permission**: *read:notifications*
*/
let postINotificationsGrouped = async (~body: postINotificationsGroupedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postINotificationsGroupedResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postINotificationsGroupedRequestSchema)
  let response = await fetch(
    ~url="/i/notifications-grouped",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postINotificationsGroupedResponseSchema)
}

type postIPageLikesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIPageLikesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postIPageLikesResponse_1 = {
  id: string,
  page: MisskeyIoComponentSchemas.Page.t,
}

type postIPageLikesResponse = array<postIPageLikesResponse_1>

let postIPageLikesResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    page: s.field("page", MisskeyIoComponentSchemas.Page.schema),
  })

let postIPageLikesResponseSchema = S.array(postIPageLikesResponse_1Schema)

/**
i/page-likes

No description provided.

**Credential required**: *Yes* / **Permission**: *read:page-likes*
*/
let postIPageLikes = async (~body: postIPageLikesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIPageLikesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPageLikesRequestSchema)
  let response = await fetch(
    ~url="/i/page-likes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIPageLikesResponseSchema)
}

type postIPagesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postIPagesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postIPagesResponse = array<MisskeyIoComponentSchemas.Page.t>

let postIPagesResponseSchema = S.array(MisskeyIoComponentSchemas.Page.schema)

/**
i/pages

No description provided.

**Credential required**: *Yes* / **Permission**: *read:pages*
*/
let postIPages = async (~body: postIPagesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIPagesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPagesRequestSchema)
  let response = await fetch(
    ~url="/i/pages",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIPagesResponseSchema)
}

type postIPinRequest = {
  noteId: string,
}

let postIPinRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postIPinResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postIPinResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
i/pin

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIPin = async (~body: postIPinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIPinResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPinRequestSchema)
  let response = await fetch(
    ~url="/i/pin",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIPinResponseSchema)
}

type postIPurgeTimelineCacheRequest = {
  @as("type") type_: string,
  listId: option<string>,
  antennaId: option<string>,
}

let postIPurgeTimelineCacheRequestSchema = S.object(s => {
    type_: s.field("type", S.string),
    listId: s.field("listId", S.option(S.string)),
    antennaId: s.field("antennaId", S.option(S.string)),
  })

type postIPurgeTimelineCacheResponse = unit

/**
i/purge-timeline-cache

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIPurgeTimelineCache = async (~body: postIPurgeTimelineCacheRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIPurgeTimelineCacheResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIPurgeTimelineCacheRequestSchema)
  let response = await fetch(
    ~url="/i/purge-timeline-cache",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIReadAnnouncementRequest = {
  announcementId: string,
}

let postIReadAnnouncementRequestSchema = S.object(s => {
    announcementId: s.field("announcementId", S.string),
  })

type postIReadAnnouncementResponse = unit

/**
i/read-announcement

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIReadAnnouncement = async (~body: postIReadAnnouncementRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIReadAnnouncementResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIReadAnnouncementRequestSchema)
  let response = await fetch(
    ~url="/i/read-announcement",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postIUnpinRequest = {
  noteId: string,
}

let postIUnpinRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postIUnpinResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postIUnpinResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
i/unpin

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIUnpin = async (~body: postIUnpinRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIUnpinResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUnpinRequestSchema)
  let response = await fetch(
    ~url="/i/unpin",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIUnpinResponseSchema)
}

type postIUpdateRequest_5 = {
  url: string,
  fileId: string,
  description: option<string>,
}

type postIUpdateRequest_4 = {
  name: option<string>,
  mutualLinks: array<postIUpdateRequest_5>,
}

type postIUpdateRequest_3 = {
  note: option<dict<JSON.t>>,
  follow: option<dict<JSON.t>>,
  mention: option<dict<JSON.t>>,
  reply: option<dict<JSON.t>>,
  renote: option<dict<JSON.t>>,
  quote: option<dict<JSON.t>>,
  reaction: option<dict<JSON.t>>,
  pollEnded: option<dict<JSON.t>>,
  receiveFollowRequest: option<dict<JSON.t>>,
  followRequestAccepted: option<dict<JSON.t>>,
  roleAssigned: option<dict<JSON.t>>,
  chatRoomInvitationReceived: option<dict<JSON.t>>,
  achievementEarned: option<dict<JSON.t>>,
  app: option<dict<JSON.t>>,
  test: option<dict<JSON.t>>,
}

type postIUpdateRequest_2 = {
  name: string,
  value: string,
}

type postIUpdateRequest_1 = {
  id: string,
  angle: option<float>,
  flipH: option<bool>,
  offsetX: option<float>,
  offsetY: option<float>,
}

type postIUpdateRequest = {
  name: option<string>,
  description: option<string>,
  followedMessage: option<string>,
  location: option<string>,
  birthday: option<string>,
  lang: option<string>,
  postingLang: option<string>,
  viewingLangs: option<array<string>>,
  showMediaInAllLanguages: option<bool>,
  showHashtagsInAllLanguages: option<bool>,
  avatarId: option<string>,
  avatarDecorations: option<array<postIUpdateRequest_1>>,
  bannerId: option<string>,
  fields: option<array<postIUpdateRequest_2>>,
  isLocked: option<bool>,
  isExplorable: option<bool>,
  hideOnlineStatus: option<bool>,
  publicReactions: option<bool>,
  carefulBot: option<bool>,
  autoAcceptFollowed: option<bool>,
  noCrawle: option<bool>,
  preventAiLearning: option<bool>,
  requireSigninToViewContents: option<bool>,
  makeNotesFollowersOnlyBefore: option<int>,
  makeNotesHiddenBefore: option<int>,
  isBot: option<bool>,
  isCat: option<bool>,
  injectFeaturedNote: option<bool>,
  receiveAnnouncementEmail: option<bool>,
  alwaysMarkNsfw: option<bool>,
  autoSensitive: option<bool>,
  followingVisibility: option<string>,
  followersVisibility: option<string>,
  chatScope: option<string>,
  pinnedPageId: option<string>,
  mutedWords: option<array<array<string>>>,
  mutedInstances: option<array<string>>,
  notificationRecieveConfig: option<postIUpdateRequest_3>,
  emailNotificationTypes: option<array<string>>,
  alsoKnownAs: option<array<string>>,
  mutualLinkSections: option<array<postIUpdateRequest_4>>,
}

let postIUpdateRequest_5Schema = S.object(s => {
    url: s.field("url", S.string),
    fileId: s.field("fileId", S.string),
    description: s.field("description", S.option(S.string)),
  })

let postIUpdateRequest_4Schema = S.object(s => {
    name: s.field("name", S.option(S.string)),
    mutualLinks: s.field("mutualLinks", S.array(postIUpdateRequest_5Schema)),
  })

let postIUpdateRequest_3Schema = S.object(s => {
    note: s.field("note", S.option(S.dict(S.json))),
    follow: s.field("follow", S.option(S.dict(S.json))),
    mention: s.field("mention", S.option(S.dict(S.json))),
    reply: s.field("reply", S.option(S.dict(S.json))),
    renote: s.field("renote", S.option(S.dict(S.json))),
    quote: s.field("quote", S.option(S.dict(S.json))),
    reaction: s.field("reaction", S.option(S.dict(S.json))),
    pollEnded: s.field("pollEnded", S.option(S.dict(S.json))),
    receiveFollowRequest: s.field("receiveFollowRequest", S.option(S.dict(S.json))),
    followRequestAccepted: s.field("followRequestAccepted", S.option(S.dict(S.json))),
    roleAssigned: s.field("roleAssigned", S.option(S.dict(S.json))),
    chatRoomInvitationReceived: s.field("chatRoomInvitationReceived", S.option(S.dict(S.json))),
    achievementEarned: s.field("achievementEarned", S.option(S.dict(S.json))),
    app: s.field("app", S.option(S.dict(S.json))),
    test: s.field("test", S.option(S.dict(S.json))),
  })

let postIUpdateRequest_2Schema = S.object(s => {
    name: s.field("name", S.string),
    value: s.field("value", S.string),
  })

let postIUpdateRequest_1Schema = S.object(s => {
    id: s.field("id", S.string),
    angle: s.field("angle", S.option(S.float->S.min(0)->S.max(0))),
    flipH: s.field("flipH", S.option(S.bool)),
    offsetX: s.field("offsetX", S.option(S.float->S.min(0)->S.max(0))),
    offsetY: s.field("offsetY", S.option(S.float->S.min(0)->S.max(0))),
  })

let postIUpdateRequestSchema = S.object(s => {
    name: s.field("name", S.option(S.string->S.min(1)->S.max(50))),
    description: s.field("description", S.option(S.string->S.min(1)->S.max(1500))),
    followedMessage: s.field("followedMessage", S.option(S.string->S.min(1)->S.max(256))),
    location: s.field("location", S.option(S.string->S.min(1)->S.max(50))),
    birthday: s.field("birthday", S.option(S.string->S.pattern(/^([0-9]{4})-([0-9]{2})-([0-9]{2})$/))),
    lang: s.field("lang", S.option(S.string)),
    postingLang: s.field("postingLang", S.option(S.string)),
    viewingLangs: s.field("viewingLangs", S.option(S.array(S.string))),
    showMediaInAllLanguages: s.field("showMediaInAllLanguages", S.option(S.bool)),
    showHashtagsInAllLanguages: s.field("showHashtagsInAllLanguages", S.option(S.bool)),
    avatarId: s.field("avatarId", S.option(S.string)),
    avatarDecorations: s.field("avatarDecorations", S.option(S.array(postIUpdateRequest_1Schema))),
    bannerId: s.field("bannerId", S.option(S.string)),
    fields: s.field("fields", S.option(S.array(postIUpdateRequest_2Schema))),
    isLocked: s.field("isLocked", S.option(S.bool)),
    isExplorable: s.field("isExplorable", S.option(S.bool)),
    hideOnlineStatus: s.field("hideOnlineStatus", S.option(S.bool)),
    publicReactions: s.field("publicReactions", S.option(S.bool)),
    carefulBot: s.field("carefulBot", S.option(S.bool)),
    autoAcceptFollowed: s.field("autoAcceptFollowed", S.option(S.bool)),
    noCrawle: s.field("noCrawle", S.option(S.bool)),
    preventAiLearning: s.field("preventAiLearning", S.option(S.bool)),
    requireSigninToViewContents: s.field("requireSigninToViewContents", S.option(S.bool)),
    makeNotesFollowersOnlyBefore: s.field("makeNotesFollowersOnlyBefore", S.option(S.int)),
    makeNotesHiddenBefore: s.field("makeNotesHiddenBefore", S.option(S.int)),
    isBot: s.field("isBot", S.option(S.bool)),
    isCat: s.field("isCat", S.option(S.bool)),
    injectFeaturedNote: s.field("injectFeaturedNote", S.option(S.bool)),
    receiveAnnouncementEmail: s.field("receiveAnnouncementEmail", S.option(S.bool)),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.option(S.bool)),
    autoSensitive: s.field("autoSensitive", S.option(S.bool)),
    followingVisibility: s.field("followingVisibility", S.option(S.string)),
    followersVisibility: s.field("followersVisibility", S.option(S.string)),
    chatScope: s.field("chatScope", S.option(S.string)),
    pinnedPageId: s.field("pinnedPageId", S.option(S.string)),
    mutedWords: s.field("mutedWords", S.option(S.array(S.array(S.string)))),
    mutedInstances: s.field("mutedInstances", S.option(S.array(S.string))),
    notificationRecieveConfig: s.field("notificationRecieveConfig", S.option(postIUpdateRequest_3Schema)),
    emailNotificationTypes: s.field("emailNotificationTypes", S.option(S.array(S.string))),
    alsoKnownAs: s.field("alsoKnownAs", S.option(S.array(S.string))),
    mutualLinkSections: s.field("mutualLinkSections", S.option(S.array(postIUpdateRequest_4Schema))),
  })

type postIUpdateResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postIUpdateResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
i/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postIUpdate = async (~body: postIUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postIUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIUpdateRequestSchema)
  let response = await fetch(
    ~url="/i/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postIUpdateResponseSchema)
}

type postMuteCreateRequest = {
  userId: string,
  expiresAt: option<int>,
}

let postMuteCreateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    expiresAt: s.field("expiresAt", S.option(S.int)),
  })

type postMuteCreateResponse = unit

/**
mute/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:mutes*
*/
let postMuteCreate = async (~body: postMuteCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postMuteCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMuteCreateRequestSchema)
  let response = await fetch(
    ~url="/mute/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postMuteDeleteRequest = {
  userId: string,
}

let postMuteDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postMuteDeleteResponse = unit

/**
mute/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:mutes*
*/
let postMuteDelete = async (~body: postMuteDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postMuteDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMuteDeleteRequestSchema)
  let response = await fetch(
    ~url="/mute/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postMuteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postMuteListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postMuteListResponse = array<MisskeyIoComponentSchemas.Muting.t>

let postMuteListResponseSchema = S.array(MisskeyIoComponentSchemas.Muting.schema)

/**
mute/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:mutes*
*/
let postMuteList = async (~body: postMuteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postMuteListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMuteListRequestSchema)
  let response = await fetch(
    ~url="/mute/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postMuteListResponseSchema)
}

type postMyAppsRequest = {
  limit: option<int>,
  offset: option<int>,
}

let postMyAppsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
  })

type postMyAppsResponse = array<MisskeyIoComponentSchemas.App.t>

let postMyAppsResponseSchema = S.array(MisskeyIoComponentSchemas.App.schema)

/**
my/apps

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postMyApps = async (~body: postMyAppsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postMyAppsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postMyAppsRequestSchema)
  let response = await fetch(
    ~url="/my/apps",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postMyAppsResponseSchema)
}

type postRenoteMuteCreateRequest = {
  userId: string,
}

let postRenoteMuteCreateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postRenoteMuteCreateResponse = unit

/**
renote-mute/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:mutes*
*/
let postRenoteMuteCreate = async (~body: postRenoteMuteCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postRenoteMuteCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postRenoteMuteCreateRequestSchema)
  let response = await fetch(
    ~url="/renote-mute/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postRenoteMuteDeleteRequest = {
  userId: string,
}

let postRenoteMuteDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postRenoteMuteDeleteResponse = unit

/**
renote-mute/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:mutes*
*/
let postRenoteMuteDelete = async (~body: postRenoteMuteDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postRenoteMuteDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postRenoteMuteDeleteRequestSchema)
  let response = await fetch(
    ~url="/renote-mute/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postRenoteMuteListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postRenoteMuteListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postRenoteMuteListResponse = array<MisskeyIoComponentSchemas.RenoteMuting.t>

let postRenoteMuteListResponseSchema = S.array(MisskeyIoComponentSchemas.RenoteMuting.schema)

/**
renote-mute/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:mutes*
*/
let postRenoteMuteList = async (~body: postRenoteMuteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postRenoteMuteListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postRenoteMuteListRequestSchema)
  let response = await fetch(
    ~url="/renote-mute/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postRenoteMuteListResponseSchema)
}

type postSwRegisterRequest = {
  endpoint: string,
  auth: string,
  publickey: string,
  sendReadMessage: option<bool>,
}

let postSwRegisterRequestSchema = S.object(s => {
    endpoint: s.field("endpoint", S.string),
    auth: s.field("auth", S.string),
    publickey: s.field("publickey", S.string),
    sendReadMessage: s.field("sendReadMessage", S.option(S.bool)),
  })

type postSwRegisterResponse = {
  state: option<string>,
  key: option<string>,
  userId: string,
  endpoint: string,
  sendReadMessage: bool,
}

let postSwRegisterResponseSchema = S.object(s => {
    state: s.field("state", S.option(S.string)),
    key: s.field("key", S.nullableAsOption(S.string)),
    userId: s.field("userId", S.string),
    endpoint: s.field("endpoint", S.string),
    sendReadMessage: s.field("sendReadMessage", S.bool),
  })

/**
sw/register

Register to receive push notifications.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postSwRegister = async (~body: postSwRegisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postSwRegisterResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwRegisterRequestSchema)
  let response = await fetch(
    ~url="/sw/register",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postSwRegisterResponseSchema)
}

type postSwShowRegistrationRequest = {
  endpoint: string,
}

let postSwShowRegistrationRequestSchema = S.object(s => {
    endpoint: s.field("endpoint", S.string),
  })

type postSwShowRegistrationResponse_1 = {
  userId: string,
  endpoint: string,
  sendReadMessage: bool,
}

type postSwShowRegistrationResponse = option<postSwShowRegistrationResponse_1>

let postSwShowRegistrationResponse_1Schema = S.object(s => {
    userId: s.field("userId", S.string),
    endpoint: s.field("endpoint", S.string),
    sendReadMessage: s.field("sendReadMessage", S.bool),
  })

let postSwShowRegistrationResponseSchema = S.nullableAsOption(postSwShowRegistrationResponse_1Schema)

/**
sw/show-registration

Check push notification registration exists.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postSwShowRegistration = async (~body: postSwShowRegistrationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postSwShowRegistrationResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwShowRegistrationRequestSchema)
  let response = await fetch(
    ~url="/sw/show-registration",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postSwShowRegistrationResponseSchema)
}

type postSwUnregisterRequest = {
  endpoint: string,
}

let postSwUnregisterRequestSchema = S.object(s => {
    endpoint: s.field("endpoint", S.string),
  })

type postSwUnregisterResponse = unit

/**
sw/unregister

Unregister from receiving push notifications.

**Credential required**: *No*
*/
let postSwUnregister = async (~body: postSwUnregisterRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postSwUnregisterResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwUnregisterRequestSchema)
  let response = await fetch(
    ~url="/sw/unregister",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postSwUpdateRegistrationRequest = {
  endpoint: string,
  sendReadMessage: option<bool>,
}

let postSwUpdateRegistrationRequestSchema = S.object(s => {
    endpoint: s.field("endpoint", S.string),
    sendReadMessage: s.field("sendReadMessage", S.option(S.bool)),
  })

type postSwUpdateRegistrationResponse = {
  userId: string,
  endpoint: string,
  sendReadMessage: bool,
}

let postSwUpdateRegistrationResponseSchema = S.object(s => {
    userId: s.field("userId", S.string),
    endpoint: s.field("endpoint", S.string),
    sendReadMessage: s.field("sendReadMessage", S.bool),
  })

/**
sw/update-registration

Update push notification registration.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes*
*/
let postSwUpdateRegistration = async (~body: postSwUpdateRegistrationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postSwUpdateRegistrationResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postSwUpdateRegistrationRequestSchema)
  let response = await fetch(
    ~url="/sw/update-registration",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postSwUpdateRegistrationResponseSchema)
}

type postUsersUpdateMemoRequest = {
  userId: string,
  memo: option<string>,
}

let postUsersUpdateMemoRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    memo: s.field("memo", S.nullableAsOption(S.string)),
  })

type postUsersUpdateMemoResponse = unit

/**
users/update-memo

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postUsersUpdateMemo = async (~body: postUsersUpdateMemoRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersUpdateMemoResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersUpdateMemoRequestSchema)
  let response = await fetch(
    ~url="/users/update-memo",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}
