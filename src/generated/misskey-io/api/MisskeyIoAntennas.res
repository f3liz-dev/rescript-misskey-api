// misskey-io API for antennas
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postAntennasCreateRequest = {
  name: string,
  src: string,
  userListId: option<string>,
  keywords: array<array<string>>,
  excludeKeywords: array<array<string>>,
  users: array<string>,
  caseSensitive: bool,
  localOnly: option<bool>,
  excludeBots: option<bool>,
  withReplies: bool,
  withFile: bool,
  excludeNotesInSensitiveChannel: option<bool>,
}

let postAntennasCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
    src: s.field("src", S.string),
    userListId: s.field("userListId", S.option(S.string)),
    keywords: s.field("keywords", S.array(S.array(S.string))),
    excludeKeywords: s.field("excludeKeywords", S.array(S.array(S.string))),
    users: s.field("users", S.array(S.string)),
    caseSensitive: s.field("caseSensitive", S.bool),
    localOnly: s.field("localOnly", S.option(S.bool)),
    excludeBots: s.field("excludeBots", S.option(S.bool)),
    withReplies: s.field("withReplies", S.bool),
    withFile: s.field("withFile", S.bool),
    excludeNotesInSensitiveChannel: s.field("excludeNotesInSensitiveChannel", S.option(S.bool)),
  })

type postAntennasCreateResponse = MisskeyIoComponentSchemas.Antenna.t

let postAntennasCreateResponseSchema = MisskeyIoComponentSchemas.Antenna.schema

/**
antennas/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postAntennasCreate = (~body: postAntennasCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasCreateRequestSchema)
  fetch(
    ~url="/antennas/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAntennasCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAntennasDeleteRequest = {
  antennaId: string,
}

let postAntennasDeleteRequestSchema = S.object(s => {
    antennaId: s.field("antennaId", S.string),
  })

type postAntennasDeleteResponse = unit

/**
antennas/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postAntennasDelete = (~body: postAntennasDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasDeleteRequestSchema)
  fetch(
    ~url="/antennas/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAntennasListResponse = array<MisskeyIoComponentSchemas.Antenna.t>

let postAntennasListResponseSchema = S.array(MisskeyIoComponentSchemas.Antenna.schema)

/**
antennas/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postAntennasList = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasListResponse> => {

  fetch(
    ~url="/antennas/list",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAntennasListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAntennasNotesRequest = {
  antennaId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postAntennasNotesRequestSchema = S.object(s => {
    antennaId: s.field("antennaId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
  })

type postAntennasNotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postAntennasNotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
antennas/notes

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postAntennasNotes = (~body: postAntennasNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasNotesRequestSchema)
  fetch(
    ~url="/antennas/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAntennasNotesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAntennasShowRequest = {
  antennaId: string,
}

let postAntennasShowRequestSchema = S.object(s => {
    antennaId: s.field("antennaId", S.string),
  })

type postAntennasShowResponse = MisskeyIoComponentSchemas.Antenna.t

let postAntennasShowResponseSchema = MisskeyIoComponentSchemas.Antenna.schema

/**
antennas/show

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postAntennasShow = (~body: postAntennasShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasShowRequestSchema)
  fetch(
    ~url="/antennas/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAntennasShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAntennasUpdateRequest = {
  antennaId: string,
  name: option<string>,
  src: option<string>,
  userListId: option<string>,
  keywords: option<array<array<string>>>,
  excludeKeywords: option<array<array<string>>>,
  users: option<array<string>>,
  caseSensitive: option<bool>,
  localOnly: option<bool>,
  excludeBots: option<bool>,
  withReplies: option<bool>,
  withFile: option<bool>,
  excludeNotesInSensitiveChannel: option<bool>,
}

let postAntennasUpdateRequestSchema = S.object(s => {
    antennaId: s.field("antennaId", S.string),
    name: s.field("name", S.option(S.string->S.min(1)->S.max(100))),
    src: s.field("src", S.option(S.string)),
    userListId: s.field("userListId", S.option(S.string)),
    keywords: s.field("keywords", S.option(S.array(S.array(S.string)))),
    excludeKeywords: s.field("excludeKeywords", S.option(S.array(S.array(S.string)))),
    users: s.field("users", S.option(S.array(S.string))),
    caseSensitive: s.field("caseSensitive", S.option(S.bool)),
    localOnly: s.field("localOnly", S.option(S.bool)),
    excludeBots: s.field("excludeBots", S.option(S.bool)),
    withReplies: s.field("withReplies", S.option(S.bool)),
    withFile: s.field("withFile", S.option(S.bool)),
    excludeNotesInSensitiveChannel: s.field("excludeNotesInSensitiveChannel", S.option(S.bool)),
  })

type postAntennasUpdateResponse = MisskeyIoComponentSchemas.Antenna.t

let postAntennasUpdateResponseSchema = MisskeyIoComponentSchemas.Antenna.schema

/**
antennas/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postAntennasUpdate = (~body: postAntennasUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAntennasUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAntennasUpdateRequestSchema)
  fetch(
    ~url="/antennas/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAntennasUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}
