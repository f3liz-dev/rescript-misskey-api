// SPDX-License-Identifier: MIT
// misskey-io API for webhooks
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type postAdminSystemWebhookTestRequest = {
  webhookId: string,
  @as("type") type_: string,
  override: option<JSON.t>,
}

let postAdminSystemWebhookTestRequestSchema = S.object(s => {
    webhookId: s.field("webhookId", S.string),
    type_: s.field("type", S.string),
    override: s.fieldOr("override", S.nullableAsOption(S.json), None),
  })

type postAdminSystemWebhookTestResponse = unit

/**
 * admin/system-webhook/test
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *read:admin:system-webhook*
 */
let postAdminSystemWebhookTest = (~body: postAdminSystemWebhookTestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookTestResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookTestRequestSchema)
  
  fetch(
    ~url="/admin/system-webhook/test",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postIWebhooksCreateRequest = {
  name: string,
  url: string,
  secret: option<string>,
  on: array<string>,
}

let postIWebhooksCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
    url: s.field("url", S.string->S.min(1)->S.max(1024)),
    secret: s.fieldOr("secret", S.nullableAsOption(S.string->S.max(1024)), None),
    on: s.field("on", S.array(S.string)),
  })

type postIWebhooksCreateResponse = {
  id: string,
  userId: string,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
  active: bool,
  latestSentAt: JSON.t,
  latestStatus: JSON.t,
}

let postIWebhooksCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    userId: s.field("userId", S.string),
    name: s.field("name", S.string),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
    active: s.field("active", S.bool),
    latestSentAt: s.field("latestSentAt", S.json),
    latestStatus: s.field("latestStatus", S.json),
  })

/**
 * i/webhooks/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIWebhooksCreate = (~body: postIWebhooksCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksCreateRequestSchema)
  
  fetch(
    ~url="/i/webhooks/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postIWebhooksCreateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postIWebhooksDeleteRequest = {
  webhookId: string,
}

let postIWebhooksDeleteRequestSchema = S.object(s => {
    webhookId: s.field("webhookId", S.string),
  })

type postIWebhooksDeleteResponse = unit

/**
 * i/webhooks/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIWebhooksDelete = (~body: postIWebhooksDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksDeleteRequestSchema)
  
  fetch(
    ~url="/i/webhooks/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postIWebhooksListResponse = array<JSON.t>

let postIWebhooksListResponseSchema = S.array(S.json)

/**
 * i/webhooks/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIWebhooksList = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksListResponse> => {
  
  fetch(
    ~url="/i/webhooks/list",
    ~method_="POST",
     ~body=None
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postIWebhooksListResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postIWebhooksShowRequest = {
  webhookId: string,
}

let postIWebhooksShowRequestSchema = S.object(s => {
    webhookId: s.field("webhookId", S.string),
  })

type postIWebhooksShowResponse = {
  id: string,
  userId: string,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
  active: bool,
  latestSentAt: JSON.t,
  latestStatus: JSON.t,
}

let postIWebhooksShowResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    userId: s.field("userId", S.string),
    name: s.field("name", S.string),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
    active: s.field("active", S.bool),
    latestSentAt: s.field("latestSentAt", S.json),
    latestStatus: s.field("latestStatus", S.json),
  })

/**
 * i/webhooks/show
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIWebhooksShow = (~body: postIWebhooksShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksShowRequestSchema)
  
  fetch(
    ~url="/i/webhooks/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postIWebhooksShowResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postIWebhooksTestRequest = {
  webhookId: string,
  @as("type") type_: string,
  override: option<JSON.t>,
}

let postIWebhooksTestRequestSchema = S.object(s => {
    webhookId: s.field("webhookId", S.string),
    type_: s.field("type", S.string),
    override: s.fieldOr("override", S.nullableAsOption(S.json), None),
  })

type postIWebhooksTestResponse = unit

/**
 * i/webhooks/test
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIWebhooksTest = (~body: postIWebhooksTestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksTestResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksTestRequestSchema)
  
  fetch(
    ~url="/i/webhooks/test",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postIWebhooksUpdateRequest = {
  webhookId: string,
  name: option<string>,
  url: option<string>,
  secret: option<JSON.t>,
  on: option<array<string>>,
  active: option<bool>,
}

let postIWebhooksUpdateRequestSchema = S.object(s => {
    webhookId: s.field("webhookId", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.max(100)), None),
    url: s.fieldOr("url", S.nullableAsOption(S.string->S.min(1)->S.max(1024)), None),
    secret: s.fieldOr("secret", S.nullableAsOption(S.json), None),
    on: s.fieldOr("on", S.nullableAsOption(S.array(S.string)), None),
    active: s.fieldOr("active", S.nullableAsOption(S.bool), None),
  })

type postIWebhooksUpdateResponse = unit

/**
 * i/webhooks/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIWebhooksUpdate = (~body: postIWebhooksUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksUpdateRequestSchema)
  
  fetch(
    ~url="/i/webhooks/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}
