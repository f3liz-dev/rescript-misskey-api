// misskey-io API for webhooks
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postAdminSystemWebhookTestRequest_1 = {
  url: option<string>,
  secret: option<string>,
}

type postAdminSystemWebhookTestRequest = {
  webhookId: string,
  @as("type") type_: string,
  override: option<postAdminSystemWebhookTestRequest_1>,
}

let postAdminSystemWebhookTestRequest_1Schema = S.object(s => {
    url: s.field("url", S.option(S.string)),
    secret: s.field("secret", S.option(S.string)),
  })

let postAdminSystemWebhookTestRequestSchema = S.object(s => {
    webhookId: s.field("webhookId", S.string),
    type_: s.field("type", S.string),
    override: s.field("override", S.option(postAdminSystemWebhookTestRequest_1Schema)),
  })

type postAdminSystemWebhookTestResponse = unit

/**
 * admin/system-webhook/test
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *read:admin:system-webhook*
 */
let postAdminSystemWebhookTest = (~body: postAdminSystemWebhookTestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookTestResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookTestRequestSchema)
  fetch(
    ~url="/admin/system-webhook/test",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIWebhooksCreateRequest = {
  name: string,
  url: string,
  secret: option<string>,
  on: array<string>,
}

let postIWebhooksCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
    url: s.field("url", S.string->S.min(1)->S.max(1024)),
    secret: s.field("secret", S.option(S.string->S.max(1024))),
    on: s.field("on", S.array(S.string)),
  })

type postIWebhooksCreateResponse = {
  id: string,
  userId: string,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
  active: bool,
  latestSentAt: option<string>,
  latestStatus: option<int>,
}

let postIWebhooksCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    userId: s.field("userId", S.string),
    name: s.field("name", S.string),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
    active: s.field("active", S.bool),
    latestSentAt: s.field("latestSentAt", S.nullableAsOption(S.string)),
    latestStatus: s.field("latestStatus", S.nullableAsOption(S.int)),
  })

/**
 * i/webhooks/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIWebhooksCreate = (~body: postIWebhooksCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksCreateRequestSchema)
  fetch(
    ~url="/i/webhooks/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIWebhooksCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIWebhooksDeleteRequest = {
  webhookId: string,
}

let postIWebhooksDeleteRequestSchema = S.object(s => {
    webhookId: s.field("webhookId", S.string),
  })

type postIWebhooksDeleteResponse = unit

/**
 * i/webhooks/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIWebhooksDelete = (~body: postIWebhooksDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksDeleteRequestSchema)
  fetch(
    ~url="/i/webhooks/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIWebhooksListResponse_1 = {
  id: string,
  userId: string,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
  active: bool,
  latestSentAt: option<string>,
  latestStatus: option<int>,
}

type postIWebhooksListResponse = array<postIWebhooksListResponse_1>

let postIWebhooksListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    userId: s.field("userId", S.string),
    name: s.field("name", S.string),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
    active: s.field("active", S.bool),
    latestSentAt: s.field("latestSentAt", S.nullableAsOption(S.string)),
    latestStatus: s.field("latestStatus", S.nullableAsOption(S.int)),
  })

let postIWebhooksListResponseSchema = S.array(postIWebhooksListResponse_1Schema)

/**
 * i/webhooks/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIWebhooksList = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksListResponse> => {

  fetch(
    ~url="/i/webhooks/list",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIWebhooksListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIWebhooksShowRequest = {
  webhookId: string,
}

let postIWebhooksShowRequestSchema = S.object(s => {
    webhookId: s.field("webhookId", S.string),
  })

type postIWebhooksShowResponse = {
  id: string,
  userId: string,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
  active: bool,
  latestSentAt: option<string>,
  latestStatus: option<int>,
}

let postIWebhooksShowResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    userId: s.field("userId", S.string),
    name: s.field("name", S.string),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
    active: s.field("active", S.bool),
    latestSentAt: s.field("latestSentAt", S.nullableAsOption(S.string)),
    latestStatus: s.field("latestStatus", S.nullableAsOption(S.int)),
  })

/**
 * i/webhooks/show
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIWebhooksShow = (~body: postIWebhooksShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksShowRequestSchema)
  fetch(
    ~url="/i/webhooks/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIWebhooksShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIWebhooksTestRequest_1 = {
  url: option<string>,
  secret: option<string>,
}

type postIWebhooksTestRequest = {
  webhookId: string,
  @as("type") type_: string,
  override: option<postIWebhooksTestRequest_1>,
}

let postIWebhooksTestRequest_1Schema = S.object(s => {
    url: s.field("url", S.option(S.string)),
    secret: s.field("secret", S.option(S.string)),
  })

let postIWebhooksTestRequestSchema = S.object(s => {
    webhookId: s.field("webhookId", S.string),
    type_: s.field("type", S.string),
    override: s.field("override", S.option(postIWebhooksTestRequest_1Schema)),
  })

type postIWebhooksTestResponse = unit

/**
 * i/webhooks/test
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postIWebhooksTest = (~body: postIWebhooksTestRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksTestResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksTestRequestSchema)
  fetch(
    ~url="/i/webhooks/test",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postIWebhooksUpdateRequest = {
  webhookId: string,
  name: option<string>,
  url: option<string>,
  secret: option<string>,
  on: option<array<string>>,
  active: option<bool>,
}

let postIWebhooksUpdateRequestSchema = S.object(s => {
    webhookId: s.field("webhookId", S.string),
    name: s.field("name", S.option(S.string->S.min(1)->S.max(100))),
    url: s.field("url", S.option(S.string->S.min(1)->S.max(1024))),
    secret: s.field("secret", S.option(S.string->S.max(1024))),
    on: s.field("on", S.option(S.array(S.string))),
    active: s.field("active", S.option(S.bool)),
  })

type postIWebhooksUpdateResponse = unit

/**
 * i/webhooks/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postIWebhooksUpdate = (~body: postIWebhooksUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIWebhooksUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIWebhooksUpdateRequestSchema)
  fetch(
    ~url="/i/webhooks/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}
