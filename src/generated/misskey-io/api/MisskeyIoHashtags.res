// misskey-io API for hashtags
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postHashtagsListRequest = {
  limit: option<int>,
  attachedToUserOnly: option<bool>,
  attachedToLocalUserOnly: option<bool>,
  attachedToRemoteUserOnly: option<bool>,
  sort: string,
}

let postHashtagsListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    attachedToUserOnly: s.fieldOr("attachedToUserOnly", S.nullableAsOption(S.bool), None),
    attachedToLocalUserOnly: s.fieldOr("attachedToLocalUserOnly", S.nullableAsOption(S.bool), None),
    attachedToRemoteUserOnly: s.fieldOr("attachedToRemoteUserOnly", S.nullableAsOption(S.bool), None),
    sort: s.field("sort", S.string),
  })

type postHashtagsListResponse = array<MisskeyIoComponentSchemas.Hashtag.t>

let postHashtagsListResponseSchema = S.array(MisskeyIoComponentSchemas.Hashtag.schema)

/**
 * hashtags/list
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postHashtagsList = (~body: postHashtagsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postHashtagsListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsListRequestSchema)
  fetch(
    ~url="/hashtags/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postHashtagsListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postHashtagsSearchRequest = {
  limit: option<int>,
  query: string,
  offset: option<int>,
}

let postHashtagsSearchRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    query: s.field("query", S.string),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
  })

type postHashtagsSearchResponse = array<string>

let postHashtagsSearchResponseSchema = S.array(S.string)

/**
 * hashtags/search
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postHashtagsSearch = (~body: postHashtagsSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postHashtagsSearchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsSearchRequestSchema)
  fetch(
    ~url="/hashtags/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postHashtagsSearchResponseSchema)
  value
    ->Promise.resolve
  })
}

type postHashtagsShowRequest = {
  tag: string,
}

let postHashtagsShowRequestSchema = S.object(s => {
    tag: s.field("tag", S.string),
  })

type postHashtagsShowResponse = MisskeyIoComponentSchemas.Hashtag.t

let postHashtagsShowResponseSchema = MisskeyIoComponentSchemas.Hashtag.schema

/**
 * hashtags/show
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postHashtagsShow = (~body: postHashtagsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postHashtagsShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsShowRequestSchema)
  fetch(
    ~url="/hashtags/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postHashtagsShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type getHashtagsTrendResponse = array<{
  tag: string,
  chart: array<float>,
  usersCount: float,
}>

let getHashtagsTrendResponseSchema = S.array(S.object(s => {
    tag: s.field("tag", S.string),
    chart: s.field("chart", S.array(S.float)),
    usersCount: s.field("usersCount", S.float),
  }))

/**
 * hashtags/trend
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getHashtagsTrend = (~body as _, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getHashtagsTrendResponse> => {

  fetch(
    ~url="/hashtags/trend",
    ~method_="GET",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getHashtagsTrendResponseSchema)
  value
    ->Promise.resolve
  })
}

type postHashtagsTrendResponse = array<{
  tag: string,
  chart: array<float>,
  usersCount: float,
}>

let postHashtagsTrendResponseSchema = S.array(S.object(s => {
    tag: s.field("tag", S.string),
    chart: s.field("chart", S.array(S.float)),
    usersCount: s.field("usersCount", S.float),
  }))

/**
 * hashtags/trend
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postHashtagsTrend = (~body as _, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postHashtagsTrendResponse> => {

  fetch(
    ~url="/hashtags/trend",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postHashtagsTrendResponseSchema)
  value
    ->Promise.resolve
  })
}

type postHashtagsUsersRequest = {
  tag: string,
  limit: option<int>,
  sort: string,
  state: option<string>,
  origin: option<string>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postHashtagsUsersRequestSchema = S.object(s => {
    tag: s.field("tag", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sort: s.field("sort", S.string),
    state: s.fieldOr("state", S.nullableAsOption(S.string), None),
    origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postHashtagsUsersResponse = array<MisskeyIoComponentSchemas.UserDetailed.t>

let postHashtagsUsersResponseSchema = S.array(MisskeyIoComponentSchemas.UserDetailed.schema)

/**
 * hashtags/users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postHashtagsUsers = (~body: postHashtagsUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postHashtagsUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsUsersRequestSchema)
  fetch(
    ~url="/hashtags/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postHashtagsUsersResponseSchema)
  value
    ->Promise.resolve
  })
}
