// misskey-io API for hashtags
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postHashtagsListRequest = {
  limit: option<int>,
  attachedToUserOnly: option<bool>,
  attachedToLocalUserOnly: option<bool>,
  attachedToRemoteUserOnly: option<bool>,
  sort: string,
}

let postHashtagsListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    attachedToUserOnly: s.field("attachedToUserOnly", S.option(S.bool)),
    attachedToLocalUserOnly: s.field("attachedToLocalUserOnly", S.option(S.bool)),
    attachedToRemoteUserOnly: s.field("attachedToRemoteUserOnly", S.option(S.bool)),
    sort: s.field("sort", S.string),
  })

type postHashtagsListResponse = array<MisskeyIoComponentSchemas.Hashtag.t>

let postHashtagsListResponseSchema = S.array(MisskeyIoComponentSchemas.Hashtag.schema)

/**
hashtags/list

No description provided.

**Credential required**: *No*
*/
let postHashtagsList = async (~body: postHashtagsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postHashtagsListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsListRequestSchema)
  let response = await fetch(
    ~url="/hashtags/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postHashtagsListResponseSchema)
}

type postHashtagsSearchRequest = {
  limit: option<int>,
  query: string,
  offset: option<int>,
}

let postHashtagsSearchRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    query: s.field("query", S.string),
    offset: s.field("offset", S.option(S.int)),
  })

type postHashtagsSearchResponse = array<string>

let postHashtagsSearchResponseSchema = S.array(S.string)

/**
hashtags/search

No description provided.

**Credential required**: *No*
*/
let postHashtagsSearch = async (~body: postHashtagsSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postHashtagsSearchResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsSearchRequestSchema)
  let response = await fetch(
    ~url="/hashtags/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postHashtagsSearchResponseSchema)
}

type postHashtagsShowRequest = {
  tag: string,
}

let postHashtagsShowRequestSchema = S.object(s => {
    tag: s.field("tag", S.string),
  })

type postHashtagsShowResponse = MisskeyIoComponentSchemas.Hashtag.t

let postHashtagsShowResponseSchema = MisskeyIoComponentSchemas.Hashtag.schema

/**
hashtags/show

No description provided.

**Credential required**: *No*
*/
let postHashtagsShow = async (~body: postHashtagsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postHashtagsShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsShowRequestSchema)
  let response = await fetch(
    ~url="/hashtags/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postHashtagsShowResponseSchema)
}

type getHashtagsTrendResponse_1 = {
  tag: string,
  chart: array<float>,
  usersCount: float,
}

type getHashtagsTrendResponse = array<getHashtagsTrendResponse_1>

let getHashtagsTrendResponse_1Schema = S.object(s => {
    tag: s.field("tag", S.string),
    chart: s.field("chart", S.array(S.float)),
    usersCount: s.field("usersCount", S.float),
  })

let getHashtagsTrendResponseSchema = S.array(getHashtagsTrendResponse_1Schema)

/**
hashtags/trend

No description provided.

**Credential required**: *No*
*/
let getHashtagsTrend = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getHashtagsTrendResponse => {

  let response = await fetch(
    ~url="/hashtags/trend",
    ~method_="GET",
    ~body=None,
  )
  response->S.parseOrThrow(getHashtagsTrendResponseSchema)
}

type postHashtagsTrendResponse_1 = {
  tag: string,
  chart: array<float>,
  usersCount: float,
}

type postHashtagsTrendResponse = array<postHashtagsTrendResponse_1>

let postHashtagsTrendResponse_1Schema = S.object(s => {
    tag: s.field("tag", S.string),
    chart: s.field("chart", S.array(S.float)),
    usersCount: s.field("usersCount", S.float),
  })

let postHashtagsTrendResponseSchema = S.array(postHashtagsTrendResponse_1Schema)

/**
hashtags/trend

No description provided.

**Credential required**: *No*
*/
let postHashtagsTrend = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postHashtagsTrendResponse => {

  let response = await fetch(
    ~url="/hashtags/trend",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postHashtagsTrendResponseSchema)
}

type postHashtagsUsersRequest = {
  tag: string,
  limit: option<int>,
  sort: string,
  state: option<string>,
  origin: option<string>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postHashtagsUsersRequestSchema = S.object(s => {
    tag: s.field("tag", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sort: s.field("sort", S.string),
    state: s.field("state", S.option(S.string)),
    origin: s.field("origin", S.option(S.string)),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postHashtagsUsersResponse = array<MisskeyIoComponentSchemas.UserDetailed.t>

let postHashtagsUsersResponseSchema = S.array(MisskeyIoComponentSchemas.UserDetailed.schema)

/**
hashtags/users

No description provided.

**Credential required**: *No*
*/
let postHashtagsUsers = async (~body: postHashtagsUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postHashtagsUsersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postHashtagsUsersRequestSchema)
  let response = await fetch(
    ~url="/hashtags/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postHashtagsUsersResponseSchema)
}
