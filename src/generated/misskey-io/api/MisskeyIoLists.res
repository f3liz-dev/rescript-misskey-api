// misskey-io API for lists
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postUsersListsCreateRequest = {
  name: string,
}

let postUsersListsCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)->S.max(100)),
  })

type postUsersListsCreateResponse = MisskeyIoComponentSchemas.UserList.t

let postUsersListsCreateResponseSchema = MisskeyIoComponentSchemas.UserList.schema

/**
 * users/lists/create
 *
 * Create a new list of users.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postUsersListsCreate = (~body: postUsersListsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsCreateRequestSchema)
  fetch(
    ~url="/users/lists/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersListsCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersListsDeleteRequest = {
  listId: string,
}

let postUsersListsDeleteRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
  })

type postUsersListsDeleteResponse = unit

/**
 * users/lists/delete
 *
 * Delete an existing list of users.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postUsersListsDelete = (~body: postUsersListsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsDeleteRequestSchema)
  fetch(
    ~url="/users/lists/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postUsersListsGetMembershipsRequest = {
  listId: string,
  forPublic: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postUsersListsGetMembershipsRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
    forPublic: s.fieldOr("forPublic", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postUsersListsGetMembershipsResponse = array<{
  id: string,
  createdAt: string,
  userId: string,
  user: MisskeyIoComponentSchemas.UserLite.t,
  withReplies: bool,
}>

let postUsersListsGetMembershipsResponseSchema = S.array(S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", MisskeyIoComponentSchemas.UserLite.schema),
    withReplies: s.field("withReplies", S.bool),
  }))

/**
 * users/lists/get-memberships
 *
 * No description provided.
 *
 * **Credential required**: *No* / **Permission**: *read:account*
 */
let postUsersListsGetMemberships = (~body: postUsersListsGetMembershipsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsGetMembershipsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsGetMembershipsRequestSchema)
  fetch(
    ~url="/users/lists/get-memberships",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersListsGetMembershipsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersListsListRequest = {
  userId: option<string>,
}

let postUsersListsListRequestSchema = S.object(s => {
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
  })

type postUsersListsListResponse = array<MisskeyIoComponentSchemas.UserList.t>

let postUsersListsListResponseSchema = S.array(MisskeyIoComponentSchemas.UserList.schema)

/**
 * users/lists/list
 *
 * Show all lists that the authenticated user has created.
 *
 * **Credential required**: *No* / **Permission**: *read:account*
 */
let postUsersListsList = (~body: postUsersListsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsListRequestSchema)
  fetch(
    ~url="/users/lists/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersListsListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersListsPullRequest = {
  listId: string,
  userId: string,
}

let postUsersListsPullRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
    userId: s.field("userId", S.string),
  })

type postUsersListsPullResponse = unit

/**
 * users/lists/pull
 *
 * Remove a user from a list.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postUsersListsPull = (~body: postUsersListsPullRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsPullResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsPullRequestSchema)
  fetch(
    ~url="/users/lists/pull",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postUsersListsPushRequest = {
  listId: string,
  userId: string,
}

let postUsersListsPushRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
    userId: s.field("userId", S.string),
  })

type postUsersListsPushResponse = unit

/**
 * users/lists/push
 *
 * Add a user to an existing list.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postUsersListsPush = (~body: postUsersListsPushRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsPushResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsPushRequestSchema)
  fetch(
    ~url="/users/lists/push",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postUsersListsShowRequest = {
  listId: string,
  forPublic: option<bool>,
}

let postUsersListsShowRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
    forPublic: s.fieldOr("forPublic", S.nullableAsOption(S.bool), None),
  })

type postUsersListsShowResponse = MisskeyIoComponentSchemas.UserList.t

let postUsersListsShowResponseSchema = MisskeyIoComponentSchemas.UserList.schema

/**
 * users/lists/show
 *
 * Show the properties of a list.
 *
 * **Credential required**: *No* / **Permission**: *read:account*
 */
let postUsersListsShow = (~body: postUsersListsShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsShowRequestSchema)
  fetch(
    ~url="/users/lists/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersListsShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersListsUpdateRequest = {
  listId: string,
  name: option<string>,
  isPublic: option<bool>,
}

let postUsersListsUpdateRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.max(100)), None),
    isPublic: s.fieldOr("isPublic", S.nullableAsOption(S.bool), None),
  })

type postUsersListsUpdateResponse = MisskeyIoComponentSchemas.UserList.t

let postUsersListsUpdateResponseSchema = MisskeyIoComponentSchemas.UserList.schema

/**
 * users/lists/update
 *
 * Update the properties of a list.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postUsersListsUpdate = (~body: postUsersListsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsUpdateRequestSchema)
  fetch(
    ~url="/users/lists/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersListsUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersListsUpdateMembershipRequest = {
  listId: string,
  userId: string,
  withReplies: option<bool>,
}

let postUsersListsUpdateMembershipRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
    userId: s.field("userId", S.string),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
  })

type postUsersListsUpdateMembershipResponse = unit

/**
 * users/lists/update-membership
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:account*
 */
let postUsersListsUpdateMembership = (~body: postUsersListsUpdateMembershipRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersListsUpdateMembershipResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersListsUpdateMembershipRequestSchema)
  fetch(
    ~url="/users/lists/update-membership",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}
