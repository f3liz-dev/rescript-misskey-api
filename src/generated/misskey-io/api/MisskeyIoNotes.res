// misskey-io API for notes
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postChannelsTimelineRequest = {
  channelId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  dimension: option<int>,
}

let postChannelsTimelineRequestSchema = S.object(s => {
    channelId: s.field("channelId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    allowPartial: s.field("allowPartial", S.option(S.bool)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
  })

type postChannelsTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postChannelsTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
channels/timeline

No description provided.

**Credential required**: *No*
*/
let postChannelsTimeline = async (~body: postChannelsTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postChannelsTimelineResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsTimelineRequestSchema)
  let response = await fetch(
    ~url="/channels/timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postChannelsTimelineResponseSchema)
}

type postNotesRequest = {
  local: option<bool>,
  reply: option<bool>,
  renote: option<bool>,
  withFiles: option<bool>,
  poll: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postNotesRequestSchema = S.object(s => {
    local: s.field("local", S.option(S.bool)),
    reply: s.field("reply", S.option(S.bool)),
    renote: s.field("renote", S.option(S.bool)),
    withFiles: s.field("withFiles", S.option(S.bool)),
    poll: s.field("poll", S.option(S.bool)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postNotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes

No description provided.

**Credential required**: *No*
*/
let postNotes = async (~body: postNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRequestSchema)
  let response = await fetch(
    ~url="/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesResponseSchema)
}

type postNotesChildrenRequest = {
  noteId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postNotesChildrenRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postNotesChildrenResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesChildrenResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/children

No description provided.

**Credential required**: *No*
*/
let postNotesChildren = async (~body: postNotesChildrenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesChildrenResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesChildrenRequestSchema)
  let response = await fetch(
    ~url="/notes/children",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesChildrenResponseSchema)
}

type postNotesConversationRequest = {
  noteId: string,
  limit: option<int>,
  offset: option<int>,
}

let postNotesConversationRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
  })

type postNotesConversationResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesConversationResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/conversation

No description provided.

**Credential required**: *No*
*/
let postNotesConversation = async (~body: postNotesConversationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesConversationResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesConversationRequestSchema)
  let response = await fetch(
    ~url="/notes/conversation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesConversationResponseSchema)
}

type postNotesCreateRequest_1 = {
  choices: array<string>,
  multiple: option<bool>,
  expiresAt: option<int>,
  expiredAfter: option<int>,
}

type postNotesCreateRequest = {
  visibility: option<string>,
  visibleUserIds: option<array<string>>,
  cw: option<string>,
  localOnly: option<bool>,
  dimension: option<int>,
  reactionAcceptance: option<string>,
  noExtractMentions: option<bool>,
  noExtractHashtags: option<bool>,
  noExtractEmojis: option<bool>,
  replyId: option<string>,
  renoteId: option<string>,
  channelId: option<string>,
  lang: option<string>,
  text: option<string>,
  fileIds: option<array<string>>,
  mediaIds: option<array<string>>,
  poll: option<postNotesCreateRequest_1>,
  scheduledAt: option<int>,
  noCreatedNote: option<bool>,
}

let postNotesCreateRequest_1Schema = S.object(s => {
    choices: s.field("choices", S.array(S.string->S.min(1)->S.max(50))),
    multiple: s.field("multiple", S.option(S.bool)),
    expiresAt: s.field("expiresAt", S.option(S.int)),
    expiredAfter: s.field("expiredAfter", S.option(S.int->S.min(1))),
  })

let postNotesCreateRequestSchema = S.object(s => {
    visibility: s.field("visibility", S.option(S.string)),
    visibleUserIds: s.field("visibleUserIds", S.option(S.array(S.string))),
    cw: s.field("cw", S.option(S.string->S.min(1)->S.max(100))),
    localOnly: s.field("localOnly", S.option(S.bool)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
    reactionAcceptance: s.field("reactionAcceptance", S.option(S.string)),
    noExtractMentions: s.field("noExtractMentions", S.option(S.bool)),
    noExtractHashtags: s.field("noExtractHashtags", S.option(S.bool)),
    noExtractEmojis: s.field("noExtractEmojis", S.option(S.bool)),
    replyId: s.field("replyId", S.option(S.string)),
    renoteId: s.field("renoteId", S.option(S.string)),
    channelId: s.field("channelId", S.option(S.string)),
    lang: s.field("lang", S.option(S.string)),
    text: s.field("text", S.option(S.string->S.min(1)->S.max(3000))),
    fileIds: s.field("fileIds", S.option(S.array(S.string))),
    mediaIds: s.field("mediaIds", S.option(S.array(S.string))),
    poll: s.field("poll", S.option(postNotesCreateRequest_1Schema)),
    scheduledAt: s.field("scheduledAt", S.option(S.int)),
    noCreatedNote: s.field("noCreatedNote", S.option(S.bool)),
  })

type postNotesCreateResponse = {
  createdNote: MisskeyIoComponentSchemas.Note.t,
}

let postNotesCreateResponseSchema = S.object(s => {
    createdNote: s.field("createdNote", MisskeyIoComponentSchemas.Note.schema),
  })

/**
notes/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:notes*
*/
let postNotesCreate = async (~body: postNotesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesCreateRequestSchema)
  let response = await fetch(
    ~url="/notes/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesCreateResponseSchema)
}

type postNotesDeleteRequest = {
  noteId: string,
}

let postNotesDeleteRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesDeleteResponse = unit

/**
notes/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:notes*
*/
let postNotesDelete = async (~body: postNotesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDeleteRequestSchema)
  let response = await fetch(
    ~url="/notes/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postNotesFavoritesCreateRequest = {
  noteId: string,
}

let postNotesFavoritesCreateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesFavoritesCreateResponse = unit

/**
notes/favorites/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:favorites*
*/
let postNotesFavoritesCreate = async (~body: postNotesFavoritesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesFavoritesCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFavoritesCreateRequestSchema)
  let response = await fetch(
    ~url="/notes/favorites/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postNotesFavoritesDeleteRequest = {
  noteId: string,
}

let postNotesFavoritesDeleteRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesFavoritesDeleteResponse = unit

/**
notes/favorites/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:favorites*
*/
let postNotesFavoritesDelete = async (~body: postNotesFavoritesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesFavoritesDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFavoritesDeleteRequestSchema)
  let response = await fetch(
    ~url="/notes/favorites/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type getNotesFeaturedRequest = {
  limit: option<int>,
  untilId: option<string>,
  channelId: option<string>,
}

let getNotesFeaturedRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    untilId: s.field("untilId", S.option(S.string)),
    channelId: s.field("channelId", S.option(S.string)),
  })

type getNotesFeaturedResponse = array<MisskeyIoComponentSchemas.Note.t>

let getNotesFeaturedResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/featured

No description provided.

**Credential required**: *No*
*/
let getNotesFeatured = async (~body: getNotesFeaturedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getNotesFeaturedResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getNotesFeaturedRequestSchema)
  let response = await fetch(
    ~url="/notes/featured",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getNotesFeaturedResponseSchema)
}

type postNotesFeaturedRequest = {
  limit: option<int>,
  untilId: option<string>,
  channelId: option<string>,
}

let postNotesFeaturedRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    untilId: s.field("untilId", S.option(S.string)),
    channelId: s.field("channelId", S.option(S.string)),
  })

type postNotesFeaturedResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesFeaturedResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/featured

No description provided.

**Credential required**: *No*
*/
let postNotesFeatured = async (~body: postNotesFeaturedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesFeaturedResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFeaturedRequestSchema)
  let response = await fetch(
    ~url="/notes/featured",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesFeaturedResponseSchema)
}

type postNotesGlobalTimelineRequest = {
  withFiles: option<bool>,
  withRenotes: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  dimension: option<int>,
}

let postNotesGlobalTimelineRequestSchema = S.object(s => {
    withFiles: s.field("withFiles", S.option(S.bool)),
    withRenotes: s.field("withRenotes", S.option(S.bool)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
  })

type postNotesGlobalTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesGlobalTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/global-timeline

No description provided.

**Credential required**: *No*
*/
let postNotesGlobalTimeline = async (~body: postNotesGlobalTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesGlobalTimelineResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesGlobalTimelineRequestSchema)
  let response = await fetch(
    ~url="/notes/global-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesGlobalTimelineResponseSchema)
}

type postNotesHybridTimelineRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  includeMyRenotes: option<bool>,
  includeRenotedMyNotes: option<bool>,
  includeLocalRenotes: option<bool>,
  withFiles: option<bool>,
  withRenotes: option<bool>,
  withReplies: option<bool>,
  dimension: option<int>,
}

let postNotesHybridTimelineRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    allowPartial: s.field("allowPartial", S.option(S.bool)),
    includeMyRenotes: s.field("includeMyRenotes", S.option(S.bool)),
    includeRenotedMyNotes: s.field("includeRenotedMyNotes", S.option(S.bool)),
    includeLocalRenotes: s.field("includeLocalRenotes", S.option(S.bool)),
    withFiles: s.field("withFiles", S.option(S.bool)),
    withRenotes: s.field("withRenotes", S.option(S.bool)),
    withReplies: s.field("withReplies", S.option(S.bool)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
  })

type postNotesHybridTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesHybridTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/hybrid-timeline

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesHybridTimeline = async (~body: postNotesHybridTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesHybridTimelineResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesHybridTimelineRequestSchema)
  let response = await fetch(
    ~url="/notes/hybrid-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesHybridTimelineResponseSchema)
}

type postNotesLocalTimelineRequest = {
  withFiles: option<bool>,
  withRenotes: option<bool>,
  withReplies: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  allowPartial: option<bool>,
  sinceDate: option<int>,
  untilDate: option<int>,
  dimension: option<int>,
}

let postNotesLocalTimelineRequestSchema = S.object(s => {
    withFiles: s.field("withFiles", S.option(S.bool)),
    withRenotes: s.field("withRenotes", S.option(S.bool)),
    withReplies: s.field("withReplies", S.option(S.bool)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    allowPartial: s.field("allowPartial", S.option(S.bool)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
  })

type postNotesLocalTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesLocalTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/local-timeline

No description provided.

**Credential required**: *No*
*/
let postNotesLocalTimeline = async (~body: postNotesLocalTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesLocalTimelineResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesLocalTimelineRequestSchema)
  let response = await fetch(
    ~url="/notes/local-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesLocalTimelineResponseSchema)
}

type postNotesMentionsRequest = {
  following: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  visibility: option<string>,
}

let postNotesMentionsRequestSchema = S.object(s => {
    following: s.field("following", S.option(S.bool)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    visibility: s.field("visibility", S.option(S.string)),
  })

type postNotesMentionsResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesMentionsResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/mentions

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesMentions = async (~body: postNotesMentionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesMentionsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesMentionsRequestSchema)
  let response = await fetch(
    ~url="/notes/mentions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesMentionsResponseSchema)
}

type postNotesPollsRecommendationRequest = {
  limit: option<int>,
  offset: option<int>,
  excludeChannels: option<bool>,
}

let postNotesPollsRecommendationRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
    excludeChannels: s.field("excludeChannels", S.option(S.bool)),
  })

type postNotesPollsRecommendationResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesPollsRecommendationResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/polls/recommendation

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesPollsRecommendation = async (~body: postNotesPollsRecommendationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesPollsRecommendationResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesPollsRecommendationRequestSchema)
  let response = await fetch(
    ~url="/notes/polls/recommendation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesPollsRecommendationResponseSchema)
}

type postNotesPollsVoteRequest = {
  noteId: string,
  choice: int,
}

let postNotesPollsVoteRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    choice: s.field("choice", S.int),
  })

type postNotesPollsVoteResponse = unit

/**
notes/polls/vote

No description provided.

**Credential required**: *Yes* / **Permission**: *write:votes*
*/
let postNotesPollsVote = async (~body: postNotesPollsVoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesPollsVoteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesPollsVoteRequestSchema)
  let response = await fetch(
    ~url="/notes/polls/vote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type getNotesReactionsRequest = {
  noteId: string,
  @as("type") type_: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let getNotesReactionsRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    type_: s.field("type", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type getNotesReactionsResponse = array<MisskeyIoComponentSchemas.NoteReaction.t>

let getNotesReactionsResponseSchema = S.array(MisskeyIoComponentSchemas.NoteReaction.schema)

/**
notes/reactions

No description provided.

**Credential required**: *No*
*/
let getNotesReactions = async (~body: getNotesReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getNotesReactionsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getNotesReactionsRequestSchema)
  let response = await fetch(
    ~url="/notes/reactions",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getNotesReactionsResponseSchema)
}

type postNotesReactionsRequest = {
  noteId: string,
  @as("type") type_: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postNotesReactionsRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    type_: s.field("type", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postNotesReactionsResponse = array<MisskeyIoComponentSchemas.NoteReaction.t>

let postNotesReactionsResponseSchema = S.array(MisskeyIoComponentSchemas.NoteReaction.schema)

/**
notes/reactions

No description provided.

**Credential required**: *No*
*/
let postNotesReactions = async (~body: postNotesReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesReactionsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesReactionsRequestSchema)
  let response = await fetch(
    ~url="/notes/reactions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesReactionsResponseSchema)
}

type postNotesRenotesRequest = {
  noteId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postNotesRenotesRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postNotesRenotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesRenotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/renotes

No description provided.

**Credential required**: *No*
*/
let postNotesRenotes = async (~body: postNotesRenotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesRenotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRenotesRequestSchema)
  let response = await fetch(
    ~url="/notes/renotes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesRenotesResponseSchema)
}

type postNotesRepliesRequest = {
  noteId: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postNotesRepliesRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postNotesRepliesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesRepliesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/replies

No description provided.

**Credential required**: *No*
*/
let postNotesReplies = async (~body: postNotesRepliesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesRepliesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRepliesRequestSchema)
  let response = await fetch(
    ~url="/notes/replies",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesRepliesResponseSchema)
}

type postNotesScheduledCancelRequest = {
  draftId: string,
}

let postNotesScheduledCancelRequestSchema = S.object(s => {
    draftId: s.field("draftId", S.string),
  })

type postNotesScheduledCancelResponse = unit

/**
notes/scheduled/cancel

No description provided.

**Credential required**: *Yes* / **Permission**: *write:notes*
*/
let postNotesScheduledCancel = async (~body: postNotesScheduledCancelRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesScheduledCancelResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesScheduledCancelRequestSchema)
  let response = await fetch(
    ~url="/notes/scheduled/cancel",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postNotesScheduledListRequest = {
  limit: option<int>,
  offset: option<int>,
}

let postNotesScheduledListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
  })

type postNotesScheduledListResponse = array<MisskeyIoComponentSchemas.NoteDraft.t>

let postNotesScheduledListResponseSchema = S.array(MisskeyIoComponentSchemas.NoteDraft.schema)

/**
notes/scheduled/list

No description provided.

**Credential required**: *Yes* / **Permission**: *write:notes*
*/
let postNotesScheduledList = async (~body: postNotesScheduledListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesScheduledListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesScheduledListRequestSchema)
  let response = await fetch(
    ~url="/notes/scheduled/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesScheduledListResponseSchema)
}

type postNotesSearchRequest = {
  query: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
  offset: option<int>,
  host: option<string>,
  userId: option<string>,
  channelId: option<string>,
}

let postNotesSearchRequestSchema = S.object(s => {
    query: s.field("query", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
    host: s.field("host", S.option(S.string)),
    userId: s.field("userId", S.option(S.string)),
    channelId: s.field("channelId", S.option(S.string)),
  })

type postNotesSearchResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesSearchResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/search

No description provided.

**Credential required**: *No*
*/
let postNotesSearch = async (~body: postNotesSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesSearchResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesSearchRequestSchema)
  let response = await fetch(
    ~url="/notes/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesSearchResponseSchema)
}

type postNotesSearchByTagRequest = {
  local: option<bool>,
  reply: option<bool>,
  renote: option<bool>,
  withFiles: option<bool>,
  poll: option<bool>,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
  tag: option<string>,
  query: option<array<array<string>>>,
}

let postNotesSearchByTagRequestSchema = S.object(s => {
    local: s.field("local", S.option(S.bool)),
    reply: s.field("reply", S.option(S.bool)),
    renote: s.field("renote", S.option(S.bool)),
    withFiles: s.field("withFiles", S.option(S.bool)),
    poll: s.field("poll", S.option(S.bool)),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    tag: s.field("tag", S.option(S.string->S.min(1))),
    query: s.field("query", S.option(S.array(S.array(S.string->S.min(1))))),
  })

type postNotesSearchByTagResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesSearchByTagResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/search-by-tag

No description provided.

**Credential required**: *No*
*/
let postNotesSearchByTag = async (~body: postNotesSearchByTagRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesSearchByTagResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesSearchByTagRequestSchema)
  let response = await fetch(
    ~url="/notes/search-by-tag",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesSearchByTagResponseSchema)
}

type postNotesShowRequest = {
  noteId: string,
}

let postNotesShowRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesShowResponse = MisskeyIoComponentSchemas.Note.t

let postNotesShowResponseSchema = MisskeyIoComponentSchemas.Note.schema

/**
notes/show

No description provided.

**Credential required**: *No*
*/
let postNotesShow = async (~body: postNotesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesShowRequestSchema)
  let response = await fetch(
    ~url="/notes/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesShowResponseSchema)
}

type postNotesStateRequest = {
  noteId: string,
}

let postNotesStateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesStateResponse = {
  isFavorited: bool,
  isMutedThread: bool,
}

let postNotesStateResponseSchema = S.object(s => {
    isFavorited: s.field("isFavorited", S.bool),
    isMutedThread: s.field("isMutedThread", S.bool),
  })

/**
notes/state

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesState = async (~body: postNotesStateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesStateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesStateRequestSchema)
  let response = await fetch(
    ~url="/notes/state",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesStateResponseSchema)
}

type postNotesThreadMutingCreateRequest = {
  noteId: string,
}

let postNotesThreadMutingCreateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesThreadMutingCreateResponse = unit

/**
notes/thread-muting/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postNotesThreadMutingCreate = async (~body: postNotesThreadMutingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesThreadMutingCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesThreadMutingCreateRequestSchema)
  let response = await fetch(
    ~url="/notes/thread-muting/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postNotesThreadMutingDeleteRequest = {
  noteId: string,
}

let postNotesThreadMutingDeleteRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesThreadMutingDeleteResponse = unit

/**
notes/thread-muting/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postNotesThreadMutingDelete = async (~body: postNotesThreadMutingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesThreadMutingDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesThreadMutingDeleteRequestSchema)
  let response = await fetch(
    ~url="/notes/thread-muting/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postNotesTimelineRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  includeMyRenotes: option<bool>,
  includeRenotedMyNotes: option<bool>,
  includeLocalRenotes: option<bool>,
  withFiles: option<bool>,
  withRenotes: option<bool>,
  dimension: option<int>,
}

let postNotesTimelineRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    allowPartial: s.field("allowPartial", S.option(S.bool)),
    includeMyRenotes: s.field("includeMyRenotes", S.option(S.bool)),
    includeRenotedMyNotes: s.field("includeRenotedMyNotes", S.option(S.bool)),
    includeLocalRenotes: s.field("includeLocalRenotes", S.option(S.bool)),
    withFiles: s.field("withFiles", S.option(S.bool)),
    withRenotes: s.field("withRenotes", S.option(S.bool)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
  })

type postNotesTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/timeline

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesTimeline = async (~body: postNotesTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesTimelineResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesTimelineRequestSchema)
  let response = await fetch(
    ~url="/notes/timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesTimelineResponseSchema)
}

type postNotesTranslateRequest = {
  noteId: string,
  targetLang: string,
}

let postNotesTranslateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    targetLang: s.field("targetLang", S.string),
  })

type postNotesTranslateResponse = {
  sourceLang: string,
  text: string,
}

let postNotesTranslateResponseSchema = S.object(s => {
    sourceLang: s.field("sourceLang", S.string),
    text: s.field("text", S.string),
  })

/**
notes/translate

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesTranslate = async (~body: postNotesTranslateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesTranslateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesTranslateRequestSchema)
  let response = await fetch(
    ~url="/notes/translate",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesTranslateResponseSchema)
}

type postNotesUnrenoteRequest = {
  noteId: string,
}

let postNotesUnrenoteRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesUnrenoteResponse = unit

/**
notes/unrenote

No description provided.

**Credential required**: *Yes* / **Permission**: *write:notes*
*/
let postNotesUnrenote = async (~body: postNotesUnrenoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesUnrenoteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesUnrenoteRequestSchema)
  let response = await fetch(
    ~url="/notes/unrenote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postNotesUserListTimelineRequest = {
  listId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  includeMyRenotes: option<bool>,
  includeRenotedMyNotes: option<bool>,
  includeLocalRenotes: option<bool>,
  withRenotes: option<bool>,
  withFiles: option<bool>,
}

let postNotesUserListTimelineRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    allowPartial: s.field("allowPartial", S.option(S.bool)),
    includeMyRenotes: s.field("includeMyRenotes", S.option(S.bool)),
    includeRenotedMyNotes: s.field("includeRenotedMyNotes", S.option(S.bool)),
    includeLocalRenotes: s.field("includeLocalRenotes", S.option(S.bool)),
    withRenotes: s.field("withRenotes", S.option(S.bool)),
    withFiles: s.field("withFiles", S.option(S.bool)),
  })

type postNotesUserListTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesUserListTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/user-list-timeline

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesUserListTimeline = async (~body: postNotesUserListTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postNotesUserListTimelineResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesUserListTimelineRequestSchema)
  let response = await fetch(
    ~url="/notes/user-list-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postNotesUserListTimelineResponseSchema)
}

type postPromoReadRequest = {
  noteId: string,
}

let postPromoReadRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postPromoReadResponse = unit

/**
promo/read

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postPromoRead = async (~body: postPromoReadRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postPromoReadResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postPromoReadRequestSchema)
  let response = await fetch(
    ~url="/promo/read",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type getUsersFeaturedNotesRequest = {
  limit: option<int>,
  untilId: option<string>,
  userId: string,
}

let getUsersFeaturedNotesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    untilId: s.field("untilId", S.option(S.string)),
    userId: s.field("userId", S.string),
  })

type getUsersFeaturedNotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let getUsersFeaturedNotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
users/featured-notes

No description provided.

**Credential required**: *No*
*/
let getUsersFeaturedNotes = async (~body: getUsersFeaturedNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): getUsersFeaturedNotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getUsersFeaturedNotesRequestSchema)
  let response = await fetch(
    ~url="/users/featured-notes",
    ~method_="GET",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(getUsersFeaturedNotesResponseSchema)
}

type postUsersFeaturedNotesRequest = {
  limit: option<int>,
  untilId: option<string>,
  userId: string,
}

let postUsersFeaturedNotesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    untilId: s.field("untilId", S.option(S.string)),
    userId: s.field("userId", S.string),
  })

type postUsersFeaturedNotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postUsersFeaturedNotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
users/featured-notes

No description provided.

**Credential required**: *No*
*/
let postUsersFeaturedNotes = async (~body: postUsersFeaturedNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postUsersFeaturedNotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFeaturedNotesRequestSchema)
  let response = await fetch(
    ~url="/users/featured-notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postUsersFeaturedNotesResponseSchema)
}
