// misskey-io API for notes
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postChannelsTimelineRequest = {
  channelId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  dimension: option<int>,
}

let postChannelsTimelineRequestSchema = S.object(s => {
    channelId: s.field("channelId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    allowPartial: s.field("allowPartial", S.option(S.bool)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
  })

type postChannelsTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postChannelsTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
channels/timeline

No description provided.

**Credential required**: *No*
*/
let postChannelsTimeline = (~body: postChannelsTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postChannelsTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postChannelsTimelineRequestSchema)
  fetch(
    ~url="/channels/timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postChannelsTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesRequest = {
  local: option<bool>,
  reply: option<bool>,
  renote: option<bool>,
  withFiles: option<bool>,
  poll: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postNotesRequestSchema = S.object(s => {
    local: s.field("local", S.option(S.bool)),
    reply: s.field("reply", S.option(S.bool)),
    renote: s.field("renote", S.option(S.bool)),
    withFiles: s.field("withFiles", S.option(S.bool)),
    poll: s.field("poll", S.option(S.bool)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postNotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes

No description provided.

**Credential required**: *No*
*/
let postNotes = (~body: postNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRequestSchema)
  fetch(
    ~url="/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesChildrenRequest = {
  noteId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postNotesChildrenRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postNotesChildrenResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesChildrenResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/children

No description provided.

**Credential required**: *No*
*/
let postNotesChildren = (~body: postNotesChildrenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesChildrenResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesChildrenRequestSchema)
  fetch(
    ~url="/notes/children",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesChildrenResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesConversationRequest = {
  noteId: string,
  limit: option<int>,
  offset: option<int>,
}

let postNotesConversationRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
  })

type postNotesConversationResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesConversationResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/conversation

No description provided.

**Credential required**: *No*
*/
let postNotesConversation = (~body: postNotesConversationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesConversationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesConversationRequestSchema)
  fetch(
    ~url="/notes/conversation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesConversationResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesCreateRequest_1 = {
  choices: array<string>,
  multiple: option<bool>,
  expiresAt: option<int>,
  expiredAfter: option<int>,
}

type postNotesCreateRequest = {
  visibility: option<string>,
  visibleUserIds: option<array<string>>,
  cw: option<string>,
  localOnly: option<bool>,
  dimension: option<int>,
  reactionAcceptance: option<string>,
  noExtractMentions: option<bool>,
  noExtractHashtags: option<bool>,
  noExtractEmojis: option<bool>,
  replyId: option<string>,
  renoteId: option<string>,
  channelId: option<string>,
  lang: option<string>,
  text: option<string>,
  fileIds: option<array<string>>,
  mediaIds: option<array<string>>,
  poll: option<postNotesCreateRequest_1>,
  scheduledAt: option<int>,
  noCreatedNote: option<bool>,
}

let postNotesCreateRequest_1Schema = S.object(s => {
    choices: s.field("choices", S.array(S.string->S.min(1)->S.max(50))),
    multiple: s.field("multiple", S.option(S.bool)),
    expiresAt: s.field("expiresAt", S.option(S.int)),
    expiredAfter: s.field("expiredAfter", S.option(S.int->S.min(1))),
  })

let postNotesCreateRequestSchema = S.object(s => {
    visibility: s.field("visibility", S.option(S.string)),
    visibleUserIds: s.field("visibleUserIds", S.option(S.array(S.string))),
    cw: s.field("cw", S.option(S.string->S.min(1)->S.max(100))),
    localOnly: s.field("localOnly", S.option(S.bool)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
    reactionAcceptance: s.field("reactionAcceptance", S.option(S.string)),
    noExtractMentions: s.field("noExtractMentions", S.option(S.bool)),
    noExtractHashtags: s.field("noExtractHashtags", S.option(S.bool)),
    noExtractEmojis: s.field("noExtractEmojis", S.option(S.bool)),
    replyId: s.field("replyId", S.option(S.string)),
    renoteId: s.field("renoteId", S.option(S.string)),
    channelId: s.field("channelId", S.option(S.string)),
    lang: s.field("lang", S.option(S.string)),
    text: s.field("text", S.option(S.string->S.min(1)->S.max(3000))),
    fileIds: s.field("fileIds", S.option(S.array(S.string))),
    mediaIds: s.field("mediaIds", S.option(S.array(S.string))),
    poll: s.field("poll", S.option(postNotesCreateRequest_1Schema)),
    scheduledAt: s.field("scheduledAt", S.option(S.int)),
    noCreatedNote: s.field("noCreatedNote", S.option(S.bool)),
  })

type postNotesCreateResponse = {
  createdNote: MisskeyIoComponentSchemas.Note.t,
}

let postNotesCreateResponseSchema = S.object(s => {
    createdNote: s.field("createdNote", MisskeyIoComponentSchemas.Note.schema),
  })

/**
notes/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:notes*
*/
let postNotesCreate = (~body: postNotesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesCreateRequestSchema)
  fetch(
    ~url="/notes/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesDeleteRequest = {
  noteId: string,
}

let postNotesDeleteRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesDeleteResponse = unit

/**
notes/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:notes*
*/
let postNotesDelete = (~body: postNotesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesDeleteRequestSchema)
  fetch(
    ~url="/notes/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postNotesFavoritesCreateRequest = {
  noteId: string,
}

let postNotesFavoritesCreateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesFavoritesCreateResponse = unit

/**
notes/favorites/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:favorites*
*/
let postNotesFavoritesCreate = (~body: postNotesFavoritesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesFavoritesCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFavoritesCreateRequestSchema)
  fetch(
    ~url="/notes/favorites/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postNotesFavoritesDeleteRequest = {
  noteId: string,
}

let postNotesFavoritesDeleteRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesFavoritesDeleteResponse = unit

/**
notes/favorites/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:favorites*
*/
let postNotesFavoritesDelete = (~body: postNotesFavoritesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesFavoritesDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFavoritesDeleteRequestSchema)
  fetch(
    ~url="/notes/favorites/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type getNotesFeaturedRequest = {
  limit: option<int>,
  untilId: option<string>,
  channelId: option<string>,
}

let getNotesFeaturedRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    untilId: s.field("untilId", S.option(S.string)),
    channelId: s.field("channelId", S.option(S.string)),
  })

type getNotesFeaturedResponse = array<MisskeyIoComponentSchemas.Note.t>

let getNotesFeaturedResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/featured

No description provided.

**Credential required**: *No*
*/
let getNotesFeatured = (~body: getNotesFeaturedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getNotesFeaturedResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getNotesFeaturedRequestSchema)
  fetch(
    ~url="/notes/featured",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getNotesFeaturedResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesFeaturedRequest = {
  limit: option<int>,
  untilId: option<string>,
  channelId: option<string>,
}

let postNotesFeaturedRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    untilId: s.field("untilId", S.option(S.string)),
    channelId: s.field("channelId", S.option(S.string)),
  })

type postNotesFeaturedResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesFeaturedResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/featured

No description provided.

**Credential required**: *No*
*/
let postNotesFeatured = (~body: postNotesFeaturedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesFeaturedResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesFeaturedRequestSchema)
  fetch(
    ~url="/notes/featured",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesFeaturedResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesGlobalTimelineRequest = {
  withFiles: option<bool>,
  withRenotes: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  dimension: option<int>,
}

let postNotesGlobalTimelineRequestSchema = S.object(s => {
    withFiles: s.field("withFiles", S.option(S.bool)),
    withRenotes: s.field("withRenotes", S.option(S.bool)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
  })

type postNotesGlobalTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesGlobalTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/global-timeline

No description provided.

**Credential required**: *No*
*/
let postNotesGlobalTimeline = (~body: postNotesGlobalTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesGlobalTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesGlobalTimelineRequestSchema)
  fetch(
    ~url="/notes/global-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesGlobalTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesHybridTimelineRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  includeMyRenotes: option<bool>,
  includeRenotedMyNotes: option<bool>,
  includeLocalRenotes: option<bool>,
  withFiles: option<bool>,
  withRenotes: option<bool>,
  withReplies: option<bool>,
  dimension: option<int>,
}

let postNotesHybridTimelineRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    allowPartial: s.field("allowPartial", S.option(S.bool)),
    includeMyRenotes: s.field("includeMyRenotes", S.option(S.bool)),
    includeRenotedMyNotes: s.field("includeRenotedMyNotes", S.option(S.bool)),
    includeLocalRenotes: s.field("includeLocalRenotes", S.option(S.bool)),
    withFiles: s.field("withFiles", S.option(S.bool)),
    withRenotes: s.field("withRenotes", S.option(S.bool)),
    withReplies: s.field("withReplies", S.option(S.bool)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
  })

type postNotesHybridTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesHybridTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/hybrid-timeline

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesHybridTimeline = (~body: postNotesHybridTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesHybridTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesHybridTimelineRequestSchema)
  fetch(
    ~url="/notes/hybrid-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesHybridTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesLocalTimelineRequest = {
  withFiles: option<bool>,
  withRenotes: option<bool>,
  withReplies: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  allowPartial: option<bool>,
  sinceDate: option<int>,
  untilDate: option<int>,
  dimension: option<int>,
}

let postNotesLocalTimelineRequestSchema = S.object(s => {
    withFiles: s.field("withFiles", S.option(S.bool)),
    withRenotes: s.field("withRenotes", S.option(S.bool)),
    withReplies: s.field("withReplies", S.option(S.bool)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    allowPartial: s.field("allowPartial", S.option(S.bool)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
  })

type postNotesLocalTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesLocalTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/local-timeline

No description provided.

**Credential required**: *No*
*/
let postNotesLocalTimeline = (~body: postNotesLocalTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesLocalTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesLocalTimelineRequestSchema)
  fetch(
    ~url="/notes/local-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesLocalTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesMentionsRequest = {
  following: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  visibility: option<string>,
}

let postNotesMentionsRequestSchema = S.object(s => {
    following: s.field("following", S.option(S.bool)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    visibility: s.field("visibility", S.option(S.string)),
  })

type postNotesMentionsResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesMentionsResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/mentions

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesMentions = (~body: postNotesMentionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesMentionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesMentionsRequestSchema)
  fetch(
    ~url="/notes/mentions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesMentionsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesPollsRecommendationRequest = {
  limit: option<int>,
  offset: option<int>,
  excludeChannels: option<bool>,
}

let postNotesPollsRecommendationRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
    excludeChannels: s.field("excludeChannels", S.option(S.bool)),
  })

type postNotesPollsRecommendationResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesPollsRecommendationResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/polls/recommendation

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesPollsRecommendation = (~body: postNotesPollsRecommendationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesPollsRecommendationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesPollsRecommendationRequestSchema)
  fetch(
    ~url="/notes/polls/recommendation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesPollsRecommendationResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesPollsVoteRequest = {
  noteId: string,
  choice: int,
}

let postNotesPollsVoteRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    choice: s.field("choice", S.int),
  })

type postNotesPollsVoteResponse = unit

/**
notes/polls/vote

No description provided.

**Credential required**: *Yes* / **Permission**: *write:votes*
*/
let postNotesPollsVote = (~body: postNotesPollsVoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesPollsVoteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesPollsVoteRequestSchema)
  fetch(
    ~url="/notes/polls/vote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type getNotesReactionsRequest = {
  noteId: string,
  @as("type") type_: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let getNotesReactionsRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    type_: s.field("type", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type getNotesReactionsResponse = array<MisskeyIoComponentSchemas.NoteReaction.t>

let getNotesReactionsResponseSchema = S.array(MisskeyIoComponentSchemas.NoteReaction.schema)

/**
notes/reactions

No description provided.

**Credential required**: *No*
*/
let getNotesReactions = (~body: getNotesReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getNotesReactionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getNotesReactionsRequestSchema)
  fetch(
    ~url="/notes/reactions",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getNotesReactionsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesReactionsRequest = {
  noteId: string,
  @as("type") type_: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postNotesReactionsRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    type_: s.field("type", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postNotesReactionsResponse = array<MisskeyIoComponentSchemas.NoteReaction.t>

let postNotesReactionsResponseSchema = S.array(MisskeyIoComponentSchemas.NoteReaction.schema)

/**
notes/reactions

No description provided.

**Credential required**: *No*
*/
let postNotesReactions = (~body: postNotesReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesReactionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesReactionsRequestSchema)
  fetch(
    ~url="/notes/reactions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesReactionsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesRenotesRequest = {
  noteId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postNotesRenotesRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postNotesRenotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesRenotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/renotes

No description provided.

**Credential required**: *No*
*/
let postNotesRenotes = (~body: postNotesRenotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesRenotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRenotesRequestSchema)
  fetch(
    ~url="/notes/renotes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesRenotesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesRepliesRequest = {
  noteId: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postNotesRepliesRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postNotesRepliesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesRepliesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/replies

No description provided.

**Credential required**: *No*
*/
let postNotesReplies = (~body: postNotesRepliesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesRepliesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesRepliesRequestSchema)
  fetch(
    ~url="/notes/replies",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesRepliesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesScheduledCancelRequest = {
  draftId: string,
}

let postNotesScheduledCancelRequestSchema = S.object(s => {
    draftId: s.field("draftId", S.string),
  })

type postNotesScheduledCancelResponse = unit

/**
notes/scheduled/cancel

No description provided.

**Credential required**: *Yes* / **Permission**: *write:notes*
*/
let postNotesScheduledCancel = (~body: postNotesScheduledCancelRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesScheduledCancelResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesScheduledCancelRequestSchema)
  fetch(
    ~url="/notes/scheduled/cancel",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postNotesScheduledListRequest = {
  limit: option<int>,
  offset: option<int>,
}

let postNotesScheduledListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
  })

type postNotesScheduledListResponse = array<MisskeyIoComponentSchemas.NoteDraft.t>

let postNotesScheduledListResponseSchema = S.array(MisskeyIoComponentSchemas.NoteDraft.schema)

/**
notes/scheduled/list

No description provided.

**Credential required**: *Yes* / **Permission**: *write:notes*
*/
let postNotesScheduledList = (~body: postNotesScheduledListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesScheduledListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesScheduledListRequestSchema)
  fetch(
    ~url="/notes/scheduled/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesScheduledListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesSearchRequest = {
  query: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
  offset: option<int>,
  host: option<string>,
  userId: option<string>,
  channelId: option<string>,
}

let postNotesSearchRequestSchema = S.object(s => {
    query: s.field("query", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
    host: s.field("host", S.option(S.string)),
    userId: s.field("userId", S.option(S.string)),
    channelId: s.field("channelId", S.option(S.string)),
  })

type postNotesSearchResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesSearchResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/search

No description provided.

**Credential required**: *No*
*/
let postNotesSearch = (~body: postNotesSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesSearchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesSearchRequestSchema)
  fetch(
    ~url="/notes/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesSearchResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesSearchByTagRequest = {
  local: option<bool>,
  reply: option<bool>,
  renote: option<bool>,
  withFiles: option<bool>,
  poll: option<bool>,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
  tag: option<string>,
  query: option<array<array<string>>>,
}

let postNotesSearchByTagRequestSchema = S.object(s => {
    local: s.field("local", S.option(S.bool)),
    reply: s.field("reply", S.option(S.bool)),
    renote: s.field("renote", S.option(S.bool)),
    withFiles: s.field("withFiles", S.option(S.bool)),
    poll: s.field("poll", S.option(S.bool)),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    tag: s.field("tag", S.option(S.string->S.min(1))),
    query: s.field("query", S.option(S.array(S.array(S.string->S.min(1))))),
  })

type postNotesSearchByTagResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesSearchByTagResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/search-by-tag

No description provided.

**Credential required**: *No*
*/
let postNotesSearchByTag = (~body: postNotesSearchByTagRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesSearchByTagResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesSearchByTagRequestSchema)
  fetch(
    ~url="/notes/search-by-tag",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesSearchByTagResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesShowRequest = {
  noteId: string,
}

let postNotesShowRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesShowResponse = MisskeyIoComponentSchemas.Note.t

let postNotesShowResponseSchema = MisskeyIoComponentSchemas.Note.schema

/**
notes/show

No description provided.

**Credential required**: *No*
*/
let postNotesShow = (~body: postNotesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesShowRequestSchema)
  fetch(
    ~url="/notes/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesStateRequest = {
  noteId: string,
}

let postNotesStateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesStateResponse = {
  isFavorited: bool,
  isMutedThread: bool,
}

let postNotesStateResponseSchema = S.object(s => {
    isFavorited: s.field("isFavorited", S.bool),
    isMutedThread: s.field("isMutedThread", S.bool),
  })

/**
notes/state

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesState = (~body: postNotesStateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesStateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesStateRequestSchema)
  fetch(
    ~url="/notes/state",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesStateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesThreadMutingCreateRequest = {
  noteId: string,
}

let postNotesThreadMutingCreateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesThreadMutingCreateResponse = unit

/**
notes/thread-muting/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postNotesThreadMutingCreate = (~body: postNotesThreadMutingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesThreadMutingCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesThreadMutingCreateRequestSchema)
  fetch(
    ~url="/notes/thread-muting/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postNotesThreadMutingDeleteRequest = {
  noteId: string,
}

let postNotesThreadMutingDeleteRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesThreadMutingDeleteResponse = unit

/**
notes/thread-muting/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postNotesThreadMutingDelete = (~body: postNotesThreadMutingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesThreadMutingDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesThreadMutingDeleteRequestSchema)
  fetch(
    ~url="/notes/thread-muting/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postNotesTimelineRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  includeMyRenotes: option<bool>,
  includeRenotedMyNotes: option<bool>,
  includeLocalRenotes: option<bool>,
  withFiles: option<bool>,
  withRenotes: option<bool>,
  dimension: option<int>,
}

let postNotesTimelineRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    allowPartial: s.field("allowPartial", S.option(S.bool)),
    includeMyRenotes: s.field("includeMyRenotes", S.option(S.bool)),
    includeRenotedMyNotes: s.field("includeRenotedMyNotes", S.option(S.bool)),
    includeLocalRenotes: s.field("includeLocalRenotes", S.option(S.bool)),
    withFiles: s.field("withFiles", S.option(S.bool)),
    withRenotes: s.field("withRenotes", S.option(S.bool)),
    dimension: s.field("dimension", S.option(S.int->S.min(0))),
  })

type postNotesTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/timeline

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesTimeline = (~body: postNotesTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesTimelineRequestSchema)
  fetch(
    ~url="/notes/timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesTranslateRequest = {
  noteId: string,
  targetLang: string,
}

let postNotesTranslateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    targetLang: s.field("targetLang", S.string),
  })

type postNotesTranslateResponse = {
  sourceLang: string,
  text: string,
}

let postNotesTranslateResponseSchema = S.object(s => {
    sourceLang: s.field("sourceLang", S.string),
    text: s.field("text", S.string),
  })

/**
notes/translate

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesTranslate = (~body: postNotesTranslateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesTranslateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesTranslateRequestSchema)
  fetch(
    ~url="/notes/translate",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesTranslateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postNotesUnrenoteRequest = {
  noteId: string,
}

let postNotesUnrenoteRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postNotesUnrenoteResponse = unit

/**
notes/unrenote

No description provided.

**Credential required**: *Yes* / **Permission**: *write:notes*
*/
let postNotesUnrenote = (~body: postNotesUnrenoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesUnrenoteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesUnrenoteRequestSchema)
  fetch(
    ~url="/notes/unrenote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postNotesUserListTimelineRequest = {
  listId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  includeMyRenotes: option<bool>,
  includeRenotedMyNotes: option<bool>,
  includeLocalRenotes: option<bool>,
  withRenotes: option<bool>,
  withFiles: option<bool>,
}

let postNotesUserListTimelineRequestSchema = S.object(s => {
    listId: s.field("listId", S.string),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    sinceDate: s.field("sinceDate", S.option(S.int)),
    untilDate: s.field("untilDate", S.option(S.int)),
    allowPartial: s.field("allowPartial", S.option(S.bool)),
    includeMyRenotes: s.field("includeMyRenotes", S.option(S.bool)),
    includeRenotedMyNotes: s.field("includeRenotedMyNotes", S.option(S.bool)),
    includeLocalRenotes: s.field("includeLocalRenotes", S.option(S.bool)),
    withRenotes: s.field("withRenotes", S.option(S.bool)),
    withFiles: s.field("withFiles", S.option(S.bool)),
  })

type postNotesUserListTimelineResponse = array<MisskeyIoComponentSchemas.Note.t>

let postNotesUserListTimelineResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
notes/user-list-timeline

No description provided.

**Credential required**: *Yes* / **Permission**: *read:account*
*/
let postNotesUserListTimeline = (~body: postNotesUserListTimelineRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postNotesUserListTimelineResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postNotesUserListTimelineRequestSchema)
  fetch(
    ~url="/notes/user-list-timeline",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postNotesUserListTimelineResponseSchema)
  value
    ->Promise.resolve
  })
}

type postPromoReadRequest = {
  noteId: string,
}

let postPromoReadRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
  })

type postPromoReadResponse = unit

/**
promo/read

No description provided.

**Credential required**: *Yes* / **Permission**: *write:account*
*/
let postPromoRead = (~body: postPromoReadRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPromoReadResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postPromoReadRequestSchema)
  fetch(
    ~url="/promo/read",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type getUsersFeaturedNotesRequest = {
  limit: option<int>,
  untilId: option<string>,
  userId: string,
}

let getUsersFeaturedNotesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    untilId: s.field("untilId", S.option(S.string)),
    userId: s.field("userId", S.string),
  })

type getUsersFeaturedNotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let getUsersFeaturedNotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
users/featured-notes

No description provided.

**Credential required**: *No*
*/
let getUsersFeaturedNotes = (~body: getUsersFeaturedNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getUsersFeaturedNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getUsersFeaturedNotesRequestSchema)
  fetch(
    ~url="/users/featured-notes",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getUsersFeaturedNotesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersFeaturedNotesRequest = {
  limit: option<int>,
  untilId: option<string>,
  userId: string,
}

let postUsersFeaturedNotesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    untilId: s.field("untilId", S.option(S.string)),
    userId: s.field("userId", S.string),
  })

type postUsersFeaturedNotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postUsersFeaturedNotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
users/featured-notes

No description provided.

**Credential required**: *No*
*/
let postUsersFeaturedNotes = (~body: postUsersFeaturedNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFeaturedNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFeaturedNotesRequestSchema)
  fetch(
    ~url="/users/featured-notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersFeaturedNotesResponseSchema)
  value
    ->Promise.resolve
  })
}
