// misskey-io API for users
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postEmailAddressAvailableRequest = {
  emailAddress: string,
}

let postEmailAddressAvailableRequestSchema = S.object(s => {
    emailAddress: s.field("emailAddress", S.string),
  })

type postEmailAddressAvailableResponse = {
  available: bool,
  reason: option<string>,
}

let postEmailAddressAvailableResponseSchema = S.object(s => {
    available: s.field("available", S.bool),
    reason: s.field("reason", S.nullableAsOption(S.string)),
  })

/**
 * email-address/available
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postEmailAddressAvailable = (~body: postEmailAddressAvailableRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postEmailAddressAvailableResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postEmailAddressAvailableRequestSchema)
  fetch(
    ~url="/email-address/available",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postEmailAddressAvailableResponseSchema)
  value
    ->Promise.resolve
  })
}

type postGetAvatarDecorationsResponse_1 = {
  id: string,
  name: string,
  description: string,
  url: string,
  roleIdsThatCanBeUsedThisDecoration: array<string>,
}

type postGetAvatarDecorationsResponse = array<postGetAvatarDecorationsResponse_1>

let postGetAvatarDecorationsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    url: s.field("url", S.string),
    roleIdsThatCanBeUsedThisDecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.array(S.string)),
  })

let postGetAvatarDecorationsResponseSchema = S.array(postGetAvatarDecorationsResponse_1Schema)

/**
 * get-avatar-decorations
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postGetAvatarDecorations = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postGetAvatarDecorationsResponse> => {

  fetch(
    ~url="/get-avatar-decorations",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postGetAvatarDecorationsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postIMoveRequest = {
  moveToAccount: string,
}

let postIMoveRequestSchema = S.object(s => {
    moveToAccount: s.field("moveToAccount", S.string),
  })

type postIMoveResponse = dict<JSON.t>

let postIMoveResponseSchema = S.dict(S.json)

/**
 * i/move
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes*
 */
let postIMove = (~body: postIMoveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postIMoveResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postIMoveRequestSchema)
  fetch(
    ~url="/i/move",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postIMoveResponseSchema)
  value
    ->Promise.resolve
  })
}

type postPinnedUsersResponse = array<MisskeyIoComponentSchemas.UserDetailed.t>

let postPinnedUsersResponseSchema = S.array(MisskeyIoComponentSchemas.UserDetailed.schema)

/**
 * pinned-users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postPinnedUsers = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPinnedUsersResponse> => {

  fetch(
    ~url="/pinned-users",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postPinnedUsersResponseSchema)
  value
    ->Promise.resolve
  })
}

type getRetentionResponse_1 = {
  createdAt: string,
  users: float,
  data: dict<JSON.t>,
}

type getRetentionResponse = array<getRetentionResponse_1>

let getRetentionResponse_1Schema = S.object(s => {
    createdAt: s.field("createdAt", S.string),
    users: s.field("users", S.float),
    data: s.field("data", S.dict(S.json)),
  })

let getRetentionResponseSchema = S.array(getRetentionResponse_1Schema)

/**
 * retention
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getRetention = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getRetentionResponse> => {

  fetch(
    ~url="/retention",
    ~method_="GET",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getRetentionResponseSchema)
  value
    ->Promise.resolve
  })
}

type postRetentionResponse_1 = {
  createdAt: string,
  users: float,
  data: dict<JSON.t>,
}

type postRetentionResponse = array<postRetentionResponse_1>

let postRetentionResponse_1Schema = S.object(s => {
    createdAt: s.field("createdAt", S.string),
    users: s.field("users", S.float),
    data: s.field("data", S.dict(S.json)),
  })

let postRetentionResponseSchema = S.array(postRetentionResponse_1Schema)

/**
 * retention
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postRetention = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postRetentionResponse> => {

  fetch(
    ~url="/retention",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postRetentionResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsernameAvailableRequest = {
  username: string,
}

let postUsernameAvailableRequestSchema = S.object(s => {
    username: s.field("username", S.string->S.pattern(/^\w{1,20}$/)),
  })

type postUsernameAvailableResponse = {
  available: bool,
}

let postUsernameAvailableResponseSchema = S.object(s => {
    available: s.field("available", S.bool),
  })

/**
 * username/available
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsernameAvailable = (~body: postUsernameAvailableRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsernameAvailableResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsernameAvailableRequestSchema)
  fetch(
    ~url="/username/available",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsernameAvailableResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersRequest = {
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
  state: option<string>,
  origin: option<string>,
  hostname: option<string>,
}

let postUsersRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
    state: s.fieldOr("state", S.nullableAsOption(S.string), None),
    origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
    hostname: s.fieldOr("hostname", S.nullableAsOption(S.string), None),
  })

type postUsersResponse = array<MisskeyIoComponentSchemas.UserDetailed.t>

let postUsersResponseSchema = S.array(MisskeyIoComponentSchemas.UserDetailed.schema)

/**
 * users
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsers = (~body: postUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersRequestSchema)
  fetch(
    ~url="/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersClipsRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postUsersClipsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postUsersClipsResponse = array<MisskeyIoComponentSchemas.Clip.t>

let postUsersClipsResponseSchema = S.array(MisskeyIoComponentSchemas.Clip.schema)

/**
 * users/clips
 *
 * Show all clips this user owns.
 *
 * **Credential required**: *No*
 */
let postUsersClips = (~body: postUsersClipsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersClipsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersClipsRequestSchema)
  fetch(
    ~url="/users/clips",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersClipsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersFlashsRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postUsersFlashsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postUsersFlashsResponse = array<MisskeyIoComponentSchemas.Flash.t>

let postUsersFlashsResponseSchema = S.array(MisskeyIoComponentSchemas.Flash.schema)

/**
 * users/flashs
 *
 * Show all flashs this user created.
 *
 * **Credential required**: *No*
 */
let postUsersFlashs = (~body: postUsersFlashsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFlashsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFlashsRequestSchema)
  fetch(
    ~url="/users/flashs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersFlashsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersFollowersRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
  userId: option<string>,
  username: option<string>,
  host: option<string>,
}

let postUsersFollowersRequestSchema = S.object(s => {
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    username: s.fieldOr("username", S.nullableAsOption(S.string), None),
    host: s.fieldOr("host", S.nullableAsOption(S.string), None),
  })

type postUsersFollowersResponse = array<MisskeyIoComponentSchemas.Following.t>

let postUsersFollowersResponseSchema = S.array(MisskeyIoComponentSchemas.Following.schema)

/**
 * users/followers
 *
 * Show everyone that follows this user.
 *
 * **Credential required**: *No*
 */
let postUsersFollowers = (~body: postUsersFollowersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFollowersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFollowersRequestSchema)
  fetch(
    ~url="/users/followers",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersFollowersResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersFollowingRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
  userId: option<string>,
  username: option<string>,
  host: option<string>,
  birthday: option<string>,
}

let postUsersFollowingRequestSchema = S.object(s => {
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    username: s.fieldOr("username", S.nullableAsOption(S.string), None),
    host: s.fieldOr("host", S.nullableAsOption(S.string), None),
    birthday: s.fieldOr("birthday", S.nullableAsOption(S.string->S.pattern(/^([0-9]{4})-([0-9]{2})-([0-9]{2})$/)), None),
  })

type postUsersFollowingResponse = array<MisskeyIoComponentSchemas.Following.t>

let postUsersFollowingResponseSchema = S.array(MisskeyIoComponentSchemas.Following.schema)

/**
 * users/following
 *
 * Show everyone that this user is following.
 *
 * **Credential required**: *No*
 */
let postUsersFollowing = (~body: postUsersFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersFollowingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersFollowingRequestSchema)
  fetch(
    ~url="/users/following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersFollowingResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersGalleryPostsRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postUsersGalleryPostsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postUsersGalleryPostsResponse = array<MisskeyIoComponentSchemas.GalleryPost.t>

let postUsersGalleryPostsResponseSchema = S.array(MisskeyIoComponentSchemas.GalleryPost.schema)

/**
 * users/gallery/posts
 *
 * Show all gallery posts by the given user.
 *
 * **Credential required**: *No*
 */
let postUsersGalleryPosts = (~body: postUsersGalleryPostsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGalleryPostsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGalleryPostsRequestSchema)
  fetch(
    ~url="/users/gallery/posts",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersGalleryPostsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersGetFollowingBirthdayUsersRequest_2 = {
  month: int,
  day: int,
}

type postUsersGetFollowingBirthdayUsersRequest_1 = {
  month: option<int>,
  day: option<int>,
  begin: option<postUsersGetFollowingBirthdayUsersRequest_2>,
  @as("end") end_: option<postUsersGetFollowingBirthdayUsersRequest_2>,
}

type postUsersGetFollowingBirthdayUsersRequest = {
  limit: option<int>,
  offset: option<int>,
  birthday: postUsersGetFollowingBirthdayUsersRequest_1,
}

let postUsersGetFollowingBirthdayUsersRequest_2Schema = S.object(s => {
    month: s.field("month", S.int->S.min(1)->S.max(12)),
    day: s.field("day", S.int->S.min(1)->S.max(31)),
  })

let postUsersGetFollowingBirthdayUsersRequest_1Schema = S.object(s => {
    month: s.fieldOr("month", S.nullableAsOption(S.int->S.min(1)->S.max(12)), None),
    day: s.fieldOr("day", S.nullableAsOption(S.int->S.min(1)->S.max(31)), None),
    begin: s.fieldOr("begin", S.nullableAsOption(postUsersGetFollowingBirthdayUsersRequest_2Schema), None),
    end_: s.fieldOr("end", S.nullableAsOption(postUsersGetFollowingBirthdayUsersRequest_2Schema), None),
  })

let postUsersGetFollowingBirthdayUsersRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    birthday: s.field("birthday", postUsersGetFollowingBirthdayUsersRequest_1Schema),
  })

type postUsersGetFollowingBirthdayUsersResponse_1 = {
  birthday: string,
  user: MisskeyIoComponentSchemas.UserLite.t,
}

type postUsersGetFollowingBirthdayUsersResponse = array<postUsersGetFollowingBirthdayUsersResponse_1>

let postUsersGetFollowingBirthdayUsersResponse_1Schema = S.object(s => {
    birthday: s.field("birthday", S.string),
    user: s.field("user", MisskeyIoComponentSchemas.UserLite.schema),
  })

let postUsersGetFollowingBirthdayUsersResponseSchema = S.array(postUsersGetFollowingBirthdayUsersResponse_1Schema)

/**
 * users/get-following-birthday-users
 *
 * Find users who have a birthday on the specified range.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postUsersGetFollowingBirthdayUsers = (~body: postUsersGetFollowingBirthdayUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGetFollowingBirthdayUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGetFollowingBirthdayUsersRequestSchema)
  fetch(
    ~url="/users/get-following-birthday-users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersGetFollowingBirthdayUsersResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersGetFrequentlyRepliedUsersRequest = {
  userId: string,
  limit: option<int>,
}

let postUsersGetFrequentlyRepliedUsersRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postUsersGetFrequentlyRepliedUsersResponse_1 = {
  user: MisskeyIoComponentSchemas.UserDetailed.t,
  weight: float,
}

type postUsersGetFrequentlyRepliedUsersResponse = array<postUsersGetFrequentlyRepliedUsersResponse_1>

let postUsersGetFrequentlyRepliedUsersResponse_1Schema = S.object(s => {
    user: s.field("user", MisskeyIoComponentSchemas.UserDetailed.schema),
    weight: s.field("weight", S.float),
  })

let postUsersGetFrequentlyRepliedUsersResponseSchema = S.array(postUsersGetFrequentlyRepliedUsersResponse_1Schema)

/**
 * users/get-frequently-replied-users
 *
 * Get a list of other users that the specified user frequently replies to.
 *
 * **Credential required**: *No*
 */
let postUsersGetFrequentlyRepliedUsers = (~body: postUsersGetFrequentlyRepliedUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGetFrequentlyRepliedUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGetFrequentlyRepliedUsersRequestSchema)
  fetch(
    ~url="/users/get-frequently-replied-users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersGetFrequentlyRepliedUsersResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersGetSecurityInfoRequest = {
  email: string,
  password: string,
}

let postUsersGetSecurityInfoRequestSchema = S.object(s => {
    email: s.field("email", S.string),
    password: s.field("password", S.string),
  })

type postUsersGetSecurityInfoResponse = {
  twoFactorEnabled: bool,
  usePasswordLessLogin: bool,
  securityKeys: bool,
}

let postUsersGetSecurityInfoResponseSchema = S.object(s => {
    twoFactorEnabled: s.field("twoFactorEnabled", S.bool),
    usePasswordLessLogin: s.field("usePasswordLessLogin", S.bool),
    securityKeys: s.field("securityKeys", S.bool),
  })

/**
 * users/get-security-info
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsersGetSecurityInfo = (~body: postUsersGetSecurityInfoRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGetSecurityInfoResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGetSecurityInfoRequestSchema)
  fetch(
    ~url="/users/get-security-info",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersGetSecurityInfoResponseSchema)
  value
    ->Promise.resolve
  })
}

type getUsersGetSkebStatusRequest = {
  userId: string,
}

let getUsersGetSkebStatusRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type getUsersGetSkebStatusResponse_1 = {
  amount: int,
  genre: string,
}

type getUsersGetSkebStatusResponse = {
  screenName: string,
  isCreator: bool,
  isAcceptable: bool,
  creatorRequestCount: int,
  clientRequestCount: int,
  skills: array<getUsersGetSkebStatusResponse_1>,
}

let getUsersGetSkebStatusResponse_1Schema = S.object(s => {
    amount: s.field("amount", S.int),
    genre: s.field("genre", S.string),
  })

let getUsersGetSkebStatusResponseSchema = S.object(s => {
    screenName: s.field("screenName", S.string),
    isCreator: s.field("isCreator", S.bool),
    isAcceptable: s.field("isAcceptable", S.bool),
    creatorRequestCount: s.field("creatorRequestCount", S.int),
    clientRequestCount: s.field("clientRequestCount", S.int),
    skills: s.field("skills", S.array(getUsersGetSkebStatusResponse_1Schema)),
  })

/**
 * users/get-skeb-status
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let getUsersGetSkebStatus = (~body: getUsersGetSkebStatusRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<getUsersGetSkebStatusResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(getUsersGetSkebStatusRequestSchema)
  fetch(
    ~url="/users/get-skeb-status",
    ~method_="GET",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(getUsersGetSkebStatusResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersGetSkebStatusRequest = {
  userId: string,
}

let postUsersGetSkebStatusRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postUsersGetSkebStatusResponse_1 = {
  amount: int,
  genre: string,
}

type postUsersGetSkebStatusResponse = {
  screenName: string,
  isCreator: bool,
  isAcceptable: bool,
  creatorRequestCount: int,
  clientRequestCount: int,
  skills: array<postUsersGetSkebStatusResponse_1>,
}

let postUsersGetSkebStatusResponse_1Schema = S.object(s => {
    amount: s.field("amount", S.int),
    genre: s.field("genre", S.string),
  })

let postUsersGetSkebStatusResponseSchema = S.object(s => {
    screenName: s.field("screenName", S.string),
    isCreator: s.field("isCreator", S.bool),
    isAcceptable: s.field("isAcceptable", S.bool),
    creatorRequestCount: s.field("creatorRequestCount", S.int),
    clientRequestCount: s.field("clientRequestCount", S.int),
    skills: s.field("skills", S.array(postUsersGetSkebStatusResponse_1Schema)),
  })

/**
 * users/get-skeb-status
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsersGetSkebStatus = (~body: postUsersGetSkebStatusRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersGetSkebStatusResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersGetSkebStatusRequestSchema)
  fetch(
    ~url="/users/get-skeb-status",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersGetSkebStatusResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersNotesRequest = {
  userId: string,
  withReplies: option<bool>,
  withRenotes: option<bool>,
  withChannelNotes: option<bool>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
  allowPartial: option<bool>,
  withFiles: option<bool>,
}

let postUsersNotesRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
    withRenotes: s.fieldOr("withRenotes", S.nullableAsOption(S.bool), None),
    withChannelNotes: s.fieldOr("withChannelNotes", S.nullableAsOption(S.bool), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
    allowPartial: s.fieldOr("allowPartial", S.nullableAsOption(S.bool), None),
    withFiles: s.fieldOr("withFiles", S.nullableAsOption(S.bool), None),
  })

type postUsersNotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postUsersNotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
 * users/notes
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postUsersNotes = (~body: postUsersNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersNotesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersNotesRequestSchema)
  fetch(
    ~url="/users/notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersNotesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersPagesRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postUsersPagesRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postUsersPagesResponse = array<MisskeyIoComponentSchemas.Page.t>

let postUsersPagesResponseSchema = S.array(MisskeyIoComponentSchemas.Page.schema)

/**
 * users/pages
 *
 * Show all pages this user created.
 *
 * **Credential required**: *No*
 */
let postUsersPages = (~body: postUsersPagesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersPagesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersPagesRequestSchema)
  fetch(
    ~url="/users/pages",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersPagesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersReactionsRequest = {
  userId: string,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  sinceDate: option<int>,
  untilDate: option<int>,
}

let postUsersReactionsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    sinceDate: s.fieldOr("sinceDate", S.nullableAsOption(S.int), None),
    untilDate: s.fieldOr("untilDate", S.nullableAsOption(S.int), None),
  })

type postUsersReactionsResponse = array<MisskeyIoComponentSchemas.NoteReaction.t>

let postUsersReactionsResponseSchema = S.array(MisskeyIoComponentSchemas.NoteReaction.schema)

/**
 * users/reactions
 *
 * Show all reactions this user made.
 *
 * **Credential required**: *No*
 */
let postUsersReactions = (~body: postUsersReactionsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersReactionsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersReactionsRequestSchema)
  fetch(
    ~url="/users/reactions",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersReactionsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersRecommendationRequest = {
  limit: option<int>,
  offset: option<int>,
}

let postUsersRecommendationRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
  })

type postUsersRecommendationResponse = array<MisskeyIoComponentSchemas.UserDetailed.t>

let postUsersRecommendationResponseSchema = S.array(MisskeyIoComponentSchemas.UserDetailed.schema)

/**
 * users/recommendation
 *
 * Show users that the authenticated user might be interested to follow.
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postUsersRecommendation = (~body: postUsersRecommendationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersRecommendationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersRecommendationRequestSchema)
  fetch(
    ~url="/users/recommendation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersRecommendationResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersRelationRequest = {
  userId: array<string>,
}

let postUsersRelationRequestSchema = S.object(s => {
    userId: s.field("userId", S.array(S.string)),
  })

type postUsersRelationResponse_1 = {
  id: string,
  isFollowing: bool,
  hasPendingFollowRequestFromYou: bool,
  hasPendingFollowRequestToYou: bool,
  isFollowed: bool,
  isBlocking: bool,
  isBlocked: bool,
  isMuted: bool,
  isRenoteMuted: bool,
}

type postUsersRelationResponse = array<postUsersRelationResponse_1>

let postUsersRelationResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    isFollowing: s.field("isFollowing", S.bool),
    hasPendingFollowRequestFromYou: s.field("hasPendingFollowRequestFromYou", S.bool),
    hasPendingFollowRequestToYou: s.field("hasPendingFollowRequestToYou", S.bool),
    isFollowed: s.field("isFollowed", S.bool),
    isBlocking: s.field("isBlocking", S.bool),
    isBlocked: s.field("isBlocked", S.bool),
    isMuted: s.field("isMuted", S.bool),
    isRenoteMuted: s.field("isRenoteMuted", S.bool),
  })

let postUsersRelationResponseSchema = S.array(postUsersRelationResponse_1Schema)

/**
 * users/relation
 *
 * Show the different kinds of relations between the authenticated user and the specified user(s).
 *
 * **Credential required**: *Yes* / **Permission**: *read:account*
 */
let postUsersRelation = (~body: postUsersRelationRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersRelationResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersRelationRequestSchema)
  fetch(
    ~url="/users/relation",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersRelationResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersReportAbuseRequest = {
  userId: string,
  comment: string,
  category: option<string>,
}

let postUsersReportAbuseRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    comment: s.field("comment", S.string->S.min(1)->S.max(2048)),
    category: s.fieldOr("category", S.nullableAsOption(S.string), None),
  })

type postUsersReportAbuseResponse = unit

/**
 * users/report-abuse
 *
 * File a report.
 *
 * **Credential required**: *Yes* / **Permission**: *write:report-abuse*
 */
let postUsersReportAbuse = (~body: postUsersReportAbuseRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersReportAbuseResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersReportAbuseRequestSchema)
  fetch(
    ~url="/users/report-abuse",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postUsersSearchRequest = {
  query: string,
  offset: option<int>,
  limit: option<int>,
  origin: option<string>,
  detail: option<bool>,
}

let postUsersSearchRequestSchema = S.object(s => {
    query: s.field("query", S.string),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
    detail: s.fieldOr("detail", S.nullableAsOption(S.bool), None),
  })

type postUsersSearchResponse = array<MisskeyIoComponentSchemas.User.t>

let postUsersSearchResponseSchema = S.array(MisskeyIoComponentSchemas.User.schema)

/**
 * users/search
 *
 * Search for users.
 *
 * **Credential required**: *No*
 */
let postUsersSearch = (~body: postUsersSearchRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersSearchResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersSearchRequestSchema)
  fetch(
    ~url="/users/search",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersSearchResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersSearchByUsernameAndHostRequest = {
  limit: option<int>,
  detail: option<bool>,
  username: option<string>,
  host: option<string>,
}

let postUsersSearchByUsernameAndHostRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    detail: s.fieldOr("detail", S.nullableAsOption(S.bool), None),
    username: s.fieldOr("username", S.nullableAsOption(S.string), None),
    host: s.fieldOr("host", S.nullableAsOption(S.string), None),
  })

type postUsersSearchByUsernameAndHostResponse = array<MisskeyIoComponentSchemas.User.t>

let postUsersSearchByUsernameAndHostResponseSchema = S.array(MisskeyIoComponentSchemas.User.schema)

/**
 * users/search-by-username-and-host
 *
 * Search for a user by username and/or host.
 *
 * **Credential required**: *No*
 */
let postUsersSearchByUsernameAndHost = (~body: postUsersSearchByUsernameAndHostRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersSearchByUsernameAndHostResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersSearchByUsernameAndHostRequestSchema)
  fetch(
    ~url="/users/search-by-username-and-host",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersSearchByUsernameAndHostResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersShowRequest = {
  userId: option<string>,
  userIds: option<array<string>>,
  username: option<string>,
  host: option<string>,
  detailed: option<bool>,
}

let postUsersShowRequestSchema = S.object(s => {
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    userIds: s.fieldOr("userIds", S.nullableAsOption(S.array(S.string)), None),
    username: s.fieldOr("username", S.nullableAsOption(S.string), None),
    host: s.fieldOr("host", S.nullableAsOption(S.string), None),
    detailed: s.fieldOr("detailed", S.nullableAsOption(S.bool), None),
  })

type postUsersShowResponse = array<MisskeyIoComponentSchemas.UserDetailed.t>

let postUsersShowResponseSchema = S.array(MisskeyIoComponentSchemas.UserDetailed.schema)

/**
 * users/show
 *
 * Show the properties of a user.
 *
 * **Credential required**: *No*
 */
let postUsersShow = (~body: postUsersShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersShowRequestSchema)
  fetch(
    ~url="/users/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postUsersStatsRequest = {
  userId: string,
}

let postUsersStatsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postUsersStatsResponse = {
  notesCount: int,
  repliesCount: int,
  renotesCount: int,
  repliedCount: int,
  renotedCount: int,
  pollVotesCount: int,
  pollVotedCount: int,
  localFollowingCount: int,
  remoteFollowingCount: int,
  localFollowersCount: int,
  remoteFollowersCount: int,
  followingCount: int,
  followersCount: int,
  sentReactionsCount: int,
  receivedReactionsCount: int,
  noteFavoritesCount: int,
  pageLikesCount: int,
  pageLikedCount: int,
  driveFilesCount: int,
  driveUsage: int,
}

let postUsersStatsResponseSchema = S.object(s => {
    notesCount: s.field("notesCount", S.int),
    repliesCount: s.field("repliesCount", S.int),
    renotesCount: s.field("renotesCount", S.int),
    repliedCount: s.field("repliedCount", S.int),
    renotedCount: s.field("renotedCount", S.int),
    pollVotesCount: s.field("pollVotesCount", S.int),
    pollVotedCount: s.field("pollVotedCount", S.int),
    localFollowingCount: s.field("localFollowingCount", S.int),
    remoteFollowingCount: s.field("remoteFollowingCount", S.int),
    localFollowersCount: s.field("localFollowersCount", S.int),
    remoteFollowersCount: s.field("remoteFollowersCount", S.int),
    followingCount: s.field("followingCount", S.int),
    followersCount: s.field("followersCount", S.int),
    sentReactionsCount: s.field("sentReactionsCount", S.int),
    receivedReactionsCount: s.field("receivedReactionsCount", S.int),
    noteFavoritesCount: s.field("noteFavoritesCount", S.int),
    pageLikesCount: s.field("pageLikesCount", S.int),
    pageLikedCount: s.field("pageLikedCount", S.int),
    driveFilesCount: s.field("driveFilesCount", S.int),
    driveUsage: s.field("driveUsage", S.int),
  })

/**
 * users/stats
 *
 * Show statistics about a user.
 *
 * **Credential required**: *No*
 */
let postUsersStats = (~body: postUsersStatsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postUsersStatsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postUsersStatsRequestSchema)
  fetch(
    ~url="/users/stats",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postUsersStatsResponseSchema)
  value
    ->Promise.resolve
  })
}
