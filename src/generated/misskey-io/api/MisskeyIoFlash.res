// misskey-io API for flash
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postFlashCreateRequest = {
  title: string,
  summary: string,
  script: string,
  permissions: array<string>,
  visibility: option<string>,
}

let postFlashCreateRequestSchema = S.object(s => {
    title: s.field("title", S.string),
    summary: s.field("summary", S.string),
    script: s.field("script", S.string),
    permissions: s.field("permissions", S.array(S.string)),
    visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
  })

type postFlashCreateResponse = MisskeyIoComponentSchemas.Flash.t

let postFlashCreateResponseSchema = MisskeyIoComponentSchemas.Flash.schema

/**
 * flash/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:flash*
 */
let postFlashCreate = (~body: postFlashCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashCreateRequestSchema)
  fetch(
    ~url="/flash/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFlashCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFlashFeaturedRequest = {
  offset: option<int>,
  limit: option<int>,
}

let postFlashFeaturedRequestSchema = S.object(s => {
    offset: s.fieldOr("offset", S.nullableAsOption(S.int->S.min(0)), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postFlashFeaturedResponse = array<MisskeyIoComponentSchemas.Flash.t>

let postFlashFeaturedResponseSchema = S.array(MisskeyIoComponentSchemas.Flash.schema)

/**
 * flash/featured
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postFlashFeatured = (~body: postFlashFeaturedRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashFeaturedResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashFeaturedRequestSchema)
  fetch(
    ~url="/flash/featured",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postFlashFeaturedResponseSchema)
  value
    ->Promise.resolve
  })
}

type postFlashLikeRequest = {
  flashId: string,
}

let postFlashLikeRequestSchema = S.object(s => {
    flashId: s.field("flashId", S.string),
  })

type postFlashLikeResponse = unit

/**
 * flash/like
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:flash-likes*
 */
let postFlashLike = (~body: postFlashLikeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashLikeResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashLikeRequestSchema)
  fetch(
    ~url="/flash/like",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postFlashUnlikeRequest = {
  flashId: string,
}

let postFlashUnlikeRequestSchema = S.object(s => {
    flashId: s.field("flashId", S.string),
  })

type postFlashUnlikeResponse = unit

/**
 * flash/unlike
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:flash-likes*
 */
let postFlashUnlike = (~body: postFlashUnlikeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashUnlikeResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashUnlikeRequestSchema)
  fetch(
    ~url="/flash/unlike",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postFlashUpdateRequest = {
  flashId: string,
  title: option<string>,
  summary: option<string>,
  script: option<string>,
  permissions: option<array<string>>,
  visibility: option<string>,
}

let postFlashUpdateRequestSchema = S.object(s => {
    flashId: s.field("flashId", S.string),
    title: s.fieldOr("title", S.nullableAsOption(S.string), None),
    summary: s.fieldOr("summary", S.nullableAsOption(S.string), None),
    script: s.fieldOr("script", S.nullableAsOption(S.string), None),
    permissions: s.fieldOr("permissions", S.nullableAsOption(S.array(S.string)), None),
    visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
  })

type postFlashUpdateResponse = unit

/**
 * flash/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:flash*
 */
let postFlashUpdate = (~body: postFlashUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFlashUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFlashUpdateRequestSchema)
  fetch(
    ~url="/flash/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}
