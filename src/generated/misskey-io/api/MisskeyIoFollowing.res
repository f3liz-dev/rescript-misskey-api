// SPDX-License-Identifier: MIT
// misskey-io API for following
// Generated by rescript-codegen-openapi
// DO NOT EDIT - This file is auto-generated



type postFollowingCreateRequest = {
  userId: string,
  withReplies: option<bool>,
}

let postFollowingCreateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
  })

type postFollowingCreateResponse = MisskeyIoComponentSchemas.UserLite.t

let postFollowingCreateResponseSchema = MisskeyIoComponentSchemas.UserLite.schema

/**
 * following/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:following*
 */
let postFollowingCreate = (~body: postFollowingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingCreateRequestSchema)
  
  fetch(
    ~url="/following/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFollowingCreateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFollowingDeleteRequest = {
  userId: string,
}

let postFollowingDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingDeleteResponse = MisskeyIoComponentSchemas.UserLite.t

let postFollowingDeleteResponseSchema = MisskeyIoComponentSchemas.UserLite.schema

/**
 * following/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:following*
 */
let postFollowingDelete = (~body: postFollowingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingDeleteRequestSchema)
  
  fetch(
    ~url="/following/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFollowingDeleteResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFollowingInvalidateRequest = {
  userId: string,
}

let postFollowingInvalidateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingInvalidateResponse = MisskeyIoComponentSchemas.UserLite.t

let postFollowingInvalidateResponseSchema = MisskeyIoComponentSchemas.UserLite.schema

/**
 * following/invalidate
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:following*
 */
let postFollowingInvalidate = (~body: postFollowingInvalidateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingInvalidateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingInvalidateRequestSchema)
  
  fetch(
    ~url="/following/invalidate",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFollowingInvalidateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFollowingRequestsAcceptRequest = {
  userId: string,
}

let postFollowingRequestsAcceptRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingRequestsAcceptResponse = unit

/**
 * following/requests/accept
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:following*
 */
let postFollowingRequestsAccept = (~body: postFollowingRequestsAcceptRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingRequestsAcceptResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsAcceptRequestSchema)
  
  fetch(
    ~url="/following/requests/accept",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postFollowingRequestsCancelRequest = {
  userId: string,
}

let postFollowingRequestsCancelRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingRequestsCancelResponse = MisskeyIoComponentSchemas.UserLite.t

let postFollowingRequestsCancelResponseSchema = MisskeyIoComponentSchemas.UserLite.schema

/**
 * following/requests/cancel
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:following*
 */
let postFollowingRequestsCancel = (~body: postFollowingRequestsCancelRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingRequestsCancelResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsCancelRequestSchema)
  
  fetch(
    ~url="/following/requests/cancel",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFollowingRequestsCancelResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFollowingRequestsListRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postFollowingRequestsListRequestSchema = S.object(s => {
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postFollowingRequestsListResponse = array<JSON.t>

let postFollowingRequestsListResponseSchema = S.array(S.json)

/**
 * following/requests/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:following*
 */
let postFollowingRequestsList = (~body: postFollowingRequestsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingRequestsListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsListRequestSchema)
  
  fetch(
    ~url="/following/requests/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFollowingRequestsListResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFollowingRequestsRejectRequest = {
  userId: string,
}

let postFollowingRequestsRejectRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingRequestsRejectResponse = unit

/**
 * following/requests/reject
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:following*
 */
let postFollowingRequestsReject = (~body: postFollowingRequestsRejectRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingRequestsRejectResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsRejectRequestSchema)
  
  fetch(
    ~url="/following/requests/reject",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}

type postFollowingRequestsSentRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postFollowingRequestsSentRequestSchema = S.object(s => {
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postFollowingRequestsSentResponse = array<JSON.t>

let postFollowingRequestsSentResponseSchema = S.array(S.json)

/**
 * following/requests/sent
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:following*
 */
let postFollowingRequestsSent = (~body: postFollowingRequestsSentRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingRequestsSentResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsSentRequestSchema)
  
  fetch(
    ~url="/following/requests/sent",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFollowingRequestsSentResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFollowingUpdateRequest = {
  userId: string,
  notify: option<string>,
  withReplies: option<bool>,
}

let postFollowingUpdateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    notify: s.fieldOr("notify", S.nullableAsOption(S.string), None),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
  })

type postFollowingUpdateResponse = MisskeyIoComponentSchemas.UserLite.t

let postFollowingUpdateResponseSchema = MisskeyIoComponentSchemas.UserLite.schema

/**
 * following/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:following*
 */
let postFollowingUpdate = (~body: postFollowingUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingUpdateRequestSchema)
  
  fetch(
    ~url="/following/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let validatedResponse = response->S.parseOrThrow(postFollowingUpdateResponseSchema)
  validatedResponse
->Promise.resolve
  })
}

type postFollowingUpdateAllRequest = {
  notify: option<string>,
  withReplies: option<bool>,
}

let postFollowingUpdateAllRequestSchema = S.object(s => {
    notify: s.fieldOr("notify", S.nullableAsOption(S.string), None),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
  })

type postFollowingUpdateAllResponse = unit

/**
 * following/update-all
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:following*
 */
let postFollowingUpdateAll = (~body: postFollowingUpdateAllRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postFollowingUpdateAllResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingUpdateAllRequestSchema)
  
  fetch(
    ~url="/following/update-all",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
->Promise.resolve
  })
}
