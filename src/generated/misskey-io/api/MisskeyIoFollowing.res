// misskey-io API for following
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postFollowingCreateRequest = {
  userId: string,
  withReplies: option<bool>,
}

let postFollowingCreateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    withReplies: s.field("withReplies", S.option(S.bool)),
  })

type postFollowingCreateResponse = MisskeyIoComponentSchemas.UserLite.t

let postFollowingCreateResponseSchema = MisskeyIoComponentSchemas.UserLite.schema

/**
following/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingCreate = async (~body: postFollowingCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingCreateRequestSchema)
  let response = await fetch(
    ~url="/following/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingCreateResponseSchema)
}

type postFollowingDeleteRequest = {
  userId: string,
}

let postFollowingDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingDeleteResponse = MisskeyIoComponentSchemas.UserLite.t

let postFollowingDeleteResponseSchema = MisskeyIoComponentSchemas.UserLite.schema

/**
following/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingDelete = async (~body: postFollowingDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingDeleteRequestSchema)
  let response = await fetch(
    ~url="/following/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingDeleteResponseSchema)
}

type postFollowingInvalidateRequest = {
  userId: string,
}

let postFollowingInvalidateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingInvalidateResponse = MisskeyIoComponentSchemas.UserLite.t

let postFollowingInvalidateResponseSchema = MisskeyIoComponentSchemas.UserLite.schema

/**
following/invalidate

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingInvalidate = async (~body: postFollowingInvalidateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingInvalidateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingInvalidateRequestSchema)
  let response = await fetch(
    ~url="/following/invalidate",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingInvalidateResponseSchema)
}

type postFollowingRequestsAcceptRequest = {
  userId: string,
}

let postFollowingRequestsAcceptRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingRequestsAcceptResponse = unit

/**
following/requests/accept

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingRequestsAccept = async (~body: postFollowingRequestsAcceptRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingRequestsAcceptResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsAcceptRequestSchema)
  let response = await fetch(
    ~url="/following/requests/accept",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postFollowingRequestsCancelRequest = {
  userId: string,
}

let postFollowingRequestsCancelRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingRequestsCancelResponse = MisskeyIoComponentSchemas.UserLite.t

let postFollowingRequestsCancelResponseSchema = MisskeyIoComponentSchemas.UserLite.schema

/**
following/requests/cancel

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingRequestsCancel = async (~body: postFollowingRequestsCancelRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingRequestsCancelResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsCancelRequestSchema)
  let response = await fetch(
    ~url="/following/requests/cancel",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingRequestsCancelResponseSchema)
}

type postFollowingRequestsListRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postFollowingRequestsListRequestSchema = S.object(s => {
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postFollowingRequestsListResponse_1 = {
  id: string,
  follower: MisskeyIoComponentSchemas.UserLite.t,
  followee: MisskeyIoComponentSchemas.UserLite.t,
}

type postFollowingRequestsListResponse = array<postFollowingRequestsListResponse_1>

let postFollowingRequestsListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    follower: s.field("follower", MisskeyIoComponentSchemas.UserLite.schema),
    followee: s.field("followee", MisskeyIoComponentSchemas.UserLite.schema),
  })

let postFollowingRequestsListResponseSchema = S.array(postFollowingRequestsListResponse_1Schema)

/**
following/requests/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:following*
*/
let postFollowingRequestsList = async (~body: postFollowingRequestsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingRequestsListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsListRequestSchema)
  let response = await fetch(
    ~url="/following/requests/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingRequestsListResponseSchema)
}

type postFollowingRequestsRejectRequest = {
  userId: string,
}

let postFollowingRequestsRejectRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postFollowingRequestsRejectResponse = unit

/**
following/requests/reject

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingRequestsReject = async (~body: postFollowingRequestsRejectRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingRequestsRejectResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsRejectRequestSchema)
  let response = await fetch(
    ~url="/following/requests/reject",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postFollowingRequestsSentRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postFollowingRequestsSentRequestSchema = S.object(s => {
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postFollowingRequestsSentResponse_1 = {
  id: string,
  follower: MisskeyIoComponentSchemas.UserLite.t,
  followee: MisskeyIoComponentSchemas.UserLite.t,
}

type postFollowingRequestsSentResponse = array<postFollowingRequestsSentResponse_1>

let postFollowingRequestsSentResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    follower: s.field("follower", MisskeyIoComponentSchemas.UserLite.schema),
    followee: s.field("followee", MisskeyIoComponentSchemas.UserLite.schema),
  })

let postFollowingRequestsSentResponseSchema = S.array(postFollowingRequestsSentResponse_1Schema)

/**
following/requests/sent

No description provided.

**Credential required**: *Yes* / **Permission**: *read:following*
*/
let postFollowingRequestsSent = async (~body: postFollowingRequestsSentRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingRequestsSentResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingRequestsSentRequestSchema)
  let response = await fetch(
    ~url="/following/requests/sent",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingRequestsSentResponseSchema)
}

type postFollowingUpdateRequest = {
  userId: string,
  notify: option<string>,
  withReplies: option<bool>,
}

let postFollowingUpdateRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    notify: s.field("notify", S.option(S.string)),
    withReplies: s.field("withReplies", S.option(S.bool)),
  })

type postFollowingUpdateResponse = MisskeyIoComponentSchemas.UserLite.t

let postFollowingUpdateResponseSchema = MisskeyIoComponentSchemas.UserLite.schema

/**
following/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingUpdate = async (~body: postFollowingUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingUpdateRequestSchema)
  let response = await fetch(
    ~url="/following/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postFollowingUpdateResponseSchema)
}

type postFollowingUpdateAllRequest = {
  notify: option<string>,
  withReplies: option<bool>,
}

let postFollowingUpdateAllRequestSchema = S.object(s => {
    notify: s.field("notify", S.option(S.string)),
    withReplies: s.field("withReplies", S.option(S.bool)),
  })

type postFollowingUpdateAllResponse = unit

/**
following/update-all

No description provided.

**Credential required**: *Yes* / **Permission**: *write:following*
*/
let postFollowingUpdateAll = async (~body: postFollowingUpdateAllRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postFollowingUpdateAllResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postFollowingUpdateAllRequestSchema)
  let response = await fetch(
    ~url="/following/update-all",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}
