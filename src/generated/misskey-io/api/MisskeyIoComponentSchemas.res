// Shared component schemas
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



module Error = {
  type t = {
  error: {
  code: string,
  message: string,
  id: string,
},
}
  let schema = S.object(s => {
    error: s.field("error", S.object(s => {
    code: s.field("code", S.string),
    message: s.field("message", S.string),
    id: s.field("id", S.string),
  })),
  })
}

module UserLite = {
  type t = {
  id: string,
  name: JSON.t,
  username: string,
  host: JSON.t,
  avatarUrl: JSON.t,
  avatarBlurhash: JSON.t,
  avatarDecorations: array<{
  id: string,
  angle: option<float>,
  flipH: option<bool>,
  url: string,
  offsetX: option<float>,
  offsetY: option<float>,
}>,
  isBot: option<bool>,
  isCat: option<bool>,
  requireSigninToViewContents: option<bool>,
  makeNotesFollowersOnlyBefore: option<JSON.t>,
  makeNotesHiddenBefore: option<JSON.t>,
  instance: option<{
  name: JSON.t,
  softwareName: JSON.t,
  softwareVersion: JSON.t,
  iconUrl: JSON.t,
  faviconUrl: JSON.t,
  themeColor: JSON.t,
}>,
  emojis: JSON.t,
  onlineStatus: string,
  badgeRoles: option<array<{
  name: string,
  iconUrl: JSON.t,
  displayOrder: float,
  behavior: option<string>,
}>>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.json),
    username: s.field("username", S.string),
    host: s.field("host", S.json),
    avatarUrl: s.field("avatarUrl", S.json),
    avatarBlurhash: s.field("avatarBlurhash", S.json),
    avatarDecorations: s.field("avatarDecorations", S.array(S.object(s => {
    id: s.field("id", S.string),
    angle: s.fieldOr("angle", S.nullableAsOption(S.float), None),
    flipH: s.fieldOr("flipH", S.nullableAsOption(S.bool), None),
    url: s.field("url", S.string),
    offsetX: s.fieldOr("offsetX", S.nullableAsOption(S.float), None),
    offsetY: s.fieldOr("offsetY", S.nullableAsOption(S.float), None),
  }))),
    isBot: s.fieldOr("isBot", S.nullableAsOption(S.bool), None),
    isCat: s.fieldOr("isCat", S.nullableAsOption(S.bool), None),
    requireSigninToViewContents: s.fieldOr("requireSigninToViewContents", S.nullableAsOption(S.bool), None),
    makeNotesFollowersOnlyBefore: s.fieldOr("makeNotesFollowersOnlyBefore", S.nullableAsOption(S.json), None),
    makeNotesHiddenBefore: s.fieldOr("makeNotesHiddenBefore", S.nullableAsOption(S.json), None),
    instance: s.fieldOr("instance", S.nullableAsOption(S.object(s => {
    name: s.field("name", S.json),
    softwareName: s.field("softwareName", S.json),
    softwareVersion: s.field("softwareVersion", S.json),
    iconUrl: s.field("iconUrl", S.json),
    faviconUrl: s.field("faviconUrl", S.json),
    themeColor: s.field("themeColor", S.json),
  })), None),
    emojis: s.field("emojis", S.json),
    onlineStatus: s.field("onlineStatus", S.string),
    badgeRoles: s.fieldOr("badgeRoles", S.nullableAsOption(S.array(S.object(s => {
    name: s.field("name", S.string),
    iconUrl: s.field("iconUrl", S.json),
    displayOrder: s.field("displayOrder", S.float),
    behavior: s.fieldOr("behavior", S.nullableAsOption(S.string), None),
  }))), None),
  })
}

module UserList = {
  type t = {
  id: string,
  createdAt: string,
  name: string,
  userIds: option<array<string>>,
  isPublic: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    userIds: s.fieldOr("userIds", S.nullableAsOption(S.array(S.string)), None),
    isPublic: s.field("isPublic", S.bool),
  })
}

module Ad = {
  type t = {
  id: string,
  expiresAt: string,
  startsAt: string,
  place: string,
  priority: string,
  ratio: float,
  url: string,
  imageUrl: string,
  imageBlurhash: JSON.t,
  memo: string,
  dayOfWeek: int,
  isSensitive: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    expiresAt: s.field("expiresAt", S.string),
    startsAt: s.field("startsAt", S.string),
    place: s.field("place", S.string),
    priority: s.field("priority", S.string),
    ratio: s.field("ratio", S.float),
    url: s.field("url", S.string),
    imageUrl: s.field("imageUrl", S.string),
    imageBlurhash: s.field("imageBlurhash", S.json),
    memo: s.field("memo", S.string),
    dayOfWeek: s.field("dayOfWeek", S.int),
    isSensitive: s.field("isSensitive", S.bool),
  })
}

module Announcement = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: JSON.t,
  text: string,
  title: string,
  imageUrl: JSON.t,
  icon: string,
  display: string,
  needConfirmationToRead: bool,
  needEnrollmentTutorialToRead: bool,
  forYou: bool,
  closeDuration: float,
  displayOrder: float,
  silence: bool,
  isRead: option<bool>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.json),
    text: s.field("text", S.string),
    title: s.field("title", S.string),
    imageUrl: s.field("imageUrl", S.json),
    icon: s.field("icon", S.string),
    display: s.field("display", S.string),
    needConfirmationToRead: s.field("needConfirmationToRead", S.bool),
    needEnrollmentTutorialToRead: s.field("needEnrollmentTutorialToRead", S.bool),
    forYou: s.field("forYou", S.bool),
    closeDuration: s.field("closeDuration", S.float),
    displayOrder: s.field("displayOrder", S.float),
    silence: s.field("silence", S.bool),
    isRead: s.fieldOr("isRead", S.nullableAsOption(S.bool), None),
  })
}

module App = {
  type t = {
  id: string,
  name: string,
  callbackUrl: JSON.t,
  permission: array<string>,
  secret: option<string>,
  isAuthorized: option<bool>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    callbackUrl: s.field("callbackUrl", S.json),
    permission: s.field("permission", S.array(S.string)),
    secret: s.fieldOr("secret", S.nullableAsOption(S.string), None),
    isAuthorized: s.fieldOr("isAuthorized", S.nullableAsOption(S.bool), None),
  })
}

module Notification = {
  type t = JSON.t
  let schema = S.json
}

module DriveFile = {
  type t = {
  id: string,
  createdAt: string,
  name: string,
  @as("type") type_: string,
  md5: string,
  size: float,
  isSensitive: bool,
  isSensitiveByModerator: option<JSON.t>,
  blurhash: JSON.t,
  properties: {
  width: option<float>,
  height: option<float>,
  orientation: option<float>,
  avgColor: option<string>,
},
  url: string,
  thumbnailUrl: JSON.t,
  comment: JSON.t,
  folderId: JSON.t,
  folder: option<JSON.t>,
  userId: JSON.t,
  user: option<JSON.t>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    type_: s.field("type", S.string),
    md5: s.field("md5", S.string),
    size: s.field("size", S.float),
    isSensitive: s.field("isSensitive", S.bool),
    isSensitiveByModerator: s.fieldOr("isSensitiveByModerator", S.nullableAsOption(S.json), None),
    blurhash: s.field("blurhash", S.json),
    properties: s.field("properties", S.object(s => {
    width: s.fieldOr("width", S.nullableAsOption(S.float), None),
    height: s.fieldOr("height", S.nullableAsOption(S.float), None),
    orientation: s.fieldOr("orientation", S.nullableAsOption(S.float), None),
    avgColor: s.fieldOr("avgColor", S.nullableAsOption(S.string), None),
  })),
    url: s.field("url", S.string),
    thumbnailUrl: s.field("thumbnailUrl", S.json),
    comment: s.field("comment", S.json),
    folderId: s.field("folderId", S.json),
    folder: s.fieldOr("folder", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.json),
    user: s.fieldOr("user", S.nullableAsOption(S.json), None),
  })
}

module DriveFolder = {
  type t = {
  id: string,
  createdAt: string,
  name: string,
  parentId: JSON.t,
  foldersCount: option<float>,
  filesCount: option<float>,
  parent: option<JSON.t>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    parentId: s.field("parentId", S.json),
    foldersCount: s.fieldOr("foldersCount", S.nullableAsOption(S.float), None),
    filesCount: s.fieldOr("filesCount", S.nullableAsOption(S.float), None),
    parent: s.fieldOr("parent", S.nullableAsOption(S.json), None),
  })
}

module Following = {
  type t = {
  id: string,
  createdAt: string,
  followeeId: string,
  followerId: string,
  followee: option<JSON.t>,
  follower: option<JSON.t>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    followeeId: s.field("followeeId", S.string),
    followerId: s.field("followerId", S.string),
    followee: s.fieldOr("followee", S.nullableAsOption(S.json), None),
    follower: s.fieldOr("follower", S.nullableAsOption(S.json), None),
  })
}

module Hashtag = {
  type t = {
  tag: string,
  mentionedUsersCount: float,
  mentionedLocalUsersCount: float,
  mentionedRemoteUsersCount: float,
  attachedUsersCount: float,
  attachedLocalUsersCount: float,
  attachedRemoteUsersCount: float,
}
  let schema = S.object(s => {
    tag: s.field("tag", S.string),
    mentionedUsersCount: s.field("mentionedUsersCount", S.float),
    mentionedLocalUsersCount: s.field("mentionedLocalUsersCount", S.float),
    mentionedRemoteUsersCount: s.field("mentionedRemoteUsersCount", S.float),
    attachedUsersCount: s.field("attachedUsersCount", S.float),
    attachedLocalUsersCount: s.field("attachedLocalUsersCount", S.float),
    attachedRemoteUsersCount: s.field("attachedRemoteUsersCount", S.float),
  })
}

module InviteCode = {
  type t = {
  id: string,
  code: string,
  expiresAt: JSON.t,
  createdAt: string,
  createdBy: JSON.t,
  usedBy: JSON.t,
  usedAt: JSON.t,
  used: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    code: s.field("code", S.string),
    expiresAt: s.field("expiresAt", S.json),
    createdAt: s.field("createdAt", S.string),
    createdBy: s.field("createdBy", S.json),
    usedBy: s.field("usedBy", S.json),
    usedAt: s.field("usedAt", S.json),
    used: s.field("used", S.bool),
  })
}

module PageBlock = {
  type t = JSON.t
  let schema = S.json
}

module QueueCount = {
  type t = {
  waiting: float,
  active: float,
  completed: float,
  failed: float,
  delayed: float,
}
  let schema = S.object(s => {
    waiting: s.field("waiting", S.float),
    active: s.field("active", S.float),
    completed: s.field("completed", S.float),
    failed: s.field("failed", S.float),
    delayed: s.field("delayed", S.float),
  })
}

module Antenna = {
  type t = {
  id: string,
  createdAt: string,
  name: string,
  keywords: array<array<string>>,
  excludeKeywords: array<array<string>>,
  src: string,
  userListId: JSON.t,
  users: array<string>,
  caseSensitive: bool,
  localOnly: bool,
  excludeBots: bool,
  withReplies: bool,
  withFile: bool,
  isActive: bool,
  hasUnreadNote: bool,
  notify: bool,
  excludeNotesInSensitiveChannel: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    keywords: s.field("keywords", S.array(S.array(S.string))),
    excludeKeywords: s.field("excludeKeywords", S.array(S.array(S.string))),
    src: s.field("src", S.string),
    userListId: s.field("userListId", S.json),
    users: s.field("users", S.array(S.string)),
    caseSensitive: s.field("caseSensitive", S.bool),
    localOnly: s.field("localOnly", S.bool),
    excludeBots: s.field("excludeBots", S.bool),
    withReplies: s.field("withReplies", S.bool),
    withFile: s.field("withFile", S.bool),
    isActive: s.field("isActive", S.bool),
    hasUnreadNote: s.field("hasUnreadNote", S.bool),
    notify: s.field("notify", S.bool),
    excludeNotesInSensitiveChannel: s.field("excludeNotesInSensitiveChannel", S.bool),
  })
}

module FederationInstance = {
  type t = {
  id: string,
  firstRetrievedAt: string,
  host: string,
  usersCount: float,
  notesCount: float,
  followingCount: float,
  followersCount: float,
  isNotResponding: bool,
  isSuspended: bool,
  suspensionState: string,
  isBlocked: bool,
  softwareName: JSON.t,
  softwareVersion: JSON.t,
  openRegistrations: JSON.t,
  name: JSON.t,
  description: JSON.t,
  maintainerName: JSON.t,
  maintainerEmail: JSON.t,
  isSilenced: bool,
  isSensitiveMedia: bool,
  iconUrl: JSON.t,
  faviconUrl: JSON.t,
  themeColor: JSON.t,
  infoUpdatedAt: JSON.t,
  latestRequestReceivedAt: JSON.t,
  moderationNote: option<JSON.t>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    firstRetrievedAt: s.field("firstRetrievedAt", S.string),
    host: s.field("host", S.string),
    usersCount: s.field("usersCount", S.float),
    notesCount: s.field("notesCount", S.float),
    followingCount: s.field("followingCount", S.float),
    followersCount: s.field("followersCount", S.float),
    isNotResponding: s.field("isNotResponding", S.bool),
    isSuspended: s.field("isSuspended", S.bool),
    suspensionState: s.field("suspensionState", S.string),
    isBlocked: s.field("isBlocked", S.bool),
    softwareName: s.field("softwareName", S.json),
    softwareVersion: s.field("softwareVersion", S.json),
    openRegistrations: s.field("openRegistrations", S.json),
    name: s.field("name", S.json),
    description: s.field("description", S.json),
    maintainerName: s.field("maintainerName", S.json),
    maintainerEmail: s.field("maintainerEmail", S.json),
    isSilenced: s.field("isSilenced", S.bool),
    isSensitiveMedia: s.field("isSensitiveMedia", S.bool),
    iconUrl: s.field("iconUrl", S.json),
    faviconUrl: s.field("faviconUrl", S.json),
    themeColor: s.field("themeColor", S.json),
    infoUpdatedAt: s.field("infoUpdatedAt", S.json),
    latestRequestReceivedAt: s.field("latestRequestReceivedAt", S.json),
    moderationNote: s.fieldOr("moderationNote", S.nullableAsOption(S.json), None),
  })
}

module EmojiSimple = {
  type t = {
  aliases: array<string>,
  name: string,
  category: JSON.t,
  url: string,
  localOnly: option<bool>,
  isSensitive: option<bool>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
  roleIdsThatCanNotBeUsedThisEmojiAsReaction: option<array<string>>,
}
  let schema = S.object(s => {
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.json),
    url: s.field("url", S.string),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    isSensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
    roleIdsThatCanNotBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanNotBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
  })
}

module EmojiDetailed = {
  type t = {
  id: string,
  createdAt: option<string>,
  updatedAt: option<JSON.t>,
  aliases: array<string>,
  name: string,
  category: JSON.t,
  host: JSON.t,
  url: string,
  license: JSON.t,
  isSensitive: bool,
  localOnly: bool,
  requestedBy: option<JSON.t>,
  memo: option<JSON.t>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
  roleIdsThatCanNotBeUsedThisEmojiAsReaction: option<array<string>>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.fieldOr("createdAt", S.nullableAsOption(S.string), None),
    updatedAt: s.fieldOr("updatedAt", S.nullableAsOption(S.json), None),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.json),
    host: s.field("host", S.json),
    url: s.field("url", S.string),
    license: s.field("license", S.json),
    isSensitive: s.field("isSensitive", S.bool),
    localOnly: s.field("localOnly", S.bool),
    requestedBy: s.fieldOr("requestedBy", S.nullableAsOption(S.json), None),
    memo: s.fieldOr("memo", S.nullableAsOption(S.json), None),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
    roleIdsThatCanNotBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanNotBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
  })
}

module EmojiDetailedAdmin = {
  type t = {
  id: string,
  updatedAt: JSON.t,
  name: string,
  host: JSON.t,
  publicUrl: string,
  originalUrl: string,
  uri: JSON.t,
  @as("type") type_: JSON.t,
  aliases: array<string>,
  category: JSON.t,
  license: JSON.t,
  localOnly: bool,
  isSensitive: bool,
  roleIdsThatCanBeUsedThisEmojiAsReaction: array<{
  id: string,
  name: string,
}>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    updatedAt: s.field("updatedAt", S.json),
    name: s.field("name", S.string),
    host: s.field("host", S.json),
    publicUrl: s.field("publicUrl", S.string),
    originalUrl: s.field("originalUrl", S.string),
    uri: s.field("uri", S.json),
    type_: s.field("type", S.json),
    aliases: s.field("aliases", S.array(S.string)),
    category: s.field("category", S.json),
    license: s.field("license", S.json),
    localOnly: s.field("localOnly", S.bool),
    isSensitive: s.field("isSensitive", S.bool),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.field("roleIdsThatCanBeUsedThisEmojiAsReaction", S.array(S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
  }))),
  })
}

module Signin = {
  type t = {
  id: string,
  createdAt: string,
  ip: string,
  headers: JSON.t,
  success: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    ip: s.field("ip", S.string),
    headers: s.field("headers", S.json),
    success: s.field("success", S.bool),
  })
}

module RoleCondFormulaValueIsLocalOrRemote = {
  type t = {
  id: string,
  @as("type") type_: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
  })
}

module RoleCondFormulaValueUserSettingBooleanSchema = {
  type t = {
  id: string,
  @as("type") type_: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
  })
}

module RoleCondFormulaValueAssignedRole = {
  type t = {
  id: string,
  @as("type") type_: string,
  roleId: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    roleId: s.field("roleId", S.string),
  })
}

module RoleCondFormulaValueCreated = {
  type t = {
  id: string,
  @as("type") type_: string,
  sec: float,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    sec: s.field("sec", S.float),
  })
}

module RoleCondFormulaFollowersOrFollowingOrNotes = {
  type t = {
  id: string,
  @as("type") type_: string,
  value: float,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    value: s.field("value", S.float),
  })
}

module RoleCondFormulaValue = {
  type t = JSON.t
  let schema = S.json
}

module RoleLite = {
  type t = {
  id: string,
  name: string,
  color: JSON.t,
  iconUrl: JSON.t,
  description: string,
  isModerator: bool,
  isAdministrator: bool,
  displayOrder: int,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    color: s.field("color", S.json),
    iconUrl: s.field("iconUrl", S.json),
    description: s.field("description", S.string),
    isModerator: s.field("isModerator", S.bool),
    isAdministrator: s.field("isAdministrator", S.bool),
    displayOrder: s.field("displayOrder", S.int),
  })
}

module RolePolicies = {
  type t = {
  gtlAvailable: bool,
  ltlAvailable: bool,
  canPublicNote: bool,
  canScheduleNote: bool,
  scheduleNoteLimit: int,
  scheduleNoteMaxDays: int,
  canInitiateConversation: bool,
  canCreateContent: bool,
  canUpdateContent: bool,
  canDeleteContent: bool,
  canPurgeAccount: bool,
  canUpdateAvatar: bool,
  canUpdateBanner: bool,
  mentionLimit: int,
  canInvite: bool,
  inviteLimit: int,
  inviteLimitCycle: int,
  inviteExpirationTime: int,
  canManageCustomEmojis: bool,
  canManageAvatarDecorations: bool,
  canSearchNotes: bool,
  canUseTranslator: bool,
  canUseDriveFileInSoundSettings: bool,
  canUseReaction: bool,
  canHideAds: bool,
  driveCapacityMb: int,
  maxFileSizeMb: int,
  alwaysMarkNsfw: bool,
  skipNsfwDetection: bool,
  canUpdateBioMedia: bool,
  pinLimit: int,
  antennaLimit: int,
  antennaNotesLimit: int,
  wordMuteLimit: int,
  webhookLimit: int,
  clipLimit: int,
  noteEachClipsLimit: int,
  userListLimit: int,
  userEachUserListsLimit: int,
  rateLimitFactor: int,
  avatarDecorationLimit: int,
  canImportAntennas: bool,
  canImportBlocking: bool,
  canImportFollowing: bool,
  canImportMuting: bool,
  canImportUserLists: bool,
  mutualLinkSectionLimit: int,
  mutualLinkLimit: int,
  chatAvailability: string,
}
  let schema = S.object(s => {
    gtlAvailable: s.field("gtlAvailable", S.bool),
    ltlAvailable: s.field("ltlAvailable", S.bool),
    canPublicNote: s.field("canPublicNote", S.bool),
    canScheduleNote: s.field("canScheduleNote", S.bool),
    scheduleNoteLimit: s.field("scheduleNoteLimit", S.int),
    scheduleNoteMaxDays: s.field("scheduleNoteMaxDays", S.int),
    canInitiateConversation: s.field("canInitiateConversation", S.bool),
    canCreateContent: s.field("canCreateContent", S.bool),
    canUpdateContent: s.field("canUpdateContent", S.bool),
    canDeleteContent: s.field("canDeleteContent", S.bool),
    canPurgeAccount: s.field("canPurgeAccount", S.bool),
    canUpdateAvatar: s.field("canUpdateAvatar", S.bool),
    canUpdateBanner: s.field("canUpdateBanner", S.bool),
    mentionLimit: s.field("mentionLimit", S.int),
    canInvite: s.field("canInvite", S.bool),
    inviteLimit: s.field("inviteLimit", S.int),
    inviteLimitCycle: s.field("inviteLimitCycle", S.int),
    inviteExpirationTime: s.field("inviteExpirationTime", S.int),
    canManageCustomEmojis: s.field("canManageCustomEmojis", S.bool),
    canManageAvatarDecorations: s.field("canManageAvatarDecorations", S.bool),
    canSearchNotes: s.field("canSearchNotes", S.bool),
    canUseTranslator: s.field("canUseTranslator", S.bool),
    canUseDriveFileInSoundSettings: s.field("canUseDriveFileInSoundSettings", S.bool),
    canUseReaction: s.field("canUseReaction", S.bool),
    canHideAds: s.field("canHideAds", S.bool),
    driveCapacityMb: s.field("driveCapacityMb", S.int),
    maxFileSizeMb: s.field("maxFileSizeMb", S.int),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.bool),
    skipNsfwDetection: s.field("skipNsfwDetection", S.bool),
    canUpdateBioMedia: s.field("canUpdateBioMedia", S.bool),
    pinLimit: s.field("pinLimit", S.int),
    antennaLimit: s.field("antennaLimit", S.int),
    antennaNotesLimit: s.field("antennaNotesLimit", S.int),
    wordMuteLimit: s.field("wordMuteLimit", S.int),
    webhookLimit: s.field("webhookLimit", S.int),
    clipLimit: s.field("clipLimit", S.int),
    noteEachClipsLimit: s.field("noteEachClipsLimit", S.int),
    userListLimit: s.field("userListLimit", S.int),
    userEachUserListsLimit: s.field("userEachUserListsLimit", S.int),
    rateLimitFactor: s.field("rateLimitFactor", S.int),
    avatarDecorationLimit: s.field("avatarDecorationLimit", S.int),
    canImportAntennas: s.field("canImportAntennas", S.bool),
    canImportBlocking: s.field("canImportBlocking", S.bool),
    canImportFollowing: s.field("canImportFollowing", S.bool),
    canImportMuting: s.field("canImportMuting", S.bool),
    canImportUserLists: s.field("canImportUserLists", S.bool),
    mutualLinkSectionLimit: s.field("mutualLinkSectionLimit", S.int),
    mutualLinkLimit: s.field("mutualLinkLimit", S.int),
    chatAvailability: s.field("chatAvailability", S.string),
  })
}

module MetaDetailedOnly = {
  type t = {
  features: option<{
  registration: bool,
  emailRequiredForSignup: bool,
  localTimeline: bool,
  globalTimeline: bool,
  hCaptcha: bool,
  hcaptcha: bool,
  mCaptcha: bool,
  mcaptcha: bool,
  reCaptcha: bool,
  recaptcha: bool,
  turnstile: bool,
  objectStorage: bool,
  serviceWorker: bool,
  miauth: option<bool>,
}>,
  proxyAccountName: JSON.t,
  requireSetup: bool,
  cacheRemoteFiles: bool,
  cacheRemoteSensitiveFiles: bool,
}
  let schema = S.object(s => {
    features: s.fieldOr("features", S.nullableAsOption(S.object(s => {
    registration: s.field("registration", S.bool),
    emailRequiredForSignup: s.field("emailRequiredForSignup", S.bool),
    localTimeline: s.field("localTimeline", S.bool),
    globalTimeline: s.field("globalTimeline", S.bool),
    hCaptcha: s.field("hCaptcha", S.bool),
    hcaptcha: s.field("hcaptcha", S.bool),
    mCaptcha: s.field("mCaptcha", S.bool),
    mcaptcha: s.field("mcaptcha", S.bool),
    reCaptcha: s.field("reCaptcha", S.bool),
    recaptcha: s.field("recaptcha", S.bool),
    turnstile: s.field("turnstile", S.bool),
    objectStorage: s.field("objectStorage", S.bool),
    serviceWorker: s.field("serviceWorker", S.bool),
    miauth: s.fieldOr("miauth", S.nullableAsOption(S.bool), None),
  })), None),
    proxyAccountName: s.field("proxyAccountName", S.json),
    requireSetup: s.field("requireSetup", S.bool),
    cacheRemoteFiles: s.field("cacheRemoteFiles", S.bool),
    cacheRemoteSensitiveFiles: s.field("cacheRemoteSensitiveFiles", S.bool),
  })
}

module SystemWebhook = {
  type t = {
  id: string,
  isActive: bool,
  updatedAt: string,
  latestSentAt: JSON.t,
  latestStatus: JSON.t,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    updatedAt: s.field("updatedAt", S.string),
    latestSentAt: s.field("latestSentAt", S.json),
    latestStatus: s.field("latestStatus", S.json),
    name: s.field("name", S.string),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
  })
}

module AbuseReportNotificationRecipient = {
  type t = {
  id: string,
  isActive: bool,
  updatedAt: string,
  name: string,
  @as("method") method_: string,
  userId: option<string>,
  user: option<JSON.t>,
  systemWebhookId: option<string>,
  systemWebhook: option<JSON.t>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    updatedAt: s.field("updatedAt", S.string),
    name: s.field("name", S.string),
    method_: s.field("method", S.string),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    user: s.fieldOr("user", S.nullableAsOption(S.json), None),
    systemWebhookId: s.fieldOr("systemWebhookId", S.nullableAsOption(S.string), None),
    systemWebhook: s.fieldOr("systemWebhook", S.nullableAsOption(S.json), None),
  })
}

module ChatMessageLite = {
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  fromUser: option<JSON.t>,
  toUserId: option<JSON.t>,
  toRoomId: option<JSON.t>,
  text: option<JSON.t>,
  fileId: option<JSON.t>,
  file: option<JSON.t>,
  reactions: array<{
  reaction: string,
  user: option<JSON.t>,
}>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    fromUser: s.fieldOr("fromUser", S.nullableAsOption(S.json), None),
    toUserId: s.fieldOr("toUserId", S.nullableAsOption(S.json), None),
    toRoomId: s.fieldOr("toRoomId", S.nullableAsOption(S.json), None),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    reactions: s.field("reactions", S.array(S.object(s => {
    reaction: s.field("reaction", S.string),
    user: s.fieldOr("user", S.nullableAsOption(S.json), None),
  }))),
  })
}

module ChatMessageLiteFor1on1 = {
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  toUserId: string,
  text: option<JSON.t>,
  fileId: option<JSON.t>,
  file: option<JSON.t>,
  reactions: array<{
  reaction: string,
}>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    toUserId: s.field("toUserId", S.string),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    reactions: s.field("reactions", S.array(S.object(s => {
    reaction: s.field("reaction", S.string),
  }))),
  })
}

module ChatRoomMembership = {
  type t = {
  id: string,
  createdAt: string,
  userId: string,
  user: option<JSON.t>,
  roomId: string,
  room: option<JSON.t>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.string),
    user: s.fieldOr("user", S.nullableAsOption(S.json), None),
    roomId: s.field("roomId", S.string),
    room: s.fieldOr("room", S.nullableAsOption(S.json), None),
  })
}

module UserListMembership = {
  type t = {
  id: string,
  createdAt: string,
  userId: string,
  user: UserLite.t,
  withReplies: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    withReplies: s.field("withReplies", S.bool),
  })
}

module NoteReaction = {
  type t = {
  id: string,
  createdAt: string,
  user: UserLite.t,
  @as("type") type_: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    user: s.field("user", UserLite.schema),
    type_: s.field("type", S.string),
  })
}

module Clip = {
  type t = {
  id: string,
  createdAt: string,
  lastClippedAt: JSON.t,
  userId: string,
  user: UserLite.t,
  name: string,
  description: JSON.t,
  isPublic: bool,
  favoritedCount: float,
  isFavorited: option<bool>,
  notesCount: option<int>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    lastClippedAt: s.field("lastClippedAt", S.json),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    name: s.field("name", S.string),
    description: s.field("description", S.json),
    isPublic: s.field("isPublic", S.bool),
    favoritedCount: s.field("favoritedCount", S.float),
    isFavorited: s.fieldOr("isFavorited", S.nullableAsOption(S.bool), None),
    notesCount: s.fieldOr("notesCount", S.nullableAsOption(S.int), None),
  })
}

module Flash = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: string,
  userId: string,
  user: UserLite.t,
  title: string,
  summary: string,
  script: string,
  visibility: string,
  likedCount: JSON.t,
  isLiked: option<bool>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    title: s.field("title", S.string),
    summary: s.field("summary", S.string),
    script: s.field("script", S.string),
    visibility: s.field("visibility", S.string),
    likedCount: s.field("likedCount", S.json),
    isLiked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
  })
}

module ChatRoom = {
  type t = {
  id: string,
  createdAt: string,
  ownerId: string,
  owner: UserLite.t,
  name: string,
  description: string,
  isMuted: option<bool>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    ownerId: s.field("ownerId", S.string),
    owner: s.field("owner", UserLite.schema),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    isMuted: s.fieldOr("isMuted", S.nullableAsOption(S.bool), None),
  })
}

module Note = {
  type t = {
  id: string,
  createdAt: string,
  deletedAt: option<JSON.t>,
  text: JSON.t,
  cw: option<JSON.t>,
  userId: string,
  user: UserLite.t,
  replyId: option<JSON.t>,
  renoteId: option<JSON.t>,
  reply: option<JSON.t>,
  renote: option<JSON.t>,
  isHidden: option<bool>,
  visibility: string,
  mentions: option<array<string>>,
  visibleUserIds: option<array<string>>,
  fileIds: option<array<string>>,
  files: option<array<DriveFile.t>>,
  tags: option<array<string>>,
  poll: option<JSON.t>,
  emojis: option<JSON.t>,
  channelId: option<JSON.t>,
  channel: option<JSON.t>,
  localOnly: option<bool>,
  dimension: option<JSON.t>,
  reactionAcceptance: JSON.t,
  reactionEmojis: JSON.t,
  reactions: JSON.t,
  reactionCount: float,
  renoteCount: float,
  repliesCount: float,
  uri: option<string>,
  url: option<string>,
  reactionAndUserPairCache: option<array<string>>,
  clippedCount: option<float>,
  myReaction: option<JSON.t>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    deletedAt: s.fieldOr("deletedAt", S.nullableAsOption(S.json), None),
    text: s.field("text", S.json),
    cw: s.fieldOr("cw", S.nullableAsOption(S.json), None),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    replyId: s.fieldOr("replyId", S.nullableAsOption(S.json), None),
    renoteId: s.fieldOr("renoteId", S.nullableAsOption(S.json), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.json), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.json), None),
    isHidden: s.fieldOr("isHidden", S.nullableAsOption(S.bool), None),
    visibility: s.field("visibility", S.string),
    mentions: s.fieldOr("mentions", S.nullableAsOption(S.array(S.string)), None),
    visibleUserIds: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
    fileIds: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    files: s.fieldOr("files", S.nullableAsOption(S.array(DriveFile.schema)), None),
    tags: s.fieldOr("tags", S.nullableAsOption(S.array(S.string)), None),
    poll: s.fieldOr("poll", S.nullableAsOption(S.json), None),
    emojis: s.fieldOr("emojis", S.nullableAsOption(S.json), None),
    channelId: s.fieldOr("channelId", S.nullableAsOption(S.json), None),
    channel: s.fieldOr("channel", S.nullableAsOption(S.json), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    dimension: s.fieldOr("dimension", S.nullableAsOption(S.json), None),
    reactionAcceptance: s.field("reactionAcceptance", S.json),
    reactionEmojis: s.field("reactionEmojis", S.json),
    reactions: s.field("reactions", S.json),
    reactionCount: s.field("reactionCount", S.float),
    renoteCount: s.field("renoteCount", S.float),
    repliesCount: s.field("repliesCount", S.float),
    uri: s.fieldOr("uri", S.nullableAsOption(S.string), None),
    url: s.fieldOr("url", S.nullableAsOption(S.string), None),
    reactionAndUserPairCache: s.fieldOr("reactionAndUserPairCache", S.nullableAsOption(S.array(S.string)), None),
    clippedCount: s.fieldOr("clippedCount", S.nullableAsOption(S.float), None),
    myReaction: s.fieldOr("myReaction", S.nullableAsOption(S.json), None),
  })
}

module NoteDraft = {
  type t = {
  id: string,
  updatedAt: string,
  scheduledAt: JSON.t,
  reason: option<string>,
  channel: option<JSON.t>,
  renote: option<JSON.t>,
  reply: option<JSON.t>,
  data: {
  text: JSON.t,
  useCw: bool,
  cw: JSON.t,
  visibility: string,
  localOnly: bool,
  lang: option<JSON.t>,
  dimension: option<JSON.t>,
  files: array<DriveFile.t>,
  poll: JSON.t,
  visibleUserIds: option<array<string>>,
},
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    updatedAt: s.field("updatedAt", S.string),
    scheduledAt: s.field("scheduledAt", S.json),
    reason: s.fieldOr("reason", S.nullableAsOption(S.string), None),
    channel: s.fieldOr("channel", S.nullableAsOption(S.json), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.json), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.json), None),
    data: s.field("data", S.object(s => {
    text: s.field("text", S.json),
    useCw: s.field("useCw", S.bool),
    cw: s.field("cw", S.json),
    visibility: s.field("visibility", S.string),
    localOnly: s.field("localOnly", S.bool),
    lang: s.fieldOr("lang", S.nullableAsOption(S.json), None),
    dimension: s.fieldOr("dimension", S.nullableAsOption(S.json), None),
    files: s.field("files", S.array(DriveFile.schema)),
    poll: s.field("poll", S.json),
    visibleUserIds: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
  })),
  })
}

module GalleryPost = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: string,
  userId: string,
  user: UserLite.t,
  title: string,
  description: JSON.t,
  fileIds: option<array<string>>,
  files: option<array<DriveFile.t>>,
  tags: option<array<string>>,
  isSensitive: bool,
  likedCount: float,
  isLiked: option<bool>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    title: s.field("title", S.string),
    description: s.field("description", S.json),
    fileIds: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    files: s.fieldOr("files", S.nullableAsOption(S.array(DriveFile.schema)), None),
    tags: s.fieldOr("tags", S.nullableAsOption(S.array(S.string)), None),
    isSensitive: s.field("isSensitive", S.bool),
    likedCount: s.field("likedCount", S.float),
    isLiked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
  })
}

module Page = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: string,
  userId: string,
  user: UserLite.t,
  content: array<PageBlock.t>,
  variables: array<JSON.t>,
  title: string,
  name: string,
  summary: JSON.t,
  hideTitleWhenPinned: bool,
  alignCenter: bool,
  font: string,
  script: string,
  eyeCatchingImageId: JSON.t,
  eyeCatchingImage: JSON.t,
  attachedFiles: array<DriveFile.t>,
  likedCount: float,
  isLiked: option<bool>,
  visibility: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    content: s.field("content", S.array(PageBlock.schema)),
    variables: s.field("variables", S.array(S.json)),
    title: s.field("title", S.string),
    name: s.field("name", S.string),
    summary: s.field("summary", S.json),
    hideTitleWhenPinned: s.field("hideTitleWhenPinned", S.bool),
    alignCenter: s.field("alignCenter", S.bool),
    font: s.field("font", S.string),
    script: s.field("script", S.string),
    eyeCatchingImageId: s.field("eyeCatchingImageId", S.json),
    eyeCatchingImage: s.field("eyeCatchingImage", S.json),
    attachedFiles: s.field("attachedFiles", S.array(DriveFile.schema)),
    likedCount: s.field("likedCount", S.float),
    isLiked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
    visibility: s.field("visibility", S.string),
  })
}

module RoleCondFormulaLogics = {
  type t = {
  id: string,
  @as("type") type_: string,
  values: array<RoleCondFormulaValue.t>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    values: s.field("values", S.array(RoleCondFormulaValue.schema)),
  })
}

module RoleCondFormulaValueNot = {
  type t = {
  id: string,
  @as("type") type_: string,
  value: RoleCondFormulaValue.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    value: s.field("value", RoleCondFormulaValue.schema),
  })
}

module Role = {
  type t = {
  createdAt: string,
  updatedAt: string,
  target: string,
  condFormula: RoleCondFormulaValue.t,
  isPublic: bool,
  isExplorable: bool,
  asBadge: bool,
  preserveAssignmentOnMoveAccount: bool,
  badgeBehavior: JSON.t,
  canEditMembersByModerator: bool,
  policies: JSON.t,
  usersCount: int,
}
  let schema = S.object(s => {
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    target: s.field("target", S.string),
    condFormula: s.field("condFormula", RoleCondFormulaValue.schema),
    isPublic: s.field("isPublic", S.bool),
    isExplorable: s.field("isExplorable", S.bool),
    asBadge: s.field("asBadge", S.bool),
    preserveAssignmentOnMoveAccount: s.field("preserveAssignmentOnMoveAccount", S.bool),
    badgeBehavior: s.field("badgeBehavior", S.json),
    canEditMembersByModerator: s.field("canEditMembersByModerator", S.bool),
    policies: s.field("policies", S.json),
    usersCount: s.field("usersCount", S.int),
  })
}

module MeDetailedOnly = {
  type t = {
  avatarId: JSON.t,
  bannerId: JSON.t,
  followedMessage: JSON.t,
  isModerator: JSON.t,
  isAdmin: JSON.t,
  injectFeaturedNote: bool,
  receiveAnnouncementEmail: bool,
  alwaysMarkNsfw: bool,
  autoSensitive: bool,
  carefulBot: bool,
  autoAcceptFollowed: bool,
  noCrawle: bool,
  preventAiLearning: bool,
  isExplorable: bool,
  isDeleted: bool,
  twoFactorBackupCodesStock: string,
  hideOnlineStatus: bool,
  hasUnreadSpecifiedNotes: bool,
  hasUnreadMentions: bool,
  hasUnreadAnnouncement: bool,
  unreadAnnouncements: array<Announcement.t>,
  hasUnreadAntenna: bool,
  hasUnreadChannel: bool,
  hasUnreadChatMessages: bool,
  hasUnreadNotification: bool,
  hasPendingReceivedFollowRequest: bool,
  unreadNotificationsCount: float,
  mutedWords: array<array<string>>,
  mutedInstances: JSON.t,
  postingLang: JSON.t,
  viewingLangs: array<string>,
  showMediaInAllLanguages: bool,
  showHashtagsInAllLanguages: bool,
  notificationRecieveConfig: {
  note: option<JSON.t>,
  follow: option<JSON.t>,
  mention: option<JSON.t>,
  reply: option<JSON.t>,
  renote: option<JSON.t>,
  quote: option<JSON.t>,
  reaction: option<JSON.t>,
  pollEnded: option<JSON.t>,
  receiveFollowRequest: option<JSON.t>,
  followRequestAccepted: option<JSON.t>,
  roleAssigned: option<JSON.t>,
  chatRoomInvitationReceived: option<JSON.t>,
  achievementEarned: option<JSON.t>,
  app: option<JSON.t>,
  test: option<JSON.t>,
},
  emailNotificationTypes: array<string>,
  achievements: array<{
  name: string,
  unlockedAt: float,
}>,
  loggedInDays: float,
  policies: RolePolicies.t,
  twoFactorEnabled: bool,
  usePasswordLessLogin: bool,
  securityKeys: bool,
  email: option<JSON.t>,
  emailVerified: option<JSON.t>,
  securityKeysList: option<array<{
  id: string,
  name: string,
  lastUsed: string,
}>>,
}
  let schema = S.object(s => {
    avatarId: s.field("avatarId", S.json),
    bannerId: s.field("bannerId", S.json),
    followedMessage: s.field("followedMessage", S.json),
    isModerator: s.field("isModerator", S.json),
    isAdmin: s.field("isAdmin", S.json),
    injectFeaturedNote: s.field("injectFeaturedNote", S.bool),
    receiveAnnouncementEmail: s.field("receiveAnnouncementEmail", S.bool),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.bool),
    autoSensitive: s.field("autoSensitive", S.bool),
    carefulBot: s.field("carefulBot", S.bool),
    autoAcceptFollowed: s.field("autoAcceptFollowed", S.bool),
    noCrawle: s.field("noCrawle", S.bool),
    preventAiLearning: s.field("preventAiLearning", S.bool),
    isExplorable: s.field("isExplorable", S.bool),
    isDeleted: s.field("isDeleted", S.bool),
    twoFactorBackupCodesStock: s.field("twoFactorBackupCodesStock", S.string),
    hideOnlineStatus: s.field("hideOnlineStatus", S.bool),
    hasUnreadSpecifiedNotes: s.field("hasUnreadSpecifiedNotes", S.bool),
    hasUnreadMentions: s.field("hasUnreadMentions", S.bool),
    hasUnreadAnnouncement: s.field("hasUnreadAnnouncement", S.bool),
    unreadAnnouncements: s.field("unreadAnnouncements", S.array(Announcement.schema)),
    hasUnreadAntenna: s.field("hasUnreadAntenna", S.bool),
    hasUnreadChannel: s.field("hasUnreadChannel", S.bool),
    hasUnreadChatMessages: s.field("hasUnreadChatMessages", S.bool),
    hasUnreadNotification: s.field("hasUnreadNotification", S.bool),
    hasPendingReceivedFollowRequest: s.field("hasPendingReceivedFollowRequest", S.bool),
    unreadNotificationsCount: s.field("unreadNotificationsCount", S.float),
    mutedWords: s.field("mutedWords", S.array(S.array(S.string))),
    mutedInstances: s.field("mutedInstances", S.json),
    postingLang: s.field("postingLang", S.json),
    viewingLangs: s.field("viewingLangs", S.array(S.string)),
    showMediaInAllLanguages: s.field("showMediaInAllLanguages", S.bool),
    showHashtagsInAllLanguages: s.field("showHashtagsInAllLanguages", S.bool),
    notificationRecieveConfig: s.field("notificationRecieveConfig", S.object(s => {
    note: s.fieldOr("note", S.nullableAsOption(S.json), None),
    follow: s.fieldOr("follow", S.nullableAsOption(S.json), None),
    mention: s.fieldOr("mention", S.nullableAsOption(S.json), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.json), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.json), None),
    quote: s.fieldOr("quote", S.nullableAsOption(S.json), None),
    reaction: s.fieldOr("reaction", S.nullableAsOption(S.json), None),
    pollEnded: s.fieldOr("pollEnded", S.nullableAsOption(S.json), None),
    receiveFollowRequest: s.fieldOr("receiveFollowRequest", S.nullableAsOption(S.json), None),
    followRequestAccepted: s.fieldOr("followRequestAccepted", S.nullableAsOption(S.json), None),
    roleAssigned: s.fieldOr("roleAssigned", S.nullableAsOption(S.json), None),
    chatRoomInvitationReceived: s.fieldOr("chatRoomInvitationReceived", S.nullableAsOption(S.json), None),
    achievementEarned: s.fieldOr("achievementEarned", S.nullableAsOption(S.json), None),
    app: s.fieldOr("app", S.nullableAsOption(S.json), None),
    test: s.fieldOr("test", S.nullableAsOption(S.json), None),
  })),
    emailNotificationTypes: s.field("emailNotificationTypes", S.array(S.string)),
    achievements: s.field("achievements", S.array(S.object(s => {
    name: s.field("name", S.string),
    unlockedAt: s.field("unlockedAt", S.float),
  }))),
    loggedInDays: s.field("loggedInDays", S.float),
    policies: s.field("policies", RolePolicies.schema),
    twoFactorEnabled: s.field("twoFactorEnabled", S.bool),
    usePasswordLessLogin: s.field("usePasswordLessLogin", S.bool),
    securityKeys: s.field("securityKeys", S.bool),
    email: s.fieldOr("email", S.nullableAsOption(S.json), None),
    emailVerified: s.fieldOr("emailVerified", S.nullableAsOption(S.json), None),
    securityKeysList: s.fieldOr("securityKeysList", S.nullableAsOption(S.array(S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    lastUsed: s.field("lastUsed", S.string),
  }))), None),
  })
}

module MetaLite = {
  type t = {
  maintainerName: JSON.t,
  maintainerEmail: JSON.t,
  version: string,
  name: JSON.t,
  shortName: JSON.t,
  uri: string,
  description: JSON.t,
  langs: array<string>,
  dimensions: float,
  tosUrl: JSON.t,
  repositoryUrl: JSON.t,
  feedbackUrl: JSON.t,
  defaultDarkTheme: JSON.t,
  defaultLightTheme: JSON.t,
  disableRegistration: bool,
  emailRequiredForSignup: bool,
  enableHcaptcha: bool,
  hcaptchaSiteKey: JSON.t,
  enableMcaptcha: bool,
  mcaptchaSiteKey: JSON.t,
  mcaptchaInstanceUrl: JSON.t,
  enableRecaptcha: bool,
  recaptchaSiteKey: JSON.t,
  enableTurnstile: bool,
  turnstileSiteKey: JSON.t,
  googleAnalyticsId: JSON.t,
  enableTestcaptcha: bool,
  swPublickey: JSON.t,
  mascotImageUrl: string,
  bannerUrl: JSON.t,
  serverErrorImageUrl: JSON.t,
  infoImageUrl: JSON.t,
  notFoundImageUrl: JSON.t,
  iconUrl: JSON.t,
  maxNoteTextLength: float,
  ads: array<{
  id: string,
  url: string,
  place: string,
  ratio: float,
  imageUrl: string,
  imageBlurhash: JSON.t,
  dayOfWeek: int,
  isSensitive: bool,
}>,
  wellKnownWebsites: array<string>,
  notesPerOneAd: float,
  enableEmail: bool,
  enableServiceWorker: bool,
  translatorAvailable: bool,
  sentryForFrontend: JSON.t,
  mediaProxy: string,
  enableUrlPreview: bool,
  enableSkebStatus: bool,
  backgroundImageUrl: JSON.t,
  impressumUrl: JSON.t,
  logoImageUrl: JSON.t,
  privacyPolicyUrl: JSON.t,
  inquiryUrl: JSON.t,
  serverRules: array<string>,
  themeColor: JSON.t,
  policies: RolePolicies.t,
  noteSearchableScope: string,
  maxFileSize: float,
  federation: string,
}
  let schema = S.object(s => {
    maintainerName: s.field("maintainerName", S.json),
    maintainerEmail: s.field("maintainerEmail", S.json),
    version: s.field("version", S.string),
    name: s.field("name", S.json),
    shortName: s.field("shortName", S.json),
    uri: s.field("uri", S.string),
    description: s.field("description", S.json),
    langs: s.field("langs", S.array(S.string)),
    dimensions: s.field("dimensions", S.float->S.min(1)),
    tosUrl: s.field("tosUrl", S.json),
    repositoryUrl: s.field("repositoryUrl", S.json),
    feedbackUrl: s.field("feedbackUrl", S.json),
    defaultDarkTheme: s.field("defaultDarkTheme", S.json),
    defaultLightTheme: s.field("defaultLightTheme", S.json),
    disableRegistration: s.field("disableRegistration", S.bool),
    emailRequiredForSignup: s.field("emailRequiredForSignup", S.bool),
    enableHcaptcha: s.field("enableHcaptcha", S.bool),
    hcaptchaSiteKey: s.field("hcaptchaSiteKey", S.json),
    enableMcaptcha: s.field("enableMcaptcha", S.bool),
    mcaptchaSiteKey: s.field("mcaptchaSiteKey", S.json),
    mcaptchaInstanceUrl: s.field("mcaptchaInstanceUrl", S.json),
    enableRecaptcha: s.field("enableRecaptcha", S.bool),
    recaptchaSiteKey: s.field("recaptchaSiteKey", S.json),
    enableTurnstile: s.field("enableTurnstile", S.bool),
    turnstileSiteKey: s.field("turnstileSiteKey", S.json),
    googleAnalyticsId: s.field("googleAnalyticsId", S.json),
    enableTestcaptcha: s.field("enableTestcaptcha", S.bool),
    swPublickey: s.field("swPublickey", S.json),
    mascotImageUrl: s.field("mascotImageUrl", S.string),
    bannerUrl: s.field("bannerUrl", S.json),
    serverErrorImageUrl: s.field("serverErrorImageUrl", S.json),
    infoImageUrl: s.field("infoImageUrl", S.json),
    notFoundImageUrl: s.field("notFoundImageUrl", S.json),
    iconUrl: s.field("iconUrl", S.json),
    maxNoteTextLength: s.field("maxNoteTextLength", S.float),
    ads: s.field("ads", S.array(S.object(s => {
    id: s.field("id", S.string),
    url: s.field("url", S.string),
    place: s.field("place", S.string),
    ratio: s.field("ratio", S.float),
    imageUrl: s.field("imageUrl", S.string),
    imageBlurhash: s.field("imageBlurhash", S.json),
    dayOfWeek: s.field("dayOfWeek", S.int),
    isSensitive: s.field("isSensitive", S.bool),
  }))),
    wellKnownWebsites: s.field("wellKnownWebsites", S.array(S.string)),
    notesPerOneAd: s.field("notesPerOneAd", S.float),
    enableEmail: s.field("enableEmail", S.bool),
    enableServiceWorker: s.field("enableServiceWorker", S.bool),
    translatorAvailable: s.field("translatorAvailable", S.bool),
    sentryForFrontend: s.field("sentryForFrontend", S.json),
    mediaProxy: s.field("mediaProxy", S.string),
    enableUrlPreview: s.field("enableUrlPreview", S.bool),
    enableSkebStatus: s.field("enableSkebStatus", S.bool),
    backgroundImageUrl: s.field("backgroundImageUrl", S.json),
    impressumUrl: s.field("impressumUrl", S.json),
    logoImageUrl: s.field("logoImageUrl", S.json),
    privacyPolicyUrl: s.field("privacyPolicyUrl", S.json),
    inquiryUrl: s.field("inquiryUrl", S.json),
    serverRules: s.field("serverRules", S.array(S.string)),
    themeColor: s.field("themeColor", S.json),
    policies: s.field("policies", RolePolicies.schema),
    noteSearchableScope: s.field("noteSearchableScope", S.string),
    maxFileSize: s.field("maxFileSize", S.float),
    federation: s.field("federation", S.string),
  })
}

module FlashLike = {
  type t = {
  id: string,
  flash: Flash.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    flash: s.field("flash", Flash.schema),
  })
}

module ChatRoomInvitation = {
  type t = {
  id: string,
  createdAt: string,
  userId: string,
  user: UserLite.t,
  roomId: string,
  room: ChatRoom.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    roomId: s.field("roomId", S.string),
    room: s.field("room", ChatRoom.schema),
  })
}

module UserDetailedNotMeOnly = {
  type t = {
  url: JSON.t,
  uri: JSON.t,
  movedTo: JSON.t,
  alsoKnownAs: JSON.t,
  createdAt: string,
  updatedAt: JSON.t,
  lastFetchedAt: JSON.t,
  bannerUrl: JSON.t,
  bannerBlurhash: JSON.t,
  isLocked: bool,
  isSilenced: bool,
  isLimited: bool,
  isSuspended: bool,
  description: JSON.t,
  location: JSON.t,
  birthday: JSON.t,
  lang: JSON.t,
  fields: array<{
  name: string,
  value: string,
}>,
  verifiedLinks: array<string>,
  followersCount: float,
  followingCount: float,
  notesCount: float,
  pinnedNoteIds: array<string>,
  pinnedNotes: array<Note.t>,
  pinnedPageId: JSON.t,
  pinnedPage: JSON.t,
  publicReactions: bool,
  followingVisibility: string,
  followersVisibility: string,
  chatScope: string,
  canChat: bool,
  roles: array<RoleLite.t>,
  followedMessage: option<JSON.t>,
  memo: JSON.t,
  moderationNote: option<string>,
  twoFactorEnabled: option<bool>,
  usePasswordLessLogin: option<bool>,
  securityKeys: option<bool>,
  mutualLinkSections: array<{
  name: JSON.t,
  mutualLinks: array<{
  id: string,
  url: string,
  fileId: string,
  description: JSON.t,
  imgSrc: string,
}>,
}>,
  isFollowing: option<bool>,
  isFollowed: option<bool>,
  hasPendingFollowRequestFromYou: option<bool>,
  hasPendingFollowRequestToYou: option<bool>,
  isBlocking: option<bool>,
  isBlocked: option<bool>,
  isMuted: option<bool>,
  isRenoteMuted: option<bool>,
  notify: option<string>,
  withReplies: option<bool>,
}
  let schema = S.object(s => {
    url: s.field("url", S.json),
    uri: s.field("uri", S.json),
    movedTo: s.field("movedTo", S.json),
    alsoKnownAs: s.field("alsoKnownAs", S.json),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.json),
    lastFetchedAt: s.field("lastFetchedAt", S.json),
    bannerUrl: s.field("bannerUrl", S.json),
    bannerBlurhash: s.field("bannerBlurhash", S.json),
    isLocked: s.field("isLocked", S.bool),
    isSilenced: s.field("isSilenced", S.bool),
    isLimited: s.field("isLimited", S.bool),
    isSuspended: s.field("isSuspended", S.bool),
    description: s.field("description", S.json),
    location: s.field("location", S.json),
    birthday: s.field("birthday", S.json),
    lang: s.field("lang", S.json),
    fields: s.field("fields", S.array(S.object(s => {
    name: s.field("name", S.string),
    value: s.field("value", S.string),
  }))),
    verifiedLinks: s.field("verifiedLinks", S.array(S.string)),
    followersCount: s.field("followersCount", S.float),
    followingCount: s.field("followingCount", S.float),
    notesCount: s.field("notesCount", S.float),
    pinnedNoteIds: s.field("pinnedNoteIds", S.array(S.string)),
    pinnedNotes: s.field("pinnedNotes", S.array(Note.schema)),
    pinnedPageId: s.field("pinnedPageId", S.json),
    pinnedPage: s.field("pinnedPage", S.json),
    publicReactions: s.field("publicReactions", S.bool),
    followingVisibility: s.field("followingVisibility", S.string),
    followersVisibility: s.field("followersVisibility", S.string),
    chatScope: s.field("chatScope", S.string),
    canChat: s.field("canChat", S.bool),
    roles: s.field("roles", S.array(RoleLite.schema)),
    followedMessage: s.fieldOr("followedMessage", S.nullableAsOption(S.json), None),
    memo: s.field("memo", S.json),
    moderationNote: s.fieldOr("moderationNote", S.nullableAsOption(S.string), None),
    twoFactorEnabled: s.fieldOr("twoFactorEnabled", S.nullableAsOption(S.bool), None),
    usePasswordLessLogin: s.fieldOr("usePasswordLessLogin", S.nullableAsOption(S.bool), None),
    securityKeys: s.fieldOr("securityKeys", S.nullableAsOption(S.bool), None),
    mutualLinkSections: s.field("mutualLinkSections", S.array(S.object(s => {
    name: s.field("name", S.json),
    mutualLinks: s.field("mutualLinks", S.array(S.object(s => {
    id: s.field("id", S.string),
    url: s.field("url", S.string),
    fileId: s.field("fileId", S.string),
    description: s.field("description", S.json),
    imgSrc: s.field("imgSrc", S.string),
  }))),
  }))),
    isFollowing: s.fieldOr("isFollowing", S.nullableAsOption(S.bool), None),
    isFollowed: s.fieldOr("isFollowed", S.nullableAsOption(S.bool), None),
    hasPendingFollowRequestFromYou: s.fieldOr("hasPendingFollowRequestFromYou", S.nullableAsOption(S.bool), None),
    hasPendingFollowRequestToYou: s.fieldOr("hasPendingFollowRequestToYou", S.nullableAsOption(S.bool), None),
    isBlocking: s.fieldOr("isBlocking", S.nullableAsOption(S.bool), None),
    isBlocked: s.fieldOr("isBlocked", S.nullableAsOption(S.bool), None),
    isMuted: s.fieldOr("isMuted", S.nullableAsOption(S.bool), None),
    isRenoteMuted: s.fieldOr("isRenoteMuted", S.nullableAsOption(S.bool), None),
    notify: s.fieldOr("notify", S.nullableAsOption(S.string), None),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
  })
}

module NoteFavorite = {
  type t = {
  id: string,
  createdAt: string,
  note: Note.t,
  noteId: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    note: s.field("note", Note.schema),
    noteId: s.field("noteId", S.string),
  })
}

module Channel = {
  type t = {
  id: string,
  createdAt: string,
  lastNotedAt: JSON.t,
  name: string,
  description: JSON.t,
  userId: JSON.t,
  bannerUrl: JSON.t,
  pinnedNoteIds: array<string>,
  color: string,
  isArchived: bool,
  usersCount: float,
  notesCount: float,
  isSensitive: bool,
  allowRenoteToExternal: bool,
  isFollowing: option<bool>,
  isFavorited: option<bool>,
  pinnedNotes: option<array<Note.t>>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    lastNotedAt: s.field("lastNotedAt", S.json),
    name: s.field("name", S.string),
    description: s.field("description", S.json),
    userId: s.field("userId", S.json),
    bannerUrl: s.field("bannerUrl", S.json),
    pinnedNoteIds: s.field("pinnedNoteIds", S.array(S.string)),
    color: s.field("color", S.string),
    isArchived: s.field("isArchived", S.bool),
    usersCount: s.field("usersCount", S.float),
    notesCount: s.field("notesCount", S.float),
    isSensitive: s.field("isSensitive", S.bool),
    allowRenoteToExternal: s.field("allowRenoteToExternal", S.bool),
    isFollowing: s.fieldOr("isFollowing", S.nullableAsOption(S.bool), None),
    isFavorited: s.fieldOr("isFavorited", S.nullableAsOption(S.bool), None),
    pinnedNotes: s.fieldOr("pinnedNotes", S.nullableAsOption(S.array(Note.schema)), None),
  })
}

module GalleryLike = {
  type t = {
  id: string,
  post: GalleryPost.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    post: s.field("post", GalleryPost.schema),
  })
}

module PageLike = {
  type t = {
  id: string,
  page: Page.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    page: s.field("page", Page.schema),
  })
}

module MetaDetailed = {
  type t = MetaDetailedOnly.t
  let schema = MetaDetailedOnly.schema
}

module UserDetailedNotMe = {
  type t = UserDetailedNotMeOnly.t
  let schema = UserDetailedNotMeOnly.schema
}

module MeDetailed = {
  type t = MeDetailedOnly.t
  let schema = MeDetailedOnly.schema
}

module Muting = {
  type t = {
  id: string,
  createdAt: string,
  expiresAt: JSON.t,
  muteeId: string,
  mutee: UserDetailedNotMe.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    expiresAt: s.field("expiresAt", S.json),
    muteeId: s.field("muteeId", S.string),
    mutee: s.field("mutee", UserDetailedNotMe.schema),
  })
}

module RenoteMuting = {
  type t = {
  id: string,
  createdAt: string,
  muteeId: string,
  mutee: UserDetailedNotMe.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    muteeId: s.field("muteeId", S.string),
    mutee: s.field("mutee", UserDetailedNotMe.schema),
  })
}

module Blocking = {
  type t = {
  id: string,
  createdAt: string,
  blockeeId: string,
  blockee: UserDetailedNotMe.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    blockeeId: s.field("blockeeId", S.string),
    blockee: s.field("blockee", UserDetailedNotMe.schema),
  })
}

module UserDetailed = {
  type t = [
  | UserDetailedNotMe(UserDetailedNotMe.t)
  | MeDetailed(MeDetailed.t)
]
  let schema = S.union([UserDetailedNotMe.schema, MeDetailed.schema])
}

module User = {
  type t = [
  | UserLite(UserLite.t)
  | UserDetailed(UserDetailed.t)
]
  let schema = S.union([UserLite.schema, UserDetailed.schema])
}

module ModerationLog = {
  type t = {
  id: string,
  createdAt: string,
  @as("type") type_: string,
  info: JSON.t,
  userId: string,
  user: UserDetailed.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    type_: s.field("type", S.string),
    info: s.field("info", S.json),
    userId: s.field("userId", S.string),
    user: s.field("user", UserDetailed.schema),
  })
}

module AbuseUserReport = {
  type t = {
  id: string,
  category: string,
  createdAt: string,
  comment: string,
  resolved: bool,
  reporterId: string,
  reporter: UserDetailed.t,
  targetUserId: string,
  targetUser: UserDetailed.t,
  assigneeId: JSON.t,
  assignee: option<JSON.t>,
  forwarded: bool,
  moderationNote: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    category: s.field("category", S.string),
    createdAt: s.field("createdAt", S.string),
    comment: s.field("comment", S.string),
    resolved: s.field("resolved", S.bool),
    reporterId: s.field("reporterId", S.string),
    reporter: s.field("reporter", UserDetailed.schema),
    targetUserId: s.field("targetUserId", S.string),
    targetUser: s.field("targetUser", UserDetailed.schema),
    assigneeId: s.field("assigneeId", S.json),
    assignee: s.fieldOr("assignee", S.nullableAsOption(S.json), None),
    forwarded: s.field("forwarded", S.bool),
    moderationNote: s.field("moderationNote", S.string),
  })
}

module ChatMessage = {
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  fromUser: UserLite.t,
  toUserId: option<JSON.t>,
  toUser: option<JSON.t>,
  toRoomId: option<JSON.t>,
  toRoom: option<JSON.t>,
  text: option<JSON.t>,
  fileId: option<JSON.t>,
  file: option<JSON.t>,
  isRead: option<bool>,
  reactions: array<{
  reaction: string,
  user: UserLite.t,
}>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    fromUser: s.field("fromUser", UserLite.schema),
    toUserId: s.fieldOr("toUserId", S.nullableAsOption(S.json), None),
    toUser: s.fieldOr("toUser", S.nullableAsOption(S.json), None),
    toRoomId: s.fieldOr("toRoomId", S.nullableAsOption(S.json), None),
    toRoom: s.fieldOr("toRoom", S.nullableAsOption(S.json), None),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    isRead: s.fieldOr("isRead", S.nullableAsOption(S.bool), None),
    reactions: s.field("reactions", S.array(S.object(s => {
    reaction: s.field("reaction", S.string),
    user: s.field("user", UserLite.schema),
  }))),
  })
}

module ChatMessageLiteForRoom = {
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  fromUser: UserLite.t,
  toRoomId: string,
  text: option<JSON.t>,
  fileId: option<JSON.t>,
  file: option<JSON.t>,
  reactions: array<{
  reaction: string,
  user: UserLite.t,
}>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    fromUser: s.field("fromUser", UserLite.schema),
    toRoomId: s.field("toRoomId", S.string),
    text: s.fieldOr("text", S.nullableAsOption(S.json), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.json), None),
    file: s.fieldOr("file", S.nullableAsOption(S.json), None),
    reactions: s.field("reactions", S.array(S.object(s => {
    reaction: s.field("reaction", S.string),
    user: s.field("user", UserLite.schema),
  }))),
  })
}

module FollowRequest = {
  type t = {
  id: string,
  follower: UserLite.t,
  followee: UserLite.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    follower: s.field("follower", UserLite.schema),
    followee: s.field("followee", UserLite.schema),
  })
}

module ReversiGameDetailed = {
  type t = {
  id: string,
  createdAt: string,
  startedAt: JSON.t,
  endedAt: JSON.t,
  isStarted: bool,
  isEnded: bool,
  form1: JSON.t,
  form2: JSON.t,
  @as("user1Ready") user1ready: bool,
  @as("user2Ready") user2ready: bool,
  @as("user1Id") user1id: string,
  @as("user2Id") user2id: string,
  user1: UserLite.t,
  user2: UserLite.t,
  winnerId: JSON.t,
  winner: JSON.t,
  surrenderedUserId: JSON.t,
  timeoutUserId: JSON.t,
  black: JSON.t,
  bw: string,
  noIrregularRules: bool,
  isLlotheo: bool,
  canPutEverywhere: bool,
  loopedBoard: bool,
  timeLimitForEachTurn: float,
  logs: array<array<float>>,
  map: array<string>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    startedAt: s.field("startedAt", S.json),
    endedAt: s.field("endedAt", S.json),
    isStarted: s.field("isStarted", S.bool),
    isEnded: s.field("isEnded", S.bool),
    form1: s.field("form1", S.json),
    form2: s.field("form2", S.json),
    user1ready: s.field("user1Ready", S.bool),
    user2ready: s.field("user2Ready", S.bool),
    user1id: s.field("user1Id", S.string),
    user2id: s.field("user2Id", S.string),
    user1: s.field("user1", UserLite.schema),
    user2: s.field("user2", UserLite.schema),
    winnerId: s.field("winnerId", S.json),
    winner: s.field("winner", S.json),
    surrenderedUserId: s.field("surrenderedUserId", S.json),
    timeoutUserId: s.field("timeoutUserId", S.json),
    black: s.field("black", S.json),
    bw: s.field("bw", S.string),
    noIrregularRules: s.field("noIrregularRules", S.bool),
    isLlotheo: s.field("isLlotheo", S.bool),
    canPutEverywhere: s.field("canPutEverywhere", S.bool),
    loopedBoard: s.field("loopedBoard", S.bool),
    timeLimitForEachTurn: s.field("timeLimitForEachTurn", S.float),
    logs: s.field("logs", S.array(S.array(S.float))),
    map: s.field("map", S.array(S.string)),
  })
}

module ReversiGameLite = {
  type t = {
  id: string,
  createdAt: string,
  startedAt: JSON.t,
  endedAt: JSON.t,
  isStarted: bool,
  isEnded: bool,
  @as("user1Id") user1id: string,
  @as("user2Id") user2id: string,
  user1: UserLite.t,
  user2: UserLite.t,
  winnerId: JSON.t,
  winner: JSON.t,
  surrenderedUserId: JSON.t,
  timeoutUserId: JSON.t,
  black: JSON.t,
  bw: string,
  noIrregularRules: bool,
  isLlotheo: bool,
  canPutEverywhere: bool,
  loopedBoard: bool,
  timeLimitForEachTurn: float,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    startedAt: s.field("startedAt", S.json),
    endedAt: s.field("endedAt", S.json),
    isStarted: s.field("isStarted", S.bool),
    isEnded: s.field("isEnded", S.bool),
    user1id: s.field("user1Id", S.string),
    user2id: s.field("user2Id", S.string),
    user1: s.field("user1", UserLite.schema),
    user2: s.field("user2", UserLite.schema),
    winnerId: s.field("winnerId", S.json),
    winner: s.field("winner", S.json),
    surrenderedUserId: s.field("surrenderedUserId", S.json),
    timeoutUserId: s.field("timeoutUserId", S.json),
    black: s.field("black", S.json),
    bw: s.field("bw", S.string),
    noIrregularRules: s.field("noIrregularRules", S.bool),
    isLlotheo: s.field("isLlotheo", S.bool),
    canPutEverywhere: s.field("canPutEverywhere", S.bool),
    loopedBoard: s.field("loopedBoard", S.bool),
    timeLimitForEachTurn: s.field("timeLimitForEachTurn", S.float),
  })
}

module UserAccountMoveLog = {
  type t = {
  id: string,
  createdAt: string,
  movedToId: string,
  movedTo: UserDetailed.t,
  movedFromId: string,
  movedFrom: UserDetailed.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    movedToId: s.field("movedToId", S.string),
    movedTo: s.field("movedTo", UserDetailed.schema),
    movedFromId: s.field("movedFromId", S.string),
    movedFrom: s.field("movedFrom", UserDetailed.schema),
  })
}