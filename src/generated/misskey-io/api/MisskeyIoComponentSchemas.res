// Shared component schemas
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



module ChatRoomMembership = {
  type t = {
  id: string,
  createdAt: string,
  userId: string,
  user: option<dict<JSON.t>>,
  roomId: string,
  room: option<dict<JSON.t>>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.string),
    user: s.fieldOr("user", S.nullableAsOption(S.dict(S.json)), None),
    roomId: s.field("roomId", S.string),
    room: s.fieldOr("room", S.nullableAsOption(S.dict(S.json)), None),
  })
}

module UserLite = {
  type userLite_3 = {
  name: string,
  iconUrl: option<string>,
  displayOrder: float,
  behavior: option<string>,
}
  let userLite_3Schema = S.object(s => {
    name: s.field("name", S.string),
    iconUrl: s.field("iconUrl", S.nullableAsOption(S.string)),
    displayOrder: s.field("displayOrder", S.float),
    behavior: s.fieldOr("behavior", S.nullableAsOption(S.string), None),
  })
  type userLite_2 = {
  name: option<string>,
  softwareName: option<string>,
  softwareVersion: option<string>,
  iconUrl: option<string>,
  faviconUrl: option<string>,
  themeColor: option<string>,
}
  let userLite_2Schema = S.object(s => {
    name: s.field("name", S.nullableAsOption(S.string)),
    softwareName: s.field("softwareName", S.nullableAsOption(S.string)),
    softwareVersion: s.field("softwareVersion", S.nullableAsOption(S.string)),
    iconUrl: s.field("iconUrl", S.nullableAsOption(S.string)),
    faviconUrl: s.field("faviconUrl", S.nullableAsOption(S.string)),
    themeColor: s.field("themeColor", S.nullableAsOption(S.string)),
  })
  type userLite_1 = {
  id: string,
  angle: option<float>,
  flipH: option<bool>,
  url: string,
  offsetX: option<float>,
  offsetY: option<float>,
}
  let userLite_1Schema = S.object(s => {
    id: s.field("id", S.string),
    angle: s.fieldOr("angle", S.nullableAsOption(S.float), None),
    flipH: s.fieldOr("flipH", S.nullableAsOption(S.bool), None),
    url: s.field("url", S.string),
    offsetX: s.fieldOr("offsetX", S.nullableAsOption(S.float), None),
    offsetY: s.fieldOr("offsetY", S.nullableAsOption(S.float), None),
  })
  type t = {
  id: string,
  name: option<string>,
  username: string,
  host: option<string>,
  avatarUrl: option<string>,
  avatarBlurhash: option<string>,
  avatarDecorations: array<userLite_1>,
  isBot: option<bool>,
  isCat: option<bool>,
  requireSigninToViewContents: option<bool>,
  makeNotesFollowersOnlyBefore: option<float>,
  makeNotesHiddenBefore: option<float>,
  instance: option<userLite_2>,
  emojis: dict<JSON.t>,
  onlineStatus: string,
  badgeRoles: option<array<userLite_3>>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.nullableAsOption(S.string)),
    username: s.field("username", S.string),
    host: s.field("host", S.nullableAsOption(S.string)),
    avatarUrl: s.field("avatarUrl", S.nullableAsOption(S.string)),
    avatarBlurhash: s.field("avatarBlurhash", S.nullableAsOption(S.string)),
    avatarDecorations: s.field("avatarDecorations", S.array(userLite_1Schema)),
    isBot: s.fieldOr("isBot", S.nullableAsOption(S.bool), None),
    isCat: s.fieldOr("isCat", S.nullableAsOption(S.bool), None),
    requireSigninToViewContents: s.fieldOr("requireSigninToViewContents", S.nullableAsOption(S.bool), None),
    makeNotesFollowersOnlyBefore: s.fieldOr("makeNotesFollowersOnlyBefore", S.nullableAsOption(S.float), None),
    makeNotesHiddenBefore: s.fieldOr("makeNotesHiddenBefore", S.nullableAsOption(S.float), None),
    instance: s.fieldOr("instance", S.nullableAsOption(userLite_2Schema), None),
    emojis: s.field("emojis", S.dict(S.json)),
    onlineStatus: s.field("onlineStatus", S.string),
    badgeRoles: s.fieldOr("badgeRoles", S.nullableAsOption(S.array(userLite_3Schema)), None),
  })
}

module ChatRoom = {
  type t = {
  id: string,
  createdAt: string,
  ownerId: string,
  owner: UserLite.t,
  name: string,
  description: string,
  isMuted: option<bool>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    ownerId: s.field("ownerId", S.string),
    owner: s.field("owner", UserLite.schema),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    isMuted: s.fieldOr("isMuted", S.nullableAsOption(S.bool), None),
  })
}

module ChatRoomInvitation = {
  type t = {
  id: string,
  createdAt: string,
  userId: string,
  user: UserLite.t,
  roomId: string,
  room: ChatRoom.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    roomId: s.field("roomId", S.string),
    room: s.field("room", ChatRoom.schema),
  })
}

module DriveFolder = {
  type rec t = {
  id: string,
  createdAt: string,
  name: string,
  parentId: option<string>,
  foldersCount: option<float>,
  filesCount: option<float>,
  parent: option<t>,
}
  let schema = S.recursive("DriveFolder", schema => S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    parentId: s.field("parentId", S.nullableAsOption(S.string)),
    foldersCount: s.fieldOr("foldersCount", S.nullableAsOption(S.float), None),
    filesCount: s.fieldOr("filesCount", S.nullableAsOption(S.float), None),
    parent: s.fieldOr("parent", S.nullableAsOption(schema), None),
  }))
}

module DriveFile = {
  type driveFile_1 = {
  width: option<float>,
  height: option<float>,
  orientation: option<float>,
  avgColor: option<string>,
}
  let driveFile_1Schema = S.object(s => {
    width: s.fieldOr("width", S.nullableAsOption(S.float), None),
    height: s.fieldOr("height", S.nullableAsOption(S.float), None),
    orientation: s.fieldOr("orientation", S.nullableAsOption(S.float), None),
    avgColor: s.fieldOr("avgColor", S.nullableAsOption(S.string), None),
  })
  type t = {
  id: string,
  createdAt: string,
  name: string,
  @as("type") type_: string,
  md5: string,
  size: float,
  isSensitive: bool,
  isSensitiveByModerator: option<bool>,
  blurhash: option<string>,
  properties: driveFile_1,
  url: string,
  thumbnailUrl: option<string>,
  comment: option<string>,
  folderId: option<string>,
  folder: option<DriveFolder.t>,
  userId: option<string>,
  user: option<UserLite.t>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    type_: s.field("type", S.string),
    md5: s.field("md5", S.string),
    size: s.field("size", S.float),
    isSensitive: s.field("isSensitive", S.bool),
    isSensitiveByModerator: s.fieldOr("isSensitiveByModerator", S.nullableAsOption(S.bool), None),
    blurhash: s.field("blurhash", S.nullableAsOption(S.string)),
    properties: s.field("properties", driveFile_1Schema),
    url: s.field("url", S.string),
    thumbnailUrl: s.field("thumbnailUrl", S.nullableAsOption(S.string)),
    comment: s.field("comment", S.nullableAsOption(S.string)),
    folderId: s.field("folderId", S.nullableAsOption(S.string)),
    folder: s.fieldOr("folder", S.nullableAsOption(DriveFolder.schema), None),
    userId: s.field("userId", S.nullableAsOption(S.string)),
    user: s.fieldOr("user", S.nullableAsOption(UserLite.schema), None),
  })
}

module ChatMessageLiteForRoom = {
  type chatMessageLiteForRoom_1 = {
  reaction: string,
  user: UserLite.t,
}
  let chatMessageLiteForRoom_1Schema = S.object(s => {
    reaction: s.field("reaction", S.string),
    user: s.field("user", UserLite.schema),
  })
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  fromUser: UserLite.t,
  toRoomId: string,
  text: option<string>,
  fileId: option<string>,
  file: option<DriveFile.t>,
  reactions: array<chatMessageLiteForRoom_1>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    fromUser: s.field("fromUser", UserLite.schema),
    toRoomId: s.field("toRoomId", S.string),
    text: s.fieldOr("text", S.nullableAsOption(S.string), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.string), None),
    file: s.fieldOr("file", S.nullableAsOption(DriveFile.schema), None),
    reactions: s.field("reactions", S.array(chatMessageLiteForRoom_1Schema)),
  })
}

module ChatMessageLiteFor1on1 = {
  type chatMessageLiteFor1on1_1 = {
  reaction: string,
}
  let chatMessageLiteFor1on1_1Schema = S.object(s => {
    reaction: s.field("reaction", S.string),
  })
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  toUserId: string,
  text: option<string>,
  fileId: option<string>,
  file: option<DriveFile.t>,
  reactions: array<chatMessageLiteFor1on1_1>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    toUserId: s.field("toUserId", S.string),
    text: s.fieldOr("text", S.nullableAsOption(S.string), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.string), None),
    file: s.fieldOr("file", S.nullableAsOption(DriveFile.schema), None),
    reactions: s.field("reactions", S.array(chatMessageLiteFor1on1_1Schema)),
  })
}

module ChatMessageLite = {
  type chatMessageLite_1 = {
  reaction: string,
  user: option<UserLite.t>,
}
  let chatMessageLite_1Schema = S.object(s => {
    reaction: s.field("reaction", S.string),
    user: s.fieldOr("user", S.nullableAsOption(UserLite.schema), None),
  })
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  fromUser: option<dict<JSON.t>>,
  toUserId: option<string>,
  toRoomId: option<string>,
  text: option<string>,
  fileId: option<string>,
  file: option<DriveFile.t>,
  reactions: array<chatMessageLite_1>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    fromUser: s.fieldOr("fromUser", S.nullableAsOption(S.dict(S.json)), None),
    toUserId: s.fieldOr("toUserId", S.nullableAsOption(S.string), None),
    toRoomId: s.fieldOr("toRoomId", S.nullableAsOption(S.string), None),
    text: s.fieldOr("text", S.nullableAsOption(S.string), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.string), None),
    file: s.fieldOr("file", S.nullableAsOption(DriveFile.schema), None),
    reactions: s.field("reactions", S.array(chatMessageLite_1Schema)),
  })
}

module ChatMessage = {
  type chatMessage_1 = {
  reaction: string,
  user: UserLite.t,
}
  let chatMessage_1Schema = S.object(s => {
    reaction: s.field("reaction", S.string),
    user: s.field("user", UserLite.schema),
  })
  type t = {
  id: string,
  createdAt: string,
  fromUserId: string,
  fromUser: UserLite.t,
  toUserId: option<string>,
  toUser: option<UserLite.t>,
  toRoomId: option<string>,
  toRoom: option<ChatRoom.t>,
  text: option<string>,
  fileId: option<string>,
  file: option<DriveFile.t>,
  isRead: option<bool>,
  reactions: array<chatMessage_1>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    fromUserId: s.field("fromUserId", S.string),
    fromUser: s.field("fromUser", UserLite.schema),
    toUserId: s.fieldOr("toUserId", S.nullableAsOption(S.string), None),
    toUser: s.fieldOr("toUser", S.nullableAsOption(UserLite.schema), None),
    toRoomId: s.fieldOr("toRoomId", S.nullableAsOption(S.string), None),
    toRoom: s.fieldOr("toRoom", S.nullableAsOption(ChatRoom.schema), None),
    text: s.fieldOr("text", S.nullableAsOption(S.string), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.string), None),
    file: s.fieldOr("file", S.nullableAsOption(DriveFile.schema), None),
    isRead: s.fieldOr("isRead", S.nullableAsOption(S.bool), None),
    reactions: s.field("reactions", S.array(chatMessage_1Schema)),
  })
}

module AbuseReportNotificationRecipient = {
  type t = {
  id: string,
  isActive: bool,
  updatedAt: string,
  name: string,
  @as("method") method_: string,
  userId: option<string>,
  user: option<dict<JSON.t>>,
  systemWebhookId: option<string>,
  systemWebhook: option<dict<JSON.t>>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    updatedAt: s.field("updatedAt", S.string),
    name: s.field("name", S.string),
    method_: s.field("method", S.string),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    user: s.fieldOr("user", S.nullableAsOption(S.dict(S.json)), None),
    systemWebhookId: s.fieldOr("systemWebhookId", S.nullableAsOption(S.string), None),
    systemWebhook: s.fieldOr("systemWebhook", S.nullableAsOption(S.dict(S.json)), None),
  })
}

module SystemWebhook = {
  type t = {
  id: string,
  isActive: bool,
  updatedAt: string,
  latestSentAt: option<string>,
  latestStatus: option<float>,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    updatedAt: s.field("updatedAt", S.string),
    latestSentAt: s.field("latestSentAt", S.nullableAsOption(S.string)),
    latestStatus: s.field("latestStatus", S.nullableAsOption(S.float)),
    name: s.field("name", S.string),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string),
    secret: s.field("secret", S.string),
  })
}

module RolePolicies = {
  type t = {
  gtlAvailable: bool,
  ltlAvailable: bool,
  canPublicNote: bool,
  canScheduleNote: bool,
  scheduleNoteLimit: int,
  scheduleNoteMaxDays: int,
  canInitiateConversation: bool,
  canCreateContent: bool,
  canUpdateContent: bool,
  canDeleteContent: bool,
  canPurgeAccount: bool,
  canUpdateAvatar: bool,
  canUpdateBanner: bool,
  mentionLimit: int,
  canInvite: bool,
  inviteLimit: int,
  inviteLimitCycle: int,
  inviteExpirationTime: int,
  canManageCustomEmojis: bool,
  canManageAvatarDecorations: bool,
  canSearchNotes: bool,
  canUseTranslator: bool,
  canUseDriveFileInSoundSettings: bool,
  canUseReaction: bool,
  canHideAds: bool,
  driveCapacityMb: int,
  maxFileSizeMb: int,
  alwaysMarkNsfw: bool,
  skipNsfwDetection: bool,
  canUpdateBioMedia: bool,
  pinLimit: int,
  antennaLimit: int,
  antennaNotesLimit: int,
  wordMuteLimit: int,
  webhookLimit: int,
  clipLimit: int,
  noteEachClipsLimit: int,
  userListLimit: int,
  userEachUserListsLimit: int,
  rateLimitFactor: int,
  avatarDecorationLimit: int,
  canImportAntennas: bool,
  canImportBlocking: bool,
  canImportFollowing: bool,
  canImportMuting: bool,
  canImportUserLists: bool,
  mutualLinkSectionLimit: int,
  mutualLinkLimit: int,
  chatAvailability: string,
}
  let schema = S.object(s => {
    gtlAvailable: s.field("gtlAvailable", S.bool),
    ltlAvailable: s.field("ltlAvailable", S.bool),
    canPublicNote: s.field("canPublicNote", S.bool),
    canScheduleNote: s.field("canScheduleNote", S.bool),
    scheduleNoteLimit: s.field("scheduleNoteLimit", S.int),
    scheduleNoteMaxDays: s.field("scheduleNoteMaxDays", S.int),
    canInitiateConversation: s.field("canInitiateConversation", S.bool),
    canCreateContent: s.field("canCreateContent", S.bool),
    canUpdateContent: s.field("canUpdateContent", S.bool),
    canDeleteContent: s.field("canDeleteContent", S.bool),
    canPurgeAccount: s.field("canPurgeAccount", S.bool),
    canUpdateAvatar: s.field("canUpdateAvatar", S.bool),
    canUpdateBanner: s.field("canUpdateBanner", S.bool),
    mentionLimit: s.field("mentionLimit", S.int),
    canInvite: s.field("canInvite", S.bool),
    inviteLimit: s.field("inviteLimit", S.int),
    inviteLimitCycle: s.field("inviteLimitCycle", S.int),
    inviteExpirationTime: s.field("inviteExpirationTime", S.int),
    canManageCustomEmojis: s.field("canManageCustomEmojis", S.bool),
    canManageAvatarDecorations: s.field("canManageAvatarDecorations", S.bool),
    canSearchNotes: s.field("canSearchNotes", S.bool),
    canUseTranslator: s.field("canUseTranslator", S.bool),
    canUseDriveFileInSoundSettings: s.field("canUseDriveFileInSoundSettings", S.bool),
    canUseReaction: s.field("canUseReaction", S.bool),
    canHideAds: s.field("canHideAds", S.bool),
    driveCapacityMb: s.field("driveCapacityMb", S.int),
    maxFileSizeMb: s.field("maxFileSizeMb", S.int),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.bool),
    skipNsfwDetection: s.field("skipNsfwDetection", S.bool),
    canUpdateBioMedia: s.field("canUpdateBioMedia", S.bool),
    pinLimit: s.field("pinLimit", S.int),
    antennaLimit: s.field("antennaLimit", S.int),
    antennaNotesLimit: s.field("antennaNotesLimit", S.int),
    wordMuteLimit: s.field("wordMuteLimit", S.int),
    webhookLimit: s.field("webhookLimit", S.int),
    clipLimit: s.field("clipLimit", S.int),
    noteEachClipsLimit: s.field("noteEachClipsLimit", S.int),
    userListLimit: s.field("userListLimit", S.int),
    userEachUserListsLimit: s.field("userEachUserListsLimit", S.int),
    rateLimitFactor: s.field("rateLimitFactor", S.int),
    avatarDecorationLimit: s.field("avatarDecorationLimit", S.int),
    canImportAntennas: s.field("canImportAntennas", S.bool),
    canImportBlocking: s.field("canImportBlocking", S.bool),
    canImportFollowing: s.field("canImportFollowing", S.bool),
    canImportMuting: s.field("canImportMuting", S.bool),
    canImportUserLists: s.field("canImportUserLists", S.bool),
    mutualLinkSectionLimit: s.field("mutualLinkSectionLimit", S.int),
    mutualLinkLimit: s.field("mutualLinkLimit", S.int),
    chatAvailability: s.field("chatAvailability", S.string),
  })
}

module Announcement = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  text: string,
  title: string,
  imageUrl: option<string>,
  icon: string,
  display: string,
  needConfirmationToRead: bool,
  needEnrollmentTutorialToRead: bool,
  forYou: bool,
  closeDuration: float,
  displayOrder: float,
  silence: bool,
  isRead: option<bool>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    text: s.field("text", S.string),
    title: s.field("title", S.string),
    imageUrl: s.field("imageUrl", S.nullableAsOption(S.string)),
    icon: s.field("icon", S.string),
    display: s.field("display", S.string),
    needConfirmationToRead: s.field("needConfirmationToRead", S.bool),
    needEnrollmentTutorialToRead: s.field("needEnrollmentTutorialToRead", S.bool),
    forYou: s.field("forYou", S.bool),
    closeDuration: s.field("closeDuration", S.float),
    displayOrder: s.field("displayOrder", S.float),
    silence: s.field("silence", S.bool),
    isRead: s.fieldOr("isRead", S.nullableAsOption(S.bool), None),
  })
}

module MeDetailedOnly = {
  type meDetailedOnly_3 = {
  id: string,
  name: string,
  lastUsed: string,
}
  let meDetailedOnly_3Schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    lastUsed: s.field("lastUsed", S.string),
  })
  type meDetailedOnly_2 = {
  name: string,
  unlockedAt: float,
}
  let meDetailedOnly_2Schema = S.object(s => {
    name: s.field("name", S.string),
    unlockedAt: s.field("unlockedAt", S.float),
  })
  type meDetailedOnly_1 = {
  note: option<dict<JSON.t>>,
  follow: option<dict<JSON.t>>,
  mention: option<dict<JSON.t>>,
  reply: option<dict<JSON.t>>,
  renote: option<dict<JSON.t>>,
  quote: option<dict<JSON.t>>,
  reaction: option<dict<JSON.t>>,
  pollEnded: option<dict<JSON.t>>,
  receiveFollowRequest: option<dict<JSON.t>>,
  followRequestAccepted: option<dict<JSON.t>>,
  roleAssigned: option<dict<JSON.t>>,
  chatRoomInvitationReceived: option<dict<JSON.t>>,
  achievementEarned: option<dict<JSON.t>>,
  app: option<dict<JSON.t>>,
  test: option<dict<JSON.t>>,
}
  let meDetailedOnly_1Schema = S.object(s => {
    note: s.fieldOr("note", S.nullableAsOption(S.dict(S.json)), None),
    follow: s.fieldOr("follow", S.nullableAsOption(S.dict(S.json)), None),
    mention: s.fieldOr("mention", S.nullableAsOption(S.dict(S.json)), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.dict(S.json)), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.dict(S.json)), None),
    quote: s.fieldOr("quote", S.nullableAsOption(S.dict(S.json)), None),
    reaction: s.fieldOr("reaction", S.nullableAsOption(S.dict(S.json)), None),
    pollEnded: s.fieldOr("pollEnded", S.nullableAsOption(S.dict(S.json)), None),
    receiveFollowRequest: s.fieldOr("receiveFollowRequest", S.nullableAsOption(S.dict(S.json)), None),
    followRequestAccepted: s.fieldOr("followRequestAccepted", S.nullableAsOption(S.dict(S.json)), None),
    roleAssigned: s.fieldOr("roleAssigned", S.nullableAsOption(S.dict(S.json)), None),
    chatRoomInvitationReceived: s.fieldOr("chatRoomInvitationReceived", S.nullableAsOption(S.dict(S.json)), None),
    achievementEarned: s.fieldOr("achievementEarned", S.nullableAsOption(S.dict(S.json)), None),
    app: s.fieldOr("app", S.nullableAsOption(S.dict(S.json)), None),
    test: s.fieldOr("test", S.nullableAsOption(S.dict(S.json)), None),
  })
  type t = {
  avatarId: option<string>,
  bannerId: option<string>,
  followedMessage: option<string>,
  isModerator: option<bool>,
  isAdmin: option<bool>,
  injectFeaturedNote: bool,
  receiveAnnouncementEmail: bool,
  alwaysMarkNsfw: bool,
  autoSensitive: bool,
  carefulBot: bool,
  autoAcceptFollowed: bool,
  noCrawle: bool,
  preventAiLearning: bool,
  isExplorable: bool,
  isDeleted: bool,
  twoFactorBackupCodesStock: string,
  hideOnlineStatus: bool,
  hasUnreadSpecifiedNotes: bool,
  hasUnreadMentions: bool,
  hasUnreadAnnouncement: bool,
  unreadAnnouncements: array<Announcement.t>,
  hasUnreadAntenna: bool,
  hasUnreadChannel: bool,
  hasUnreadChatMessages: bool,
  hasUnreadNotification: bool,
  hasPendingReceivedFollowRequest: bool,
  unreadNotificationsCount: float,
  mutedWords: array<array<string>>,
  mutedInstances: option<JSON.t>,
  postingLang: option<string>,
  viewingLangs: array<string>,
  showMediaInAllLanguages: bool,
  showHashtagsInAllLanguages: bool,
  notificationRecieveConfig: meDetailedOnly_1,
  emailNotificationTypes: array<string>,
  achievements: array<meDetailedOnly_2>,
  loggedInDays: float,
  policies: RolePolicies.t,
  twoFactorEnabled: bool,
  usePasswordLessLogin: bool,
  securityKeys: bool,
  email: option<string>,
  emailVerified: option<bool>,
  securityKeysList: option<array<meDetailedOnly_3>>,
}
  let schema = S.object(s => {
    avatarId: s.field("avatarId", S.nullableAsOption(S.string)),
    bannerId: s.field("bannerId", S.nullableAsOption(S.string)),
    followedMessage: s.field("followedMessage", S.nullableAsOption(S.string)),
    isModerator: s.field("isModerator", S.nullableAsOption(S.bool)),
    isAdmin: s.field("isAdmin", S.nullableAsOption(S.bool)),
    injectFeaturedNote: s.field("injectFeaturedNote", S.bool),
    receiveAnnouncementEmail: s.field("receiveAnnouncementEmail", S.bool),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.bool),
    autoSensitive: s.field("autoSensitive", S.bool),
    carefulBot: s.field("carefulBot", S.bool),
    autoAcceptFollowed: s.field("autoAcceptFollowed", S.bool),
    noCrawle: s.field("noCrawle", S.bool),
    preventAiLearning: s.field("preventAiLearning", S.bool),
    isExplorable: s.field("isExplorable", S.bool),
    isDeleted: s.field("isDeleted", S.bool),
    twoFactorBackupCodesStock: s.field("twoFactorBackupCodesStock", S.string),
    hideOnlineStatus: s.field("hideOnlineStatus", S.bool),
    hasUnreadSpecifiedNotes: s.field("hasUnreadSpecifiedNotes", S.bool),
    hasUnreadMentions: s.field("hasUnreadMentions", S.bool),
    hasUnreadAnnouncement: s.field("hasUnreadAnnouncement", S.bool),
    unreadAnnouncements: s.field("unreadAnnouncements", S.array(Announcement.schema)),
    hasUnreadAntenna: s.field("hasUnreadAntenna", S.bool),
    hasUnreadChannel: s.field("hasUnreadChannel", S.bool),
    hasUnreadChatMessages: s.field("hasUnreadChatMessages", S.bool),
    hasUnreadNotification: s.field("hasUnreadNotification", S.bool),
    hasPendingReceivedFollowRequest: s.field("hasPendingReceivedFollowRequest", S.bool),
    unreadNotificationsCount: s.field("unreadNotificationsCount", S.float),
    mutedWords: s.field("mutedWords", S.array(S.array(S.string))),
    mutedInstances: s.field("mutedInstances", S.nullableAsOption(S.json)),
    postingLang: s.field("postingLang", S.nullableAsOption(S.string)),
    viewingLangs: s.field("viewingLangs", S.array(S.string)),
    showMediaInAllLanguages: s.field("showMediaInAllLanguages", S.bool),
    showHashtagsInAllLanguages: s.field("showHashtagsInAllLanguages", S.bool),
    notificationRecieveConfig: s.field("notificationRecieveConfig", meDetailedOnly_1Schema),
    emailNotificationTypes: s.field("emailNotificationTypes", S.array(S.string)),
    achievements: s.field("achievements", S.array(meDetailedOnly_2Schema)),
    loggedInDays: s.field("loggedInDays", S.float),
    policies: s.field("policies", RolePolicies.schema),
    twoFactorEnabled: s.field("twoFactorEnabled", S.bool),
    usePasswordLessLogin: s.field("usePasswordLessLogin", S.bool),
    securityKeys: s.field("securityKeys", S.bool),
    email: s.fieldOr("email", S.nullableAsOption(S.string), None),
    emailVerified: s.fieldOr("emailVerified", S.nullableAsOption(S.bool), None),
    securityKeysList: s.fieldOr("securityKeysList", S.nullableAsOption(S.array(meDetailedOnly_3Schema)), None),
  })
}

module RoleLite = {
  type t = {
  id: string,
  name: string,
  color: option<string>,
  iconUrl: option<string>,
  description: string,
  isModerator: bool,
  isAdministrator: bool,
  displayOrder: int,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    color: s.field("color", S.nullableAsOption(S.string)),
    iconUrl: s.field("iconUrl", S.nullableAsOption(S.string)),
    description: s.field("description", S.string),
    isModerator: s.field("isModerator", S.bool),
    isAdministrator: s.field("isAdministrator", S.bool),
    displayOrder: s.field("displayOrder", S.int),
  })
}

module PageBlock = {
  type t = dict<JSON.t>
  let schema = S.dict(S.json)
}

module Page = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: string,
  userId: string,
  user: UserLite.t,
  content: array<PageBlock.t>,
  variables: array<dict<JSON.t>>,
  title: string,
  name: string,
  summary: option<string>,
  hideTitleWhenPinned: bool,
  alignCenter: bool,
  font: string,
  script: string,
  eyeCatchingImageId: option<string>,
  eyeCatchingImage: option<DriveFile.t>,
  attachedFiles: array<DriveFile.t>,
  likedCount: float,
  isLiked: option<bool>,
  visibility: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    content: s.field("content", S.array(PageBlock.schema)),
    variables: s.field("variables", S.array(S.dict(S.json))),
    title: s.field("title", S.string),
    name: s.field("name", S.string),
    summary: s.field("summary", S.nullableAsOption(S.string)),
    hideTitleWhenPinned: s.field("hideTitleWhenPinned", S.bool),
    alignCenter: s.field("alignCenter", S.bool),
    font: s.field("font", S.string),
    script: s.field("script", S.string),
    eyeCatchingImageId: s.field("eyeCatchingImageId", S.nullableAsOption(S.string)),
    eyeCatchingImage: s.field("eyeCatchingImage", S.nullableAsOption(DriveFile.schema)),
    attachedFiles: s.field("attachedFiles", S.array(DriveFile.schema)),
    likedCount: s.field("likedCount", S.float),
    isLiked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
    visibility: s.field("visibility", S.string),
  })
}

module Note = {
  type note_3 = {
  isVoted: bool,
  text: string,
  votes: float,
}
  let note_3Schema = S.object(s => {
    isVoted: s.field("isVoted", S.bool),
    text: s.field("text", S.string),
    votes: s.field("votes", S.float),
  })
  type note_2 = {
  id: string,
  name: string,
  color: string,
  isSensitive: bool,
  allowRenoteToExternal: bool,
  userId: option<string>,
}
  let note_2Schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    color: s.field("color", S.string),
    isSensitive: s.field("isSensitive", S.bool),
    allowRenoteToExternal: s.field("allowRenoteToExternal", S.bool),
    userId: s.field("userId", S.nullableAsOption(S.string)),
  })
  type note_1 = {
  expiresAt: option<string>,
  multiple: bool,
  choices: array<note_3>,
}
  let note_1Schema = S.object(s => {
    expiresAt: s.fieldOr("expiresAt", S.nullableAsOption(S.string), None),
    multiple: s.field("multiple", S.bool),
    choices: s.field("choices", S.array(note_3Schema)),
  })
  type rec t = {
  id: string,
  createdAt: string,
  deletedAt: option<string>,
  text: option<string>,
  cw: option<string>,
  userId: string,
  user: UserLite.t,
  replyId: option<string>,
  renoteId: option<string>,
  reply: option<t>,
  renote: option<t>,
  isHidden: option<bool>,
  visibility: string,
  mentions: option<array<string>>,
  visibleUserIds: option<array<string>>,
  fileIds: option<array<string>>,
  files: option<array<DriveFile.t>>,
  tags: option<array<string>>,
  poll: option<note_1>,
  emojis: option<dict<JSON.t>>,
  channelId: option<string>,
  channel: option<note_2>,
  localOnly: option<bool>,
  dimension: option<int>,
  reactionAcceptance: option<string>,
  reactionEmojis: dict<JSON.t>,
  reactions: dict<JSON.t>,
  reactionCount: float,
  renoteCount: float,
  repliesCount: float,
  uri: option<string>,
  url: option<string>,
  reactionAndUserPairCache: option<array<string>>,
  clippedCount: option<float>,
  myReaction: option<string>,
}
  let schema = S.recursive("Note", schema => S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    deletedAt: s.fieldOr("deletedAt", S.nullableAsOption(S.string), None),
    text: s.field("text", S.nullableAsOption(S.string)),
    cw: s.fieldOr("cw", S.nullableAsOption(S.string), None),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    replyId: s.fieldOr("replyId", S.nullableAsOption(S.string), None),
    renoteId: s.fieldOr("renoteId", S.nullableAsOption(S.string), None),
    reply: s.fieldOr("reply", S.nullableAsOption(schema), None),
    renote: s.fieldOr("renote", S.nullableAsOption(schema), None),
    isHidden: s.fieldOr("isHidden", S.nullableAsOption(S.bool), None),
    visibility: s.field("visibility", S.string),
    mentions: s.fieldOr("mentions", S.nullableAsOption(S.array(S.string)), None),
    visibleUserIds: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
    fileIds: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    files: s.fieldOr("files", S.nullableAsOption(S.array(DriveFile.schema)), None),
    tags: s.fieldOr("tags", S.nullableAsOption(S.array(S.string)), None),
    poll: s.fieldOr("poll", S.nullableAsOption(note_1Schema), None),
    emojis: s.fieldOr("emojis", S.nullableAsOption(S.dict(S.json)), None),
    channelId: s.fieldOr("channelId", S.nullableAsOption(S.string), None),
    channel: s.fieldOr("channel", S.nullableAsOption(note_2Schema), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    dimension: s.fieldOr("dimension", S.nullableAsOption(S.int), None),
    reactionAcceptance: s.field("reactionAcceptance", S.nullableAsOption(S.string)),
    reactionEmojis: s.field("reactionEmojis", S.dict(S.json)),
    reactions: s.field("reactions", S.dict(S.json)),
    reactionCount: s.field("reactionCount", S.float),
    renoteCount: s.field("renoteCount", S.float),
    repliesCount: s.field("repliesCount", S.float),
    uri: s.fieldOr("uri", S.nullableAsOption(S.string), None),
    url: s.fieldOr("url", S.nullableAsOption(S.string), None),
    reactionAndUserPairCache: s.fieldOr("reactionAndUserPairCache", S.nullableAsOption(S.array(S.string)), None),
    clippedCount: s.fieldOr("clippedCount", S.nullableAsOption(S.float), None),
    myReaction: s.fieldOr("myReaction", S.nullableAsOption(S.string), None),
  }))
}

module UserDetailedNotMeOnly = {
  type userDetailedNotMeOnly_3 = {
  id: string,
  url: string,
  fileId: string,
  description: option<string>,
  imgSrc: string,
}
  let userDetailedNotMeOnly_3Schema = S.object(s => {
    id: s.field("id", S.string),
    url: s.field("url", S.string),
    fileId: s.field("fileId", S.string),
    description: s.field("description", S.nullableAsOption(S.string)),
    imgSrc: s.field("imgSrc", S.string),
  })
  type userDetailedNotMeOnly_2 = {
  name: option<string>,
  mutualLinks: array<userDetailedNotMeOnly_3>,
}
  let userDetailedNotMeOnly_2Schema = S.object(s => {
    name: s.field("name", S.nullableAsOption(S.string)),
    mutualLinks: s.field("mutualLinks", S.array(userDetailedNotMeOnly_3Schema)),
  })
  type userDetailedNotMeOnly_1 = {
  name: string,
  value: string,
}
  let userDetailedNotMeOnly_1Schema = S.object(s => {
    name: s.field("name", S.string),
    value: s.field("value", S.string),
  })
  type t = {
  url: option<string>,
  uri: option<string>,
  movedTo: option<string>,
  alsoKnownAs: option<JSON.t>,
  createdAt: string,
  updatedAt: option<string>,
  lastFetchedAt: option<string>,
  bannerUrl: option<string>,
  bannerBlurhash: option<string>,
  isLocked: bool,
  isSilenced: bool,
  isLimited: bool,
  isSuspended: bool,
  description: option<string>,
  location: option<string>,
  birthday: option<string>,
  lang: option<string>,
  fields: array<userDetailedNotMeOnly_1>,
  verifiedLinks: array<string>,
  followersCount: float,
  followingCount: float,
  notesCount: float,
  pinnedNoteIds: array<string>,
  pinnedNotes: array<Note.t>,
  pinnedPageId: option<string>,
  pinnedPage: option<Page.t>,
  publicReactions: bool,
  followingVisibility: string,
  followersVisibility: string,
  chatScope: string,
  canChat: bool,
  roles: array<RoleLite.t>,
  followedMessage: option<string>,
  memo: option<string>,
  moderationNote: option<string>,
  twoFactorEnabled: option<bool>,
  usePasswordLessLogin: option<bool>,
  securityKeys: option<bool>,
  mutualLinkSections: array<userDetailedNotMeOnly_2>,
  isFollowing: option<bool>,
  isFollowed: option<bool>,
  hasPendingFollowRequestFromYou: option<bool>,
  hasPendingFollowRequestToYou: option<bool>,
  isBlocking: option<bool>,
  isBlocked: option<bool>,
  isMuted: option<bool>,
  isRenoteMuted: option<bool>,
  notify: option<string>,
  withReplies: option<bool>,
}
  let schema = S.object(s => {
    url: s.field("url", S.nullableAsOption(S.string)),
    uri: s.field("uri", S.nullableAsOption(S.string)),
    movedTo: s.field("movedTo", S.nullableAsOption(S.string)),
    alsoKnownAs: s.field("alsoKnownAs", S.nullableAsOption(S.json)),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    lastFetchedAt: s.field("lastFetchedAt", S.nullableAsOption(S.string)),
    bannerUrl: s.field("bannerUrl", S.nullableAsOption(S.string)),
    bannerBlurhash: s.field("bannerBlurhash", S.nullableAsOption(S.string)),
    isLocked: s.field("isLocked", S.bool),
    isSilenced: s.field("isSilenced", S.bool),
    isLimited: s.field("isLimited", S.bool),
    isSuspended: s.field("isSuspended", S.bool),
    description: s.field("description", S.nullableAsOption(S.string)),
    location: s.field("location", S.nullableAsOption(S.string)),
    birthday: s.field("birthday", S.nullableAsOption(S.string)),
    lang: s.field("lang", S.nullableAsOption(S.string)),
    fields: s.field("fields", S.array(userDetailedNotMeOnly_1Schema)),
    verifiedLinks: s.field("verifiedLinks", S.array(S.string)),
    followersCount: s.field("followersCount", S.float),
    followingCount: s.field("followingCount", S.float),
    notesCount: s.field("notesCount", S.float),
    pinnedNoteIds: s.field("pinnedNoteIds", S.array(S.string)),
    pinnedNotes: s.field("pinnedNotes", S.array(Note.schema)),
    pinnedPageId: s.field("pinnedPageId", S.nullableAsOption(S.string)),
    pinnedPage: s.field("pinnedPage", S.nullableAsOption(Page.schema)),
    publicReactions: s.field("publicReactions", S.bool),
    followingVisibility: s.field("followingVisibility", S.string),
    followersVisibility: s.field("followersVisibility", S.string),
    chatScope: s.field("chatScope", S.string),
    canChat: s.field("canChat", S.bool),
    roles: s.field("roles", S.array(RoleLite.schema)),
    followedMessage: s.fieldOr("followedMessage", S.nullableAsOption(S.string), None),
    memo: s.field("memo", S.nullableAsOption(S.string)),
    moderationNote: s.fieldOr("moderationNote", S.nullableAsOption(S.string), None),
    twoFactorEnabled: s.fieldOr("twoFactorEnabled", S.nullableAsOption(S.bool), None),
    usePasswordLessLogin: s.fieldOr("usePasswordLessLogin", S.nullableAsOption(S.bool), None),
    securityKeys: s.fieldOr("securityKeys", S.nullableAsOption(S.bool), None),
    mutualLinkSections: s.field("mutualLinkSections", S.array(userDetailedNotMeOnly_2Schema)),
    isFollowing: s.fieldOr("isFollowing", S.nullableAsOption(S.bool), None),
    isFollowed: s.fieldOr("isFollowed", S.nullableAsOption(S.bool), None),
    hasPendingFollowRequestFromYou: s.fieldOr("hasPendingFollowRequestFromYou", S.nullableAsOption(S.bool), None),
    hasPendingFollowRequestToYou: s.fieldOr("hasPendingFollowRequestToYou", S.nullableAsOption(S.bool), None),
    isBlocking: s.fieldOr("isBlocking", S.nullableAsOption(S.bool), None),
    isBlocked: s.fieldOr("isBlocked", S.nullableAsOption(S.bool), None),
    isMuted: s.fieldOr("isMuted", S.nullableAsOption(S.bool), None),
    isRenoteMuted: s.fieldOr("isRenoteMuted", S.nullableAsOption(S.bool), None),
    notify: s.fieldOr("notify", S.nullableAsOption(S.string), None),
    withReplies: s.fieldOr("withReplies", S.nullableAsOption(S.bool), None),
  })
}

module MeDetailed = {
  type t = MeDetailedOnly.t
  let schema = MeDetailedOnly.schema
}

module UserDetailedNotMe = {
  type t = UserDetailedNotMeOnly.t
  let schema = UserDetailedNotMeOnly.schema
}

module UserDetailed = {
  type t = MeDetailed.t
  let schema = MeDetailed.schema
}

module ModerationLog = {
  type t = {
  id: string,
  createdAt: string,
  @as("type") type_: string,
  info: dict<JSON.t>,
  userId: string,
  user: UserDetailed.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    type_: s.field("type", S.string),
    info: s.field("info", S.dict(S.json)),
    userId: s.field("userId", S.string),
    user: s.field("user", UserDetailed.schema),
  })
}

module AbuseUserReport = {
  type t = {
  id: string,
  category: string,
  createdAt: string,
  comment: string,
  resolved: bool,
  reporterId: string,
  reporter: UserDetailed.t,
  targetUserId: string,
  targetUser: UserDetailed.t,
  assigneeId: option<string>,
  assignee: option<UserDetailed.t>,
  forwarded: bool,
  moderationNote: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    category: s.field("category", S.string),
    createdAt: s.field("createdAt", S.string),
    comment: s.field("comment", S.string),
    resolved: s.field("resolved", S.bool),
    reporterId: s.field("reporterId", S.string),
    reporter: s.field("reporter", UserDetailed.schema),
    targetUserId: s.field("targetUserId", S.string),
    targetUser: s.field("targetUser", UserDetailed.schema),
    assigneeId: s.field("assigneeId", S.nullableAsOption(S.string)),
    assignee: s.fieldOr("assignee", S.nullableAsOption(UserDetailed.schema), None),
    forwarded: s.field("forwarded", S.bool),
    moderationNote: s.field("moderationNote", S.string),
  })
}

module MetaDetailedOnly = {
  type metaDetailedOnly_1 = {
  registration: bool,
  emailRequiredForSignup: bool,
  localTimeline: bool,
  globalTimeline: bool,
  hCaptcha: bool,
  hcaptcha: bool,
  mCaptcha: bool,
  mcaptcha: bool,
  reCaptcha: bool,
  recaptcha: bool,
  turnstile: bool,
  objectStorage: bool,
  serviceWorker: bool,
  miauth: option<bool>,
}
  let metaDetailedOnly_1Schema = S.object(s => {
    registration: s.field("registration", S.bool),
    emailRequiredForSignup: s.field("emailRequiredForSignup", S.bool),
    localTimeline: s.field("localTimeline", S.bool),
    globalTimeline: s.field("globalTimeline", S.bool),
    hCaptcha: s.field("hCaptcha", S.bool),
    hcaptcha: s.field("hcaptcha", S.bool),
    mCaptcha: s.field("mCaptcha", S.bool),
    mcaptcha: s.field("mcaptcha", S.bool),
    reCaptcha: s.field("reCaptcha", S.bool),
    recaptcha: s.field("recaptcha", S.bool),
    turnstile: s.field("turnstile", S.bool),
    objectStorage: s.field("objectStorage", S.bool),
    serviceWorker: s.field("serviceWorker", S.bool),
    miauth: s.fieldOr("miauth", S.nullableAsOption(S.bool), None),
  })
  type t = {
  features: option<metaDetailedOnly_1>,
  proxyAccountName: option<string>,
  requireSetup: bool,
  cacheRemoteFiles: bool,
  cacheRemoteSensitiveFiles: bool,
}
  let schema = S.object(s => {
    features: s.fieldOr("features", S.nullableAsOption(metaDetailedOnly_1Schema), None),
    proxyAccountName: s.field("proxyAccountName", S.nullableAsOption(S.string)),
    requireSetup: s.field("requireSetup", S.bool),
    cacheRemoteFiles: s.field("cacheRemoteFiles", S.bool),
    cacheRemoteSensitiveFiles: s.field("cacheRemoteSensitiveFiles", S.bool),
  })
}

module MetaLite = {
  type metaLite_3 = {
  dsn: string,
}
  let metaLite_3Schema = S.object(s => {
    dsn: s.field("dsn", S.string),
  })
  type metaLite_2 = {
  options: metaLite_3,
  vueIntegration: option<dict<JSON.t>>,
  browserTracingIntegration: option<dict<JSON.t>>,
  replayIntegration: option<dict<JSON.t>>,
}
  let metaLite_2Schema = S.object(s => {
    options: s.field("options", metaLite_3Schema),
    vueIntegration: s.fieldOr("vueIntegration", S.nullableAsOption(S.dict(S.json)), None),
    browserTracingIntegration: s.fieldOr("browserTracingIntegration", S.nullableAsOption(S.dict(S.json)), None),
    replayIntegration: s.fieldOr("replayIntegration", S.nullableAsOption(S.dict(S.json)), None),
  })
  type metaLite_1 = {
  id: string,
  url: string,
  place: string,
  ratio: float,
  imageUrl: string,
  imageBlurhash: option<string>,
  dayOfWeek: int,
  isSensitive: bool,
}
  let metaLite_1Schema = S.object(s => {
    id: s.field("id", S.string),
    url: s.field("url", S.string),
    place: s.field("place", S.string),
    ratio: s.field("ratio", S.float),
    imageUrl: s.field("imageUrl", S.string),
    imageBlurhash: s.field("imageBlurhash", S.nullableAsOption(S.string)),
    dayOfWeek: s.field("dayOfWeek", S.int),
    isSensitive: s.field("isSensitive", S.bool),
  })
  type t = {
  maintainerName: option<string>,
  maintainerEmail: option<string>,
  version: string,
  name: option<string>,
  shortName: option<string>,
  uri: string,
  description: option<string>,
  langs: array<string>,
  dimensions: float,
  tosUrl: option<string>,
  repositoryUrl: option<string>,
  feedbackUrl: option<string>,
  defaultDarkTheme: option<string>,
  defaultLightTheme: option<string>,
  disableRegistration: bool,
  emailRequiredForSignup: bool,
  enableHcaptcha: bool,
  hcaptchaSiteKey: option<string>,
  enableMcaptcha: bool,
  mcaptchaSiteKey: option<string>,
  mcaptchaInstanceUrl: option<string>,
  enableRecaptcha: bool,
  recaptchaSiteKey: option<string>,
  enableTurnstile: bool,
  turnstileSiteKey: option<string>,
  googleAnalyticsId: option<string>,
  enableTestcaptcha: bool,
  swPublickey: option<string>,
  mascotImageUrl: string,
  bannerUrl: option<string>,
  serverErrorImageUrl: option<string>,
  infoImageUrl: option<string>,
  notFoundImageUrl: option<string>,
  iconUrl: option<string>,
  maxNoteTextLength: float,
  ads: array<metaLite_1>,
  wellKnownWebsites: array<string>,
  notesPerOneAd: float,
  enableEmail: bool,
  enableServiceWorker: bool,
  translatorAvailable: bool,
  sentryForFrontend: option<metaLite_2>,
  mediaProxy: string,
  enableUrlPreview: bool,
  enableSkebStatus: bool,
  backgroundImageUrl: option<string>,
  impressumUrl: option<string>,
  logoImageUrl: option<string>,
  privacyPolicyUrl: option<string>,
  inquiryUrl: option<string>,
  serverRules: array<string>,
  themeColor: option<string>,
  policies: RolePolicies.t,
  noteSearchableScope: string,
  maxFileSize: float,
  federation: string,
}
  let schema = S.object(s => {
    maintainerName: s.field("maintainerName", S.nullableAsOption(S.string)),
    maintainerEmail: s.field("maintainerEmail", S.nullableAsOption(S.string)),
    version: s.field("version", S.string),
    name: s.field("name", S.nullableAsOption(S.string)),
    shortName: s.field("shortName", S.nullableAsOption(S.string)),
    uri: s.field("uri", S.string),
    description: s.field("description", S.nullableAsOption(S.string)),
    langs: s.field("langs", S.array(S.string)),
    dimensions: s.field("dimensions", S.float->S.min(1)),
    tosUrl: s.field("tosUrl", S.nullableAsOption(S.string)),
    repositoryUrl: s.field("repositoryUrl", S.nullableAsOption(S.string)),
    feedbackUrl: s.field("feedbackUrl", S.nullableAsOption(S.string)),
    defaultDarkTheme: s.field("defaultDarkTheme", S.nullableAsOption(S.string)),
    defaultLightTheme: s.field("defaultLightTheme", S.nullableAsOption(S.string)),
    disableRegistration: s.field("disableRegistration", S.bool),
    emailRequiredForSignup: s.field("emailRequiredForSignup", S.bool),
    enableHcaptcha: s.field("enableHcaptcha", S.bool),
    hcaptchaSiteKey: s.field("hcaptchaSiteKey", S.nullableAsOption(S.string)),
    enableMcaptcha: s.field("enableMcaptcha", S.bool),
    mcaptchaSiteKey: s.field("mcaptchaSiteKey", S.nullableAsOption(S.string)),
    mcaptchaInstanceUrl: s.field("mcaptchaInstanceUrl", S.nullableAsOption(S.string)),
    enableRecaptcha: s.field("enableRecaptcha", S.bool),
    recaptchaSiteKey: s.field("recaptchaSiteKey", S.nullableAsOption(S.string)),
    enableTurnstile: s.field("enableTurnstile", S.bool),
    turnstileSiteKey: s.field("turnstileSiteKey", S.nullableAsOption(S.string)),
    googleAnalyticsId: s.field("googleAnalyticsId", S.nullableAsOption(S.string)),
    enableTestcaptcha: s.field("enableTestcaptcha", S.bool),
    swPublickey: s.field("swPublickey", S.nullableAsOption(S.string)),
    mascotImageUrl: s.field("mascotImageUrl", S.string),
    bannerUrl: s.field("bannerUrl", S.nullableAsOption(S.string)),
    serverErrorImageUrl: s.field("serverErrorImageUrl", S.nullableAsOption(S.string)),
    infoImageUrl: s.field("infoImageUrl", S.nullableAsOption(S.string)),
    notFoundImageUrl: s.field("notFoundImageUrl", S.nullableAsOption(S.string)),
    iconUrl: s.field("iconUrl", S.nullableAsOption(S.string)),
    maxNoteTextLength: s.field("maxNoteTextLength", S.float),
    ads: s.field("ads", S.array(metaLite_1Schema)),
    wellKnownWebsites: s.field("wellKnownWebsites", S.array(S.string)),
    notesPerOneAd: s.field("notesPerOneAd", S.float),
    enableEmail: s.field("enableEmail", S.bool),
    enableServiceWorker: s.field("enableServiceWorker", S.bool),
    translatorAvailable: s.field("translatorAvailable", S.bool),
    sentryForFrontend: s.field("sentryForFrontend", S.nullableAsOption(metaLite_2Schema)),
    mediaProxy: s.field("mediaProxy", S.string),
    enableUrlPreview: s.field("enableUrlPreview", S.bool),
    enableSkebStatus: s.field("enableSkebStatus", S.bool),
    backgroundImageUrl: s.field("backgroundImageUrl", S.nullableAsOption(S.string)),
    impressumUrl: s.field("impressumUrl", S.nullableAsOption(S.string)),
    logoImageUrl: s.field("logoImageUrl", S.nullableAsOption(S.string)),
    privacyPolicyUrl: s.field("privacyPolicyUrl", S.nullableAsOption(S.string)),
    inquiryUrl: s.field("inquiryUrl", S.nullableAsOption(S.string)),
    serverRules: s.field("serverRules", S.array(S.string)),
    themeColor: s.field("themeColor", S.nullableAsOption(S.string)),
    policies: s.field("policies", RolePolicies.schema),
    noteSearchableScope: s.field("noteSearchableScope", S.string),
    maxFileSize: s.field("maxFileSize", S.float),
    federation: s.field("federation", S.string),
  })
}

module MetaDetailed = {
  type t = MetaDetailedOnly.t
  let schema = MetaDetailedOnly.schema
}

module ReversiGameDetailed = {
  type t = {
  id: string,
  createdAt: string,
  startedAt: option<string>,
  endedAt: option<string>,
  isStarted: bool,
  isEnded: bool,
  form1: option<dict<JSON.t>>,
  form2: option<dict<JSON.t>>,
  @as("user1Ready") user1ready: bool,
  @as("user2Ready") user2ready: bool,
  @as("user1Id") user1id: string,
  @as("user2Id") user2id: string,
  user1: UserLite.t,
  user2: UserLite.t,
  winnerId: option<string>,
  winner: option<UserLite.t>,
  surrenderedUserId: option<string>,
  timeoutUserId: option<string>,
  black: option<float>,
  bw: string,
  noIrregularRules: bool,
  isLlotheo: bool,
  canPutEverywhere: bool,
  loopedBoard: bool,
  timeLimitForEachTurn: float,
  logs: array<array<float>>,
  map: array<string>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    startedAt: s.field("startedAt", S.nullableAsOption(S.string)),
    endedAt: s.field("endedAt", S.nullableAsOption(S.string)),
    isStarted: s.field("isStarted", S.bool),
    isEnded: s.field("isEnded", S.bool),
    form1: s.field("form1", S.nullableAsOption(S.dict(S.json))),
    form2: s.field("form2", S.nullableAsOption(S.dict(S.json))),
    user1ready: s.field("user1Ready", S.bool),
    user2ready: s.field("user2Ready", S.bool),
    user1id: s.field("user1Id", S.string),
    user2id: s.field("user2Id", S.string),
    user1: s.field("user1", UserLite.schema),
    user2: s.field("user2", UserLite.schema),
    winnerId: s.field("winnerId", S.nullableAsOption(S.string)),
    winner: s.field("winner", S.nullableAsOption(UserLite.schema)),
    surrenderedUserId: s.field("surrenderedUserId", S.nullableAsOption(S.string)),
    timeoutUserId: s.field("timeoutUserId", S.nullableAsOption(S.string)),
    black: s.field("black", S.nullableAsOption(S.float)),
    bw: s.field("bw", S.string),
    noIrregularRules: s.field("noIrregularRules", S.bool),
    isLlotheo: s.field("isLlotheo", S.bool),
    canPutEverywhere: s.field("canPutEverywhere", S.bool),
    loopedBoard: s.field("loopedBoard", S.bool),
    timeLimitForEachTurn: s.field("timeLimitForEachTurn", S.float),
    logs: s.field("logs", S.array(S.array(S.float))),
    map: s.field("map", S.array(S.string)),
  })
}

module ReversiGameLite = {
  type t = {
  id: string,
  createdAt: string,
  startedAt: option<string>,
  endedAt: option<string>,
  isStarted: bool,
  isEnded: bool,
  @as("user1Id") user1id: string,
  @as("user2Id") user2id: string,
  user1: UserLite.t,
  user2: UserLite.t,
  winnerId: option<string>,
  winner: option<UserLite.t>,
  surrenderedUserId: option<string>,
  timeoutUserId: option<string>,
  black: option<float>,
  bw: string,
  noIrregularRules: bool,
  isLlotheo: bool,
  canPutEverywhere: bool,
  loopedBoard: bool,
  timeLimitForEachTurn: float,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    startedAt: s.field("startedAt", S.nullableAsOption(S.string)),
    endedAt: s.field("endedAt", S.nullableAsOption(S.string)),
    isStarted: s.field("isStarted", S.bool),
    isEnded: s.field("isEnded", S.bool),
    user1id: s.field("user1Id", S.string),
    user2id: s.field("user2Id", S.string),
    user1: s.field("user1", UserLite.schema),
    user2: s.field("user2", UserLite.schema),
    winnerId: s.field("winnerId", S.nullableAsOption(S.string)),
    winner: s.field("winner", S.nullableAsOption(UserLite.schema)),
    surrenderedUserId: s.field("surrenderedUserId", S.nullableAsOption(S.string)),
    timeoutUserId: s.field("timeoutUserId", S.nullableAsOption(S.string)),
    black: s.field("black", S.nullableAsOption(S.float)),
    bw: s.field("bw", S.string),
    noIrregularRules: s.field("noIrregularRules", S.bool),
    isLlotheo: s.field("isLlotheo", S.bool),
    canPutEverywhere: s.field("canPutEverywhere", S.bool),
    loopedBoard: s.field("loopedBoard", S.bool),
    timeLimitForEachTurn: s.field("timeLimitForEachTurn", S.float),
  })
}

module RoleCondFormulaValue = {
  type t = dict<JSON.t>
  let schema = S.dict(S.json)
}

module Role = {
  type t = {
  createdAt: string,
  updatedAt: string,
  target: string,
  condFormula: RoleCondFormulaValue.t,
  isPublic: bool,
  isExplorable: bool,
  asBadge: bool,
  preserveAssignmentOnMoveAccount: bool,
  badgeBehavior: option<string>,
  canEditMembersByModerator: bool,
  policies: dict<JSON.t>,
  usersCount: int,
}
  let schema = S.object(s => {
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    target: s.field("target", S.string),
    condFormula: s.field("condFormula", RoleCondFormulaValue.schema),
    isPublic: s.field("isPublic", S.bool),
    isExplorable: s.field("isExplorable", S.bool),
    asBadge: s.field("asBadge", S.bool),
    preserveAssignmentOnMoveAccount: s.field("preserveAssignmentOnMoveAccount", S.bool),
    badgeBehavior: s.field("badgeBehavior", S.nullableAsOption(S.string)),
    canEditMembersByModerator: s.field("canEditMembersByModerator", S.bool),
    policies: s.field("policies", S.dict(S.json)),
    usersCount: s.field("usersCount", S.int),
  })
}

module RoleCondFormulaFollowersOrFollowingOrNotes = {
  type t = {
  id: string,
  @as("type") type_: string,
  value: float,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    value: s.field("value", S.float),
  })
}

module RoleCondFormulaValueCreated = {
  type t = {
  id: string,
  @as("type") type_: string,
  sec: float,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    sec: s.field("sec", S.float),
  })
}

module RoleCondFormulaValueAssignedRole = {
  type t = {
  id: string,
  @as("type") type_: string,
  roleId: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    roleId: s.field("roleId", S.string),
  })
}

module RoleCondFormulaValueUserSettingBooleanSchema = {
  type t = {
  id: string,
  @as("type") type_: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
  })
}

module RoleCondFormulaValueIsLocalOrRemote = {
  type t = {
  id: string,
  @as("type") type_: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
  })
}

module RoleCondFormulaValueNot = {
  type t = {
  id: string,
  @as("type") type_: string,
  value: RoleCondFormulaValue.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    value: s.field("value", RoleCondFormulaValue.schema),
  })
}

module RoleCondFormulaLogics = {
  type t = {
  id: string,
  @as("type") type_: string,
  values: array<RoleCondFormulaValue.t>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    type_: s.field("type", S.string),
    values: s.field("values", S.array(RoleCondFormulaValue.schema)),
  })
}

module Signin = {
  type t = {
  id: string,
  createdAt: string,
  ip: string,
  headers: dict<JSON.t>,
  success: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    ip: s.field("ip", S.string),
    headers: s.field("headers", S.dict(S.json)),
    success: s.field("success", S.bool),
  })
}

module Flash = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: string,
  userId: string,
  user: UserLite.t,
  title: string,
  summary: string,
  script: string,
  visibility: string,
  likedCount: option<float>,
  isLiked: option<bool>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    title: s.field("title", S.string),
    summary: s.field("summary", S.string),
    script: s.field("script", S.string),
    visibility: s.field("visibility", S.string),
    likedCount: s.field("likedCount", S.nullableAsOption(S.float)),
    isLiked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
  })
}

module FlashLike = {
  type t = {
  id: string,
  flash: Flash.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    flash: s.field("flash", Flash.schema),
  })
}

module EmojiDetailedAdmin = {
  type emojiDetailedAdmin_1 = {
  id: string,
  name: string,
}
  let emojiDetailedAdmin_1Schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
  })
  type t = {
  id: string,
  updatedAt: option<string>,
  name: string,
  host: option<string>,
  publicUrl: string,
  originalUrl: string,
  uri: option<string>,
  @as("type") type_: option<string>,
  aliases: array<string>,
  category: option<string>,
  license: option<string>,
  localOnly: bool,
  isSensitive: bool,
  roleIdsThatCanBeUsedThisEmojiAsReaction: array<emojiDetailedAdmin_1>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    name: s.field("name", S.string),
    host: s.field("host", S.nullableAsOption(S.string)),
    publicUrl: s.field("publicUrl", S.string),
    originalUrl: s.field("originalUrl", S.string),
    uri: s.field("uri", S.nullableAsOption(S.string)),
    type_: s.field("type", S.nullableAsOption(S.string)),
    aliases: s.field("aliases", S.array(S.string)),
    category: s.field("category", S.nullableAsOption(S.string)),
    license: s.field("license", S.nullableAsOption(S.string)),
    localOnly: s.field("localOnly", S.bool),
    isSensitive: s.field("isSensitive", S.bool),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.field("roleIdsThatCanBeUsedThisEmojiAsReaction", S.array(emojiDetailedAdmin_1Schema)),
  })
}

module EmojiDetailed = {
  type t = {
  id: string,
  createdAt: option<string>,
  updatedAt: option<string>,
  aliases: array<string>,
  name: string,
  category: option<string>,
  host: option<string>,
  url: string,
  license: option<string>,
  isSensitive: bool,
  localOnly: bool,
  requestedBy: option<string>,
  memo: option<string>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
  roleIdsThatCanNotBeUsedThisEmojiAsReaction: option<array<string>>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.fieldOr("createdAt", S.nullableAsOption(S.string), None),
    updatedAt: s.fieldOr("updatedAt", S.nullableAsOption(S.string), None),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.nullableAsOption(S.string)),
    host: s.field("host", S.nullableAsOption(S.string)),
    url: s.field("url", S.string),
    license: s.field("license", S.nullableAsOption(S.string)),
    isSensitive: s.field("isSensitive", S.bool),
    localOnly: s.field("localOnly", S.bool),
    requestedBy: s.fieldOr("requestedBy", S.nullableAsOption(S.string), None),
    memo: s.fieldOr("memo", S.nullableAsOption(S.string), None),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
    roleIdsThatCanNotBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanNotBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
  })
}

module EmojiSimple = {
  type t = {
  aliases: array<string>,
  name: string,
  category: option<string>,
  url: string,
  localOnly: option<bool>,
  isSensitive: option<bool>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
  roleIdsThatCanNotBeUsedThisEmojiAsReaction: option<array<string>>,
}
  let schema = S.object(s => {
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.nullableAsOption(S.string)),
    url: s.field("url", S.string),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    isSensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
    roleIdsThatCanNotBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanNotBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
  })
}

module GalleryPost = {
  type t = {
  id: string,
  createdAt: string,
  updatedAt: string,
  userId: string,
  user: UserLite.t,
  title: string,
  description: option<string>,
  fileIds: option<array<string>>,
  files: option<array<DriveFile.t>>,
  tags: option<array<string>>,
  isSensitive: bool,
  likedCount: float,
  isLiked: option<bool>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    title: s.field("title", S.string),
    description: s.field("description", S.nullableAsOption(S.string)),
    fileIds: s.fieldOr("fileIds", S.nullableAsOption(S.array(S.string)), None),
    files: s.fieldOr("files", S.nullableAsOption(S.array(DriveFile.schema)), None),
    tags: s.fieldOr("tags", S.nullableAsOption(S.array(S.string)), None),
    isSensitive: s.field("isSensitive", S.bool),
    likedCount: s.field("likedCount", S.float),
    isLiked: s.fieldOr("isLiked", S.nullableAsOption(S.bool), None),
  })
}

module GalleryLike = {
  type t = {
  id: string,
  post: GalleryPost.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    post: s.field("post", GalleryPost.schema),
  })
}

module FederationInstance = {
  type t = {
  id: string,
  firstRetrievedAt: string,
  host: string,
  usersCount: float,
  notesCount: float,
  followingCount: float,
  followersCount: float,
  isNotResponding: bool,
  isSuspended: bool,
  suspensionState: string,
  isBlocked: bool,
  softwareName: option<string>,
  softwareVersion: option<string>,
  openRegistrations: option<bool>,
  name: option<string>,
  description: option<string>,
  maintainerName: option<string>,
  maintainerEmail: option<string>,
  isSilenced: bool,
  isSensitiveMedia: bool,
  iconUrl: option<string>,
  faviconUrl: option<string>,
  themeColor: option<string>,
  infoUpdatedAt: option<string>,
  latestRequestReceivedAt: option<string>,
  moderationNote: option<string>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    firstRetrievedAt: s.field("firstRetrievedAt", S.string),
    host: s.field("host", S.string),
    usersCount: s.field("usersCount", S.float),
    notesCount: s.field("notesCount", S.float),
    followingCount: s.field("followingCount", S.float),
    followersCount: s.field("followersCount", S.float),
    isNotResponding: s.field("isNotResponding", S.bool),
    isSuspended: s.field("isSuspended", S.bool),
    suspensionState: s.field("suspensionState", S.string),
    isBlocked: s.field("isBlocked", S.bool),
    softwareName: s.field("softwareName", S.nullableAsOption(S.string)),
    softwareVersion: s.field("softwareVersion", S.nullableAsOption(S.string)),
    openRegistrations: s.field("openRegistrations", S.nullableAsOption(S.bool)),
    name: s.field("name", S.nullableAsOption(S.string)),
    description: s.field("description", S.nullableAsOption(S.string)),
    maintainerName: s.field("maintainerName", S.nullableAsOption(S.string)),
    maintainerEmail: s.field("maintainerEmail", S.nullableAsOption(S.string)),
    isSilenced: s.field("isSilenced", S.bool),
    isSensitiveMedia: s.field("isSensitiveMedia", S.bool),
    iconUrl: s.field("iconUrl", S.nullableAsOption(S.string)),
    faviconUrl: s.field("faviconUrl", S.nullableAsOption(S.string)),
    themeColor: s.field("themeColor", S.nullableAsOption(S.string)),
    infoUpdatedAt: s.field("infoUpdatedAt", S.nullableAsOption(S.string)),
    latestRequestReceivedAt: s.field("latestRequestReceivedAt", S.nullableAsOption(S.string)),
    moderationNote: s.fieldOr("moderationNote", S.nullableAsOption(S.string), None),
  })
}

module Clip = {
  type t = {
  id: string,
  createdAt: string,
  lastClippedAt: option<string>,
  userId: string,
  user: UserLite.t,
  name: string,
  description: option<string>,
  isPublic: bool,
  favoritedCount: float,
  isFavorited: option<bool>,
  notesCount: option<int>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    lastClippedAt: s.field("lastClippedAt", S.nullableAsOption(S.string)),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    name: s.field("name", S.string),
    description: s.field("description", S.nullableAsOption(S.string)),
    isPublic: s.field("isPublic", S.bool),
    favoritedCount: s.field("favoritedCount", S.float),
    isFavorited: s.fieldOr("isFavorited", S.nullableAsOption(S.bool), None),
    notesCount: s.fieldOr("notesCount", S.nullableAsOption(S.int), None),
  })
}

module Antenna = {
  type t = {
  id: string,
  createdAt: string,
  name: string,
  keywords: array<array<string>>,
  excludeKeywords: array<array<string>>,
  src: string,
  userListId: option<string>,
  users: array<string>,
  caseSensitive: bool,
  localOnly: bool,
  excludeBots: bool,
  withReplies: bool,
  withFile: bool,
  isActive: bool,
  hasUnreadNote: bool,
  notify: bool,
  excludeNotesInSensitiveChannel: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    keywords: s.field("keywords", S.array(S.array(S.string))),
    excludeKeywords: s.field("excludeKeywords", S.array(S.array(S.string))),
    src: s.field("src", S.string),
    userListId: s.field("userListId", S.nullableAsOption(S.string)),
    users: s.field("users", S.array(S.string)),
    caseSensitive: s.field("caseSensitive", S.bool),
    localOnly: s.field("localOnly", S.bool),
    excludeBots: s.field("excludeBots", S.bool),
    withReplies: s.field("withReplies", S.bool),
    withFile: s.field("withFile", S.bool),
    isActive: s.field("isActive", S.bool),
    hasUnreadNote: s.field("hasUnreadNote", S.bool),
    notify: s.field("notify", S.bool),
    excludeNotesInSensitiveChannel: s.field("excludeNotesInSensitiveChannel", S.bool),
  })
}

module QueueCount = {
  type t = {
  waiting: float,
  active: float,
  completed: float,
  failed: float,
  delayed: float,
}
  let schema = S.object(s => {
    waiting: s.field("waiting", S.float),
    active: s.field("active", S.float),
    completed: s.field("completed", S.float),
    failed: s.field("failed", S.float),
    delayed: s.field("delayed", S.float),
  })
}

module Channel = {
  type t = {
  id: string,
  createdAt: string,
  lastNotedAt: option<string>,
  name: string,
  description: option<string>,
  userId: option<string>,
  bannerUrl: option<string>,
  pinnedNoteIds: array<string>,
  color: string,
  isArchived: bool,
  usersCount: float,
  notesCount: float,
  isSensitive: bool,
  allowRenoteToExternal: bool,
  isFollowing: option<bool>,
  isFavorited: option<bool>,
  pinnedNotes: option<array<Note.t>>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    lastNotedAt: s.field("lastNotedAt", S.nullableAsOption(S.string)),
    name: s.field("name", S.string),
    description: s.field("description", S.nullableAsOption(S.string)),
    userId: s.field("userId", S.nullableAsOption(S.string)),
    bannerUrl: s.field("bannerUrl", S.nullableAsOption(S.string)),
    pinnedNoteIds: s.field("pinnedNoteIds", S.array(S.string)),
    color: s.field("color", S.string),
    isArchived: s.field("isArchived", S.bool),
    usersCount: s.field("usersCount", S.float),
    notesCount: s.field("notesCount", S.float),
    isSensitive: s.field("isSensitive", S.bool),
    allowRenoteToExternal: s.field("allowRenoteToExternal", S.bool),
    isFollowing: s.fieldOr("isFollowing", S.nullableAsOption(S.bool), None),
    isFavorited: s.fieldOr("isFavorited", S.nullableAsOption(S.bool), None),
    pinnedNotes: s.fieldOr("pinnedNotes", S.nullableAsOption(S.array(Note.schema)), None),
  })
}

module PageLike = {
  type t = {
  id: string,
  page: Page.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    page: s.field("page", Page.schema),
  })
}

module InviteCode = {
  type t = {
  id: string,
  code: string,
  expiresAt: option<string>,
  createdAt: string,
  createdBy: option<UserLite.t>,
  usedBy: option<UserLite.t>,
  usedAt: option<string>,
  used: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    code: s.field("code", S.string),
    expiresAt: s.field("expiresAt", S.nullableAsOption(S.string)),
    createdAt: s.field("createdAt", S.string),
    createdBy: s.field("createdBy", S.nullableAsOption(UserLite.schema)),
    usedBy: s.field("usedBy", S.nullableAsOption(UserLite.schema)),
    usedAt: s.field("usedAt", S.nullableAsOption(S.string)),
    used: s.field("used", S.bool),
  })
}

module Hashtag = {
  type t = {
  tag: string,
  mentionedUsersCount: float,
  mentionedLocalUsersCount: float,
  mentionedRemoteUsersCount: float,
  attachedUsersCount: float,
  attachedLocalUsersCount: float,
  attachedRemoteUsersCount: float,
}
  let schema = S.object(s => {
    tag: s.field("tag", S.string),
    mentionedUsersCount: s.field("mentionedUsersCount", S.float),
    mentionedLocalUsersCount: s.field("mentionedLocalUsersCount", S.float),
    mentionedRemoteUsersCount: s.field("mentionedRemoteUsersCount", S.float),
    attachedUsersCount: s.field("attachedUsersCount", S.float),
    attachedLocalUsersCount: s.field("attachedLocalUsersCount", S.float),
    attachedRemoteUsersCount: s.field("attachedRemoteUsersCount", S.float),
  })
}

module Blocking = {
  type t = {
  id: string,
  createdAt: string,
  blockeeId: string,
  blockee: UserDetailedNotMe.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    blockeeId: s.field("blockeeId", S.string),
    blockee: s.field("blockee", UserDetailedNotMe.schema),
  })
}

module RenoteMuting = {
  type t = {
  id: string,
  createdAt: string,
  muteeId: string,
  mutee: UserDetailedNotMe.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    muteeId: s.field("muteeId", S.string),
    mutee: s.field("mutee", UserDetailedNotMe.schema),
  })
}

module Muting = {
  type t = {
  id: string,
  createdAt: string,
  expiresAt: option<string>,
  muteeId: string,
  mutee: UserDetailedNotMe.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    expiresAt: s.field("expiresAt", S.nullableAsOption(S.string)),
    muteeId: s.field("muteeId", S.string),
    mutee: s.field("mutee", UserDetailedNotMe.schema),
  })
}

module FollowRequest = {
  type t = {
  id: string,
  follower: UserLite.t,
  followee: UserLite.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    follower: s.field("follower", UserLite.schema),
    followee: s.field("followee", UserLite.schema),
  })
}

module Following = {
  type t = {
  id: string,
  createdAt: string,
  followeeId: string,
  followerId: string,
  followee: option<dict<JSON.t>>,
  follower: option<dict<JSON.t>>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    followeeId: s.field("followeeId", S.string),
    followerId: s.field("followerId", S.string),
    followee: s.fieldOr("followee", S.nullableAsOption(S.dict(S.json)), None),
    follower: s.fieldOr("follower", S.nullableAsOption(S.dict(S.json)), None),
  })
}

module Notification = {
  type t = dict<JSON.t>
  let schema = S.dict(S.json)
}

module NoteFavorite = {
  type t = {
  id: string,
  createdAt: string,
  note: Note.t,
  noteId: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    note: s.field("note", Note.schema),
    noteId: s.field("noteId", S.string),
  })
}

module NoteReaction = {
  type t = {
  id: string,
  createdAt: string,
  user: UserLite.t,
  @as("type") type_: string,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    user: s.field("user", UserLite.schema),
    type_: s.field("type", S.string),
  })
}

module NoteDraft = {
  type noteDraft_5 = {
  choices: array<string>,
  multiple: bool,
  expiresAt: option<int>,
  expiredAfter: option<int>,
}
  let noteDraft_5Schema = S.object(s => {
    choices: s.field("choices", S.array(S.string)),
    multiple: s.field("multiple", S.bool),
    expiresAt: s.field("expiresAt", S.nullableAsOption(S.int)),
    expiredAfter: s.field("expiredAfter", S.nullableAsOption(S.int->S.min(1))),
  })
  type noteDraft_4 = {
  id: string,
  username: string,
  host: option<string>,
}
  let noteDraft_4Schema = S.object(s => {
    id: s.field("id", S.string),
    username: s.field("username", S.string),
    host: s.field("host", S.nullableAsOption(S.string)),
  })
  type noteDraft_3 = {
  text: option<string>,
  useCw: bool,
  cw: option<string>,
  visibility: string,
  localOnly: bool,
  lang: option<string>,
  dimension: option<int>,
  files: array<DriveFile.t>,
  poll: option<noteDraft_5>,
  visibleUserIds: option<array<string>>,
}
  let noteDraft_3Schema = S.object(s => {
    text: s.field("text", S.nullableAsOption(S.string)),
    useCw: s.field("useCw", S.bool),
    cw: s.field("cw", S.nullableAsOption(S.string)),
    visibility: s.field("visibility", S.string),
    localOnly: s.field("localOnly", S.bool),
    lang: s.fieldOr("lang", S.nullableAsOption(S.string), None),
    dimension: s.fieldOr("dimension", S.nullableAsOption(S.int), None),
    files: s.field("files", S.array(DriveFile.schema)),
    poll: s.field("poll", S.nullableAsOption(noteDraft_5Schema)),
    visibleUserIds: s.fieldOr("visibleUserIds", S.nullableAsOption(S.array(S.string)), None),
  })
  type noteDraft_2 = {
  id: string,
  text: option<string>,
  user: noteDraft_4,
}
  let noteDraft_2Schema = S.object(s => {
    id: s.field("id", S.string),
    text: s.field("text", S.nullableAsOption(S.string)),
    user: s.field("user", noteDraft_4Schema),
  })
  type noteDraft_1 = {
  id: string,
  name: string,
}
  let noteDraft_1Schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
  })
  type t = {
  id: string,
  updatedAt: string,
  scheduledAt: option<string>,
  reason: option<string>,
  channel: option<noteDraft_1>,
  renote: option<noteDraft_2>,
  reply: option<noteDraft_2>,
  data: noteDraft_3,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    updatedAt: s.field("updatedAt", S.string),
    scheduledAt: s.field("scheduledAt", S.nullableAsOption(S.string)),
    reason: s.fieldOr("reason", S.nullableAsOption(S.string), None),
    channel: s.fieldOr("channel", S.nullableAsOption(noteDraft_1Schema), None),
    renote: s.fieldOr("renote", S.nullableAsOption(noteDraft_2Schema), None),
    reply: s.fieldOr("reply", S.nullableAsOption(noteDraft_2Schema), None),
    data: s.field("data", noteDraft_3Schema),
  })
}

module App = {
  type t = {
  id: string,
  name: string,
  callbackUrl: option<string>,
  permission: array<string>,
  secret: option<string>,
  isAuthorized: option<bool>,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.string),
    callbackUrl: s.field("callbackUrl", S.nullableAsOption(S.string)),
    permission: s.field("permission", S.array(S.string)),
    secret: s.fieldOr("secret", S.nullableAsOption(S.string), None),
    isAuthorized: s.fieldOr("isAuthorized", S.nullableAsOption(S.bool), None),
  })
}

module Ad = {
  type t = {
  id: string,
  expiresAt: string,
  startsAt: string,
  place: string,
  priority: string,
  ratio: float,
  url: string,
  imageUrl: string,
  imageBlurhash: option<string>,
  memo: string,
  dayOfWeek: int,
  isSensitive: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    expiresAt: s.field("expiresAt", S.string),
    startsAt: s.field("startsAt", S.string),
    place: s.field("place", S.string),
    priority: s.field("priority", S.string),
    ratio: s.field("ratio", S.float),
    url: s.field("url", S.string),
    imageUrl: s.field("imageUrl", S.string),
    imageBlurhash: s.field("imageBlurhash", S.nullableAsOption(S.string)),
    memo: s.field("memo", S.string),
    dayOfWeek: s.field("dayOfWeek", S.int),
    isSensitive: s.field("isSensitive", S.bool),
  })
}

module UserAccountMoveLog = {
  type t = {
  id: string,
  createdAt: string,
  movedToId: string,
  movedTo: UserDetailed.t,
  movedFromId: string,
  movedFrom: UserDetailed.t,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    movedToId: s.field("movedToId", S.string),
    movedTo: s.field("movedTo", UserDetailed.schema),
    movedFromId: s.field("movedFromId", S.string),
    movedFrom: s.field("movedFrom", UserDetailed.schema),
  })
}

module UserListMembership = {
  type t = {
  id: string,
  createdAt: string,
  userId: string,
  user: UserLite.t,
  withReplies: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.string),
    user: s.field("user", UserLite.schema),
    withReplies: s.field("withReplies", S.bool),
  })
}

module UserList = {
  type t = {
  id: string,
  createdAt: string,
  name: string,
  userIds: option<array<string>>,
  isPublic: bool,
}
  let schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.string),
    userIds: s.fieldOr("userIds", S.nullableAsOption(S.array(S.string)), None),
    isPublic: s.field("isPublic", S.bool),
  })
}

module User = {
  type t = UserDetailed.t
  let schema = UserDetailed.schema
}

module Error = {
  type error_1 = {
  code: string,
  message: string,
  id: string,
}
  let error_1Schema = S.object(s => {
    code: s.field("code", S.string),
    message: s.field("message", S.string),
    id: s.field("id", S.string),
  })
  type t = {
  error: error_1,
}
  let schema = S.object(s => {
    error: s.field("error", error_1Schema),
  })
}