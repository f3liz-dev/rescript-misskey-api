// misskey-io API for pages
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postPagesCreateRequest = {
  title: string,
  name: string,
  summary: option<string>,
  content: array<dict<JSON.t>>,
  variables: array<dict<JSON.t>>,
  script: string,
  eyeCatchingImageId: option<string>,
  font: option<string>,
  alignCenter: option<bool>,
  hideTitleWhenPinned: option<bool>,
  visibility: option<string>,
}

let postPagesCreateRequestSchema = S.object(s => {
    title: s.field("title", S.string),
    name: s.field("name", S.string->S.min(1)->S.pattern(%re("/^[a-zA-Z0-9_-]+$/"))),
    summary: s.fieldOr("summary", S.nullableAsOption(S.string), None),
    content: s.field("content", S.array(S.dict(S.json))),
    variables: s.field("variables", S.array(S.dict(S.json))),
    script: s.field("script", S.string),
    eyeCatchingImageId: s.fieldOr("eyeCatchingImageId", S.nullableAsOption(S.string), None),
    font: s.fieldOr("font", S.nullableAsOption(S.string), None),
    alignCenter: s.fieldOr("alignCenter", S.nullableAsOption(S.bool), None),
    hideTitleWhenPinned: s.fieldOr("hideTitleWhenPinned", S.nullableAsOption(S.bool), None),
    visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
  })

type postPagesCreateResponse = MisskeyIoComponentSchemas.Page.t

let postPagesCreateResponseSchema = MisskeyIoComponentSchemas.Page.schema

/**
 * pages/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:pages*
 */
let postPagesCreate = (~body: postPagesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesCreateRequestSchema)
  fetch(
    ~url="/pages/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postPagesCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postPagesDeleteRequest = {
  pageId: string,
}

let postPagesDeleteRequestSchema = S.object(s => {
    pageId: s.field("pageId", S.string),
  })

type postPagesDeleteResponse = unit

/**
 * pages/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:pages*
 */
let postPagesDelete = (~body: postPagesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesDeleteRequestSchema)
  fetch(
    ~url="/pages/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postPagesFeaturedResponse = array<MisskeyIoComponentSchemas.Page.t>

let postPagesFeaturedResponseSchema = S.array(MisskeyIoComponentSchemas.Page.schema)

/**
 * pages/featured
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postPagesFeatured = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesFeaturedResponse> => {

  fetch(
    ~url="/pages/featured",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postPagesFeaturedResponseSchema)
  value
    ->Promise.resolve
  })
}

type postPagesLikeRequest = {
  pageId: string,
}

let postPagesLikeRequestSchema = S.object(s => {
    pageId: s.field("pageId", S.string),
  })

type postPagesLikeResponse = unit

/**
 * pages/like
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:page-likes*
 */
let postPagesLike = (~body: postPagesLikeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesLikeResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesLikeRequestSchema)
  fetch(
    ~url="/pages/like",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postPagesShowRequest = {
  pageId: option<string>,
  name: option<string>,
  username: option<string>,
}

let postPagesShowRequestSchema = S.object(s => {
    pageId: s.fieldOr("pageId", S.nullableAsOption(S.string), None),
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    username: s.fieldOr("username", S.nullableAsOption(S.string), None),
  })

type postPagesShowResponse = MisskeyIoComponentSchemas.Page.t

let postPagesShowResponseSchema = MisskeyIoComponentSchemas.Page.schema

/**
 * pages/show
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postPagesShow = (~body: postPagesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesShowRequestSchema)
  fetch(
    ~url="/pages/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postPagesShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postPagesUnlikeRequest = {
  pageId: string,
}

let postPagesUnlikeRequestSchema = S.object(s => {
    pageId: s.field("pageId", S.string),
  })

type postPagesUnlikeResponse = unit

/**
 * pages/unlike
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:page-likes*
 */
let postPagesUnlike = (~body: postPagesUnlikeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesUnlikeResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesUnlikeRequestSchema)
  fetch(
    ~url="/pages/unlike",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postPagesUpdateRequest = {
  pageId: string,
  title: option<string>,
  name: option<string>,
  summary: option<string>,
  content: option<array<dict<JSON.t>>>,
  variables: option<array<dict<JSON.t>>>,
  script: option<string>,
  eyeCatchingImageId: option<string>,
  font: option<string>,
  alignCenter: option<bool>,
  hideTitleWhenPinned: option<bool>,
  visibility: option<string>,
}

let postPagesUpdateRequestSchema = S.object(s => {
    pageId: s.field("pageId", S.string),
    title: s.fieldOr("title", S.nullableAsOption(S.string), None),
    name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)->S.pattern(%re("/^[a-zA-Z0-9_-]+$/"))), None),
    summary: s.fieldOr("summary", S.nullableAsOption(S.string), None),
    content: s.fieldOr("content", S.nullableAsOption(S.array(S.dict(S.json))), None),
    variables: s.fieldOr("variables", S.nullableAsOption(S.array(S.dict(S.json))), None),
    script: s.fieldOr("script", S.nullableAsOption(S.string), None),
    eyeCatchingImageId: s.fieldOr("eyeCatchingImageId", S.nullableAsOption(S.string), None),
    font: s.fieldOr("font", S.nullableAsOption(S.string), None),
    alignCenter: s.fieldOr("alignCenter", S.nullableAsOption(S.bool), None),
    hideTitleWhenPinned: s.fieldOr("hideTitleWhenPinned", S.nullableAsOption(S.bool), None),
    visibility: s.fieldOr("visibility", S.nullableAsOption(S.string), None),
  })

type postPagesUpdateResponse = unit

/**
 * pages/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:pages*
 */
let postPagesUpdate = (~body: postPagesUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postPagesUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postPagesUpdateRequestSchema)
  fetch(
    ~url="/pages/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}
