// misskey-io API for admin
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated



type postAdminAbuseReportResolverCreateRequest = {
  name: string,
  targetUserPattern: option<string>,
  reporterPattern: option<string>,
  reportContentPattern: option<string>,
  expiresAt: string,
  forward: bool,
}

let postAdminAbuseReportResolverCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)),
    targetUserPattern: s.field("targetUserPattern", S.nullableAsOption(S.string)),
    reporterPattern: s.field("reporterPattern", S.nullableAsOption(S.string)),
    reportContentPattern: s.field("reportContentPattern", S.nullableAsOption(S.string)),
    expiresAt: s.field("expiresAt", S.string),
    forward: s.field("forward", S.bool),
  })

type postAdminAbuseReportResolverCreateResponse = {
  name: string,
  targetUserPattern: option<string>,
  reporterPattern: option<string>,
  reportContentPattern: option<string>,
  expiresAt: string,
  forward: bool,
}

let postAdminAbuseReportResolverCreateResponseSchema = S.object(s => {
    name: s.field("name", S.string),
    targetUserPattern: s.field("targetUserPattern", S.nullableAsOption(S.string)),
    reporterPattern: s.field("reporterPattern", S.nullableAsOption(S.string)),
    reportContentPattern: s.field("reportContentPattern", S.nullableAsOption(S.string)),
    expiresAt: s.field("expiresAt", S.string),
    forward: s.field("forward", S.bool),
  })

/**
 * admin/abuse-report-resolver/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:abuse-report-resolvers*
 */
let postAdminAbuseReportResolverCreate = (~body: postAdminAbuseReportResolverCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportResolverCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportResolverCreateRequestSchema)
  fetch(
    ~url="/admin/abuse-report-resolver/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAbuseReportResolverCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAbuseReportResolverDeleteRequest = {
  resolverId: string,
}

let postAdminAbuseReportResolverDeleteRequestSchema = S.object(s => {
    resolverId: s.field("resolverId", S.string),
  })

type postAdminAbuseReportResolverDeleteResponse = unit

/**
 * admin/abuse-report-resolver/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:abuse-report-resolvers*
 */
let postAdminAbuseReportResolverDelete = (~body: postAdminAbuseReportResolverDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportResolverDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportResolverDeleteRequestSchema)
  fetch(
    ~url="/admin/abuse-report-resolver/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAbuseReportResolverListRequest = {
  limit: option<float>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postAdminAbuseReportResolverListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.float->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postAdminAbuseReportResolverListResponse_1 = {
  name: string,
  targetUserPattern: option<string>,
  reporterPattern: option<string>,
  reportContentPattern: option<string>,
  expiresAt: string,
  forward: bool,
}

type postAdminAbuseReportResolverListResponse = array<postAdminAbuseReportResolverListResponse_1>

let postAdminAbuseReportResolverListResponse_1Schema = S.object(s => {
    name: s.field("name", S.string),
    targetUserPattern: s.field("targetUserPattern", S.nullableAsOption(S.string)),
    reporterPattern: s.field("reporterPattern", S.nullableAsOption(S.string)),
    reportContentPattern: s.field("reportContentPattern", S.nullableAsOption(S.string)),
    expiresAt: s.field("expiresAt", S.string),
    forward: s.field("forward", S.bool),
  })

let postAdminAbuseReportResolverListResponseSchema = S.array(postAdminAbuseReportResolverListResponse_1Schema)

/**
 * admin/abuse-report-resolver/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:abuse-report-resolvers*
 */
let postAdminAbuseReportResolverList = (~body: postAdminAbuseReportResolverListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportResolverListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportResolverListRequestSchema)
  fetch(
    ~url="/admin/abuse-report-resolver/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAbuseReportResolverListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAbuseReportResolverUpdateRequest = {
  resolverId: string,
  name: option<string>,
  targetUserPattern: option<string>,
  reporterPattern: option<string>,
  reportContentPattern: option<string>,
  expiresAt: option<string>,
  forward: option<bool>,
}

let postAdminAbuseReportResolverUpdateRequestSchema = S.object(s => {
    resolverId: s.field("resolverId", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    targetUserPattern: s.fieldOr("targetUserPattern", S.nullableAsOption(S.string), None),
    reporterPattern: s.fieldOr("reporterPattern", S.nullableAsOption(S.string), None),
    reportContentPattern: s.fieldOr("reportContentPattern", S.nullableAsOption(S.string), None),
    expiresAt: s.fieldOr("expiresAt", S.nullableAsOption(S.string), None),
    forward: s.fieldOr("forward", S.nullableAsOption(S.bool), None),
  })

type postAdminAbuseReportResolverUpdateResponse = unit

/**
 * admin/abuse-report-resolver/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:abuse-report-resolvers*
 */
let postAdminAbuseReportResolverUpdate = (~body: postAdminAbuseReportResolverUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportResolverUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportResolverUpdateRequestSchema)
  fetch(
    ~url="/admin/abuse-report-resolver/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAbuseReportNotificationRecipientCreateRequest = {
  isActive: bool,
  name: string,
  @as("method") method_: string,
  userId: option<string>,
  systemWebhookId: option<string>,
}

let postAdminAbuseReportNotificationRecipientCreateRequestSchema = S.object(s => {
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    method_: s.field("method", S.string),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    systemWebhookId: s.fieldOr("systemWebhookId", S.nullableAsOption(S.string), None),
  })

type postAdminAbuseReportNotificationRecipientCreateResponse = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientCreateResponseSchema = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.schema

/**
 * admin/abuse-report/notification-recipient/create
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
 */
let postAdminAbuseReportNotificationRecipientCreate = (~body: postAdminAbuseReportNotificationRecipientCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientCreateRequestSchema)
  fetch(
    ~url="/admin/abuse-report/notification-recipient/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAbuseReportNotificationRecipientDeleteRequest = {
  id: string,
}

let postAdminAbuseReportNotificationRecipientDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAbuseReportNotificationRecipientDeleteResponse = unit

/**
 * admin/abuse-report/notification-recipient/delete
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
 */
let postAdminAbuseReportNotificationRecipientDelete = (~body: postAdminAbuseReportNotificationRecipientDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientDeleteRequestSchema)
  fetch(
    ~url="/admin/abuse-report/notification-recipient/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAbuseReportNotificationRecipientListRequest = {
  @as("method") method_: option<array<string>>,
}

let postAdminAbuseReportNotificationRecipientListRequestSchema = S.object(s => {
    method_: s.fieldOr("method", S.nullableAsOption(S.array(S.string)), None),
  })

type postAdminAbuseReportNotificationRecipientListResponse = array<MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.t>

let postAdminAbuseReportNotificationRecipientListResponseSchema = S.array(MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.schema)

/**
 * admin/abuse-report/notification-recipient/list
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *read:admin:abuse-report:notification-recipient*
 */
let postAdminAbuseReportNotificationRecipientList = (~body: postAdminAbuseReportNotificationRecipientListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientListRequestSchema)
  fetch(
    ~url="/admin/abuse-report/notification-recipient/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAbuseReportNotificationRecipientShowRequest = {
  id: string,
}

let postAdminAbuseReportNotificationRecipientShowRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAbuseReportNotificationRecipientShowResponse = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientShowResponseSchema = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.schema

/**
 * admin/abuse-report/notification-recipient/show
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *read:admin:abuse-report:notification-recipient*
 */
let postAdminAbuseReportNotificationRecipientShow = (~body: postAdminAbuseReportNotificationRecipientShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientShowRequestSchema)
  fetch(
    ~url="/admin/abuse-report/notification-recipient/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAbuseReportNotificationRecipientUpdateRequest = {
  id: string,
  isActive: bool,
  name: string,
  @as("method") method_: string,
  userId: option<string>,
  systemWebhookId: option<string>,
}

let postAdminAbuseReportNotificationRecipientUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    method_: s.field("method", S.string),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    systemWebhookId: s.fieldOr("systemWebhookId", S.nullableAsOption(S.string), None),
  })

type postAdminAbuseReportNotificationRecipientUpdateResponse = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientUpdateResponseSchema = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.schema

/**
 * admin/abuse-report/notification-recipient/update
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
 */
let postAdminAbuseReportNotificationRecipientUpdate = (~body: postAdminAbuseReportNotificationRecipientUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseReportNotificationRecipientUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientUpdateRequestSchema)
  fetch(
    ~url="/admin/abuse-report/notification-recipient/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAbuseUserReportsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  state: option<string>,
  reporterOrigin: option<string>,
  targetUserOrigin: option<string>,
  forwarded: option<bool>,
  category: option<string>,
}

let postAdminAbuseUserReportsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    state: s.fieldOr("state", S.nullableAsOption(S.string), None),
    reporterOrigin: s.fieldOr("reporterOrigin", S.nullableAsOption(S.string), None),
    targetUserOrigin: s.fieldOr("targetUserOrigin", S.nullableAsOption(S.string), None),
    forwarded: s.fieldOr("forwarded", S.nullableAsOption(S.bool), None),
    category: s.fieldOr("category", S.nullableAsOption(S.string), None),
  })

type postAdminAbuseUserReportsResponse_1 = {
  id: string,
  createdAt: string,
  comment: string,
  resolved: bool,
  forwarded: bool,
  resolvedAs: option<string>,
  reporterId: string,
  targetUserId: string,
  assigneeId: option<string>,
  reporter: MisskeyIoComponentSchemas.UserDetailed.t,
  targetUser: MisskeyIoComponentSchemas.UserDetailed.t,
  assignee: option<MisskeyIoComponentSchemas.UserDetailed.t>,
  category: string,
  moderationNote: option<string>,
}

type postAdminAbuseUserReportsResponse = array<postAdminAbuseUserReportsResponse_1>

let postAdminAbuseUserReportsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    comment: s.field("comment", S.string),
    resolved: s.field("resolved", S.bool),
    forwarded: s.field("forwarded", S.bool),
    resolvedAs: s.field("resolvedAs", S.nullableAsOption(S.string)),
    reporterId: s.field("reporterId", S.string),
    targetUserId: s.field("targetUserId", S.string),
    assigneeId: s.field("assigneeId", S.nullableAsOption(S.string)),
    reporter: s.field("reporter", MisskeyIoComponentSchemas.UserDetailed.schema),
    targetUser: s.field("targetUser", MisskeyIoComponentSchemas.UserDetailed.schema),
    assignee: s.fieldOr("assignee", S.nullableAsOption(MisskeyIoComponentSchemas.UserDetailed.schema), None),
    category: s.field("category", S.string),
    moderationNote: s.field("moderationNote", S.nullableAsOption(S.string)),
  })

let postAdminAbuseUserReportsResponseSchema = S.array(postAdminAbuseUserReportsResponse_1Schema)

/**
 * admin/abuse-user-reports
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:abuse-user-reports*
 */
let postAdminAbuseUserReports = (~body: postAdminAbuseUserReportsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAbuseUserReportsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseUserReportsRequestSchema)
  fetch(
    ~url="/admin/abuse-user-reports",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAbuseUserReportsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAccountsCreateRequest = {
  username: string,
  password: string,
  setupPassword: option<string>,
}

let postAdminAccountsCreateRequestSchema = S.object(s => {
    username: s.field("username", S.string->S.pattern(/^\w{1,20}$/)),
    password: s.field("password", S.string->S.min(1)),
    setupPassword: s.fieldOr("setupPassword", S.nullableAsOption(S.string), None),
  })

type postAdminAccountsCreateResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postAdminAccountsCreateResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
 * admin/accounts/create
 *
 * No description provided.
 *
 * **Credential required**: *No*
 */
let postAdminAccountsCreate = (~body: postAdminAccountsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAccountsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsCreateRequestSchema)
  fetch(
    ~url="/admin/accounts/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAccountsCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAccountsDeleteRequest = {
  userId: string,
  soft: option<bool>,
}

let postAdminAccountsDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    soft: s.fieldOr("soft", S.nullableAsOption(S.bool), None),
  })

type postAdminAccountsDeleteResponse = unit

/**
 * admin/accounts/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:account*
 */
let postAdminAccountsDelete = (~body: postAdminAccountsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAccountsDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsDeleteRequestSchema)
  fetch(
    ~url="/admin/accounts/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAccountsFindByEmailRequest = {
  email: string,
}

let postAdminAccountsFindByEmailRequestSchema = S.object(s => {
    email: s.field("email", S.string),
  })

type postAdminAccountsFindByEmailResponse = MisskeyIoComponentSchemas.UserDetailed.t

let postAdminAccountsFindByEmailResponseSchema = MisskeyIoComponentSchemas.UserDetailed.schema

/**
 * admin/accounts/find-by-email
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:account*
 */
let postAdminAccountsFindByEmail = (~body: postAdminAccountsFindByEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAccountsFindByEmailResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsFindByEmailRequestSchema)
  fetch(
    ~url="/admin/accounts/find-by-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAccountsFindByEmailResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAccountsPendingListRequest = {
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
  username: option<string>,
  email: option<string>,
  code: option<string>,
}

let postAdminAccountsPendingListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
    username: s.fieldOr("username", S.nullableAsOption(S.string), None),
    email: s.fieldOr("email", S.nullableAsOption(S.string), None),
    code: s.fieldOr("code", S.nullableAsOption(S.string), None),
  })

type postAdminAccountsPendingListResponse_1 = {
  id: string,
  createdAt: string,
  code: string,
  username: string,
  email: option<string>,
}

type postAdminAccountsPendingListResponse = array<postAdminAccountsPendingListResponse_1>

let postAdminAccountsPendingListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    code: s.field("code", S.string),
    username: s.field("username", S.string),
    email: s.fieldOr("email", S.nullableAsOption(S.string), None),
  })

let postAdminAccountsPendingListResponseSchema = S.array(postAdminAccountsPendingListResponse_1Schema)

/**
 * admin/accounts/pending/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:account*
 */
let postAdminAccountsPendingList = (~body: postAdminAccountsPendingListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAccountsPendingListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsPendingListRequestSchema)
  fetch(
    ~url="/admin/accounts/pending/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAccountsPendingListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAccountsPendingRevokeRequest = {
  id: option<string>,
  code: option<string>,
}

let postAdminAccountsPendingRevokeRequestSchema = S.object(s => {
    id: s.fieldOr("id", S.nullableAsOption(S.string), None),
    code: s.fieldOr("code", S.nullableAsOption(S.string), None),
  })

type postAdminAccountsPendingRevokeResponse = unit

/**
 * admin/accounts/pending/revoke
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:account*
 */
let postAdminAccountsPendingRevoke = (~body: postAdminAccountsPendingRevokeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAccountsPendingRevokeResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsPendingRevokeRequestSchema)
  fetch(
    ~url="/admin/accounts/pending/revoke",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAdCreateRequest = {
  url: string,
  memo: string,
  place: string,
  priority: string,
  ratio: int,
  expiresAt: int,
  startsAt: int,
  imageUrl: string,
  dayOfWeek: int,
  isSensitive: option<bool>,
}

let postAdminAdCreateRequestSchema = S.object(s => {
    url: s.field("url", S.string->S.min(1)),
    memo: s.field("memo", S.string),
    place: s.field("place", S.string),
    priority: s.field("priority", S.string),
    ratio: s.field("ratio", S.int),
    expiresAt: s.field("expiresAt", S.int),
    startsAt: s.field("startsAt", S.int),
    imageUrl: s.field("imageUrl", S.string->S.min(1)),
    dayOfWeek: s.field("dayOfWeek", S.int),
    isSensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
  })

type postAdminAdCreateResponse = MisskeyIoComponentSchemas.Ad.t

let postAdminAdCreateResponseSchema = MisskeyIoComponentSchemas.Ad.schema

/**
 * admin/ad/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:ad*
 */
let postAdminAdCreate = (~body: postAdminAdCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAdCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdCreateRequestSchema)
  fetch(
    ~url="/admin/ad/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAdCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAdDeleteRequest = {
  id: string,
}

let postAdminAdDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAdDeleteResponse = unit

/**
 * admin/ad/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:ad*
 */
let postAdminAdDelete = (~body: postAdminAdDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAdDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdDeleteRequestSchema)
  fetch(
    ~url="/admin/ad/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAdListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  publishing: option<bool>,
}

let postAdminAdListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    publishing: s.fieldOr("publishing", S.nullableAsOption(S.bool), None),
  })

type postAdminAdListResponse = array<MisskeyIoComponentSchemas.Ad.t>

let postAdminAdListResponseSchema = S.array(MisskeyIoComponentSchemas.Ad.schema)

/**
 * admin/ad/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:ad*
 */
let postAdminAdList = (~body: postAdminAdListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAdListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdListRequestSchema)
  fetch(
    ~url="/admin/ad/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAdListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAdUpdateRequest = {
  id: string,
  memo: option<string>,
  url: option<string>,
  imageUrl: option<string>,
  place: option<string>,
  priority: option<string>,
  ratio: option<int>,
  expiresAt: option<int>,
  startsAt: option<int>,
  dayOfWeek: option<int>,
  isSensitive: option<bool>,
}

let postAdminAdUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    memo: s.fieldOr("memo", S.nullableAsOption(S.string), None),
    url: s.fieldOr("url", S.nullableAsOption(S.string->S.min(1)), None),
    imageUrl: s.fieldOr("imageUrl", S.nullableAsOption(S.string->S.min(1)), None),
    place: s.fieldOr("place", S.nullableAsOption(S.string), None),
    priority: s.fieldOr("priority", S.nullableAsOption(S.string), None),
    ratio: s.fieldOr("ratio", S.nullableAsOption(S.int), None),
    expiresAt: s.fieldOr("expiresAt", S.nullableAsOption(S.int), None),
    startsAt: s.fieldOr("startsAt", S.nullableAsOption(S.int), None),
    dayOfWeek: s.fieldOr("dayOfWeek", S.nullableAsOption(S.int), None),
    isSensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
  })

type postAdminAdUpdateResponse = unit

/**
 * admin/ad/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:ad*
 */
let postAdminAdUpdate = (~body: postAdminAdUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAdUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdUpdateRequestSchema)
  fetch(
    ~url="/admin/ad/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAnnouncementsCreateRequest = {
  title: string,
  text: string,
  imageUrl: option<string>,
  icon: option<string>,
  display: option<string>,
  forExistingUsers: option<bool>,
  needConfirmationToRead: option<bool>,
  needEnrollmentTutorialToRead: option<bool>,
  closeDuration: option<float>,
  displayOrder: option<float>,
  silence: option<bool>,
  userId: option<string>,
}

let postAdminAnnouncementsCreateRequestSchema = S.object(s => {
    title: s.field("title", S.string->S.min(1)),
    text: s.field("text", S.string->S.min(1)),
    imageUrl: s.field("imageUrl", S.nullableAsOption(S.string->S.min(0))),
    icon: s.fieldOr("icon", S.nullableAsOption(S.string), None),
    display: s.fieldOr("display", S.nullableAsOption(S.string), None),
    forExistingUsers: s.fieldOr("forExistingUsers", S.nullableAsOption(S.bool), None),
    needConfirmationToRead: s.fieldOr("needConfirmationToRead", S.nullableAsOption(S.bool), None),
    needEnrollmentTutorialToRead: s.fieldOr("needEnrollmentTutorialToRead", S.nullableAsOption(S.bool), None),
    closeDuration: s.fieldOr("closeDuration", S.nullableAsOption(S.float), None),
    displayOrder: s.fieldOr("displayOrder", S.nullableAsOption(S.float), None),
    silence: s.fieldOr("silence", S.nullableAsOption(S.bool), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
  })

type postAdminAnnouncementsCreateResponse = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  title: string,
  text: string,
  imageUrl: option<string>,
  icon: string,
  display: string,
  forYou: bool,
  needConfirmationToRead: bool,
  needEnrollmentTutorialToRead: bool,
  closeDuration: float,
  displayOrder: float,
  silence: bool,
  isRead: option<bool>,
}

let postAdminAnnouncementsCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    title: s.field("title", S.string),
    text: s.field("text", S.string),
    imageUrl: s.field("imageUrl", S.nullableAsOption(S.string)),
    icon: s.field("icon", S.string),
    display: s.field("display", S.string),
    forYou: s.field("forYou", S.bool),
    needConfirmationToRead: s.field("needConfirmationToRead", S.bool),
    needEnrollmentTutorialToRead: s.field("needEnrollmentTutorialToRead", S.bool),
    closeDuration: s.field("closeDuration", S.float),
    displayOrder: s.field("displayOrder", S.float),
    silence: s.field("silence", S.bool),
    isRead: s.fieldOr("isRead", S.nullableAsOption(S.bool), None),
  })

/**
 * admin/announcements/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:announcements*
 */
let postAdminAnnouncementsCreate = (~body: postAdminAnnouncementsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAnnouncementsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsCreateRequestSchema)
  fetch(
    ~url="/admin/announcements/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAnnouncementsCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAnnouncementsDeleteRequest = {
  id: string,
}

let postAdminAnnouncementsDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAnnouncementsDeleteResponse = unit

/**
 * admin/announcements/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:announcements*
 */
let postAdminAnnouncementsDelete = (~body: postAdminAnnouncementsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAnnouncementsDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsDeleteRequestSchema)
  fetch(
    ~url="/admin/announcements/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAnnouncementsListRequest = {
  limit: option<int>,
  offset: option<int>,
  userId: option<string>,
  status: option<string>,
}

let postAdminAnnouncementsListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    status: s.fieldOr("status", S.nullableAsOption(S.string), None),
  })

type postAdminAnnouncementsListResponse_1 = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  text: string,
  isActive: bool,
  title: string,
  imageUrl: option<string>,
  icon: string,
  display: string,
  forExistingUsers: bool,
  needConfirmationToRead: bool,
  needEnrollmentTutorialToRead: bool,
  closeDuration: float,
  displayOrder: float,
  silence: bool,
  userId: option<string>,
  user: option<MisskeyIoComponentSchemas.UserLite.t>,
  reads: float,
  lastReadAt: option<string>,
}

type postAdminAnnouncementsListResponse = array<postAdminAnnouncementsListResponse_1>

let postAdminAnnouncementsListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    text: s.field("text", S.string),
    isActive: s.field("isActive", S.bool),
    title: s.field("title", S.string),
    imageUrl: s.field("imageUrl", S.nullableAsOption(S.string)),
    icon: s.field("icon", S.string),
    display: s.field("display", S.string),
    forExistingUsers: s.field("forExistingUsers", S.bool),
    needConfirmationToRead: s.field("needConfirmationToRead", S.bool),
    needEnrollmentTutorialToRead: s.field("needEnrollmentTutorialToRead", S.bool),
    closeDuration: s.field("closeDuration", S.float),
    displayOrder: s.field("displayOrder", S.float),
    silence: s.field("silence", S.bool),
    userId: s.field("userId", S.nullableAsOption(S.string)),
    user: s.field("user", S.nullableAsOption(MisskeyIoComponentSchemas.UserLite.schema)),
    reads: s.field("reads", S.float),
    lastReadAt: s.field("lastReadAt", S.nullableAsOption(S.string)),
  })

let postAdminAnnouncementsListResponseSchema = S.array(postAdminAnnouncementsListResponse_1Schema)

/**
 * admin/announcements/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:announcements*
 */
let postAdminAnnouncementsList = (~body: postAdminAnnouncementsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAnnouncementsListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsListRequestSchema)
  fetch(
    ~url="/admin/announcements/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAnnouncementsListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAnnouncementsUpdateRequest = {
  id: string,
  title: option<string>,
  text: option<string>,
  imageUrl: option<string>,
  icon: option<string>,
  display: option<string>,
  forExistingUsers: option<bool>,
  needConfirmationToRead: option<bool>,
  needEnrollmentTutorialToRead: option<bool>,
  closeDuration: option<float>,
  displayOrder: option<float>,
  silence: option<bool>,
  isActive: option<bool>,
}

let postAdminAnnouncementsUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    title: s.fieldOr("title", S.nullableAsOption(S.string->S.min(1)), None),
    text: s.fieldOr("text", S.nullableAsOption(S.string->S.min(1)), None),
    imageUrl: s.fieldOr("imageUrl", S.nullableAsOption(S.string->S.min(0)), None),
    icon: s.fieldOr("icon", S.nullableAsOption(S.string), None),
    display: s.fieldOr("display", S.nullableAsOption(S.string), None),
    forExistingUsers: s.fieldOr("forExistingUsers", S.nullableAsOption(S.bool), None),
    needConfirmationToRead: s.fieldOr("needConfirmationToRead", S.nullableAsOption(S.bool), None),
    needEnrollmentTutorialToRead: s.fieldOr("needEnrollmentTutorialToRead", S.nullableAsOption(S.bool), None),
    closeDuration: s.fieldOr("closeDuration", S.nullableAsOption(S.float), None),
    displayOrder: s.fieldOr("displayOrder", S.nullableAsOption(S.float), None),
    silence: s.fieldOr("silence", S.nullableAsOption(S.bool), None),
    isActive: s.fieldOr("isActive", S.nullableAsOption(S.bool), None),
  })

type postAdminAnnouncementsUpdateResponse = unit

/**
 * admin/announcements/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:announcements*
 */
let postAdminAnnouncementsUpdate = (~body: postAdminAnnouncementsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAnnouncementsUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsUpdateRequestSchema)
  fetch(
    ~url="/admin/announcements/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAvatarDecorationsCreateRequest = {
  name: string,
  description: string,
  url: string,
  roleIdsThatCanBeUsedThisDecoration: option<array<string>>,
}

let postAdminAvatarDecorationsCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)),
    description: s.field("description", S.string),
    url: s.field("url", S.string->S.min(1)),
    roleIdsThatCanBeUsedThisDecoration: s.fieldOr("roleIdsThatCanBeUsedThisDecoration", S.nullableAsOption(S.array(S.string)), None),
  })

type postAdminAvatarDecorationsCreateResponse = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  name: string,
  description: string,
  url: string,
  roleIdsThatCanBeUsedThisDecoration: array<string>,
}

let postAdminAvatarDecorationsCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    url: s.field("url", S.string),
    roleIdsThatCanBeUsedThisDecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.array(S.string)),
  })

/**
 * admin/avatar-decorations/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:avatar-decorations*
 */
let postAdminAvatarDecorationsCreate = (~body: postAdminAvatarDecorationsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAvatarDecorationsCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsCreateRequestSchema)
  fetch(
    ~url="/admin/avatar-decorations/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAvatarDecorationsCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAvatarDecorationsDeleteRequest = {
  id: string,
}

let postAdminAvatarDecorationsDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAvatarDecorationsDeleteResponse = unit

/**
 * admin/avatar-decorations/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:avatar-decorations*
 */
let postAdminAvatarDecorationsDelete = (~body: postAdminAvatarDecorationsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAvatarDecorationsDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsDeleteRequestSchema)
  fetch(
    ~url="/admin/avatar-decorations/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminAvatarDecorationsListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  userId: option<string>,
}

let postAdminAvatarDecorationsListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
  })

type postAdminAvatarDecorationsListResponse_1 = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  name: string,
  description: string,
  url: string,
  roleIdsThatCanBeUsedThisDecoration: array<string>,
}

type postAdminAvatarDecorationsListResponse = array<postAdminAvatarDecorationsListResponse_1>

let postAdminAvatarDecorationsListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    url: s.field("url", S.string),
    roleIdsThatCanBeUsedThisDecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.array(S.string)),
  })

let postAdminAvatarDecorationsListResponseSchema = S.array(postAdminAvatarDecorationsListResponse_1Schema)

/**
 * admin/avatar-decorations/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:avatar-decorations*
 */
let postAdminAvatarDecorationsList = (~body: postAdminAvatarDecorationsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAvatarDecorationsListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsListRequestSchema)
  fetch(
    ~url="/admin/avatar-decorations/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminAvatarDecorationsListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminAvatarDecorationsUpdateRequest = {
  id: string,
  name: option<string>,
  description: option<string>,
  url: option<string>,
  roleIdsThatCanBeUsedThisDecoration: option<array<string>>,
}

let postAdminAvatarDecorationsUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string->S.min(1)), None),
    description: s.fieldOr("description", S.nullableAsOption(S.string), None),
    url: s.fieldOr("url", S.nullableAsOption(S.string->S.min(1)), None),
    roleIdsThatCanBeUsedThisDecoration: s.fieldOr("roleIdsThatCanBeUsedThisDecoration", S.nullableAsOption(S.array(S.string)), None),
  })

type postAdminAvatarDecorationsUpdateResponse = unit

/**
 * admin/avatar-decorations/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:avatar-decorations*
 */
let postAdminAvatarDecorationsUpdate = (~body: postAdminAvatarDecorationsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminAvatarDecorationsUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsUpdateRequestSchema)
  fetch(
    ~url="/admin/avatar-decorations/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminCaptchaCurrentResponse_2 = {
  siteKey: option<string>,
  secretKey: option<string>,
  instanceUrl: option<string>,
}

type postAdminCaptchaCurrentResponse_1 = {
  siteKey: option<string>,
  secretKey: option<string>,
}

type postAdminCaptchaCurrentResponse = {
  provider: string,
  hcaptcha: postAdminCaptchaCurrentResponse_1,
  mcaptcha: postAdminCaptchaCurrentResponse_2,
  recaptcha: postAdminCaptchaCurrentResponse_1,
  turnstile: postAdminCaptchaCurrentResponse_1,
}

let postAdminCaptchaCurrentResponse_2Schema = S.object(s => {
    siteKey: s.field("siteKey", S.nullableAsOption(S.string)),
    secretKey: s.field("secretKey", S.nullableAsOption(S.string)),
    instanceUrl: s.field("instanceUrl", S.nullableAsOption(S.string)),
  })

let postAdminCaptchaCurrentResponse_1Schema = S.object(s => {
    siteKey: s.field("siteKey", S.nullableAsOption(S.string)),
    secretKey: s.field("secretKey", S.nullableAsOption(S.string)),
  })

let postAdminCaptchaCurrentResponseSchema = S.object(s => {
    provider: s.field("provider", S.string),
    hcaptcha: s.field("hcaptcha", postAdminCaptchaCurrentResponse_1Schema),
    mcaptcha: s.field("mcaptcha", postAdminCaptchaCurrentResponse_2Schema),
    recaptcha: s.field("recaptcha", postAdminCaptchaCurrentResponse_1Schema),
    turnstile: s.field("turnstile", postAdminCaptchaCurrentResponse_1Schema),
  })

/**
 * admin/captcha/current
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:meta*
 */
let postAdminCaptchaCurrent = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminCaptchaCurrentResponse> => {

  fetch(
    ~url="/admin/captcha/current",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminCaptchaCurrentResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminCaptchaSaveRequest = {
  provider: string,
  captchaResult: option<string>,
  sitekey: option<string>,
  secret: option<string>,
  instanceUrl: option<string>,
}

let postAdminCaptchaSaveRequestSchema = S.object(s => {
    provider: s.field("provider", S.string),
    captchaResult: s.fieldOr("captchaResult", S.nullableAsOption(S.string), None),
    sitekey: s.fieldOr("sitekey", S.nullableAsOption(S.string), None),
    secret: s.fieldOr("secret", S.nullableAsOption(S.string), None),
    instanceUrl: s.fieldOr("instanceUrl", S.nullableAsOption(S.string), None),
  })

type postAdminCaptchaSaveResponse = unit

/**
 * admin/captcha/save
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:meta*
 */
let postAdminCaptchaSave = (~body: postAdminCaptchaSaveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminCaptchaSaveResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminCaptchaSaveRequestSchema)
  fetch(
    ~url="/admin/captcha/save",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminDriveCleanRemoteFilesResponse = unit

/**
 * admin/drive/clean-remote-files
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:drive*
 */
let postAdminDriveCleanRemoteFiles = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDriveCleanRemoteFilesResponse> => {

  fetch(
    ~url="/admin/drive/clean-remote-files",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminDriveCleanupResponse = unit

/**
 * admin/drive/cleanup
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:drive*
 */
let postAdminDriveCleanup = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDriveCleanupResponse> => {

  fetch(
    ~url="/admin/drive/cleanup",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminDriveDeleteAllFilesOfAUserRequest = {
  userId: string,
}

let postAdminDriveDeleteAllFilesOfAUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminDriveDeleteAllFilesOfAUserResponse = unit

/**
 * admin/drive/delete-all-files-of-a-user
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:drive*
 */
let postAdminDriveDeleteAllFilesOfAUser = (~body: postAdminDriveDeleteAllFilesOfAUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDriveDeleteAllFilesOfAUserResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveDeleteAllFilesOfAUserRequestSchema)
  fetch(
    ~url="/admin/drive/delete-all-files-of-a-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminDriveFilesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  userId: option<string>,
  @as("type") type_: option<string>,
  origin: option<string>,
  hostname: option<string>,
}

let postAdminDriveFilesRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
    type_: s.fieldOr("type", S.nullableAsOption(S.string->S.pattern(/^[a-zA-Z0-9\/\*-]+$/)), None),
    origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
    hostname: s.fieldOr("hostname", S.nullableAsOption(S.string), None),
  })

type postAdminDriveFilesResponse = array<MisskeyIoComponentSchemas.DriveFile.t>

let postAdminDriveFilesResponseSchema = S.array(MisskeyIoComponentSchemas.DriveFile.schema)

/**
 * admin/drive/files
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:drive*
 */
let postAdminDriveFiles = (~body: postAdminDriveFilesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDriveFilesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveFilesRequestSchema)
  fetch(
    ~url="/admin/drive/files",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminDriveFilesResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminDriveShowFileRequest = {
  fileId: option<string>,
  url: option<string>,
}

let postAdminDriveShowFileRequestSchema = S.object(s => {
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.string), None),
    url: s.fieldOr("url", S.nullableAsOption(S.string), None),
  })

type postAdminDriveShowFileResponse_1 = {
  width: option<float>,
  height: option<float>,
  orientation: option<float>,
  avgColor: option<string>,
}

type postAdminDriveShowFileResponse = {
  id: string,
  createdAt: string,
  userId: option<string>,
  userHost: option<string>,
  md5: string,
  name: string,
  @as("type") type_: string,
  size: float,
  comment: option<string>,
  blurhash: option<string>,
  properties: postAdminDriveShowFileResponse_1,
  storedInternal: option<bool>,
  url: option<string>,
  thumbnailUrl: option<string>,
  webpublicUrl: option<string>,
  accessKey: option<string>,
  thumbnailAccessKey: option<string>,
  webpublicAccessKey: option<string>,
  uri: option<string>,
  src: option<string>,
  folderId: option<string>,
  isSensitive: bool,
  isLink: bool,
}

let postAdminDriveShowFileResponse_1Schema = S.object(s => {
    width: s.fieldOr("width", S.nullableAsOption(S.float), None),
    height: s.fieldOr("height", S.nullableAsOption(S.float), None),
    orientation: s.fieldOr("orientation", S.nullableAsOption(S.float), None),
    avgColor: s.fieldOr("avgColor", S.nullableAsOption(S.string), None),
  })

let postAdminDriveShowFileResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.nullableAsOption(S.string)),
    userHost: s.field("userHost", S.nullableAsOption(S.string)),
    md5: s.field("md5", S.string),
    name: s.field("name", S.string),
    type_: s.field("type", S.string),
    size: s.field("size", S.float),
    comment: s.field("comment", S.nullableAsOption(S.string)),
    blurhash: s.field("blurhash", S.nullableAsOption(S.string)),
    properties: s.field("properties", postAdminDriveShowFileResponse_1Schema),
    storedInternal: s.field("storedInternal", S.nullableAsOption(S.bool)),
    url: s.field("url", S.nullableAsOption(S.string)),
    thumbnailUrl: s.field("thumbnailUrl", S.nullableAsOption(S.string)),
    webpublicUrl: s.field("webpublicUrl", S.nullableAsOption(S.string)),
    accessKey: s.field("accessKey", S.nullableAsOption(S.string)),
    thumbnailAccessKey: s.field("thumbnailAccessKey", S.nullableAsOption(S.string)),
    webpublicAccessKey: s.field("webpublicAccessKey", S.nullableAsOption(S.string)),
    uri: s.field("uri", S.nullableAsOption(S.string)),
    src: s.field("src", S.nullableAsOption(S.string)),
    folderId: s.field("folderId", S.nullableAsOption(S.string)),
    isSensitive: s.field("isSensitive", S.bool),
    isLink: s.field("isLink", S.bool),
  })

/**
 * admin/drive/show-file
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:drive*
 */
let postAdminDriveShowFile = (~body: postAdminDriveShowFileRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminDriveShowFileResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveShowFileRequestSchema)
  fetch(
    ~url="/admin/drive/show-file",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminDriveShowFileResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminEmojiAddRequest = {
  name: string,
  fileId: string,
  category: option<string>,
  aliases: option<array<string>>,
  license: option<string>,
  isSensitive: option<bool>,
  localOnly: option<bool>,
  requestedBy: option<string>,
  memo: option<string>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
  roleIdsThatCanNotBeUsedThisEmojiAsReaction: option<array<string>>,
}

let postAdminEmojiAddRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.pattern(/^[a-zA-Z0-9_]+$/)),
    fileId: s.field("fileId", S.string),
    category: s.fieldOr("category", S.nullableAsOption(S.string), None),
    aliases: s.fieldOr("aliases", S.nullableAsOption(S.array(S.string)), None),
    license: s.fieldOr("license", S.nullableAsOption(S.string), None),
    isSensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    requestedBy: s.fieldOr("requestedBy", S.nullableAsOption(S.string), None),
    memo: s.fieldOr("memo", S.nullableAsOption(S.string), None),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
    roleIdsThatCanNotBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanNotBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
  })

type postAdminEmojiAddResponse = MisskeyIoComponentSchemas.EmojiDetailed.t

let postAdminEmojiAddResponseSchema = MisskeyIoComponentSchemas.EmojiDetailed.schema

/**
 * admin/emoji/add
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiAdd = (~body: postAdminEmojiAddRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiAddResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiAddRequestSchema)
  fetch(
    ~url="/admin/emoji/add",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminEmojiAddResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminEmojiAddAliasesBulkRequest = {
  ids: array<string>,
  aliases: array<string>,
}

let postAdminEmojiAddAliasesBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
    aliases: s.field("aliases", S.array(S.string)),
  })

type postAdminEmojiAddAliasesBulkResponse = unit

/**
 * admin/emoji/add-aliases-bulk
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiAddAliasesBulk = (~body: postAdminEmojiAddAliasesBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiAddAliasesBulkResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiAddAliasesBulkRequestSchema)
  fetch(
    ~url="/admin/emoji/add-aliases-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminEmojiCopyRequest = {
  emojiId: string,
}

let postAdminEmojiCopyRequestSchema = S.object(s => {
    emojiId: s.field("emojiId", S.string),
  })

type postAdminEmojiCopyResponse = {
  id: string,
}

let postAdminEmojiCopyResponseSchema = S.object(s => {
    id: s.field("id", S.string),
  })

/**
 * admin/emoji/copy
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiCopy = (~body: postAdminEmojiCopyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiCopyResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiCopyRequestSchema)
  fetch(
    ~url="/admin/emoji/copy",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminEmojiCopyResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminEmojiDeleteRequest = {
  id: string,
}

let postAdminEmojiDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminEmojiDeleteResponse = unit

/**
 * admin/emoji/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiDelete = (~body: postAdminEmojiDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiDeleteRequestSchema)
  fetch(
    ~url="/admin/emoji/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminEmojiDeleteBulkRequest = {
  ids: array<string>,
}

let postAdminEmojiDeleteBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
  })

type postAdminEmojiDeleteBulkResponse = unit

/**
 * admin/emoji/delete-bulk
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiDeleteBulk = (~body: postAdminEmojiDeleteBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiDeleteBulkResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiDeleteBulkRequestSchema)
  fetch(
    ~url="/admin/emoji/delete-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminEmojiListRequest = {
  query: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postAdminEmojiListRequestSchema = S.object(s => {
    query: s.fieldOr("query", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postAdminEmojiListResponse_1 = {
  id: string,
  aliases: array<string>,
  name: string,
  category: option<string>,
  host: option<string>,
  url: string,
}

type postAdminEmojiListResponse = array<postAdminEmojiListResponse_1>

let postAdminEmojiListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.nullableAsOption(S.string)),
    host: s.field("host", S.nullableAsOption(S.string)),
    url: s.field("url", S.string),
  })

let postAdminEmojiListResponseSchema = S.array(postAdminEmojiListResponse_1Schema)

/**
 * admin/emoji/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:emoji*
 */
let postAdminEmojiList = (~body: postAdminEmojiListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiListRequestSchema)
  fetch(
    ~url="/admin/emoji/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminEmojiListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminEmojiListRemoteRequest = {
  query: option<string>,
  host: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postAdminEmojiListRemoteRequestSchema = S.object(s => {
    query: s.fieldOr("query", S.nullableAsOption(S.string), None),
    host: s.fieldOr("host", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
  })

type postAdminEmojiListRemoteResponse_1 = {
  id: string,
  aliases: array<string>,
  name: string,
  category: option<string>,
  host: option<string>,
  url: string,
}

type postAdminEmojiListRemoteResponse = array<postAdminEmojiListRemoteResponse_1>

let postAdminEmojiListRemoteResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.nullableAsOption(S.string)),
    host: s.field("host", S.nullableAsOption(S.string)),
    url: s.field("url", S.string),
  })

let postAdminEmojiListRemoteResponseSchema = S.array(postAdminEmojiListRemoteResponse_1Schema)

/**
 * admin/emoji/list-remote
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:emoji*
 */
let postAdminEmojiListRemote = (~body: postAdminEmojiListRemoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiListRemoteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiListRemoteRequestSchema)
  fetch(
    ~url="/admin/emoji/list-remote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminEmojiListRemoteResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminEmojiRemoveAliasesBulkRequest = {
  ids: array<string>,
  aliases: array<string>,
}

let postAdminEmojiRemoveAliasesBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
    aliases: s.field("aliases", S.array(S.string)),
  })

type postAdminEmojiRemoveAliasesBulkResponse = unit

/**
 * admin/emoji/remove-aliases-bulk
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiRemoveAliasesBulk = (~body: postAdminEmojiRemoveAliasesBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiRemoveAliasesBulkResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiRemoveAliasesBulkRequestSchema)
  fetch(
    ~url="/admin/emoji/remove-aliases-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminEmojiSetAliasesBulkRequest = {
  ids: array<string>,
  aliases: array<string>,
}

let postAdminEmojiSetAliasesBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
    aliases: s.field("aliases", S.array(S.string)),
  })

type postAdminEmojiSetAliasesBulkResponse = unit

/**
 * admin/emoji/set-aliases-bulk
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiSetAliasesBulk = (~body: postAdminEmojiSetAliasesBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiSetAliasesBulkResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiSetAliasesBulkRequestSchema)
  fetch(
    ~url="/admin/emoji/set-aliases-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminEmojiSetCategoryBulkRequest = {
  ids: array<string>,
  category: option<string>,
}

let postAdminEmojiSetCategoryBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
    category: s.fieldOr("category", S.nullableAsOption(S.string), None),
  })

type postAdminEmojiSetCategoryBulkResponse = unit

/**
 * admin/emoji/set-category-bulk
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiSetCategoryBulk = (~body: postAdminEmojiSetCategoryBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiSetCategoryBulkResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiSetCategoryBulkRequestSchema)
  fetch(
    ~url="/admin/emoji/set-category-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminEmojiSetLicenseBulkRequest = {
  ids: array<string>,
  license: option<string>,
}

let postAdminEmojiSetLicenseBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
    license: s.fieldOr("license", S.nullableAsOption(S.string), None),
  })

type postAdminEmojiSetLicenseBulkResponse = unit

/**
 * admin/emoji/set-license-bulk
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiSetLicenseBulk = (~body: postAdminEmojiSetLicenseBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiSetLicenseBulkResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiSetLicenseBulkRequestSchema)
  fetch(
    ~url="/admin/emoji/set-license-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminEmojiUpdateRequest = {
  id: option<string>,
  name: option<string>,
  fileId: option<string>,
  category: option<string>,
  aliases: option<array<string>>,
  license: option<string>,
  isSensitive: option<bool>,
  localOnly: option<bool>,
  requestedBy: option<string>,
  memo: option<string>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
  roleIdsThatCanNotBeUsedThisEmojiAsReaction: option<array<string>>,
}

let postAdminEmojiUpdateRequestSchema = S.object(s => {
    id: s.fieldOr("id", S.nullableAsOption(S.string), None),
    name: s.fieldOr("name", S.nullableAsOption(S.string->S.pattern(/^[a-zA-Z0-9_]+$/)), None),
    fileId: s.fieldOr("fileId", S.nullableAsOption(S.string), None),
    category: s.fieldOr("category", S.nullableAsOption(S.string), None),
    aliases: s.fieldOr("aliases", S.nullableAsOption(S.array(S.string)), None),
    license: s.fieldOr("license", S.nullableAsOption(S.string), None),
    isSensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    requestedBy: s.fieldOr("requestedBy", S.nullableAsOption(S.string), None),
    memo: s.fieldOr("memo", S.nullableAsOption(S.string), None),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
    roleIdsThatCanNotBeUsedThisEmojiAsReaction: s.fieldOr("roleIdsThatCanNotBeUsedThisEmojiAsReaction", S.nullableAsOption(S.array(S.string)), None),
  })

type postAdminEmojiUpdateResponse = unit

/**
 * admin/emoji/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:emoji*
 */
let postAdminEmojiUpdate = (~body: postAdminEmojiUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminEmojiUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiUpdateRequestSchema)
  fetch(
    ~url="/admin/emoji/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminFederationDeleteAllFilesRequest = {
  host: string,
}

let postAdminFederationDeleteAllFilesRequestSchema = S.object(s => {
    host: s.field("host", S.string),
  })

type postAdminFederationDeleteAllFilesResponse = unit

/**
 * admin/federation/delete-all-files
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:federation*
 */
let postAdminFederationDeleteAllFiles = (~body: postAdminFederationDeleteAllFilesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminFederationDeleteAllFilesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationDeleteAllFilesRequestSchema)
  fetch(
    ~url="/admin/federation/delete-all-files",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminFederationRefreshRemoteInstanceMetadataRequest = {
  host: string,
}

let postAdminFederationRefreshRemoteInstanceMetadataRequestSchema = S.object(s => {
    host: s.field("host", S.string),
  })

type postAdminFederationRefreshRemoteInstanceMetadataResponse = unit

/**
 * admin/federation/refresh-remote-instance-metadata
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:federation*
 */
let postAdminFederationRefreshRemoteInstanceMetadata = (~body: postAdminFederationRefreshRemoteInstanceMetadataRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminFederationRefreshRemoteInstanceMetadataResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationRefreshRemoteInstanceMetadataRequestSchema)
  fetch(
    ~url="/admin/federation/refresh-remote-instance-metadata",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminFederationRemoveAllFollowingRequest = {
  host: string,
}

let postAdminFederationRemoveAllFollowingRequestSchema = S.object(s => {
    host: s.field("host", S.string),
  })

type postAdminFederationRemoveAllFollowingResponse = unit

/**
 * admin/federation/remove-all-following
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:federation*
 */
let postAdminFederationRemoveAllFollowing = (~body: postAdminFederationRemoveAllFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminFederationRemoveAllFollowingResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationRemoveAllFollowingRequestSchema)
  fetch(
    ~url="/admin/federation/remove-all-following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminFederationUpdateInstanceRequest = {
  host: string,
  isSuspended: option<bool>,
  moderationNote: option<string>,
}

let postAdminFederationUpdateInstanceRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    isSuspended: s.fieldOr("isSuspended", S.nullableAsOption(S.bool), None),
    moderationNote: s.fieldOr("moderationNote", S.nullableAsOption(S.string), None),
  })

type postAdminFederationUpdateInstanceResponse = unit

/**
 * admin/federation/update-instance
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:federation*
 */
let postAdminFederationUpdateInstance = (~body: postAdminFederationUpdateInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminFederationUpdateInstanceResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationUpdateInstanceRequestSchema)
  fetch(
    ~url="/admin/federation/update-instance",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminForwardAbuseUserReportRequest = {
  reportId: string,
}

let postAdminForwardAbuseUserReportRequestSchema = S.object(s => {
    reportId: s.field("reportId", S.string),
  })

type postAdminForwardAbuseUserReportResponse = unit

/**
 * admin/forward-abuse-user-report
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:resolve-abuse-user-report*
 */
let postAdminForwardAbuseUserReport = (~body: postAdminForwardAbuseUserReportRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminForwardAbuseUserReportResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminForwardAbuseUserReportRequestSchema)
  fetch(
    ~url="/admin/forward-abuse-user-report",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminGetIndexStatsResponse_1 = {
  tablename: string,
  indexname: string,
}

type postAdminGetIndexStatsResponse = array<postAdminGetIndexStatsResponse_1>

let postAdminGetIndexStatsResponse_1Schema = S.object(s => {
    tablename: s.field("tablename", S.string),
    indexname: s.field("indexname", S.string),
  })

let postAdminGetIndexStatsResponseSchema = S.array(postAdminGetIndexStatsResponse_1Schema)

/**
 * admin/get-index-stats
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:index-stats*
 */
let postAdminGetIndexStats = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminGetIndexStatsResponse> => {

  fetch(
    ~url="/admin/get-index-stats",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminGetIndexStatsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminGetTableStatsResponse = dict<JSON.t>

let postAdminGetTableStatsResponseSchema = S.dict(S.json)

/**
 * admin/get-table-stats
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:table-stats*
 */
let postAdminGetTableStats = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminGetTableStatsResponse> => {

  fetch(
    ~url="/admin/get-table-stats",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminGetTableStatsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminGetUserIpsRequest = {
  userId: string,
}

let postAdminGetUserIpsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminGetUserIpsResponse_1 = {
  ip: string,
  createdAt: string,
}

type postAdminGetUserIpsResponse = array<postAdminGetUserIpsResponse_1>

let postAdminGetUserIpsResponse_1Schema = S.object(s => {
    ip: s.field("ip", S.string),
    createdAt: s.field("createdAt", S.string),
  })

let postAdminGetUserIpsResponseSchema = S.array(postAdminGetUserIpsResponse_1Schema)

/**
 * admin/get-user-ips
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:user-ips*
 */
let postAdminGetUserIps = (~body: postAdminGetUserIpsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminGetUserIpsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminGetUserIpsRequestSchema)
  fetch(
    ~url="/admin/get-user-ips",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminGetUserIpsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminIndieAuthCreateRequest = {
  id: string,
  name: option<string>,
  redirectUris: option<array<string>>,
}

let postAdminIndieAuthCreateRequestSchema = S.object(s => {
    id: s.field("id", S.string->S.min(1)),
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    redirectUris: s.fieldOr("redirectUris", S.nullableAsOption(S.array(S.string)), None),
  })

type postAdminIndieAuthCreateResponse = {
  id: string,
  createdAt: string,
  name: option<string>,
  redirectUris: array<string>,
}

let postAdminIndieAuthCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.nullableAsOption(S.string)),
    redirectUris: s.field("redirectUris", S.array(S.string)),
  })

/**
 * admin/indie-auth/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:indie-auth*
 */
let postAdminIndieAuthCreate = (~body: postAdminIndieAuthCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminIndieAuthCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminIndieAuthCreateRequestSchema)
  fetch(
    ~url="/admin/indie-auth/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminIndieAuthCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminIndieAuthDeleteRequest = {
  id: string,
}

let postAdminIndieAuthDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminIndieAuthDeleteResponse = unit

/**
 * admin/indie-auth/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:indie-auth*
 */
let postAdminIndieAuthDelete = (~body: postAdminIndieAuthDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminIndieAuthDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminIndieAuthDeleteRequestSchema)
  fetch(
    ~url="/admin/indie-auth/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminIndieAuthListRequest = {
  limit: option<int>,
  offset: option<int>,
}

let postAdminIndieAuthListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
  })

type postAdminIndieAuthListResponse_1 = {
  id: string,
  createdAt: string,
  name: option<string>,
  redirectUris: array<string>,
}

type postAdminIndieAuthListResponse = array<postAdminIndieAuthListResponse_1>

let postAdminIndieAuthListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.nullableAsOption(S.string)),
    redirectUris: s.field("redirectUris", S.array(S.string)),
  })

let postAdminIndieAuthListResponseSchema = S.array(postAdminIndieAuthListResponse_1Schema)

/**
 * admin/indie-auth/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:indie-auth*
 */
let postAdminIndieAuthList = (~body: postAdminIndieAuthListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminIndieAuthListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminIndieAuthListRequestSchema)
  fetch(
    ~url="/admin/indie-auth/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminIndieAuthListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminIndieAuthUpdateRequest = {
  id: string,
  name: option<string>,
  redirectUris: option<array<string>>,
}

let postAdminIndieAuthUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string->S.min(1)),
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    redirectUris: s.fieldOr("redirectUris", S.nullableAsOption(S.array(S.string)), None),
  })

type postAdminIndieAuthUpdateResponse = unit

/**
 * admin/indie-auth/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:indie-auth*
 */
let postAdminIndieAuthUpdate = (~body: postAdminIndieAuthUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminIndieAuthUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminIndieAuthUpdateRequestSchema)
  fetch(
    ~url="/admin/indie-auth/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminInviteCreateRequest = {
  count: option<int>,
  expiresAt: option<string>,
}

let postAdminInviteCreateRequestSchema = S.object(s => {
    count: s.fieldOr("count", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    expiresAt: s.fieldOr("expiresAt", S.nullableAsOption(S.string), None),
  })

type postAdminInviteCreateResponse = array<MisskeyIoComponentSchemas.InviteCode.t>

let postAdminInviteCreateResponseSchema = S.array(MisskeyIoComponentSchemas.InviteCode.schema)

/**
 * admin/invite/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:invite-codes*
 */
let postAdminInviteCreate = (~body: postAdminInviteCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminInviteCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminInviteCreateRequestSchema)
  fetch(
    ~url="/admin/invite/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminInviteCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminInviteListRequest = {
  limit: option<int>,
  offset: option<int>,
  @as("type") type_: option<string>,
  sort: option<string>,
}

let postAdminInviteListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    type_: s.fieldOr("type", S.nullableAsOption(S.string), None),
    sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
  })

type postAdminInviteListResponse = array<MisskeyIoComponentSchemas.InviteCode.t>

let postAdminInviteListResponseSchema = S.array(MisskeyIoComponentSchemas.InviteCode.schema)

/**
 * admin/invite/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:invite-codes*
 */
let postAdminInviteList = (~body: postAdminInviteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminInviteListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminInviteListRequestSchema)
  fetch(
    ~url="/admin/invite/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminInviteListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminPromoCreateRequest = {
  noteId: string,
  expiresAt: int,
}

let postAdminPromoCreateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    expiresAt: s.field("expiresAt", S.int),
  })

type postAdminPromoCreateResponse = unit

/**
 * admin/promo/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:promo*
 */
let postAdminPromoCreate = (~body: postAdminPromoCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminPromoCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminPromoCreateRequestSchema)
  fetch(
    ~url="/admin/promo/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminQueueClearRequest = {
  @as("type") type_: string,
  state: string,
}

let postAdminQueueClearRequestSchema = S.object(s => {
    type_: s.field("type", S.string),
    state: s.field("state", S.string),
  })

type postAdminQueueClearResponse = unit

/**
 * admin/queue/clear
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:queue*
 */
let postAdminQueueClear = (~body: postAdminQueueClearRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueClearResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueClearRequestSchema)
  fetch(
    ~url="/admin/queue/clear",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminQueueDeliverDelayedResponse = array<array<JSON.t>>

let postAdminQueueDeliverDelayedResponseSchema = S.array(S.array(S.json))

/**
 * admin/queue/deliver-delayed
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
 */
let postAdminQueueDeliverDelayed = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueDeliverDelayedResponse> => {

  fetch(
    ~url="/admin/queue/deliver-delayed",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminQueueDeliverDelayedResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminQueueInboxDelayedResponse = array<array<JSON.t>>

let postAdminQueueInboxDelayedResponseSchema = S.array(S.array(S.json))

/**
 * admin/queue/inbox-delayed
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:queue*
 */
let postAdminQueueInboxDelayed = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueInboxDelayedResponse> => {

  fetch(
    ~url="/admin/queue/inbox-delayed",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminQueueInboxDelayedResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminQueuePromoteRequest = {
  @as("type") type_: string,
}

let postAdminQueuePromoteRequestSchema = S.object(s => {
    type_: s.field("type", S.string),
  })

type postAdminQueuePromoteResponse = unit

/**
 * admin/queue/promote
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:queue*
 */
let postAdminQueuePromote = (~body: postAdminQueuePromoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueuePromoteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueuePromoteRequestSchema)
  fetch(
    ~url="/admin/queue/promote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminQueueStatsResponse = {
  deliver: MisskeyIoComponentSchemas.QueueCount.t,
  inbox: MisskeyIoComponentSchemas.QueueCount.t,
  db: MisskeyIoComponentSchemas.QueueCount.t,
  objectStorage: MisskeyIoComponentSchemas.QueueCount.t,
}

let postAdminQueueStatsResponseSchema = S.object(s => {
    deliver: s.field("deliver", MisskeyIoComponentSchemas.QueueCount.schema),
    inbox: s.field("inbox", MisskeyIoComponentSchemas.QueueCount.schema),
    db: s.field("db", MisskeyIoComponentSchemas.QueueCount.schema),
    objectStorage: s.field("objectStorage", MisskeyIoComponentSchemas.QueueCount.schema),
  })

/**
 * admin/queue/stats
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:emoji*
 */
let postAdminQueueStats = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminQueueStatsResponse> => {

  fetch(
    ~url="/admin/queue/stats",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminQueueStatsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminRegenerateUserTokenRequest = {
  userId: string,
}

let postAdminRegenerateUserTokenRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminRegenerateUserTokenResponse = unit

/**
 * admin/regenerate-user-token
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:regenerate-user-token*
 */
let postAdminRegenerateUserToken = (~body: postAdminRegenerateUserTokenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRegenerateUserTokenResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRegenerateUserTokenRequestSchema)
  fetch(
    ~url="/admin/regenerate-user-token",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminRelaysAddRequest = {
  inbox: string,
}

let postAdminRelaysAddRequestSchema = S.object(s => {
    inbox: s.field("inbox", S.string),
  })

type postAdminRelaysAddResponse = {
  id: string,
  inbox: string,
  status: string,
}

let postAdminRelaysAddResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    inbox: s.field("inbox", S.string),
    status: s.field("status", S.string),
  })

/**
 * admin/relays/add
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:relays*
 */
let postAdminRelaysAdd = (~body: postAdminRelaysAddRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRelaysAddResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRelaysAddRequestSchema)
  fetch(
    ~url="/admin/relays/add",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminRelaysAddResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminRelaysListResponse_1 = {
  id: string,
  inbox: string,
  status: string,
}

type postAdminRelaysListResponse = array<postAdminRelaysListResponse_1>

let postAdminRelaysListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    inbox: s.field("inbox", S.string),
    status: s.field("status", S.string),
  })

let postAdminRelaysListResponseSchema = S.array(postAdminRelaysListResponse_1Schema)

/**
 * admin/relays/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:relays*
 */
let postAdminRelaysList = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRelaysListResponse> => {

  fetch(
    ~url="/admin/relays/list",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminRelaysListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminRelaysRemoveRequest = {
  inbox: string,
}

let postAdminRelaysRemoveRequestSchema = S.object(s => {
    inbox: s.field("inbox", S.string),
  })

type postAdminRelaysRemoveResponse = unit

/**
 * admin/relays/remove
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:relays*
 */
let postAdminRelaysRemove = (~body: postAdminRelaysRemoveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRelaysRemoveResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRelaysRemoveRequestSchema)
  fetch(
    ~url="/admin/relays/remove",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminResetPasswordRequest = {
  userId: string,
}

let postAdminResetPasswordRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminResetPasswordResponse = {
  password: string,
}

let postAdminResetPasswordResponseSchema = S.object(s => {
    password: s.field("password", S.string->S.min(8)->S.max(8)),
  })

/**
 * admin/reset-password
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:reset-password*
 */
let postAdminResetPassword = (~body: postAdminResetPasswordRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminResetPasswordResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminResetPasswordRequestSchema)
  fetch(
    ~url="/admin/reset-password",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminResetPasswordResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminResolveAbuseUserReportRequest = {
  reportId: string,
  resolvedAs: option<string>,
  forward: option<bool>,
}

let postAdminResolveAbuseUserReportRequestSchema = S.object(s => {
    reportId: s.field("reportId", S.string),
    resolvedAs: s.fieldOr("resolvedAs", S.nullableAsOption(S.string), None),
    forward: s.fieldOr("forward", S.nullableAsOption(S.bool), None),
  })

type postAdminResolveAbuseUserReportResponse = unit

/**
 * admin/resolve-abuse-user-report
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:resolve-abuse-user-report*
 */
let postAdminResolveAbuseUserReport = (~body: postAdminResolveAbuseUserReportRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminResolveAbuseUserReportResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminResolveAbuseUserReportRequestSchema)
  fetch(
    ~url="/admin/resolve-abuse-user-report",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminRolesAssignRequest = {
  roleId: string,
  userId: string,
  memo: option<string>,
  expiresAt: option<int>,
}

let postAdminRolesAssignRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    userId: s.field("userId", S.string),
    memo: s.fieldOr("memo", S.nullableAsOption(S.string), None),
    expiresAt: s.fieldOr("expiresAt", S.nullableAsOption(S.int), None),
  })

type postAdminRolesAssignResponse = unit

/**
 * admin/roles/assign
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
 */
let postAdminRolesAssign = (~body: postAdminRolesAssignRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesAssignResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesAssignRequestSchema)
  fetch(
    ~url="/admin/roles/assign",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminRolesCreateRequest = {
  name: string,
  description: string,
  color: option<string>,
  iconUrl: option<string>,
  target: string,
  condFormula: dict<JSON.t>,
  isPublic: bool,
  isModerator: bool,
  isAdministrator: bool,
  isExplorable: option<bool>,
  asBadge: bool,
  badgeBehavior: option<string>,
  preserveAssignmentOnMoveAccount: option<bool>,
  canEditMembersByModerator: bool,
  displayOrder: float,
  policies: dict<JSON.t>,
}

let postAdminRolesCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    color: s.field("color", S.nullableAsOption(S.string)),
    iconUrl: s.field("iconUrl", S.nullableAsOption(S.string)),
    target: s.field("target", S.string),
    condFormula: s.field("condFormula", S.dict(S.json)),
    isPublic: s.field("isPublic", S.bool),
    isModerator: s.field("isModerator", S.bool),
    isAdministrator: s.field("isAdministrator", S.bool),
    isExplorable: s.fieldOr("isExplorable", S.nullableAsOption(S.bool), None),
    asBadge: s.field("asBadge", S.bool),
    badgeBehavior: s.fieldOr("badgeBehavior", S.nullableAsOption(S.string), None),
    preserveAssignmentOnMoveAccount: s.fieldOr("preserveAssignmentOnMoveAccount", S.nullableAsOption(S.bool), None),
    canEditMembersByModerator: s.field("canEditMembersByModerator", S.bool),
    displayOrder: s.field("displayOrder", S.float),
    policies: s.field("policies", S.dict(S.json)),
  })

type postAdminRolesCreateResponse = MisskeyIoComponentSchemas.Role.t

let postAdminRolesCreateResponseSchema = MisskeyIoComponentSchemas.Role.schema

/**
 * admin/roles/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
 */
let postAdminRolesCreate = (~body: postAdminRolesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesCreateRequestSchema)
  fetch(
    ~url="/admin/roles/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminRolesCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminRolesDeleteRequest = {
  roleId: string,
}

let postAdminRolesDeleteRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
  })

type postAdminRolesDeleteResponse = unit

/**
 * admin/roles/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
 */
let postAdminRolesDelete = (~body: postAdminRolesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesDeleteRequestSchema)
  fetch(
    ~url="/admin/roles/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminRolesListResponse = array<MisskeyIoComponentSchemas.Role.t>

let postAdminRolesListResponseSchema = S.array(MisskeyIoComponentSchemas.Role.schema)

/**
 * admin/roles/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:roles*
 */
let postAdminRolesList = (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesListResponse> => {

  fetch(
    ~url="/admin/roles/list",
    ~method_="POST",
    ~body=None,
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminRolesListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminRolesShowRequest = {
  roleId: string,
}

let postAdminRolesShowRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
  })

type postAdminRolesShowResponse = MisskeyIoComponentSchemas.Role.t

let postAdminRolesShowResponseSchema = MisskeyIoComponentSchemas.Role.schema

/**
 * admin/roles/show
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:roles*
 */
let postAdminRolesShow = (~body: postAdminRolesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesShowRequestSchema)
  fetch(
    ~url="/admin/roles/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminRolesShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminRolesUnassignRequest = {
  roleId: string,
  userId: string,
}

let postAdminRolesUnassignRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    userId: s.field("userId", S.string),
  })

type postAdminRolesUnassignResponse = unit

/**
 * admin/roles/unassign
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
 */
let postAdminRolesUnassign = (~body: postAdminRolesUnassignRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesUnassignResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUnassignRequestSchema)
  fetch(
    ~url="/admin/roles/unassign",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminRolesUpdateRequest = {
  roleId: string,
  name: option<string>,
  description: option<string>,
  color: option<string>,
  iconUrl: option<string>,
  target: option<string>,
  condFormula: option<dict<JSON.t>>,
  isPublic: option<bool>,
  isModerator: option<bool>,
  isAdministrator: option<bool>,
  isExplorable: option<bool>,
  asBadge: option<bool>,
  badgeBehavior: option<string>,
  preserveAssignmentOnMoveAccount: option<bool>,
  canEditMembersByModerator: option<bool>,
  displayOrder: option<float>,
  policies: option<dict<JSON.t>>,
}

let postAdminRolesUpdateRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    description: s.fieldOr("description", S.nullableAsOption(S.string), None),
    color: s.fieldOr("color", S.nullableAsOption(S.string), None),
    iconUrl: s.fieldOr("iconUrl", S.nullableAsOption(S.string), None),
    target: s.fieldOr("target", S.nullableAsOption(S.string), None),
    condFormula: s.fieldOr("condFormula", S.nullableAsOption(S.dict(S.json)), None),
    isPublic: s.fieldOr("isPublic", S.nullableAsOption(S.bool), None),
    isModerator: s.fieldOr("isModerator", S.nullableAsOption(S.bool), None),
    isAdministrator: s.fieldOr("isAdministrator", S.nullableAsOption(S.bool), None),
    isExplorable: s.fieldOr("isExplorable", S.nullableAsOption(S.bool), None),
    asBadge: s.fieldOr("asBadge", S.nullableAsOption(S.bool), None),
    badgeBehavior: s.fieldOr("badgeBehavior", S.nullableAsOption(S.string), None),
    preserveAssignmentOnMoveAccount: s.fieldOr("preserveAssignmentOnMoveAccount", S.nullableAsOption(S.bool), None),
    canEditMembersByModerator: s.fieldOr("canEditMembersByModerator", S.nullableAsOption(S.bool), None),
    displayOrder: s.fieldOr("displayOrder", S.nullableAsOption(S.float), None),
    policies: s.fieldOr("policies", S.nullableAsOption(S.dict(S.json)), None),
  })

type postAdminRolesUpdateResponse = unit

/**
 * admin/roles/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
 */
let postAdminRolesUpdate = (~body: postAdminRolesUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUpdateRequestSchema)
  fetch(
    ~url="/admin/roles/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminRolesUpdateDefaultPoliciesRequest = {
  policies: dict<JSON.t>,
}

let postAdminRolesUpdateDefaultPoliciesRequestSchema = S.object(s => {
    policies: s.field("policies", S.dict(S.json)),
  })

type postAdminRolesUpdateDefaultPoliciesResponse = unit

/**
 * admin/roles/update-default-policies
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
 */
let postAdminRolesUpdateDefaultPolicies = (~body: postAdminRolesUpdateDefaultPoliciesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesUpdateDefaultPoliciesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUpdateDefaultPoliciesRequestSchema)
  fetch(
    ~url="/admin/roles/update-default-policies",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

@unboxed type postAdminRolesUpdateInlinePoliciesRequest_2 = Bool(bool) | Float(float) | String(string)

type postAdminRolesUpdateInlinePoliciesRequest_1 = {
  id: option<string>,
  policy: string,
  operation: option<string>,
  value: option<postAdminRolesUpdateInlinePoliciesRequest_2>,
  memo: option<string>,
}

type postAdminRolesUpdateInlinePoliciesRequest = {
  userId: string,
  policies: array<postAdminRolesUpdateInlinePoliciesRequest_1>,
}

let postAdminRolesUpdateInlinePoliciesRequest_2Schema = S.union([S.bool->S.shape(v => Bool(v)), S.float->S.shape(v => Float(v)), S.string->S.shape(v => String(v))])

let postAdminRolesUpdateInlinePoliciesRequest_1Schema = S.object(s => {
    id: s.fieldOr("id", S.nullableAsOption(S.string), None),
    policy: s.field("policy", S.string),
    operation: s.fieldOr("operation", S.nullableAsOption(S.string), None),
    value: s.fieldOr("value", S.nullableAsOption(S.union([S.bool->S.shape(v => Bool(v)), S.float->S.shape(v => Float(v)), S.string->S.shape(v => String(v))])), None),
    memo: s.fieldOr("memo", S.nullableAsOption(S.string), None),
  })

let postAdminRolesUpdateInlinePoliciesRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    policies: s.field("policies", S.array(postAdminRolesUpdateInlinePoliciesRequest_1Schema)),
  })

type postAdminRolesUpdateInlinePoliciesResponse = unit

/**
 * admin/roles/update-inline-policies
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:roles*
 */
let postAdminRolesUpdateInlinePolicies = (~body: postAdminRolesUpdateInlinePoliciesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesUpdateInlinePoliciesResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUpdateInlinePoliciesRequestSchema)
  fetch(
    ~url="/admin/roles/update-inline-policies",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminRolesUsersRequest = {
  roleId: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postAdminRolesUsersRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
  })

type postAdminRolesUsersResponse_1 = {
  id: string,
  createdAt: string,
  user: MisskeyIoComponentSchemas.UserDetailed.t,
  memo: option<string>,
  expiresAt: option<string>,
}

type postAdminRolesUsersResponse = array<postAdminRolesUsersResponse_1>

let postAdminRolesUsersResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    user: s.field("user", MisskeyIoComponentSchemas.UserDetailed.schema),
    memo: s.field("memo", S.nullableAsOption(S.string)),
    expiresAt: s.field("expiresAt", S.nullableAsOption(S.string)),
  })

let postAdminRolesUsersResponseSchema = S.array(postAdminRolesUsersResponse_1Schema)

/**
 * admin/roles/users
 *
 * No description provided.
 *
 * **Credential required**: *No* / **Permission**: *read:admin:roles*
 */
let postAdminRolesUsers = (~body: postAdminRolesUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminRolesUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUsersRequestSchema)
  fetch(
    ~url="/admin/roles/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminRolesUsersResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminSendEmailRequest = {
  @as("to") to_: string,
  subject: string,
  text: string,
}

let postAdminSendEmailRequestSchema = S.object(s => {
    to_: s.field("to", S.string),
    subject: s.field("subject", S.string),
    text: s.field("text", S.string),
  })

type postAdminSendEmailResponse = unit

/**
 * admin/send-email
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:send-email*
 */
let postAdminSendEmail = (~body: postAdminSendEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSendEmailResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSendEmailRequestSchema)
  fetch(
    ~url="/admin/send-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminShowModerationLogsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  @as("type") type_: option<string>,
  userId: option<string>,
}

let postAdminShowModerationLogsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    type_: s.fieldOr("type", S.nullableAsOption(S.string), None),
    userId: s.fieldOr("userId", S.nullableAsOption(S.string), None),
  })

type postAdminShowModerationLogsResponse_1 = {
  id: string,
  createdAt: string,
  @as("type") type_: string,
  info: dict<JSON.t>,
  userId: string,
  user: MisskeyIoComponentSchemas.UserDetailed.t,
}

type postAdminShowModerationLogsResponse = array<postAdminShowModerationLogsResponse_1>

let postAdminShowModerationLogsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    type_: s.field("type", S.string),
    info: s.field("info", S.dict(S.json)),
    userId: s.field("userId", S.string),
    user: s.field("user", MisskeyIoComponentSchemas.UserDetailed.schema),
  })

let postAdminShowModerationLogsResponseSchema = S.array(postAdminShowModerationLogsResponse_1Schema)

/**
 * admin/show-moderation-logs
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:show-moderation-log*
 */
let postAdminShowModerationLogs = (~body: postAdminShowModerationLogsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminShowModerationLogsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowModerationLogsRequestSchema)
  fetch(
    ~url="/admin/show-moderation-logs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminShowModerationLogsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminShowUserRequest = {
  userId: string,
}

let postAdminShowUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

@unboxed type postAdminShowUserResponse_4 = Bool(bool) | Float(float) | String(string)

type postAdminShowUserResponse_3 = {
  id: string,
  createdAt: string,
  updatedAt: string,
  policy: string,
  operation: string,
  value: option<postAdminShowUserResponse_4>,
  memo: option<string>,
}

type postAdminShowUserResponse_2 = {
  createdAt: string,
  expiresAt: option<string>,
  roleId: string,
  memo: option<string>,
}

type postAdminShowUserResponse_1 = {
  note: option<dict<JSON.t>>,
  follow: option<dict<JSON.t>>,
  mention: option<dict<JSON.t>>,
  reply: option<dict<JSON.t>>,
  renote: option<dict<JSON.t>>,
  quote: option<dict<JSON.t>>,
  reaction: option<dict<JSON.t>>,
  pollEnded: option<dict<JSON.t>>,
  receiveFollowRequest: option<dict<JSON.t>>,
  followRequestAccepted: option<dict<JSON.t>>,
  roleAssigned: option<dict<JSON.t>>,
  chatRoomInvitationReceived: option<dict<JSON.t>>,
  achievementEarned: option<dict<JSON.t>>,
  app: option<dict<JSON.t>>,
  test: option<dict<JSON.t>>,
}

type postAdminShowUserResponse = {
  email: option<string>,
  emailVerified: bool,
  followedMessage: option<string>,
  autoAcceptFollowed: bool,
  noCrawle: bool,
  preventAiLearning: bool,
  alwaysMarkNsfw: bool,
  autoSensitive: bool,
  carefulBot: bool,
  injectFeaturedNote: bool,
  receiveAnnouncementEmail: bool,
  mutedWords: array<array<string>>,
  mutedInstances: array<string>,
  notificationRecieveConfig: postAdminShowUserResponse_1,
  isModerator: bool,
  isSilenced: bool,
  isLimited: bool,
  isDeleted: bool,
  isSuspended: bool,
  isHibernated: bool,
  lastActiveDate: option<string>,
  moderationNote: string,
  signins: array<MisskeyIoComponentSchemas.Signin.t>,
  policies: MisskeyIoComponentSchemas.RolePolicies.t,
  roles: array<MisskeyIoComponentSchemas.Role.t>,
  roleAssigns: array<postAdminShowUserResponse_2>,
  inlinePolicies: array<postAdminShowUserResponse_3>,
}

let postAdminShowUserResponse_4Schema = S.union([S.bool->S.shape(v => Bool(v)), S.float->S.shape(v => Float(v)), S.string->S.shape(v => String(v))])

let postAdminShowUserResponse_3Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    policy: s.field("policy", S.string),
    operation: s.field("operation", S.string),
    value: s.field("value", S.nullableAsOption(S.union([S.bool->S.shape(v => Bool(v)), S.float->S.shape(v => Float(v)), S.string->S.shape(v => String(v))]))),
    memo: s.field("memo", S.nullableAsOption(S.string)),
  })

let postAdminShowUserResponse_2Schema = S.object(s => {
    createdAt: s.field("createdAt", S.string),
    expiresAt: s.field("expiresAt", S.nullableAsOption(S.string)),
    roleId: s.field("roleId", S.string),
    memo: s.field("memo", S.nullableAsOption(S.string)),
  })

let postAdminShowUserResponse_1Schema = S.object(s => {
    note: s.fieldOr("note", S.nullableAsOption(S.dict(S.json)), None),
    follow: s.fieldOr("follow", S.nullableAsOption(S.dict(S.json)), None),
    mention: s.fieldOr("mention", S.nullableAsOption(S.dict(S.json)), None),
    reply: s.fieldOr("reply", S.nullableAsOption(S.dict(S.json)), None),
    renote: s.fieldOr("renote", S.nullableAsOption(S.dict(S.json)), None),
    quote: s.fieldOr("quote", S.nullableAsOption(S.dict(S.json)), None),
    reaction: s.fieldOr("reaction", S.nullableAsOption(S.dict(S.json)), None),
    pollEnded: s.fieldOr("pollEnded", S.nullableAsOption(S.dict(S.json)), None),
    receiveFollowRequest: s.fieldOr("receiveFollowRequest", S.nullableAsOption(S.dict(S.json)), None),
    followRequestAccepted: s.fieldOr("followRequestAccepted", S.nullableAsOption(S.dict(S.json)), None),
    roleAssigned: s.fieldOr("roleAssigned", S.nullableAsOption(S.dict(S.json)), None),
    chatRoomInvitationReceived: s.fieldOr("chatRoomInvitationReceived", S.nullableAsOption(S.dict(S.json)), None),
    achievementEarned: s.fieldOr("achievementEarned", S.nullableAsOption(S.dict(S.json)), None),
    app: s.fieldOr("app", S.nullableAsOption(S.dict(S.json)), None),
    test: s.fieldOr("test", S.nullableAsOption(S.dict(S.json)), None),
  })

let postAdminShowUserResponseSchema = S.object(s => {
    email: s.field("email", S.nullableAsOption(S.string)),
    emailVerified: s.field("emailVerified", S.bool),
    followedMessage: s.field("followedMessage", S.nullableAsOption(S.string)),
    autoAcceptFollowed: s.field("autoAcceptFollowed", S.bool),
    noCrawle: s.field("noCrawle", S.bool),
    preventAiLearning: s.field("preventAiLearning", S.bool),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.bool),
    autoSensitive: s.field("autoSensitive", S.bool),
    carefulBot: s.field("carefulBot", S.bool),
    injectFeaturedNote: s.field("injectFeaturedNote", S.bool),
    receiveAnnouncementEmail: s.field("receiveAnnouncementEmail", S.bool),
    mutedWords: s.field("mutedWords", S.array(S.array(S.string))),
    mutedInstances: s.field("mutedInstances", S.array(S.string)),
    notificationRecieveConfig: s.field("notificationRecieveConfig", postAdminShowUserResponse_1Schema),
    isModerator: s.field("isModerator", S.bool),
    isSilenced: s.field("isSilenced", S.bool),
    isLimited: s.field("isLimited", S.bool),
    isDeleted: s.field("isDeleted", S.bool),
    isSuspended: s.field("isSuspended", S.bool),
    isHibernated: s.field("isHibernated", S.bool),
    lastActiveDate: s.field("lastActiveDate", S.nullableAsOption(S.string)),
    moderationNote: s.field("moderationNote", S.string),
    signins: s.field("signins", S.array(MisskeyIoComponentSchemas.Signin.schema)),
    policies: s.field("policies", MisskeyIoComponentSchemas.RolePolicies.schema),
    roles: s.field("roles", S.array(MisskeyIoComponentSchemas.Role.schema)),
    roleAssigns: s.field("roleAssigns", S.array(postAdminShowUserResponse_2Schema)),
    inlinePolicies: s.field("inlinePolicies", S.array(postAdminShowUserResponse_3Schema)),
  })

/**
 * admin/show-user
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:show-user*
 */
let postAdminShowUser = (~body: postAdminShowUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminShowUserResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowUserRequestSchema)
  fetch(
    ~url="/admin/show-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminShowUserResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminShowUserAccountMoveLogsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  movedFromId: option<string>,
  movedToId: option<string>,
  from: option<string>,
  @as("to") to_: option<string>,
}

let postAdminShowUserAccountMoveLogsRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    movedFromId: s.fieldOr("movedFromId", S.nullableAsOption(S.string), None),
    movedToId: s.fieldOr("movedToId", S.nullableAsOption(S.string), None),
    from: s.fieldOr("from", S.nullableAsOption(S.string), None),
    to_: s.fieldOr("to", S.nullableAsOption(S.string), None),
  })

type postAdminShowUserAccountMoveLogsResponse_1 = {
  id: string,
  createdAt: string,
  movedToId: string,
  movedTo: MisskeyIoComponentSchemas.UserDetailed.t,
  movedFromId: string,
  movedFrom: MisskeyIoComponentSchemas.UserDetailed.t,
}

type postAdminShowUserAccountMoveLogsResponse = array<postAdminShowUserAccountMoveLogsResponse_1>

let postAdminShowUserAccountMoveLogsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    movedToId: s.field("movedToId", S.string),
    movedTo: s.field("movedTo", MisskeyIoComponentSchemas.UserDetailed.schema),
    movedFromId: s.field("movedFromId", S.string),
    movedFrom: s.field("movedFrom", MisskeyIoComponentSchemas.UserDetailed.schema),
  })

let postAdminShowUserAccountMoveLogsResponseSchema = S.array(postAdminShowUserAccountMoveLogsResponse_1Schema)

/**
 * admin/show-user-account-move-logs
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:show-account-move-log*
 */
let postAdminShowUserAccountMoveLogs = (~body: postAdminShowUserAccountMoveLogsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminShowUserAccountMoveLogsResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowUserAccountMoveLogsRequestSchema)
  fetch(
    ~url="/admin/show-user-account-move-logs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminShowUserAccountMoveLogsResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminShowUsersRequest = {
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
  state: option<string>,
  origin: option<string>,
  username: option<string>,
  hostname: option<string>,
}

let postAdminShowUsersRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
    sort: s.fieldOr("sort", S.nullableAsOption(S.string), None),
    state: s.fieldOr("state", S.nullableAsOption(S.string), None),
    origin: s.fieldOr("origin", S.nullableAsOption(S.string), None),
    username: s.fieldOr("username", S.nullableAsOption(S.string), None),
    hostname: s.fieldOr("hostname", S.nullableAsOption(S.string), None),
  })

type postAdminShowUsersResponse = array<MisskeyIoComponentSchemas.UserDetailed.t>

let postAdminShowUsersResponseSchema = S.array(MisskeyIoComponentSchemas.UserDetailed.schema)

/**
 * admin/show-users
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:show-user*
 */
let postAdminShowUsers = (~body: postAdminShowUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminShowUsersResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowUsersRequestSchema)
  fetch(
    ~url="/admin/show-users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminShowUsersResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminSsoCreateRequest = {
  name: option<string>,
  @as("type") type_: string,
  issuer: string,
  audience: option<array<string>>,
  binding: option<string>,
  acsUrl: string,
  signatureAlgorithm: string,
  cipherAlgorithm: option<string>,
  wantAuthnRequestsSigned: option<bool>,
  wantAssertionsSigned: option<bool>,
  wantEmailAddressNormalized: option<bool>,
  useCertificate: bool,
  secret: option<string>,
}

let postAdminSsoCreateRequestSchema = S.object(s => {
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    type_: s.field("type", S.string),
    issuer: s.field("issuer", S.string),
    audience: s.fieldOr("audience", S.nullableAsOption(S.array(S.string)), None),
    binding: s.fieldOr("binding", S.nullableAsOption(S.string), None),
    acsUrl: s.field("acsUrl", S.string),
    signatureAlgorithm: s.field("signatureAlgorithm", S.string),
    cipherAlgorithm: s.fieldOr("cipherAlgorithm", S.nullableAsOption(S.string), None),
    wantAuthnRequestsSigned: s.fieldOr("wantAuthnRequestsSigned", S.nullableAsOption(S.bool), None),
    wantAssertionsSigned: s.fieldOr("wantAssertionsSigned", S.nullableAsOption(S.bool), None),
    wantEmailAddressNormalized: s.fieldOr("wantEmailAddressNormalized", S.nullableAsOption(S.bool), None),
    useCertificate: s.field("useCertificate", S.bool),
    secret: s.fieldOr("secret", S.nullableAsOption(S.string), None),
  })

type postAdminSsoCreateResponse = {
  id: string,
  createdAt: string,
  name: option<string>,
  @as("type") type_: string,
  issuer: string,
  audience: array<string>,
  binding: string,
  acsUrl: string,
  publicKey: string,
  signatureAlgorithm: string,
  cipherAlgorithm: option<string>,
  wantAuthnRequestsSigned: bool,
  wantAssertionsSigned: bool,
  wantEmailAddressNormalized: bool,
}

let postAdminSsoCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.nullableAsOption(S.string)),
    type_: s.field("type", S.string),
    issuer: s.field("issuer", S.string),
    audience: s.field("audience", S.array(S.string)),
    binding: s.field("binding", S.string),
    acsUrl: s.field("acsUrl", S.string),
    publicKey: s.field("publicKey", S.string),
    signatureAlgorithm: s.field("signatureAlgorithm", S.string),
    cipherAlgorithm: s.fieldOr("cipherAlgorithm", S.nullableAsOption(S.string), None),
    wantAuthnRequestsSigned: s.field("wantAuthnRequestsSigned", S.bool),
    wantAssertionsSigned: s.field("wantAssertionsSigned", S.bool),
    wantEmailAddressNormalized: s.field("wantEmailAddressNormalized", S.bool),
  })

/**
 * admin/sso/create
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:sso*
 */
let postAdminSsoCreate = (~body: postAdminSsoCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSsoCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSsoCreateRequestSchema)
  fetch(
    ~url="/admin/sso/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminSsoCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminSsoDeleteRequest = {
  id: string,
}

let postAdminSsoDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminSsoDeleteResponse = unit

/**
 * admin/sso/delete
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:sso*
 */
let postAdminSsoDelete = (~body: postAdminSsoDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSsoDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSsoDeleteRequestSchema)
  fetch(
    ~url="/admin/sso/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminSsoListRequest = {
  limit: option<int>,
  offset: option<int>,
}

let postAdminSsoListRequestSchema = S.object(s => {
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    offset: s.fieldOr("offset", S.nullableAsOption(S.int), None),
  })

type postAdminSsoListResponse_1 = {
  id: string,
  createdAt: string,
  name: option<string>,
  @as("type") type_: string,
  issuer: string,
  audience: array<string>,
  binding: string,
  acsUrl: string,
  useCertificate: bool,
  publicKey: string,
  signatureAlgorithm: string,
  cipherAlgorithm: option<string>,
  wantAuthnRequestsSigned: bool,
  wantAssertionsSigned: bool,
  wantEmailAddressNormalized: bool,
}

type postAdminSsoListResponse = array<postAdminSsoListResponse_1>

let postAdminSsoListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.nullableAsOption(S.string)),
    type_: s.field("type", S.string),
    issuer: s.field("issuer", S.string),
    audience: s.field("audience", S.array(S.string)),
    binding: s.field("binding", S.string),
    acsUrl: s.field("acsUrl", S.string),
    useCertificate: s.field("useCertificate", S.bool),
    publicKey: s.field("publicKey", S.string),
    signatureAlgorithm: s.field("signatureAlgorithm", S.string),
    cipherAlgorithm: s.fieldOr("cipherAlgorithm", S.nullableAsOption(S.string), None),
    wantAuthnRequestsSigned: s.field("wantAuthnRequestsSigned", S.bool),
    wantAssertionsSigned: s.field("wantAssertionsSigned", S.bool),
    wantEmailAddressNormalized: s.field("wantEmailAddressNormalized", S.bool),
  })

let postAdminSsoListResponseSchema = S.array(postAdminSsoListResponse_1Schema)

/**
 * admin/sso/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:sso*
 */
let postAdminSsoList = (~body: postAdminSsoListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSsoListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSsoListRequestSchema)
  fetch(
    ~url="/admin/sso/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminSsoListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminSsoUpdateRequest = {
  id: string,
  name: option<string>,
  issuer: option<string>,
  audience: option<array<string>>,
  binding: option<string>,
  acsUrl: option<string>,
  signatureAlgorithm: option<string>,
  cipherAlgorithm: option<string>,
  wantAuthnRequestsSigned: option<bool>,
  wantAssertionsSigned: option<bool>,
  wantEmailAddressNormalized: option<bool>,
  regenerateCertificate: option<bool>,
  secret: option<string>,
}

let postAdminSsoUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    issuer: s.fieldOr("issuer", S.nullableAsOption(S.string), None),
    audience: s.fieldOr("audience", S.nullableAsOption(S.array(S.string)), None),
    binding: s.fieldOr("binding", S.nullableAsOption(S.string), None),
    acsUrl: s.fieldOr("acsUrl", S.nullableAsOption(S.string), None),
    signatureAlgorithm: s.fieldOr("signatureAlgorithm", S.nullableAsOption(S.string), None),
    cipherAlgorithm: s.fieldOr("cipherAlgorithm", S.nullableAsOption(S.string), None),
    wantAuthnRequestsSigned: s.fieldOr("wantAuthnRequestsSigned", S.nullableAsOption(S.bool), None),
    wantAssertionsSigned: s.fieldOr("wantAssertionsSigned", S.nullableAsOption(S.bool), None),
    wantEmailAddressNormalized: s.fieldOr("wantEmailAddressNormalized", S.nullableAsOption(S.bool), None),
    regenerateCertificate: s.fieldOr("regenerateCertificate", S.nullableAsOption(S.bool), None),
    secret: s.fieldOr("secret", S.nullableAsOption(S.string), None),
  })

type postAdminSsoUpdateResponse = unit

/**
 * admin/sso/update
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:sso*
 */
let postAdminSsoUpdate = (~body: postAdminSsoUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSsoUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSsoUpdateRequestSchema)
  fetch(
    ~url="/admin/sso/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminSuspendUserRequest = {
  userId: string,
}

let postAdminSuspendUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminSuspendUserResponse = unit

/**
 * admin/suspend-user
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:suspend-user*
 */
let postAdminSuspendUser = (~body: postAdminSuspendUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSuspendUserResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSuspendUserRequestSchema)
  fetch(
    ~url="/admin/suspend-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminSystemWebhookCreateRequest = {
  isActive: bool,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
}

let postAdminSystemWebhookCreateRequestSchema = S.object(s => {
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string->S.min(1)->S.max(1024)),
    secret: s.field("secret", S.string->S.min(1)->S.max(1024)),
  })

type postAdminSystemWebhookCreateResponse = MisskeyIoComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookCreateResponseSchema = MisskeyIoComponentSchemas.SystemWebhook.schema

/**
 * admin/system-webhook/create
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
 */
let postAdminSystemWebhookCreate = (~body: postAdminSystemWebhookCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookCreateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookCreateRequestSchema)
  fetch(
    ~url="/admin/system-webhook/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminSystemWebhookCreateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminSystemWebhookDeleteRequest = {
  id: string,
}

let postAdminSystemWebhookDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminSystemWebhookDeleteResponse = unit

/**
 * admin/system-webhook/delete
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
 */
let postAdminSystemWebhookDelete = (~body: postAdminSystemWebhookDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookDeleteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookDeleteRequestSchema)
  fetch(
    ~url="/admin/system-webhook/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminSystemWebhookListRequest = {
  isActive: option<bool>,
  on: option<array<string>>,
}

let postAdminSystemWebhookListRequestSchema = S.object(s => {
    isActive: s.fieldOr("isActive", S.nullableAsOption(S.bool), None),
    on: s.fieldOr("on", S.nullableAsOption(S.array(S.string)), None),
  })

type postAdminSystemWebhookListResponse = array<MisskeyIoComponentSchemas.SystemWebhook.t>

let postAdminSystemWebhookListResponseSchema = S.array(MisskeyIoComponentSchemas.SystemWebhook.schema)

/**
 * admin/system-webhook/list
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
 */
let postAdminSystemWebhookList = (~body: postAdminSystemWebhookListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookListRequestSchema)
  fetch(
    ~url="/admin/system-webhook/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminSystemWebhookListResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminSystemWebhookShowRequest = {
  id: string,
}

let postAdminSystemWebhookShowRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminSystemWebhookShowResponse = MisskeyIoComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookShowResponseSchema = MisskeyIoComponentSchemas.SystemWebhook.schema

/**
 * admin/system-webhook/show
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
 */
let postAdminSystemWebhookShow = (~body: postAdminSystemWebhookShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookShowResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookShowRequestSchema)
  fetch(
    ~url="/admin/system-webhook/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminSystemWebhookShowResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminSystemWebhookUpdateRequest = {
  id: string,
  isActive: bool,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
}

let postAdminSystemWebhookUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string->S.min(1)->S.max(1024)),
    secret: s.field("secret", S.string->S.min(1)->S.max(1024)),
  })

type postAdminSystemWebhookUpdateResponse = MisskeyIoComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookUpdateResponseSchema = MisskeyIoComponentSchemas.SystemWebhook.schema

/**
 * admin/system-webhook/update
 *
 * No description provided.
 *
 * **Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
 * **Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
 */
let postAdminSystemWebhookUpdate = (~body: postAdminSystemWebhookUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminSystemWebhookUpdateResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookUpdateRequestSchema)
  fetch(
    ~url="/admin/system-webhook/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminSystemWebhookUpdateResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminUnsetUserAvatarRequest = {
  userId: string,
}

let postAdminUnsetUserAvatarRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminUnsetUserAvatarResponse = unit

/**
 * admin/unset-user-avatar
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:user-avatar*
 */
let postAdminUnsetUserAvatar = (~body: postAdminUnsetUserAvatarRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUnsetUserAvatarResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUnsetUserAvatarRequestSchema)
  fetch(
    ~url="/admin/unset-user-avatar",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminUnsetUserBannerRequest = {
  userId: string,
}

let postAdminUnsetUserBannerRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminUnsetUserBannerResponse = unit

/**
 * admin/unset-user-banner
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:user-banner*
 */
let postAdminUnsetUserBanner = (~body: postAdminUnsetUserBannerRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUnsetUserBannerResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUnsetUserBannerRequestSchema)
  fetch(
    ~url="/admin/unset-user-banner",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminUnsetUserMutualLinkRequest = {
  userId: string,
  itemId: string,
}

let postAdminUnsetUserMutualLinkRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    itemId: s.field("itemId", S.string),
  })

type postAdminUnsetUserMutualLinkResponse = unit

/**
 * admin/unset-user-mutual-link
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:user-mutual-link*
 */
let postAdminUnsetUserMutualLink = (~body: postAdminUnsetUserMutualLinkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUnsetUserMutualLinkResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUnsetUserMutualLinkRequestSchema)
  fetch(
    ~url="/admin/unset-user-mutual-link",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminUnsuspendUserRequest = {
  userId: string,
}

let postAdminUnsuspendUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminUnsuspendUserResponse = unit

/**
 * admin/unsuspend-user
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:unsuspend-user*
 */
let postAdminUnsuspendUser = (~body: postAdminUnsuspendUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUnsuspendUserResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUnsuspendUserRequestSchema)
  fetch(
    ~url="/admin/unsuspend-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminUpdateAbuseUserReportRequest = {
  reportId: string,
  moderationNote: option<string>,
}

let postAdminUpdateAbuseUserReportRequestSchema = S.object(s => {
    reportId: s.field("reportId", S.string),
    moderationNote: s.fieldOr("moderationNote", S.nullableAsOption(S.string), None),
  })

type postAdminUpdateAbuseUserReportResponse = unit

/**
 * admin/update-abuse-user-report
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:resolve-abuse-user-report*
 */
let postAdminUpdateAbuseUserReport = (~body: postAdminUpdateAbuseUserReportRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUpdateAbuseUserReportResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateAbuseUserReportRequestSchema)
  fetch(
    ~url="/admin/update-abuse-user-report",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminUpdateMetaRequest = {
  disableRegistration: option<bool>,
  pinnedUsers: option<JSON.t>,
  hiddenTags: option<JSON.t>,
  blockedHosts: option<JSON.t>,
  sensitiveWords: option<JSON.t>,
  blockedRemoteCustomEmojis: option<JSON.t>,
  prohibitedWords: option<JSON.t>,
  themeColor: option<string>,
  mascotImageUrl: option<string>,
  bannerUrl: option<string>,
  serverErrorImageUrl: option<string>,
  infoImageUrl: option<string>,
  notFoundImageUrl: option<string>,
  iconUrl: option<string>,
  @as("app192IconUrl") app192iconUrl: option<string>,
  @as("app512IconUrl") app512iconUrl: option<string>,
  backgroundImageUrl: option<string>,
  logoImageUrl: option<string>,
  name: option<string>,
  shortName: option<string>,
  description: option<string>,
  defaultLightTheme: option<string>,
  defaultDarkTheme: option<string>,
  cacheRemoteFiles: option<bool>,
  cacheRemoteSensitiveFiles: option<bool>,
  emailRequiredForSignup: option<bool>,
  enableHcaptcha: option<bool>,
  hcaptchaSiteKey: option<string>,
  hcaptchaSecretKey: option<string>,
  enableMcaptcha: option<bool>,
  mcaptchaSiteKey: option<string>,
  mcaptchaInstanceUrl: option<string>,
  mcaptchaSecretKey: option<string>,
  enableRecaptcha: option<bool>,
  recaptchaSiteKey: option<string>,
  recaptchaSecretKey: option<string>,
  enableTurnstile: option<bool>,
  turnstileSiteKey: option<string>,
  turnstileSecretKey: option<string>,
  googleAnalyticsId: option<string>,
  sensitiveMediaDetection: option<string>,
  sensitiveMediaDetectionSensitivity: option<string>,
  setSensitiveFlagAutomatically: option<bool>,
  enableSensitiveMediaDetectionForVideos: option<bool>,
  maintainerName: option<string>,
  maintainerEmail: option<string>,
  langs: option<array<string>>,
  dimensions: option<int>,
  deeplAuthKey: option<string>,
  deeplIsPro: option<bool>,
  enableEmail: option<bool>,
  email: option<string>,
  smtpSecure: option<bool>,
  smtpHost: option<string>,
  smtpPort: option<int>,
  smtpUser: option<string>,
  smtpPass: option<string>,
  enableServiceWorker: option<bool>,
  swPublicKey: option<string>,
  swPrivateKey: option<string>,
  tosUrl: option<string>,
  repositoryUrl: option<string>,
  feedbackUrl: option<string>,
  impressumUrl: option<string>,
  privacyPolicyUrl: option<string>,
  useObjectStorage: option<bool>,
  objectStorageBaseUrl: option<string>,
  objectStorageBucket: option<string>,
  objectStoragePrefix: option<string>,
  objectStorageEndpoint: option<string>,
  objectStorageRegion: option<string>,
  objectStoragePort: option<int>,
  objectStorageAccessKey: option<string>,
  objectStorageSecretKey: option<string>,
  @as("objectStorageUseSSL") objectStorageUseSsl: option<bool>,
  objectStorageUseProxy: option<bool>,
  objectStorageSetPublicRead: option<bool>,
  @as("objectStorageS3ForcePathStyle") objectStorageS3forcePathStyle: option<bool>,
  enableIpLogging: option<bool>,
  enableActiveEmailValidation: option<bool>,
  enableVerifymailApi: option<bool>,
  verifymailAuthKey: option<string>,
  enableTruemailApi: option<bool>,
  truemailInstance: option<string>,
  truemailAuthKey: option<string>,
  enableChartsForRemoteUser: option<bool>,
  enableChartsForFederatedInstances: option<bool>,
  enableServerMachineStats: option<bool>,
  enableIdenticonGeneration: option<bool>,
  serverRules: option<array<string>>,
  bannedEmailDomains: option<array<string>>,
  preservedUsernames: option<array<string>>,
  manifestJsonOverride: option<string>,
  enableFanoutTimeline: option<bool>,
  enableFanoutTimelineDbFallback: option<bool>,
  perLocalUserUserTimelineCacheMax: option<int>,
  perRemoteUserUserTimelineCacheMax: option<int>,
  perUserHomeTimelineCacheMax: option<int>,
  perUserListTimelineCacheMax: option<int>,
  notesPerOneAd: option<int>,
  silencedHosts: option<JSON.t>,
  sensitiveMediaHosts: option<JSON.t>,
  wellKnownWebsites: option<JSON.t>,
  urlPreviewDenyList: option<JSON.t>,
  featuredGameChannels: option<JSON.t>,
  summalyProxy: option<string>,
  urlPreviewEnabled: option<bool>,
  urlPreviewTimeout: option<int>,
  urlPreviewMaximumContentLength: option<int>,
  urlPreviewRequireContentLength: option<bool>,
  urlPreviewUserAgent: option<string>,
  urlPreviewSummaryProxyUrl: option<string>,
  prohibitedWordsForNameOfUser: option<JSON.t>,
  federation: option<string>,
  federationHosts: option<array<string>>,
}

let postAdminUpdateMetaRequestSchema = S.object(s => {
    disableRegistration: s.fieldOr("disableRegistration", S.nullableAsOption(S.bool), None),
    pinnedUsers: s.fieldOr("pinnedUsers", S.nullableAsOption(S.json), None),
    hiddenTags: s.fieldOr("hiddenTags", S.nullableAsOption(S.json), None),
    blockedHosts: s.fieldOr("blockedHosts", S.nullableAsOption(S.json), None),
    sensitiveWords: s.fieldOr("sensitiveWords", S.nullableAsOption(S.json), None),
    blockedRemoteCustomEmojis: s.fieldOr("blockedRemoteCustomEmojis", S.nullableAsOption(S.json), None),
    prohibitedWords: s.fieldOr("prohibitedWords", S.nullableAsOption(S.json), None),
    themeColor: s.fieldOr("themeColor", S.nullableAsOption(S.string->S.pattern(/^#[0-9a-fA-F]{6}$/)), None),
    mascotImageUrl: s.fieldOr("mascotImageUrl", S.nullableAsOption(S.string), None),
    bannerUrl: s.fieldOr("bannerUrl", S.nullableAsOption(S.string), None),
    serverErrorImageUrl: s.fieldOr("serverErrorImageUrl", S.nullableAsOption(S.string), None),
    infoImageUrl: s.fieldOr("infoImageUrl", S.nullableAsOption(S.string), None),
    notFoundImageUrl: s.fieldOr("notFoundImageUrl", S.nullableAsOption(S.string), None),
    iconUrl: s.fieldOr("iconUrl", S.nullableAsOption(S.string), None),
    app192iconUrl: s.fieldOr("app192IconUrl", S.nullableAsOption(S.string), None),
    app512iconUrl: s.fieldOr("app512IconUrl", S.nullableAsOption(S.string), None),
    backgroundImageUrl: s.fieldOr("backgroundImageUrl", S.nullableAsOption(S.string), None),
    logoImageUrl: s.fieldOr("logoImageUrl", S.nullableAsOption(S.string), None),
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    shortName: s.fieldOr("shortName", S.nullableAsOption(S.string), None),
    description: s.fieldOr("description", S.nullableAsOption(S.string), None),
    defaultLightTheme: s.fieldOr("defaultLightTheme", S.nullableAsOption(S.string), None),
    defaultDarkTheme: s.fieldOr("defaultDarkTheme", S.nullableAsOption(S.string), None),
    cacheRemoteFiles: s.fieldOr("cacheRemoteFiles", S.nullableAsOption(S.bool), None),
    cacheRemoteSensitiveFiles: s.fieldOr("cacheRemoteSensitiveFiles", S.nullableAsOption(S.bool), None),
    emailRequiredForSignup: s.fieldOr("emailRequiredForSignup", S.nullableAsOption(S.bool), None),
    enableHcaptcha: s.fieldOr("enableHcaptcha", S.nullableAsOption(S.bool), None),
    hcaptchaSiteKey: s.fieldOr("hcaptchaSiteKey", S.nullableAsOption(S.string), None),
    hcaptchaSecretKey: s.fieldOr("hcaptchaSecretKey", S.nullableAsOption(S.string), None),
    enableMcaptcha: s.fieldOr("enableMcaptcha", S.nullableAsOption(S.bool), None),
    mcaptchaSiteKey: s.fieldOr("mcaptchaSiteKey", S.nullableAsOption(S.string), None),
    mcaptchaInstanceUrl: s.fieldOr("mcaptchaInstanceUrl", S.nullableAsOption(S.string), None),
    mcaptchaSecretKey: s.fieldOr("mcaptchaSecretKey", S.nullableAsOption(S.string), None),
    enableRecaptcha: s.fieldOr("enableRecaptcha", S.nullableAsOption(S.bool), None),
    recaptchaSiteKey: s.fieldOr("recaptchaSiteKey", S.nullableAsOption(S.string), None),
    recaptchaSecretKey: s.fieldOr("recaptchaSecretKey", S.nullableAsOption(S.string), None),
    enableTurnstile: s.fieldOr("enableTurnstile", S.nullableAsOption(S.bool), None),
    turnstileSiteKey: s.fieldOr("turnstileSiteKey", S.nullableAsOption(S.string), None),
    turnstileSecretKey: s.fieldOr("turnstileSecretKey", S.nullableAsOption(S.string), None),
    googleAnalyticsId: s.fieldOr("googleAnalyticsId", S.nullableAsOption(S.string), None),
    sensitiveMediaDetection: s.fieldOr("sensitiveMediaDetection", S.nullableAsOption(S.string), None),
    sensitiveMediaDetectionSensitivity: s.fieldOr("sensitiveMediaDetectionSensitivity", S.nullableAsOption(S.string), None),
    setSensitiveFlagAutomatically: s.fieldOr("setSensitiveFlagAutomatically", S.nullableAsOption(S.bool), None),
    enableSensitiveMediaDetectionForVideos: s.fieldOr("enableSensitiveMediaDetectionForVideos", S.nullableAsOption(S.bool), None),
    maintainerName: s.fieldOr("maintainerName", S.nullableAsOption(S.string), None),
    maintainerEmail: s.fieldOr("maintainerEmail", S.nullableAsOption(S.string), None),
    langs: s.fieldOr("langs", S.nullableAsOption(S.array(S.string)), None),
    dimensions: s.fieldOr("dimensions", S.nullableAsOption(S.int->S.min(1)), None),
    deeplAuthKey: s.fieldOr("deeplAuthKey", S.nullableAsOption(S.string), None),
    deeplIsPro: s.fieldOr("deeplIsPro", S.nullableAsOption(S.bool), None),
    enableEmail: s.fieldOr("enableEmail", S.nullableAsOption(S.bool), None),
    email: s.fieldOr("email", S.nullableAsOption(S.string), None),
    smtpSecure: s.fieldOr("smtpSecure", S.nullableAsOption(S.bool), None),
    smtpHost: s.fieldOr("smtpHost", S.nullableAsOption(S.string), None),
    smtpPort: s.fieldOr("smtpPort", S.nullableAsOption(S.int), None),
    smtpUser: s.fieldOr("smtpUser", S.nullableAsOption(S.string), None),
    smtpPass: s.fieldOr("smtpPass", S.nullableAsOption(S.string), None),
    enableServiceWorker: s.fieldOr("enableServiceWorker", S.nullableAsOption(S.bool), None),
    swPublicKey: s.fieldOr("swPublicKey", S.nullableAsOption(S.string), None),
    swPrivateKey: s.fieldOr("swPrivateKey", S.nullableAsOption(S.string), None),
    tosUrl: s.fieldOr("tosUrl", S.nullableAsOption(S.string), None),
    repositoryUrl: s.fieldOr("repositoryUrl", S.nullableAsOption(S.string), None),
    feedbackUrl: s.fieldOr("feedbackUrl", S.nullableAsOption(S.string), None),
    impressumUrl: s.fieldOr("impressumUrl", S.nullableAsOption(S.string), None),
    privacyPolicyUrl: s.fieldOr("privacyPolicyUrl", S.nullableAsOption(S.string), None),
    useObjectStorage: s.fieldOr("useObjectStorage", S.nullableAsOption(S.bool), None),
    objectStorageBaseUrl: s.fieldOr("objectStorageBaseUrl", S.nullableAsOption(S.string), None),
    objectStorageBucket: s.fieldOr("objectStorageBucket", S.nullableAsOption(S.string), None),
    objectStoragePrefix: s.fieldOr("objectStoragePrefix", S.nullableAsOption(S.string->S.pattern(/^[a-zA-Z0-9._-]*$/)), None),
    objectStorageEndpoint: s.fieldOr("objectStorageEndpoint", S.nullableAsOption(S.string), None),
    objectStorageRegion: s.fieldOr("objectStorageRegion", S.nullableAsOption(S.string), None),
    objectStoragePort: s.fieldOr("objectStoragePort", S.nullableAsOption(S.int), None),
    objectStorageAccessKey: s.fieldOr("objectStorageAccessKey", S.nullableAsOption(S.string), None),
    objectStorageSecretKey: s.fieldOr("objectStorageSecretKey", S.nullableAsOption(S.string), None),
    objectStorageUseSsl: s.fieldOr("objectStorageUseSSL", S.nullableAsOption(S.bool), None),
    objectStorageUseProxy: s.fieldOr("objectStorageUseProxy", S.nullableAsOption(S.bool), None),
    objectStorageSetPublicRead: s.fieldOr("objectStorageSetPublicRead", S.nullableAsOption(S.bool), None),
    objectStorageS3forcePathStyle: s.fieldOr("objectStorageS3ForcePathStyle", S.nullableAsOption(S.bool), None),
    enableIpLogging: s.fieldOr("enableIpLogging", S.nullableAsOption(S.bool), None),
    enableActiveEmailValidation: s.fieldOr("enableActiveEmailValidation", S.nullableAsOption(S.bool), None),
    enableVerifymailApi: s.fieldOr("enableVerifymailApi", S.nullableAsOption(S.bool), None),
    verifymailAuthKey: s.fieldOr("verifymailAuthKey", S.nullableAsOption(S.string), None),
    enableTruemailApi: s.fieldOr("enableTruemailApi", S.nullableAsOption(S.bool), None),
    truemailInstance: s.fieldOr("truemailInstance", S.nullableAsOption(S.string), None),
    truemailAuthKey: s.fieldOr("truemailAuthKey", S.nullableAsOption(S.string), None),
    enableChartsForRemoteUser: s.fieldOr("enableChartsForRemoteUser", S.nullableAsOption(S.bool), None),
    enableChartsForFederatedInstances: s.fieldOr("enableChartsForFederatedInstances", S.nullableAsOption(S.bool), None),
    enableServerMachineStats: s.fieldOr("enableServerMachineStats", S.nullableAsOption(S.bool), None),
    enableIdenticonGeneration: s.fieldOr("enableIdenticonGeneration", S.nullableAsOption(S.bool), None),
    serverRules: s.fieldOr("serverRules", S.nullableAsOption(S.array(S.string)), None),
    bannedEmailDomains: s.fieldOr("bannedEmailDomains", S.nullableAsOption(S.array(S.string)), None),
    preservedUsernames: s.fieldOr("preservedUsernames", S.nullableAsOption(S.array(S.string)), None),
    manifestJsonOverride: s.fieldOr("manifestJsonOverride", S.nullableAsOption(S.string), None),
    enableFanoutTimeline: s.fieldOr("enableFanoutTimeline", S.nullableAsOption(S.bool), None),
    enableFanoutTimelineDbFallback: s.fieldOr("enableFanoutTimelineDbFallback", S.nullableAsOption(S.bool), None),
    perLocalUserUserTimelineCacheMax: s.fieldOr("perLocalUserUserTimelineCacheMax", S.nullableAsOption(S.int), None),
    perRemoteUserUserTimelineCacheMax: s.fieldOr("perRemoteUserUserTimelineCacheMax", S.nullableAsOption(S.int), None),
    perUserHomeTimelineCacheMax: s.fieldOr("perUserHomeTimelineCacheMax", S.nullableAsOption(S.int), None),
    perUserListTimelineCacheMax: s.fieldOr("perUserListTimelineCacheMax", S.nullableAsOption(S.int), None),
    notesPerOneAd: s.fieldOr("notesPerOneAd", S.nullableAsOption(S.int), None),
    silencedHosts: s.fieldOr("silencedHosts", S.nullableAsOption(S.json), None),
    sensitiveMediaHosts: s.fieldOr("sensitiveMediaHosts", S.nullableAsOption(S.json), None),
    wellKnownWebsites: s.fieldOr("wellKnownWebsites", S.nullableAsOption(S.json), None),
    urlPreviewDenyList: s.fieldOr("urlPreviewDenyList", S.nullableAsOption(S.json), None),
    featuredGameChannels: s.fieldOr("featuredGameChannels", S.nullableAsOption(S.json), None),
    summalyProxy: s.fieldOr("summalyProxy", S.nullableAsOption(S.string), None),
    urlPreviewEnabled: s.fieldOr("urlPreviewEnabled", S.nullableAsOption(S.bool), None),
    urlPreviewTimeout: s.fieldOr("urlPreviewTimeout", S.nullableAsOption(S.int), None),
    urlPreviewMaximumContentLength: s.fieldOr("urlPreviewMaximumContentLength", S.nullableAsOption(S.int), None),
    urlPreviewRequireContentLength: s.fieldOr("urlPreviewRequireContentLength", S.nullableAsOption(S.bool), None),
    urlPreviewUserAgent: s.fieldOr("urlPreviewUserAgent", S.nullableAsOption(S.string), None),
    urlPreviewSummaryProxyUrl: s.fieldOr("urlPreviewSummaryProxyUrl", S.nullableAsOption(S.string), None),
    prohibitedWordsForNameOfUser: s.fieldOr("prohibitedWordsForNameOfUser", S.nullableAsOption(S.json), None),
    federation: s.fieldOr("federation", S.nullableAsOption(S.string), None),
    federationHosts: s.fieldOr("federationHosts", S.nullableAsOption(S.array(S.string)), None),
  })

type postAdminUpdateMetaResponse = unit

/**
 * admin/update-meta
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:meta*
 */
let postAdminUpdateMeta = (~body: postAdminUpdateMetaRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUpdateMetaResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateMetaRequestSchema)
  fetch(
    ~url="/admin/update-meta",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminUpdateProxyAccountRequest = {
  description: option<string>,
}

let postAdminUpdateProxyAccountRequestSchema = S.object(s => {
    description: s.fieldOr("description", S.nullableAsOption(S.string->S.min(1)->S.max(1500)), None),
  })

type postAdminUpdateProxyAccountResponse = MisskeyIoComponentSchemas.UserDetailed.t

let postAdminUpdateProxyAccountResponseSchema = MisskeyIoComponentSchemas.UserDetailed.schema

/**
 * admin/update-proxy-account
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:account*
 */
let postAdminUpdateProxyAccount = (~body: postAdminUpdateProxyAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUpdateProxyAccountResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateProxyAccountRequestSchema)
  fetch(
    ~url="/admin/update-proxy-account",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postAdminUpdateProxyAccountResponseSchema)
  value
    ->Promise.resolve
  })
}

type postAdminUpdateUserNameRequest = {
  userId: string,
  name: option<string>,
}

let postAdminUpdateUserNameRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
  })

type postAdminUpdateUserNameResponse = unit

/**
 * admin/update-user-name
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:user-name*
 */
let postAdminUpdateUserName = (~body: postAdminUpdateUserNameRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUpdateUserNameResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateUserNameRequestSchema)
  fetch(
    ~url="/admin/update-user-name",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postAdminUpdateUserNoteRequest = {
  userId: string,
  text: string,
}

let postAdminUpdateUserNoteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    text: s.field("text", S.string),
  })

type postAdminUpdateUserNoteResponse = unit

/**
 * admin/update-user-note
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *write:admin:user-note*
 */
let postAdminUpdateUserNote = (~body: postAdminUpdateUserNoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postAdminUpdateUserNoteResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateUserNoteRequestSchema)
  fetch(
    ~url="/admin/update-user-note",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let _ = response
  ()
    ->Promise.resolve
  })
}

type postV2AdminEmojiListRequest_1 = {
  updatedAtFrom: option<string>,
  updatedAtTo: option<string>,
  name: option<string>,
  host: option<string>,
  uri: option<string>,
  publicUrl: option<string>,
  originalUrl: option<string>,
  @as("type") type_: option<string>,
  aliases: option<string>,
  category: option<string>,
  license: option<string>,
  isSensitive: option<bool>,
  localOnly: option<bool>,
  hostType: option<string>,
  roleIds: option<array<string>>,
}

type postV2AdminEmojiListRequest = {
  query: option<postV2AdminEmojiListRequest_1>,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
  page: option<int>,
  sortKeys: option<array<string>>,
}

let postV2AdminEmojiListRequest_1Schema = S.object(s => {
    updatedAtFrom: s.fieldOr("updatedAtFrom", S.nullableAsOption(S.string), None),
    updatedAtTo: s.fieldOr("updatedAtTo", S.nullableAsOption(S.string), None),
    name: s.fieldOr("name", S.nullableAsOption(S.string), None),
    host: s.fieldOr("host", S.nullableAsOption(S.string), None),
    uri: s.fieldOr("uri", S.nullableAsOption(S.string), None),
    publicUrl: s.fieldOr("publicUrl", S.nullableAsOption(S.string), None),
    originalUrl: s.fieldOr("originalUrl", S.nullableAsOption(S.string), None),
    type_: s.fieldOr("type", S.nullableAsOption(S.string), None),
    aliases: s.fieldOr("aliases", S.nullableAsOption(S.string), None),
    category: s.fieldOr("category", S.nullableAsOption(S.string), None),
    license: s.fieldOr("license", S.nullableAsOption(S.string), None),
    isSensitive: s.fieldOr("isSensitive", S.nullableAsOption(S.bool), None),
    localOnly: s.fieldOr("localOnly", S.nullableAsOption(S.bool), None),
    hostType: s.fieldOr("hostType", S.nullableAsOption(S.string), None),
    roleIds: s.fieldOr("roleIds", S.nullableAsOption(S.array(S.string)), None),
  })

let postV2AdminEmojiListRequestSchema = S.object(s => {
    query: s.fieldOr("query", S.nullableAsOption(postV2AdminEmojiListRequest_1Schema), None),
    sinceId: s.fieldOr("sinceId", S.nullableAsOption(S.string), None),
    untilId: s.fieldOr("untilId", S.nullableAsOption(S.string), None),
    limit: s.fieldOr("limit", S.nullableAsOption(S.int->S.min(1)->S.max(100)), None),
    page: s.fieldOr("page", S.nullableAsOption(S.int), None),
    sortKeys: s.fieldOr("sortKeys", S.nullableAsOption(S.array(S.string)), None),
  })

type postV2AdminEmojiListResponse = {
  emojis: array<MisskeyIoComponentSchemas.EmojiDetailedAdmin.t>,
  count: int,
  allCount: int,
  allPages: int,
}

let postV2AdminEmojiListResponseSchema = S.object(s => {
    emojis: s.field("emojis", S.array(MisskeyIoComponentSchemas.EmojiDetailedAdmin.schema)),
    count: s.field("count", S.int),
    allCount: s.field("allCount", S.int),
    allPages: s.field("allPages", S.int),
  })

/**
 * v2/admin/emoji/list
 *
 * No description provided.
 *
 * **Credential required**: *Yes* / **Permission**: *read:admin:emoji*
 */
let postV2AdminEmojiList = (~body: postV2AdminEmojiListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): promise<postV2AdminEmojiListResponse> => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postV2AdminEmojiListRequestSchema)
  fetch(
    ~url="/v2/admin/emoji/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )->Promise.then(response => {
  let value = response->S.parseOrThrow(postV2AdminEmojiListResponseSchema)
  value
    ->Promise.resolve
  })
}
