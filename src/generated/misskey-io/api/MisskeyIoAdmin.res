// misskey-io API for admin
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postAdminAbuseReportResolverCreateRequest = {
  name: string,
  targetUserPattern: option<string>,
  reporterPattern: option<string>,
  reportContentPattern: option<string>,
  expiresAt: string,
  forward: bool,
}

let postAdminAbuseReportResolverCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)),
    targetUserPattern: s.field("targetUserPattern", S.nullableAsOption(S.string)),
    reporterPattern: s.field("reporterPattern", S.nullableAsOption(S.string)),
    reportContentPattern: s.field("reportContentPattern", S.nullableAsOption(S.string)),
    expiresAt: s.field("expiresAt", S.string),
    forward: s.field("forward", S.bool),
  })

type postAdminAbuseReportResolverCreateResponse = {
  name: string,
  targetUserPattern: option<string>,
  reporterPattern: option<string>,
  reportContentPattern: option<string>,
  expiresAt: string,
  forward: bool,
}

let postAdminAbuseReportResolverCreateResponseSchema = S.object(s => {
    name: s.field("name", S.string),
    targetUserPattern: s.field("targetUserPattern", S.nullableAsOption(S.string)),
    reporterPattern: s.field("reporterPattern", S.nullableAsOption(S.string)),
    reportContentPattern: s.field("reportContentPattern", S.nullableAsOption(S.string)),
    expiresAt: s.field("expiresAt", S.string),
    forward: s.field("forward", S.bool),
  })

/**
admin/abuse-report-resolver/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:abuse-report-resolvers*
*/
let postAdminAbuseReportResolverCreate = async (~body: postAdminAbuseReportResolverCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportResolverCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportResolverCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report-resolver/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAbuseReportResolverCreateResponseSchema)
}

type postAdminAbuseReportResolverDeleteRequest = {
  resolverId: string,
}

let postAdminAbuseReportResolverDeleteRequestSchema = S.object(s => {
    resolverId: s.field("resolverId", S.string),
  })

type postAdminAbuseReportResolverDeleteResponse = unit

/**
admin/abuse-report-resolver/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:abuse-report-resolvers*
*/
let postAdminAbuseReportResolverDelete = async (~body: postAdminAbuseReportResolverDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportResolverDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportResolverDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report-resolver/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAbuseReportResolverListRequest = {
  limit: option<float>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postAdminAbuseReportResolverListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.float->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postAdminAbuseReportResolverListResponse_1 = {
  name: string,
  targetUserPattern: option<string>,
  reporterPattern: option<string>,
  reportContentPattern: option<string>,
  expiresAt: string,
  forward: bool,
}

type postAdminAbuseReportResolverListResponse = array<postAdminAbuseReportResolverListResponse_1>

let postAdminAbuseReportResolverListResponse_1Schema = S.object(s => {
    name: s.field("name", S.string),
    targetUserPattern: s.field("targetUserPattern", S.nullableAsOption(S.string)),
    reporterPattern: s.field("reporterPattern", S.nullableAsOption(S.string)),
    reportContentPattern: s.field("reportContentPattern", S.nullableAsOption(S.string)),
    expiresAt: s.field("expiresAt", S.string),
    forward: s.field("forward", S.bool),
  })

let postAdminAbuseReportResolverListResponseSchema = S.array(postAdminAbuseReportResolverListResponse_1Schema)

/**
admin/abuse-report-resolver/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:abuse-report-resolvers*
*/
let postAdminAbuseReportResolverList = async (~body: postAdminAbuseReportResolverListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportResolverListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportResolverListRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report-resolver/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAbuseReportResolverListResponseSchema)
}

type postAdminAbuseReportResolverUpdateRequest = {
  resolverId: string,
  name: option<string>,
  targetUserPattern: option<string>,
  reporterPattern: option<string>,
  reportContentPattern: option<string>,
  expiresAt: option<string>,
  forward: option<bool>,
}

let postAdminAbuseReportResolverUpdateRequestSchema = S.object(s => {
    resolverId: s.field("resolverId", S.string),
    name: s.field("name", S.option(S.string)),
    targetUserPattern: s.field("targetUserPattern", S.option(S.string)),
    reporterPattern: s.field("reporterPattern", S.option(S.string)),
    reportContentPattern: s.field("reportContentPattern", S.option(S.string)),
    expiresAt: s.field("expiresAt", S.option(S.string)),
    forward: s.field("forward", S.option(S.bool)),
  })

type postAdminAbuseReportResolverUpdateResponse = unit

/**
admin/abuse-report-resolver/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:abuse-report-resolvers*
*/
let postAdminAbuseReportResolverUpdate = async (~body: postAdminAbuseReportResolverUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportResolverUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportResolverUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report-resolver/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAbuseReportNotificationRecipientCreateRequest = {
  isActive: bool,
  name: string,
  @as("method") method_: string,
  userId: option<string>,
  systemWebhookId: option<string>,
}

let postAdminAbuseReportNotificationRecipientCreateRequestSchema = S.object(s => {
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    method_: s.field("method", S.string),
    userId: s.field("userId", S.option(S.string)),
    systemWebhookId: s.field("systemWebhookId", S.option(S.string)),
  })

type postAdminAbuseReportNotificationRecipientCreateResponse = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientCreateResponseSchema = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.schema

/**
admin/abuse-report/notification-recipient/create

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
*/
let postAdminAbuseReportNotificationRecipientCreate = async (~body: postAdminAbuseReportNotificationRecipientCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportNotificationRecipientCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report/notification-recipient/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientCreateResponseSchema)
}

type postAdminAbuseReportNotificationRecipientDeleteRequest = {
  id: string,
}

let postAdminAbuseReportNotificationRecipientDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAbuseReportNotificationRecipientDeleteResponse = unit

/**
admin/abuse-report/notification-recipient/delete

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
*/
let postAdminAbuseReportNotificationRecipientDelete = async (~body: postAdminAbuseReportNotificationRecipientDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportNotificationRecipientDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report/notification-recipient/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAbuseReportNotificationRecipientListRequest = {
  @as("method") method_: option<array<string>>,
}

let postAdminAbuseReportNotificationRecipientListRequestSchema = S.object(s => {
    method_: s.field("method", S.option(S.array(S.string))),
  })

type postAdminAbuseReportNotificationRecipientListResponse = array<MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.t>

let postAdminAbuseReportNotificationRecipientListResponseSchema = S.array(MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.schema)

/**
admin/abuse-report/notification-recipient/list

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *read:admin:abuse-report:notification-recipient*
*/
let postAdminAbuseReportNotificationRecipientList = async (~body: postAdminAbuseReportNotificationRecipientListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportNotificationRecipientListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientListRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report/notification-recipient/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientListResponseSchema)
}

type postAdminAbuseReportNotificationRecipientShowRequest = {
  id: string,
}

let postAdminAbuseReportNotificationRecipientShowRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAbuseReportNotificationRecipientShowResponse = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientShowResponseSchema = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.schema

/**
admin/abuse-report/notification-recipient/show

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *read:admin:abuse-report:notification-recipient*
*/
let postAdminAbuseReportNotificationRecipientShow = async (~body: postAdminAbuseReportNotificationRecipientShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportNotificationRecipientShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientShowRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report/notification-recipient/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientShowResponseSchema)
}

type postAdminAbuseReportNotificationRecipientUpdateRequest = {
  id: string,
  isActive: bool,
  name: string,
  @as("method") method_: string,
  userId: option<string>,
  systemWebhookId: option<string>,
}

let postAdminAbuseReportNotificationRecipientUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    method_: s.field("method", S.string),
    userId: s.field("userId", S.option(S.string)),
    systemWebhookId: s.field("systemWebhookId", S.option(S.string)),
  })

type postAdminAbuseReportNotificationRecipientUpdateResponse = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.t

let postAdminAbuseReportNotificationRecipientUpdateResponseSchema = MisskeyIoComponentSchemas.AbuseReportNotificationRecipient.schema

/**
admin/abuse-report/notification-recipient/update

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:abuse-report:notification-recipient*
*/
let postAdminAbuseReportNotificationRecipientUpdate = async (~body: postAdminAbuseReportNotificationRecipientUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseReportNotificationRecipientUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseReportNotificationRecipientUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-report/notification-recipient/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAbuseReportNotificationRecipientUpdateResponseSchema)
}

type postAdminAbuseUserReportsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  state: option<string>,
  reporterOrigin: option<string>,
  targetUserOrigin: option<string>,
  forwarded: option<bool>,
  category: option<string>,
}

let postAdminAbuseUserReportsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    state: s.field("state", S.option(S.string)),
    reporterOrigin: s.field("reporterOrigin", S.option(S.string)),
    targetUserOrigin: s.field("targetUserOrigin", S.option(S.string)),
    forwarded: s.field("forwarded", S.option(S.bool)),
    category: s.field("category", S.option(S.string)),
  })

type postAdminAbuseUserReportsResponse_1 = {
  id: string,
  createdAt: string,
  comment: string,
  resolved: bool,
  forwarded: bool,
  resolvedAs: option<string>,
  reporterId: string,
  targetUserId: string,
  assigneeId: option<string>,
  reporter: MisskeyIoComponentSchemas.UserDetailed.t,
  targetUser: MisskeyIoComponentSchemas.UserDetailed.t,
  assignee: option<MisskeyIoComponentSchemas.UserDetailed.t>,
  category: string,
  moderationNote: option<string>,
}

type postAdminAbuseUserReportsResponse = array<postAdminAbuseUserReportsResponse_1>

let postAdminAbuseUserReportsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    comment: s.field("comment", S.string),
    resolved: s.field("resolved", S.bool),
    forwarded: s.field("forwarded", S.bool),
    resolvedAs: s.field("resolvedAs", S.nullableAsOption(S.string)),
    reporterId: s.field("reporterId", S.string),
    targetUserId: s.field("targetUserId", S.string),
    assigneeId: s.field("assigneeId", S.nullableAsOption(S.string)),
    reporter: s.field("reporter", MisskeyIoComponentSchemas.UserDetailed.schema),
    targetUser: s.field("targetUser", MisskeyIoComponentSchemas.UserDetailed.schema),
    assignee: s.field("assignee", S.option(MisskeyIoComponentSchemas.UserDetailed.schema)),
    category: s.field("category", S.string),
    moderationNote: s.field("moderationNote", S.nullableAsOption(S.string)),
  })

let postAdminAbuseUserReportsResponseSchema = S.array(postAdminAbuseUserReportsResponse_1Schema)

/**
admin/abuse-user-reports

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:abuse-user-reports*
*/
let postAdminAbuseUserReports = async (~body: postAdminAbuseUserReportsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAbuseUserReportsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAbuseUserReportsRequestSchema)
  let response = await fetch(
    ~url="/admin/abuse-user-reports",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAbuseUserReportsResponseSchema)
}

type postAdminAccountsCreateRequest = {
  username: string,
  password: string,
  setupPassword: option<string>,
}

let postAdminAccountsCreateRequestSchema = S.object(s => {
    username: s.field("username", S.string->S.pattern(/^\w{1,20}$/)),
    password: s.field("password", S.string->S.min(1)),
    setupPassword: s.field("setupPassword", S.option(S.string)),
  })

type postAdminAccountsCreateResponse = MisskeyIoComponentSchemas.MeDetailed.t

let postAdminAccountsCreateResponseSchema = MisskeyIoComponentSchemas.MeDetailed.schema

/**
admin/accounts/create

No description provided.

**Credential required**: *No*
*/
let postAdminAccountsCreate = async (~body: postAdminAccountsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAccountsCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/accounts/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAccountsCreateResponseSchema)
}

type postAdminAccountsDeleteRequest = {
  userId: string,
  soft: option<bool>,
}

let postAdminAccountsDeleteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    soft: s.field("soft", S.option(S.bool)),
  })

type postAdminAccountsDeleteResponse = unit

/**
admin/accounts/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:account*
*/
let postAdminAccountsDelete = async (~body: postAdminAccountsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAccountsDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/accounts/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAccountsFindByEmailRequest = {
  email: string,
}

let postAdminAccountsFindByEmailRequestSchema = S.object(s => {
    email: s.field("email", S.string),
  })

type postAdminAccountsFindByEmailResponse = MisskeyIoComponentSchemas.UserDetailed.t

let postAdminAccountsFindByEmailResponseSchema = MisskeyIoComponentSchemas.UserDetailed.schema

/**
admin/accounts/find-by-email

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:account*
*/
let postAdminAccountsFindByEmail = async (~body: postAdminAccountsFindByEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAccountsFindByEmailResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsFindByEmailRequestSchema)
  let response = await fetch(
    ~url="/admin/accounts/find-by-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAccountsFindByEmailResponseSchema)
}

type postAdminAccountsPendingListRequest = {
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
  username: option<string>,
  email: option<string>,
  code: option<string>,
}

let postAdminAccountsPendingListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
    sort: s.field("sort", S.option(S.string)),
    username: s.field("username", S.option(S.string)),
    email: s.field("email", S.option(S.string)),
    code: s.field("code", S.option(S.string)),
  })

type postAdminAccountsPendingListResponse_1 = {
  id: string,
  createdAt: string,
  code: string,
  username: string,
  email: option<string>,
}

type postAdminAccountsPendingListResponse = array<postAdminAccountsPendingListResponse_1>

let postAdminAccountsPendingListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    code: s.field("code", S.string),
    username: s.field("username", S.string),
    email: s.field("email", S.option(S.string)),
  })

let postAdminAccountsPendingListResponseSchema = S.array(postAdminAccountsPendingListResponse_1Schema)

/**
admin/accounts/pending/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:account*
*/
let postAdminAccountsPendingList = async (~body: postAdminAccountsPendingListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAccountsPendingListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsPendingListRequestSchema)
  let response = await fetch(
    ~url="/admin/accounts/pending/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAccountsPendingListResponseSchema)
}

type postAdminAccountsPendingRevokeRequest = {
  id: option<string>,
  code: option<string>,
}

let postAdminAccountsPendingRevokeRequestSchema = S.object(s => {
    id: s.field("id", S.option(S.string)),
    code: s.field("code", S.option(S.string)),
  })

type postAdminAccountsPendingRevokeResponse = unit

/**
admin/accounts/pending/revoke

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:account*
*/
let postAdminAccountsPendingRevoke = async (~body: postAdminAccountsPendingRevokeRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAccountsPendingRevokeResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAccountsPendingRevokeRequestSchema)
  let response = await fetch(
    ~url="/admin/accounts/pending/revoke",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAdCreateRequest = {
  url: string,
  memo: string,
  place: string,
  priority: string,
  ratio: int,
  expiresAt: int,
  startsAt: int,
  imageUrl: string,
  dayOfWeek: int,
  isSensitive: option<bool>,
}

let postAdminAdCreateRequestSchema = S.object(s => {
    url: s.field("url", S.string->S.min(1)),
    memo: s.field("memo", S.string),
    place: s.field("place", S.string),
    priority: s.field("priority", S.string),
    ratio: s.field("ratio", S.int),
    expiresAt: s.field("expiresAt", S.int),
    startsAt: s.field("startsAt", S.int),
    imageUrl: s.field("imageUrl", S.string->S.min(1)),
    dayOfWeek: s.field("dayOfWeek", S.int),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
  })

type postAdminAdCreateResponse = MisskeyIoComponentSchemas.Ad.t

let postAdminAdCreateResponseSchema = MisskeyIoComponentSchemas.Ad.schema

/**
admin/ad/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:ad*
*/
let postAdminAdCreate = async (~body: postAdminAdCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAdCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/ad/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAdCreateResponseSchema)
}

type postAdminAdDeleteRequest = {
  id: string,
}

let postAdminAdDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAdDeleteResponse = unit

/**
admin/ad/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:ad*
*/
let postAdminAdDelete = async (~body: postAdminAdDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAdDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/ad/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAdListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  publishing: option<bool>,
}

let postAdminAdListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    publishing: s.field("publishing", S.option(S.bool)),
  })

type postAdminAdListResponse = array<MisskeyIoComponentSchemas.Ad.t>

let postAdminAdListResponseSchema = S.array(MisskeyIoComponentSchemas.Ad.schema)

/**
admin/ad/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:ad*
*/
let postAdminAdList = async (~body: postAdminAdListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAdListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdListRequestSchema)
  let response = await fetch(
    ~url="/admin/ad/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAdListResponseSchema)
}

type postAdminAdUpdateRequest = {
  id: string,
  memo: option<string>,
  url: option<string>,
  imageUrl: option<string>,
  place: option<string>,
  priority: option<string>,
  ratio: option<int>,
  expiresAt: option<int>,
  startsAt: option<int>,
  dayOfWeek: option<int>,
  isSensitive: option<bool>,
}

let postAdminAdUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    memo: s.field("memo", S.option(S.string)),
    url: s.field("url", S.option(S.string->S.min(1))),
    imageUrl: s.field("imageUrl", S.option(S.string->S.min(1))),
    place: s.field("place", S.option(S.string)),
    priority: s.field("priority", S.option(S.string)),
    ratio: s.field("ratio", S.option(S.int)),
    expiresAt: s.field("expiresAt", S.option(S.int)),
    startsAt: s.field("startsAt", S.option(S.int)),
    dayOfWeek: s.field("dayOfWeek", S.option(S.int)),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
  })

type postAdminAdUpdateResponse = unit

/**
admin/ad/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:ad*
*/
let postAdminAdUpdate = async (~body: postAdminAdUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAdUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAdUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/ad/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAnnouncementsCreateRequest = {
  title: string,
  text: string,
  imageUrl: option<string>,
  icon: option<string>,
  display: option<string>,
  forExistingUsers: option<bool>,
  needConfirmationToRead: option<bool>,
  needEnrollmentTutorialToRead: option<bool>,
  closeDuration: option<float>,
  displayOrder: option<float>,
  silence: option<bool>,
  userId: option<string>,
}

let postAdminAnnouncementsCreateRequestSchema = S.object(s => {
    title: s.field("title", S.string->S.min(1)),
    text: s.field("text", S.string->S.min(1)),
    imageUrl: s.field("imageUrl", S.nullableAsOption(S.string->S.min(0))),
    icon: s.field("icon", S.option(S.string)),
    display: s.field("display", S.option(S.string)),
    forExistingUsers: s.field("forExistingUsers", S.option(S.bool)),
    needConfirmationToRead: s.field("needConfirmationToRead", S.option(S.bool)),
    needEnrollmentTutorialToRead: s.field("needEnrollmentTutorialToRead", S.option(S.bool)),
    closeDuration: s.field("closeDuration", S.option(S.float)),
    displayOrder: s.field("displayOrder", S.option(S.float)),
    silence: s.field("silence", S.option(S.bool)),
    userId: s.field("userId", S.option(S.string)),
  })

type postAdminAnnouncementsCreateResponse = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  title: string,
  text: string,
  imageUrl: option<string>,
  icon: string,
  display: string,
  forYou: bool,
  needConfirmationToRead: bool,
  needEnrollmentTutorialToRead: bool,
  closeDuration: float,
  displayOrder: float,
  silence: bool,
  isRead: option<bool>,
}

let postAdminAnnouncementsCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    title: s.field("title", S.string),
    text: s.field("text", S.string),
    imageUrl: s.field("imageUrl", S.nullableAsOption(S.string)),
    icon: s.field("icon", S.string),
    display: s.field("display", S.string),
    forYou: s.field("forYou", S.bool),
    needConfirmationToRead: s.field("needConfirmationToRead", S.bool),
    needEnrollmentTutorialToRead: s.field("needEnrollmentTutorialToRead", S.bool),
    closeDuration: s.field("closeDuration", S.float),
    displayOrder: s.field("displayOrder", S.float),
    silence: s.field("silence", S.bool),
    isRead: s.field("isRead", S.option(S.bool)),
  })

/**
admin/announcements/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:announcements*
*/
let postAdminAnnouncementsCreate = async (~body: postAdminAnnouncementsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAnnouncementsCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/announcements/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAnnouncementsCreateResponseSchema)
}

type postAdminAnnouncementsDeleteRequest = {
  id: string,
}

let postAdminAnnouncementsDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAnnouncementsDeleteResponse = unit

/**
admin/announcements/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:announcements*
*/
let postAdminAnnouncementsDelete = async (~body: postAdminAnnouncementsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAnnouncementsDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/announcements/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAnnouncementsListRequest = {
  limit: option<int>,
  offset: option<int>,
  userId: option<string>,
  status: option<string>,
}

let postAdminAnnouncementsListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
    userId: s.field("userId", S.option(S.string)),
    status: s.field("status", S.option(S.string)),
  })

type postAdminAnnouncementsListResponse_1 = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  text: string,
  isActive: bool,
  title: string,
  imageUrl: option<string>,
  icon: string,
  display: string,
  forExistingUsers: bool,
  needConfirmationToRead: bool,
  needEnrollmentTutorialToRead: bool,
  closeDuration: float,
  displayOrder: float,
  silence: bool,
  userId: option<string>,
  user: option<MisskeyIoComponentSchemas.UserLite.t>,
  reads: float,
  lastReadAt: option<string>,
}

type postAdminAnnouncementsListResponse = array<postAdminAnnouncementsListResponse_1>

let postAdminAnnouncementsListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    text: s.field("text", S.string),
    isActive: s.field("isActive", S.bool),
    title: s.field("title", S.string),
    imageUrl: s.field("imageUrl", S.nullableAsOption(S.string)),
    icon: s.field("icon", S.string),
    display: s.field("display", S.string),
    forExistingUsers: s.field("forExistingUsers", S.bool),
    needConfirmationToRead: s.field("needConfirmationToRead", S.bool),
    needEnrollmentTutorialToRead: s.field("needEnrollmentTutorialToRead", S.bool),
    closeDuration: s.field("closeDuration", S.float),
    displayOrder: s.field("displayOrder", S.float),
    silence: s.field("silence", S.bool),
    userId: s.field("userId", S.nullableAsOption(S.string)),
    user: s.field("user", S.nullableAsOption(MisskeyIoComponentSchemas.UserLite.schema)),
    reads: s.field("reads", S.float),
    lastReadAt: s.field("lastReadAt", S.nullableAsOption(S.string)),
  })

let postAdminAnnouncementsListResponseSchema = S.array(postAdminAnnouncementsListResponse_1Schema)

/**
admin/announcements/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:announcements*
*/
let postAdminAnnouncementsList = async (~body: postAdminAnnouncementsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAnnouncementsListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsListRequestSchema)
  let response = await fetch(
    ~url="/admin/announcements/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAnnouncementsListResponseSchema)
}

type postAdminAnnouncementsUpdateRequest = {
  id: string,
  title: option<string>,
  text: option<string>,
  imageUrl: option<string>,
  icon: option<string>,
  display: option<string>,
  forExistingUsers: option<bool>,
  needConfirmationToRead: option<bool>,
  needEnrollmentTutorialToRead: option<bool>,
  closeDuration: option<float>,
  displayOrder: option<float>,
  silence: option<bool>,
  isActive: option<bool>,
}

let postAdminAnnouncementsUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    title: s.field("title", S.option(S.string->S.min(1))),
    text: s.field("text", S.option(S.string->S.min(1))),
    imageUrl: s.field("imageUrl", S.option(S.string->S.min(0))),
    icon: s.field("icon", S.option(S.string)),
    display: s.field("display", S.option(S.string)),
    forExistingUsers: s.field("forExistingUsers", S.option(S.bool)),
    needConfirmationToRead: s.field("needConfirmationToRead", S.option(S.bool)),
    needEnrollmentTutorialToRead: s.field("needEnrollmentTutorialToRead", S.option(S.bool)),
    closeDuration: s.field("closeDuration", S.option(S.float)),
    displayOrder: s.field("displayOrder", S.option(S.float)),
    silence: s.field("silence", S.option(S.bool)),
    isActive: s.field("isActive", S.option(S.bool)),
  })

type postAdminAnnouncementsUpdateResponse = unit

/**
admin/announcements/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:announcements*
*/
let postAdminAnnouncementsUpdate = async (~body: postAdminAnnouncementsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAnnouncementsUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAnnouncementsUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/announcements/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAvatarDecorationsCreateRequest = {
  name: string,
  description: string,
  url: string,
  roleIdsThatCanBeUsedThisDecoration: option<array<string>>,
}

let postAdminAvatarDecorationsCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.min(1)),
    description: s.field("description", S.string),
    url: s.field("url", S.string->S.min(1)),
    roleIdsThatCanBeUsedThisDecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.option(S.array(S.string))),
  })

type postAdminAvatarDecorationsCreateResponse = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  name: string,
  description: string,
  url: string,
  roleIdsThatCanBeUsedThisDecoration: array<string>,
}

let postAdminAvatarDecorationsCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    url: s.field("url", S.string),
    roleIdsThatCanBeUsedThisDecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.array(S.string)),
  })

/**
admin/avatar-decorations/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:avatar-decorations*
*/
let postAdminAvatarDecorationsCreate = async (~body: postAdminAvatarDecorationsCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAvatarDecorationsCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/avatar-decorations/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAvatarDecorationsCreateResponseSchema)
}

type postAdminAvatarDecorationsDeleteRequest = {
  id: string,
}

let postAdminAvatarDecorationsDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminAvatarDecorationsDeleteResponse = unit

/**
admin/avatar-decorations/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:avatar-decorations*
*/
let postAdminAvatarDecorationsDelete = async (~body: postAdminAvatarDecorationsDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAvatarDecorationsDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/avatar-decorations/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminAvatarDecorationsListRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  userId: option<string>,
}

let postAdminAvatarDecorationsListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    userId: s.field("userId", S.option(S.string)),
  })

type postAdminAvatarDecorationsListResponse_1 = {
  id: string,
  createdAt: string,
  updatedAt: option<string>,
  name: string,
  description: string,
  url: string,
  roleIdsThatCanBeUsedThisDecoration: array<string>,
}

type postAdminAvatarDecorationsListResponse = array<postAdminAvatarDecorationsListResponse_1>

let postAdminAvatarDecorationsListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.nullableAsOption(S.string)),
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    url: s.field("url", S.string),
    roleIdsThatCanBeUsedThisDecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.array(S.string)),
  })

let postAdminAvatarDecorationsListResponseSchema = S.array(postAdminAvatarDecorationsListResponse_1Schema)

/**
admin/avatar-decorations/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:avatar-decorations*
*/
let postAdminAvatarDecorationsList = async (~body: postAdminAvatarDecorationsListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAvatarDecorationsListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsListRequestSchema)
  let response = await fetch(
    ~url="/admin/avatar-decorations/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminAvatarDecorationsListResponseSchema)
}

type postAdminAvatarDecorationsUpdateRequest = {
  id: string,
  name: option<string>,
  description: option<string>,
  url: option<string>,
  roleIdsThatCanBeUsedThisDecoration: option<array<string>>,
}

let postAdminAvatarDecorationsUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.option(S.string->S.min(1))),
    description: s.field("description", S.option(S.string)),
    url: s.field("url", S.option(S.string->S.min(1))),
    roleIdsThatCanBeUsedThisDecoration: s.field("roleIdsThatCanBeUsedThisDecoration", S.option(S.array(S.string))),
  })

type postAdminAvatarDecorationsUpdateResponse = unit

/**
admin/avatar-decorations/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:avatar-decorations*
*/
let postAdminAvatarDecorationsUpdate = async (~body: postAdminAvatarDecorationsUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminAvatarDecorationsUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminAvatarDecorationsUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/avatar-decorations/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminCaptchaCurrentResponse_2 = {
  siteKey: option<string>,
  secretKey: option<string>,
  instanceUrl: option<string>,
}

type postAdminCaptchaCurrentResponse_1 = {
  siteKey: option<string>,
  secretKey: option<string>,
}

type postAdminCaptchaCurrentResponse = {
  provider: string,
  hcaptcha: postAdminCaptchaCurrentResponse_1,
  mcaptcha: postAdminCaptchaCurrentResponse_2,
  recaptcha: postAdminCaptchaCurrentResponse_1,
  turnstile: postAdminCaptchaCurrentResponse_1,
}

let postAdminCaptchaCurrentResponse_2Schema = S.object(s => {
    siteKey: s.field("siteKey", S.nullableAsOption(S.string)),
    secretKey: s.field("secretKey", S.nullableAsOption(S.string)),
    instanceUrl: s.field("instanceUrl", S.nullableAsOption(S.string)),
  })

let postAdminCaptchaCurrentResponse_1Schema = S.object(s => {
    siteKey: s.field("siteKey", S.nullableAsOption(S.string)),
    secretKey: s.field("secretKey", S.nullableAsOption(S.string)),
  })

let postAdminCaptchaCurrentResponseSchema = S.object(s => {
    provider: s.field("provider", S.string),
    hcaptcha: s.field("hcaptcha", postAdminCaptchaCurrentResponse_1Schema),
    mcaptcha: s.field("mcaptcha", postAdminCaptchaCurrentResponse_2Schema),
    recaptcha: s.field("recaptcha", postAdminCaptchaCurrentResponse_1Schema),
    turnstile: s.field("turnstile", postAdminCaptchaCurrentResponse_1Schema),
  })

/**
admin/captcha/current

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:meta*
*/
let postAdminCaptchaCurrent = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminCaptchaCurrentResponse => {

  let response = await fetch(
    ~url="/admin/captcha/current",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postAdminCaptchaCurrentResponseSchema)
}

type postAdminCaptchaSaveRequest = {
  provider: string,
  captchaResult: option<string>,
  sitekey: option<string>,
  secret: option<string>,
  instanceUrl: option<string>,
}

let postAdminCaptchaSaveRequestSchema = S.object(s => {
    provider: s.field("provider", S.string),
    captchaResult: s.field("captchaResult", S.option(S.string)),
    sitekey: s.field("sitekey", S.option(S.string)),
    secret: s.field("secret", S.option(S.string)),
    instanceUrl: s.field("instanceUrl", S.option(S.string)),
  })

type postAdminCaptchaSaveResponse = unit

/**
admin/captcha/save

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:meta*
*/
let postAdminCaptchaSave = async (~body: postAdminCaptchaSaveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminCaptchaSaveResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminCaptchaSaveRequestSchema)
  let response = await fetch(
    ~url="/admin/captcha/save",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminDriveCleanRemoteFilesResponse = unit

/**
admin/drive/clean-remote-files

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:drive*
*/
let postAdminDriveCleanRemoteFiles = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminDriveCleanRemoteFilesResponse => {

  let response = await fetch(
    ~url="/admin/drive/clean-remote-files",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postAdminDriveCleanupResponse = unit

/**
admin/drive/cleanup

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:drive*
*/
let postAdminDriveCleanup = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminDriveCleanupResponse => {

  let response = await fetch(
    ~url="/admin/drive/cleanup",
    ~method_="POST",
    ~body=None,
  )
  let _ = response
}

type postAdminDriveDeleteAllFilesOfAUserRequest = {
  userId: string,
}

let postAdminDriveDeleteAllFilesOfAUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminDriveDeleteAllFilesOfAUserResponse = unit

/**
admin/drive/delete-all-files-of-a-user

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:drive*
*/
let postAdminDriveDeleteAllFilesOfAUser = async (~body: postAdminDriveDeleteAllFilesOfAUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminDriveDeleteAllFilesOfAUserResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveDeleteAllFilesOfAUserRequestSchema)
  let response = await fetch(
    ~url="/admin/drive/delete-all-files-of-a-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminDriveFilesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  userId: option<string>,
  @as("type") type_: option<string>,
  origin: option<string>,
  hostname: option<string>,
}

let postAdminDriveFilesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    userId: s.field("userId", S.option(S.string)),
    type_: s.field("type", S.option(S.string->S.pattern(/^[a-zA-Z0-9\/\*-]+$/))),
    origin: s.field("origin", S.option(S.string)),
    hostname: s.field("hostname", S.option(S.string)),
  })

type postAdminDriveFilesResponse = array<MisskeyIoComponentSchemas.DriveFile.t>

let postAdminDriveFilesResponseSchema = S.array(MisskeyIoComponentSchemas.DriveFile.schema)

/**
admin/drive/files

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:drive*
*/
let postAdminDriveFiles = async (~body: postAdminDriveFilesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminDriveFilesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveFilesRequestSchema)
  let response = await fetch(
    ~url="/admin/drive/files",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminDriveFilesResponseSchema)
}

type postAdminDriveShowFileRequest = {
  fileId: option<string>,
  url: option<string>,
}

let postAdminDriveShowFileRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.option(S.string)),
    url: s.field("url", S.option(S.string)),
  })

type postAdminDriveShowFileResponse_1 = {
  width: option<float>,
  height: option<float>,
  orientation: option<float>,
  avgColor: option<string>,
}

type postAdminDriveShowFileResponse = {
  id: string,
  createdAt: string,
  userId: option<string>,
  userHost: option<string>,
  md5: string,
  name: string,
  @as("type") type_: string,
  size: float,
  comment: option<string>,
  blurhash: option<string>,
  properties: postAdminDriveShowFileResponse_1,
  storedInternal: option<bool>,
  url: option<string>,
  thumbnailUrl: option<string>,
  webpublicUrl: option<string>,
  accessKey: option<string>,
  thumbnailAccessKey: option<string>,
  webpublicAccessKey: option<string>,
  uri: option<string>,
  src: option<string>,
  folderId: option<string>,
  isSensitive: bool,
  isLink: bool,
}

let postAdminDriveShowFileResponse_1Schema = S.object(s => {
    width: s.field("width", S.option(S.float)),
    height: s.field("height", S.option(S.float)),
    orientation: s.field("orientation", S.option(S.float)),
    avgColor: s.field("avgColor", S.option(S.string)),
  })

let postAdminDriveShowFileResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    userId: s.field("userId", S.nullableAsOption(S.string)),
    userHost: s.field("userHost", S.nullableAsOption(S.string)),
    md5: s.field("md5", S.string),
    name: s.field("name", S.string),
    type_: s.field("type", S.string),
    size: s.field("size", S.float),
    comment: s.field("comment", S.nullableAsOption(S.string)),
    blurhash: s.field("blurhash", S.nullableAsOption(S.string)),
    properties: s.field("properties", postAdminDriveShowFileResponse_1Schema),
    storedInternal: s.field("storedInternal", S.nullableAsOption(S.bool)),
    url: s.field("url", S.nullableAsOption(S.string)),
    thumbnailUrl: s.field("thumbnailUrl", S.nullableAsOption(S.string)),
    webpublicUrl: s.field("webpublicUrl", S.nullableAsOption(S.string)),
    accessKey: s.field("accessKey", S.nullableAsOption(S.string)),
    thumbnailAccessKey: s.field("thumbnailAccessKey", S.nullableAsOption(S.string)),
    webpublicAccessKey: s.field("webpublicAccessKey", S.nullableAsOption(S.string)),
    uri: s.field("uri", S.nullableAsOption(S.string)),
    src: s.field("src", S.nullableAsOption(S.string)),
    folderId: s.field("folderId", S.nullableAsOption(S.string)),
    isSensitive: s.field("isSensitive", S.bool),
    isLink: s.field("isLink", S.bool),
  })

/**
admin/drive/show-file

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:drive*
*/
let postAdminDriveShowFile = async (~body: postAdminDriveShowFileRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminDriveShowFileResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminDriveShowFileRequestSchema)
  let response = await fetch(
    ~url="/admin/drive/show-file",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminDriveShowFileResponseSchema)
}

type postAdminEmojiAddRequest = {
  name: string,
  fileId: string,
  category: option<string>,
  aliases: option<array<string>>,
  license: option<string>,
  isSensitive: option<bool>,
  localOnly: option<bool>,
  requestedBy: option<string>,
  memo: option<string>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
  roleIdsThatCanNotBeUsedThisEmojiAsReaction: option<array<string>>,
}

let postAdminEmojiAddRequestSchema = S.object(s => {
    name: s.field("name", S.string->S.pattern(/^[a-zA-Z0-9_]+$/)),
    fileId: s.field("fileId", S.string),
    category: s.field("category", S.option(S.string)),
    aliases: s.field("aliases", S.option(S.array(S.string))),
    license: s.field("license", S.option(S.string)),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
    localOnly: s.field("localOnly", S.option(S.bool)),
    requestedBy: s.field("requestedBy", S.option(S.string)),
    memo: s.field("memo", S.option(S.string)),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.field("roleIdsThatCanBeUsedThisEmojiAsReaction", S.option(S.array(S.string))),
    roleIdsThatCanNotBeUsedThisEmojiAsReaction: s.field("roleIdsThatCanNotBeUsedThisEmojiAsReaction", S.option(S.array(S.string))),
  })

type postAdminEmojiAddResponse = MisskeyIoComponentSchemas.EmojiDetailed.t

let postAdminEmojiAddResponseSchema = MisskeyIoComponentSchemas.EmojiDetailed.schema

/**
admin/emoji/add

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiAdd = async (~body: postAdminEmojiAddRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiAddResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiAddRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/add",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminEmojiAddResponseSchema)
}

type postAdminEmojiAddAliasesBulkRequest = {
  ids: array<string>,
  aliases: array<string>,
}

let postAdminEmojiAddAliasesBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
    aliases: s.field("aliases", S.array(S.string)),
  })

type postAdminEmojiAddAliasesBulkResponse = unit

/**
admin/emoji/add-aliases-bulk

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiAddAliasesBulk = async (~body: postAdminEmojiAddAliasesBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiAddAliasesBulkResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiAddAliasesBulkRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/add-aliases-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminEmojiCopyRequest = {
  emojiId: string,
}

let postAdminEmojiCopyRequestSchema = S.object(s => {
    emojiId: s.field("emojiId", S.string),
  })

type postAdminEmojiCopyResponse = {
  id: string,
}

let postAdminEmojiCopyResponseSchema = S.object(s => {
    id: s.field("id", S.string),
  })

/**
admin/emoji/copy

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiCopy = async (~body: postAdminEmojiCopyRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiCopyResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiCopyRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/copy",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminEmojiCopyResponseSchema)
}

type postAdminEmojiDeleteRequest = {
  id: string,
}

let postAdminEmojiDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminEmojiDeleteResponse = unit

/**
admin/emoji/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiDelete = async (~body: postAdminEmojiDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminEmojiDeleteBulkRequest = {
  ids: array<string>,
}

let postAdminEmojiDeleteBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
  })

type postAdminEmojiDeleteBulkResponse = unit

/**
admin/emoji/delete-bulk

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiDeleteBulk = async (~body: postAdminEmojiDeleteBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiDeleteBulkResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiDeleteBulkRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/delete-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminEmojiListRequest = {
  query: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postAdminEmojiListRequestSchema = S.object(s => {
    query: s.field("query", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postAdminEmojiListResponse_1 = {
  id: string,
  aliases: array<string>,
  name: string,
  category: option<string>,
  host: option<string>,
  url: string,
}

type postAdminEmojiListResponse = array<postAdminEmojiListResponse_1>

let postAdminEmojiListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.nullableAsOption(S.string)),
    host: s.field("host", S.nullableAsOption(S.string)),
    url: s.field("url", S.string),
  })

let postAdminEmojiListResponseSchema = S.array(postAdminEmojiListResponse_1Schema)

/**
admin/emoji/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:emoji*
*/
let postAdminEmojiList = async (~body: postAdminEmojiListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiListRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminEmojiListResponseSchema)
}

type postAdminEmojiListRemoteRequest = {
  query: option<string>,
  host: option<string>,
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
}

let postAdminEmojiListRemoteRequestSchema = S.object(s => {
    query: s.field("query", S.option(S.string)),
    host: s.field("host", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
  })

type postAdminEmojiListRemoteResponse_1 = {
  id: string,
  aliases: array<string>,
  name: string,
  category: option<string>,
  host: option<string>,
  url: string,
}

type postAdminEmojiListRemoteResponse = array<postAdminEmojiListRemoteResponse_1>

let postAdminEmojiListRemoteResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    aliases: s.field("aliases", S.array(S.string)),
    name: s.field("name", S.string),
    category: s.field("category", S.nullableAsOption(S.string)),
    host: s.field("host", S.nullableAsOption(S.string)),
    url: s.field("url", S.string),
  })

let postAdminEmojiListRemoteResponseSchema = S.array(postAdminEmojiListRemoteResponse_1Schema)

/**
admin/emoji/list-remote

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:emoji*
*/
let postAdminEmojiListRemote = async (~body: postAdminEmojiListRemoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiListRemoteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiListRemoteRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/list-remote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminEmojiListRemoteResponseSchema)
}

type postAdminEmojiRemoveAliasesBulkRequest = {
  ids: array<string>,
  aliases: array<string>,
}

let postAdminEmojiRemoveAliasesBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
    aliases: s.field("aliases", S.array(S.string)),
  })

type postAdminEmojiRemoveAliasesBulkResponse = unit

/**
admin/emoji/remove-aliases-bulk

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiRemoveAliasesBulk = async (~body: postAdminEmojiRemoveAliasesBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiRemoveAliasesBulkResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiRemoveAliasesBulkRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/remove-aliases-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminEmojiSetAliasesBulkRequest = {
  ids: array<string>,
  aliases: array<string>,
}

let postAdminEmojiSetAliasesBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
    aliases: s.field("aliases", S.array(S.string)),
  })

type postAdminEmojiSetAliasesBulkResponse = unit

/**
admin/emoji/set-aliases-bulk

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiSetAliasesBulk = async (~body: postAdminEmojiSetAliasesBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiSetAliasesBulkResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiSetAliasesBulkRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/set-aliases-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminEmojiSetCategoryBulkRequest = {
  ids: array<string>,
  category: option<string>,
}

let postAdminEmojiSetCategoryBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
    category: s.field("category", S.option(S.string)),
  })

type postAdminEmojiSetCategoryBulkResponse = unit

/**
admin/emoji/set-category-bulk

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiSetCategoryBulk = async (~body: postAdminEmojiSetCategoryBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiSetCategoryBulkResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiSetCategoryBulkRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/set-category-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminEmojiSetLicenseBulkRequest = {
  ids: array<string>,
  license: option<string>,
}

let postAdminEmojiSetLicenseBulkRequestSchema = S.object(s => {
    ids: s.field("ids", S.array(S.string)),
    license: s.field("license", S.option(S.string)),
  })

type postAdminEmojiSetLicenseBulkResponse = unit

/**
admin/emoji/set-license-bulk

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiSetLicenseBulk = async (~body: postAdminEmojiSetLicenseBulkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiSetLicenseBulkResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiSetLicenseBulkRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/set-license-bulk",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminEmojiUpdateRequest = {
  id: option<string>,
  name: option<string>,
  fileId: option<string>,
  category: option<string>,
  aliases: option<array<string>>,
  license: option<string>,
  isSensitive: option<bool>,
  localOnly: option<bool>,
  requestedBy: option<string>,
  memo: option<string>,
  roleIdsThatCanBeUsedThisEmojiAsReaction: option<array<string>>,
  roleIdsThatCanNotBeUsedThisEmojiAsReaction: option<array<string>>,
}

let postAdminEmojiUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.option(S.string)),
    name: s.field("name", S.option(S.string->S.pattern(/^[a-zA-Z0-9_]+$/))),
    fileId: s.field("fileId", S.option(S.string)),
    category: s.field("category", S.option(S.string)),
    aliases: s.field("aliases", S.option(S.array(S.string))),
    license: s.field("license", S.option(S.string)),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
    localOnly: s.field("localOnly", S.option(S.bool)),
    requestedBy: s.field("requestedBy", S.option(S.string)),
    memo: s.field("memo", S.option(S.string)),
    roleIdsThatCanBeUsedThisEmojiAsReaction: s.field("roleIdsThatCanBeUsedThisEmojiAsReaction", S.option(S.array(S.string))),
    roleIdsThatCanNotBeUsedThisEmojiAsReaction: s.field("roleIdsThatCanNotBeUsedThisEmojiAsReaction", S.option(S.array(S.string))),
  })

type postAdminEmojiUpdateResponse = unit

/**
admin/emoji/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:emoji*
*/
let postAdminEmojiUpdate = async (~body: postAdminEmojiUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminEmojiUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminEmojiUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/emoji/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminFederationDeleteAllFilesRequest = {
  host: string,
}

let postAdminFederationDeleteAllFilesRequestSchema = S.object(s => {
    host: s.field("host", S.string),
  })

type postAdminFederationDeleteAllFilesResponse = unit

/**
admin/federation/delete-all-files

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:federation*
*/
let postAdminFederationDeleteAllFiles = async (~body: postAdminFederationDeleteAllFilesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminFederationDeleteAllFilesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationDeleteAllFilesRequestSchema)
  let response = await fetch(
    ~url="/admin/federation/delete-all-files",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminFederationRefreshRemoteInstanceMetadataRequest = {
  host: string,
}

let postAdminFederationRefreshRemoteInstanceMetadataRequestSchema = S.object(s => {
    host: s.field("host", S.string),
  })

type postAdminFederationRefreshRemoteInstanceMetadataResponse = unit

/**
admin/federation/refresh-remote-instance-metadata

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:federation*
*/
let postAdminFederationRefreshRemoteInstanceMetadata = async (~body: postAdminFederationRefreshRemoteInstanceMetadataRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminFederationRefreshRemoteInstanceMetadataResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationRefreshRemoteInstanceMetadataRequestSchema)
  let response = await fetch(
    ~url="/admin/federation/refresh-remote-instance-metadata",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminFederationRemoveAllFollowingRequest = {
  host: string,
}

let postAdminFederationRemoveAllFollowingRequestSchema = S.object(s => {
    host: s.field("host", S.string),
  })

type postAdminFederationRemoveAllFollowingResponse = unit

/**
admin/federation/remove-all-following

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:federation*
*/
let postAdminFederationRemoveAllFollowing = async (~body: postAdminFederationRemoveAllFollowingRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminFederationRemoveAllFollowingResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationRemoveAllFollowingRequestSchema)
  let response = await fetch(
    ~url="/admin/federation/remove-all-following",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminFederationUpdateInstanceRequest = {
  host: string,
  isSuspended: option<bool>,
  moderationNote: option<string>,
}

let postAdminFederationUpdateInstanceRequestSchema = S.object(s => {
    host: s.field("host", S.string),
    isSuspended: s.field("isSuspended", S.option(S.bool)),
    moderationNote: s.field("moderationNote", S.option(S.string)),
  })

type postAdminFederationUpdateInstanceResponse = unit

/**
admin/federation/update-instance

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:federation*
*/
let postAdminFederationUpdateInstance = async (~body: postAdminFederationUpdateInstanceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminFederationUpdateInstanceResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminFederationUpdateInstanceRequestSchema)
  let response = await fetch(
    ~url="/admin/federation/update-instance",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminForwardAbuseUserReportRequest = {
  reportId: string,
}

let postAdminForwardAbuseUserReportRequestSchema = S.object(s => {
    reportId: s.field("reportId", S.string),
  })

type postAdminForwardAbuseUserReportResponse = unit

/**
admin/forward-abuse-user-report

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:resolve-abuse-user-report*
*/
let postAdminForwardAbuseUserReport = async (~body: postAdminForwardAbuseUserReportRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminForwardAbuseUserReportResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminForwardAbuseUserReportRequestSchema)
  let response = await fetch(
    ~url="/admin/forward-abuse-user-report",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminGetIndexStatsResponse_1 = {
  tablename: string,
  indexname: string,
}

type postAdminGetIndexStatsResponse = array<postAdminGetIndexStatsResponse_1>

let postAdminGetIndexStatsResponse_1Schema = S.object(s => {
    tablename: s.field("tablename", S.string),
    indexname: s.field("indexname", S.string),
  })

let postAdminGetIndexStatsResponseSchema = S.array(postAdminGetIndexStatsResponse_1Schema)

/**
admin/get-index-stats

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:index-stats*
*/
let postAdminGetIndexStats = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminGetIndexStatsResponse => {

  let response = await fetch(
    ~url="/admin/get-index-stats",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postAdminGetIndexStatsResponseSchema)
}

type postAdminGetTableStatsResponse = dict<JSON.t>

let postAdminGetTableStatsResponseSchema = S.dict(S.json)

/**
admin/get-table-stats

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:table-stats*
*/
let postAdminGetTableStats = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminGetTableStatsResponse => {

  let response = await fetch(
    ~url="/admin/get-table-stats",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postAdminGetTableStatsResponseSchema)
}

type postAdminGetUserIpsRequest = {
  userId: string,
}

let postAdminGetUserIpsRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminGetUserIpsResponse_1 = {
  ip: string,
  createdAt: string,
}

type postAdminGetUserIpsResponse = array<postAdminGetUserIpsResponse_1>

let postAdminGetUserIpsResponse_1Schema = S.object(s => {
    ip: s.field("ip", S.string),
    createdAt: s.field("createdAt", S.string),
  })

let postAdminGetUserIpsResponseSchema = S.array(postAdminGetUserIpsResponse_1Schema)

/**
admin/get-user-ips

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:user-ips*
*/
let postAdminGetUserIps = async (~body: postAdminGetUserIpsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminGetUserIpsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminGetUserIpsRequestSchema)
  let response = await fetch(
    ~url="/admin/get-user-ips",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminGetUserIpsResponseSchema)
}

type postAdminIndieAuthCreateRequest = {
  id: string,
  name: option<string>,
  redirectUris: option<array<string>>,
}

let postAdminIndieAuthCreateRequestSchema = S.object(s => {
    id: s.field("id", S.string->S.min(1)),
    name: s.field("name", S.option(S.string)),
    redirectUris: s.field("redirectUris", S.option(S.array(S.string))),
  })

type postAdminIndieAuthCreateResponse = {
  id: string,
  createdAt: string,
  name: option<string>,
  redirectUris: array<string>,
}

let postAdminIndieAuthCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.nullableAsOption(S.string)),
    redirectUris: s.field("redirectUris", S.array(S.string)),
  })

/**
admin/indie-auth/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:indie-auth*
*/
let postAdminIndieAuthCreate = async (~body: postAdminIndieAuthCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminIndieAuthCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminIndieAuthCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/indie-auth/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminIndieAuthCreateResponseSchema)
}

type postAdminIndieAuthDeleteRequest = {
  id: string,
}

let postAdminIndieAuthDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminIndieAuthDeleteResponse = unit

/**
admin/indie-auth/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:indie-auth*
*/
let postAdminIndieAuthDelete = async (~body: postAdminIndieAuthDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminIndieAuthDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminIndieAuthDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/indie-auth/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminIndieAuthListRequest = {
  limit: option<int>,
  offset: option<int>,
}

let postAdminIndieAuthListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
  })

type postAdminIndieAuthListResponse_1 = {
  id: string,
  createdAt: string,
  name: option<string>,
  redirectUris: array<string>,
}

type postAdminIndieAuthListResponse = array<postAdminIndieAuthListResponse_1>

let postAdminIndieAuthListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.nullableAsOption(S.string)),
    redirectUris: s.field("redirectUris", S.array(S.string)),
  })

let postAdminIndieAuthListResponseSchema = S.array(postAdminIndieAuthListResponse_1Schema)

/**
admin/indie-auth/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:indie-auth*
*/
let postAdminIndieAuthList = async (~body: postAdminIndieAuthListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminIndieAuthListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminIndieAuthListRequestSchema)
  let response = await fetch(
    ~url="/admin/indie-auth/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminIndieAuthListResponseSchema)
}

type postAdminIndieAuthUpdateRequest = {
  id: string,
  name: option<string>,
  redirectUris: option<array<string>>,
}

let postAdminIndieAuthUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string->S.min(1)),
    name: s.field("name", S.option(S.string)),
    redirectUris: s.field("redirectUris", S.option(S.array(S.string))),
  })

type postAdminIndieAuthUpdateResponse = unit

/**
admin/indie-auth/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:indie-auth*
*/
let postAdminIndieAuthUpdate = async (~body: postAdminIndieAuthUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminIndieAuthUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminIndieAuthUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/indie-auth/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminInviteCreateRequest = {
  count: option<int>,
  expiresAt: option<string>,
}

let postAdminInviteCreateRequestSchema = S.object(s => {
    count: s.field("count", S.option(S.int->S.min(1)->S.max(100))),
    expiresAt: s.field("expiresAt", S.option(S.string)),
  })

type postAdminInviteCreateResponse = array<MisskeyIoComponentSchemas.InviteCode.t>

let postAdminInviteCreateResponseSchema = S.array(MisskeyIoComponentSchemas.InviteCode.schema)

/**
admin/invite/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:invite-codes*
*/
let postAdminInviteCreate = async (~body: postAdminInviteCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminInviteCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminInviteCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/invite/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminInviteCreateResponseSchema)
}

type postAdminInviteListRequest = {
  limit: option<int>,
  offset: option<int>,
  @as("type") type_: option<string>,
  sort: option<string>,
}

let postAdminInviteListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
    type_: s.field("type", S.option(S.string)),
    sort: s.field("sort", S.option(S.string)),
  })

type postAdminInviteListResponse = array<MisskeyIoComponentSchemas.InviteCode.t>

let postAdminInviteListResponseSchema = S.array(MisskeyIoComponentSchemas.InviteCode.schema)

/**
admin/invite/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:invite-codes*
*/
let postAdminInviteList = async (~body: postAdminInviteListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminInviteListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminInviteListRequestSchema)
  let response = await fetch(
    ~url="/admin/invite/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminInviteListResponseSchema)
}

type postAdminPromoCreateRequest = {
  noteId: string,
  expiresAt: int,
}

let postAdminPromoCreateRequestSchema = S.object(s => {
    noteId: s.field("noteId", S.string),
    expiresAt: s.field("expiresAt", S.int),
  })

type postAdminPromoCreateResponse = unit

/**
admin/promo/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:promo*
*/
let postAdminPromoCreate = async (~body: postAdminPromoCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminPromoCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminPromoCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/promo/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminQueueClearRequest = {
  @as("type") type_: string,
  state: string,
}

let postAdminQueueClearRequestSchema = S.object(s => {
    type_: s.field("type", S.string),
    state: s.field("state", S.string),
  })

type postAdminQueueClearResponse = unit

/**
admin/queue/clear

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:queue*
*/
let postAdminQueueClear = async (~body: postAdminQueueClearRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueClearResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueueClearRequestSchema)
  let response = await fetch(
    ~url="/admin/queue/clear",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminQueueDeliverDelayedResponse = array<array<JSON.t>>

let postAdminQueueDeliverDelayedResponseSchema = S.array(S.array(S.json))

/**
admin/queue/deliver-delayed

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:queue*
*/
let postAdminQueueDeliverDelayed = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueDeliverDelayedResponse => {

  let response = await fetch(
    ~url="/admin/queue/deliver-delayed",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postAdminQueueDeliverDelayedResponseSchema)
}

type postAdminQueueInboxDelayedResponse = array<array<JSON.t>>

let postAdminQueueInboxDelayedResponseSchema = S.array(S.array(S.json))

/**
admin/queue/inbox-delayed

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:queue*
*/
let postAdminQueueInboxDelayed = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueInboxDelayedResponse => {

  let response = await fetch(
    ~url="/admin/queue/inbox-delayed",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postAdminQueueInboxDelayedResponseSchema)
}

type postAdminQueuePromoteRequest = {
  @as("type") type_: string,
}

let postAdminQueuePromoteRequestSchema = S.object(s => {
    type_: s.field("type", S.string),
  })

type postAdminQueuePromoteResponse = unit

/**
admin/queue/promote

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:queue*
*/
let postAdminQueuePromote = async (~body: postAdminQueuePromoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueuePromoteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminQueuePromoteRequestSchema)
  let response = await fetch(
    ~url="/admin/queue/promote",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminQueueStatsResponse = {
  deliver: MisskeyIoComponentSchemas.QueueCount.t,
  inbox: MisskeyIoComponentSchemas.QueueCount.t,
  db: MisskeyIoComponentSchemas.QueueCount.t,
  objectStorage: MisskeyIoComponentSchemas.QueueCount.t,
}

let postAdminQueueStatsResponseSchema = S.object(s => {
    deliver: s.field("deliver", MisskeyIoComponentSchemas.QueueCount.schema),
    inbox: s.field("inbox", MisskeyIoComponentSchemas.QueueCount.schema),
    db: s.field("db", MisskeyIoComponentSchemas.QueueCount.schema),
    objectStorage: s.field("objectStorage", MisskeyIoComponentSchemas.QueueCount.schema),
  })

/**
admin/queue/stats

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:emoji*
*/
let postAdminQueueStats = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminQueueStatsResponse => {

  let response = await fetch(
    ~url="/admin/queue/stats",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postAdminQueueStatsResponseSchema)
}

type postAdminRegenerateUserTokenRequest = {
  userId: string,
}

let postAdminRegenerateUserTokenRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminRegenerateUserTokenResponse = unit

/**
admin/regenerate-user-token

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:regenerate-user-token*
*/
let postAdminRegenerateUserToken = async (~body: postAdminRegenerateUserTokenRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRegenerateUserTokenResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRegenerateUserTokenRequestSchema)
  let response = await fetch(
    ~url="/admin/regenerate-user-token",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminRelaysAddRequest = {
  inbox: string,
}

let postAdminRelaysAddRequestSchema = S.object(s => {
    inbox: s.field("inbox", S.string),
  })

type postAdminRelaysAddResponse = {
  id: string,
  inbox: string,
  status: string,
}

let postAdminRelaysAddResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    inbox: s.field("inbox", S.string),
    status: s.field("status", S.string),
  })

/**
admin/relays/add

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:relays*
*/
let postAdminRelaysAdd = async (~body: postAdminRelaysAddRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRelaysAddResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRelaysAddRequestSchema)
  let response = await fetch(
    ~url="/admin/relays/add",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminRelaysAddResponseSchema)
}

type postAdminRelaysListResponse_1 = {
  id: string,
  inbox: string,
  status: string,
}

type postAdminRelaysListResponse = array<postAdminRelaysListResponse_1>

let postAdminRelaysListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    inbox: s.field("inbox", S.string),
    status: s.field("status", S.string),
  })

let postAdminRelaysListResponseSchema = S.array(postAdminRelaysListResponse_1Schema)

/**
admin/relays/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:relays*
*/
let postAdminRelaysList = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRelaysListResponse => {

  let response = await fetch(
    ~url="/admin/relays/list",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postAdminRelaysListResponseSchema)
}

type postAdminRelaysRemoveRequest = {
  inbox: string,
}

let postAdminRelaysRemoveRequestSchema = S.object(s => {
    inbox: s.field("inbox", S.string),
  })

type postAdminRelaysRemoveResponse = unit

/**
admin/relays/remove

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:relays*
*/
let postAdminRelaysRemove = async (~body: postAdminRelaysRemoveRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRelaysRemoveResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRelaysRemoveRequestSchema)
  let response = await fetch(
    ~url="/admin/relays/remove",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminResetPasswordRequest = {
  userId: string,
}

let postAdminResetPasswordRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminResetPasswordResponse = {
  password: string,
}

let postAdminResetPasswordResponseSchema = S.object(s => {
    password: s.field("password", S.string->S.min(8)->S.max(8)),
  })

/**
admin/reset-password

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:reset-password*
*/
let postAdminResetPassword = async (~body: postAdminResetPasswordRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminResetPasswordResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminResetPasswordRequestSchema)
  let response = await fetch(
    ~url="/admin/reset-password",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminResetPasswordResponseSchema)
}

type postAdminResolveAbuseUserReportRequest = {
  reportId: string,
  resolvedAs: option<string>,
  forward: option<bool>,
}

let postAdminResolveAbuseUserReportRequestSchema = S.object(s => {
    reportId: s.field("reportId", S.string),
    resolvedAs: s.field("resolvedAs", S.option(S.string)),
    forward: s.field("forward", S.option(S.bool)),
  })

type postAdminResolveAbuseUserReportResponse = unit

/**
admin/resolve-abuse-user-report

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:resolve-abuse-user-report*
*/
let postAdminResolveAbuseUserReport = async (~body: postAdminResolveAbuseUserReportRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminResolveAbuseUserReportResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminResolveAbuseUserReportRequestSchema)
  let response = await fetch(
    ~url="/admin/resolve-abuse-user-report",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminRolesAssignRequest = {
  roleId: string,
  userId: string,
  memo: option<string>,
  expiresAt: option<int>,
}

let postAdminRolesAssignRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    userId: s.field("userId", S.string),
    memo: s.field("memo", S.option(S.string)),
    expiresAt: s.field("expiresAt", S.option(S.int)),
  })

type postAdminRolesAssignResponse = unit

/**
admin/roles/assign

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:roles*
*/
let postAdminRolesAssign = async (~body: postAdminRolesAssignRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesAssignResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesAssignRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/assign",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminRolesCreateRequest = {
  name: string,
  description: string,
  color: option<string>,
  iconUrl: option<string>,
  target: string,
  condFormula: dict<JSON.t>,
  isPublic: bool,
  isModerator: bool,
  isAdministrator: bool,
  isExplorable: option<bool>,
  asBadge: bool,
  badgeBehavior: option<string>,
  preserveAssignmentOnMoveAccount: option<bool>,
  canEditMembersByModerator: bool,
  displayOrder: float,
  policies: dict<JSON.t>,
}

let postAdminRolesCreateRequestSchema = S.object(s => {
    name: s.field("name", S.string),
    description: s.field("description", S.string),
    color: s.field("color", S.nullableAsOption(S.string)),
    iconUrl: s.field("iconUrl", S.nullableAsOption(S.string)),
    target: s.field("target", S.string),
    condFormula: s.field("condFormula", S.dict(S.json)),
    isPublic: s.field("isPublic", S.bool),
    isModerator: s.field("isModerator", S.bool),
    isAdministrator: s.field("isAdministrator", S.bool),
    isExplorable: s.field("isExplorable", S.option(S.bool)),
    asBadge: s.field("asBadge", S.bool),
    badgeBehavior: s.field("badgeBehavior", S.option(S.string)),
    preserveAssignmentOnMoveAccount: s.field("preserveAssignmentOnMoveAccount", S.option(S.bool)),
    canEditMembersByModerator: s.field("canEditMembersByModerator", S.bool),
    displayOrder: s.field("displayOrder", S.float),
    policies: s.field("policies", S.dict(S.json)),
  })

type postAdminRolesCreateResponse = MisskeyIoComponentSchemas.Role.t

let postAdminRolesCreateResponseSchema = MisskeyIoComponentSchemas.Role.schema

/**
admin/roles/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:roles*
*/
let postAdminRolesCreate = async (~body: postAdminRolesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminRolesCreateResponseSchema)
}

type postAdminRolesDeleteRequest = {
  roleId: string,
}

let postAdminRolesDeleteRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
  })

type postAdminRolesDeleteResponse = unit

/**
admin/roles/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:roles*
*/
let postAdminRolesDelete = async (~body: postAdminRolesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminRolesListResponse = array<MisskeyIoComponentSchemas.Role.t>

let postAdminRolesListResponseSchema = S.array(MisskeyIoComponentSchemas.Role.schema)

/**
admin/roles/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:roles*
*/
let postAdminRolesList = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesListResponse => {

  let response = await fetch(
    ~url="/admin/roles/list",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postAdminRolesListResponseSchema)
}

type postAdminRolesShowRequest = {
  roleId: string,
}

let postAdminRolesShowRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
  })

type postAdminRolesShowResponse = MisskeyIoComponentSchemas.Role.t

let postAdminRolesShowResponseSchema = MisskeyIoComponentSchemas.Role.schema

/**
admin/roles/show

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:roles*
*/
let postAdminRolesShow = async (~body: postAdminRolesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesShowRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminRolesShowResponseSchema)
}

type postAdminRolesUnassignRequest = {
  roleId: string,
  userId: string,
}

let postAdminRolesUnassignRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    userId: s.field("userId", S.string),
  })

type postAdminRolesUnassignResponse = unit

/**
admin/roles/unassign

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:roles*
*/
let postAdminRolesUnassign = async (~body: postAdminRolesUnassignRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesUnassignResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUnassignRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/unassign",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminRolesUpdateRequest = {
  roleId: string,
  name: option<string>,
  description: option<string>,
  color: option<string>,
  iconUrl: option<string>,
  target: option<string>,
  condFormula: option<dict<JSON.t>>,
  isPublic: option<bool>,
  isModerator: option<bool>,
  isAdministrator: option<bool>,
  isExplorable: option<bool>,
  asBadge: option<bool>,
  badgeBehavior: option<string>,
  preserveAssignmentOnMoveAccount: option<bool>,
  canEditMembersByModerator: option<bool>,
  displayOrder: option<float>,
  policies: option<dict<JSON.t>>,
}

let postAdminRolesUpdateRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    name: s.field("name", S.option(S.string)),
    description: s.field("description", S.option(S.string)),
    color: s.field("color", S.option(S.string)),
    iconUrl: s.field("iconUrl", S.option(S.string)),
    target: s.field("target", S.option(S.string)),
    condFormula: s.field("condFormula", S.option(S.dict(S.json))),
    isPublic: s.field("isPublic", S.option(S.bool)),
    isModerator: s.field("isModerator", S.option(S.bool)),
    isAdministrator: s.field("isAdministrator", S.option(S.bool)),
    isExplorable: s.field("isExplorable", S.option(S.bool)),
    asBadge: s.field("asBadge", S.option(S.bool)),
    badgeBehavior: s.field("badgeBehavior", S.option(S.string)),
    preserveAssignmentOnMoveAccount: s.field("preserveAssignmentOnMoveAccount", S.option(S.bool)),
    canEditMembersByModerator: s.field("canEditMembersByModerator", S.option(S.bool)),
    displayOrder: s.field("displayOrder", S.option(S.float)),
    policies: s.field("policies", S.option(S.dict(S.json))),
  })

type postAdminRolesUpdateResponse = unit

/**
admin/roles/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:roles*
*/
let postAdminRolesUpdate = async (~body: postAdminRolesUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminRolesUpdateDefaultPoliciesRequest = {
  policies: dict<JSON.t>,
}

let postAdminRolesUpdateDefaultPoliciesRequestSchema = S.object(s => {
    policies: s.field("policies", S.dict(S.json)),
  })

type postAdminRolesUpdateDefaultPoliciesResponse = unit

/**
admin/roles/update-default-policies

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:roles*
*/
let postAdminRolesUpdateDefaultPolicies = async (~body: postAdminRolesUpdateDefaultPoliciesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesUpdateDefaultPoliciesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUpdateDefaultPoliciesRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/update-default-policies",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

@unboxed type postAdminRolesUpdateInlinePoliciesRequest_2 = Bool(bool) | Float(float) | String(string)

type postAdminRolesUpdateInlinePoliciesRequest_1 = {
  id: option<string>,
  policy: string,
  operation: option<string>,
  value: option<postAdminRolesUpdateInlinePoliciesRequest_2>,
  memo: option<string>,
}

type postAdminRolesUpdateInlinePoliciesRequest = {
  userId: string,
  policies: array<postAdminRolesUpdateInlinePoliciesRequest_1>,
}

let postAdminRolesUpdateInlinePoliciesRequest_2Schema = S.union([S.bool->S.shape(v => Bool(v)), S.float->S.shape(v => Float(v)), S.string->S.shape(v => String(v))])

let postAdminRolesUpdateInlinePoliciesRequest_1Schema = S.object(s => {
    id: s.field("id", S.option(S.string)),
    policy: s.field("policy", S.string),
    operation: s.field("operation", S.option(S.string)),
    value: s.field("value", S.option(S.union([S.bool->S.shape(v => Bool(v)), S.float->S.shape(v => Float(v)), S.string->S.shape(v => String(v))]))),
    memo: s.field("memo", S.option(S.string)),
  })

let postAdminRolesUpdateInlinePoliciesRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    policies: s.field("policies", S.array(postAdminRolesUpdateInlinePoliciesRequest_1Schema)),
  })

type postAdminRolesUpdateInlinePoliciesResponse = unit

/**
admin/roles/update-inline-policies

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:roles*
*/
let postAdminRolesUpdateInlinePolicies = async (~body: postAdminRolesUpdateInlinePoliciesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesUpdateInlinePoliciesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUpdateInlinePoliciesRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/update-inline-policies",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminRolesUsersRequest = {
  roleId: string,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
}

let postAdminRolesUsersRequestSchema = S.object(s => {
    roleId: s.field("roleId", S.string),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
  })

type postAdminRolesUsersResponse_1 = {
  id: string,
  createdAt: string,
  user: MisskeyIoComponentSchemas.UserDetailed.t,
  memo: option<string>,
  expiresAt: option<string>,
}

type postAdminRolesUsersResponse = array<postAdminRolesUsersResponse_1>

let postAdminRolesUsersResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    user: s.field("user", MisskeyIoComponentSchemas.UserDetailed.schema),
    memo: s.field("memo", S.nullableAsOption(S.string)),
    expiresAt: s.field("expiresAt", S.nullableAsOption(S.string)),
  })

let postAdminRolesUsersResponseSchema = S.array(postAdminRolesUsersResponse_1Schema)

/**
admin/roles/users

No description provided.

**Credential required**: *No* / **Permission**: *read:admin:roles*
*/
let postAdminRolesUsers = async (~body: postAdminRolesUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminRolesUsersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminRolesUsersRequestSchema)
  let response = await fetch(
    ~url="/admin/roles/users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminRolesUsersResponseSchema)
}

type postAdminSendEmailRequest = {
  @as("to") to_: string,
  subject: string,
  text: string,
}

let postAdminSendEmailRequestSchema = S.object(s => {
    to_: s.field("to", S.string),
    subject: s.field("subject", S.string),
    text: s.field("text", S.string),
  })

type postAdminSendEmailResponse = unit

/**
admin/send-email

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:send-email*
*/
let postAdminSendEmail = async (~body: postAdminSendEmailRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSendEmailResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSendEmailRequestSchema)
  let response = await fetch(
    ~url="/admin/send-email",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminShowModerationLogsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  @as("type") type_: option<string>,
  userId: option<string>,
}

let postAdminShowModerationLogsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    type_: s.field("type", S.option(S.string)),
    userId: s.field("userId", S.option(S.string)),
  })

type postAdminShowModerationLogsResponse_1 = {
  id: string,
  createdAt: string,
  @as("type") type_: string,
  info: dict<JSON.t>,
  userId: string,
  user: MisskeyIoComponentSchemas.UserDetailed.t,
}

type postAdminShowModerationLogsResponse = array<postAdminShowModerationLogsResponse_1>

let postAdminShowModerationLogsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    type_: s.field("type", S.string),
    info: s.field("info", S.dict(S.json)),
    userId: s.field("userId", S.string),
    user: s.field("user", MisskeyIoComponentSchemas.UserDetailed.schema),
  })

let postAdminShowModerationLogsResponseSchema = S.array(postAdminShowModerationLogsResponse_1Schema)

/**
admin/show-moderation-logs

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:show-moderation-log*
*/
let postAdminShowModerationLogs = async (~body: postAdminShowModerationLogsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminShowModerationLogsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowModerationLogsRequestSchema)
  let response = await fetch(
    ~url="/admin/show-moderation-logs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminShowModerationLogsResponseSchema)
}

type postAdminShowUserRequest = {
  userId: string,
}

let postAdminShowUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

@unboxed type postAdminShowUserResponse_4 = Bool(bool) | Float(float) | String(string)

type postAdminShowUserResponse_3 = {
  id: string,
  createdAt: string,
  updatedAt: string,
  policy: string,
  operation: string,
  value: option<postAdminShowUserResponse_4>,
  memo: option<string>,
}

type postAdminShowUserResponse_2 = {
  createdAt: string,
  expiresAt: option<string>,
  roleId: string,
  memo: option<string>,
}

type postAdminShowUserResponse_1 = {
  note: option<dict<JSON.t>>,
  follow: option<dict<JSON.t>>,
  mention: option<dict<JSON.t>>,
  reply: option<dict<JSON.t>>,
  renote: option<dict<JSON.t>>,
  quote: option<dict<JSON.t>>,
  reaction: option<dict<JSON.t>>,
  pollEnded: option<dict<JSON.t>>,
  receiveFollowRequest: option<dict<JSON.t>>,
  followRequestAccepted: option<dict<JSON.t>>,
  roleAssigned: option<dict<JSON.t>>,
  chatRoomInvitationReceived: option<dict<JSON.t>>,
  achievementEarned: option<dict<JSON.t>>,
  app: option<dict<JSON.t>>,
  test: option<dict<JSON.t>>,
}

type postAdminShowUserResponse = {
  email: option<string>,
  emailVerified: bool,
  followedMessage: option<string>,
  autoAcceptFollowed: bool,
  noCrawle: bool,
  preventAiLearning: bool,
  alwaysMarkNsfw: bool,
  autoSensitive: bool,
  carefulBot: bool,
  injectFeaturedNote: bool,
  receiveAnnouncementEmail: bool,
  mutedWords: array<array<string>>,
  mutedInstances: array<string>,
  notificationRecieveConfig: postAdminShowUserResponse_1,
  isModerator: bool,
  isSilenced: bool,
  isLimited: bool,
  isDeleted: bool,
  isSuspended: bool,
  isHibernated: bool,
  lastActiveDate: option<string>,
  moderationNote: string,
  signins: array<MisskeyIoComponentSchemas.Signin.t>,
  policies: MisskeyIoComponentSchemas.RolePolicies.t,
  roles: array<MisskeyIoComponentSchemas.Role.t>,
  roleAssigns: array<postAdminShowUserResponse_2>,
  inlinePolicies: array<postAdminShowUserResponse_3>,
}

let postAdminShowUserResponse_4Schema = S.union([S.bool->S.shape(v => Bool(v)), S.float->S.shape(v => Float(v)), S.string->S.shape(v => String(v))])

let postAdminShowUserResponse_3Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    updatedAt: s.field("updatedAt", S.string),
    policy: s.field("policy", S.string),
    operation: s.field("operation", S.string),
    value: s.field("value", S.nullableAsOption(S.union([S.bool->S.shape(v => Bool(v)), S.float->S.shape(v => Float(v)), S.string->S.shape(v => String(v))]))),
    memo: s.field("memo", S.nullableAsOption(S.string)),
  })

let postAdminShowUserResponse_2Schema = S.object(s => {
    createdAt: s.field("createdAt", S.string),
    expiresAt: s.field("expiresAt", S.nullableAsOption(S.string)),
    roleId: s.field("roleId", S.string),
    memo: s.field("memo", S.nullableAsOption(S.string)),
  })

let postAdminShowUserResponse_1Schema = S.object(s => {
    note: s.field("note", S.option(S.dict(S.json))),
    follow: s.field("follow", S.option(S.dict(S.json))),
    mention: s.field("mention", S.option(S.dict(S.json))),
    reply: s.field("reply", S.option(S.dict(S.json))),
    renote: s.field("renote", S.option(S.dict(S.json))),
    quote: s.field("quote", S.option(S.dict(S.json))),
    reaction: s.field("reaction", S.option(S.dict(S.json))),
    pollEnded: s.field("pollEnded", S.option(S.dict(S.json))),
    receiveFollowRequest: s.field("receiveFollowRequest", S.option(S.dict(S.json))),
    followRequestAccepted: s.field("followRequestAccepted", S.option(S.dict(S.json))),
    roleAssigned: s.field("roleAssigned", S.option(S.dict(S.json))),
    chatRoomInvitationReceived: s.field("chatRoomInvitationReceived", S.option(S.dict(S.json))),
    achievementEarned: s.field("achievementEarned", S.option(S.dict(S.json))),
    app: s.field("app", S.option(S.dict(S.json))),
    test: s.field("test", S.option(S.dict(S.json))),
  })

let postAdminShowUserResponseSchema = S.object(s => {
    email: s.field("email", S.nullableAsOption(S.string)),
    emailVerified: s.field("emailVerified", S.bool),
    followedMessage: s.field("followedMessage", S.nullableAsOption(S.string)),
    autoAcceptFollowed: s.field("autoAcceptFollowed", S.bool),
    noCrawle: s.field("noCrawle", S.bool),
    preventAiLearning: s.field("preventAiLearning", S.bool),
    alwaysMarkNsfw: s.field("alwaysMarkNsfw", S.bool),
    autoSensitive: s.field("autoSensitive", S.bool),
    carefulBot: s.field("carefulBot", S.bool),
    injectFeaturedNote: s.field("injectFeaturedNote", S.bool),
    receiveAnnouncementEmail: s.field("receiveAnnouncementEmail", S.bool),
    mutedWords: s.field("mutedWords", S.array(S.array(S.string))),
    mutedInstances: s.field("mutedInstances", S.array(S.string)),
    notificationRecieveConfig: s.field("notificationRecieveConfig", postAdminShowUserResponse_1Schema),
    isModerator: s.field("isModerator", S.bool),
    isSilenced: s.field("isSilenced", S.bool),
    isLimited: s.field("isLimited", S.bool),
    isDeleted: s.field("isDeleted", S.bool),
    isSuspended: s.field("isSuspended", S.bool),
    isHibernated: s.field("isHibernated", S.bool),
    lastActiveDate: s.field("lastActiveDate", S.nullableAsOption(S.string)),
    moderationNote: s.field("moderationNote", S.string),
    signins: s.field("signins", S.array(MisskeyIoComponentSchemas.Signin.schema)),
    policies: s.field("policies", MisskeyIoComponentSchemas.RolePolicies.schema),
    roles: s.field("roles", S.array(MisskeyIoComponentSchemas.Role.schema)),
    roleAssigns: s.field("roleAssigns", S.array(postAdminShowUserResponse_2Schema)),
    inlinePolicies: s.field("inlinePolicies", S.array(postAdminShowUserResponse_3Schema)),
  })

/**
admin/show-user

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:show-user*
*/
let postAdminShowUser = async (~body: postAdminShowUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminShowUserResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowUserRequestSchema)
  let response = await fetch(
    ~url="/admin/show-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminShowUserResponseSchema)
}

type postAdminShowUserAccountMoveLogsRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  movedFromId: option<string>,
  movedToId: option<string>,
  from: option<string>,
  @as("to") to_: option<string>,
}

let postAdminShowUserAccountMoveLogsRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    movedFromId: s.field("movedFromId", S.option(S.string)),
    movedToId: s.field("movedToId", S.option(S.string)),
    from: s.field("from", S.option(S.string)),
    to_: s.field("to", S.option(S.string)),
  })

type postAdminShowUserAccountMoveLogsResponse_1 = {
  id: string,
  createdAt: string,
  movedToId: string,
  movedTo: MisskeyIoComponentSchemas.UserDetailed.t,
  movedFromId: string,
  movedFrom: MisskeyIoComponentSchemas.UserDetailed.t,
}

type postAdminShowUserAccountMoveLogsResponse = array<postAdminShowUserAccountMoveLogsResponse_1>

let postAdminShowUserAccountMoveLogsResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    movedToId: s.field("movedToId", S.string),
    movedTo: s.field("movedTo", MisskeyIoComponentSchemas.UserDetailed.schema),
    movedFromId: s.field("movedFromId", S.string),
    movedFrom: s.field("movedFrom", MisskeyIoComponentSchemas.UserDetailed.schema),
  })

let postAdminShowUserAccountMoveLogsResponseSchema = S.array(postAdminShowUserAccountMoveLogsResponse_1Schema)

/**
admin/show-user-account-move-logs

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:show-account-move-log*
*/
let postAdminShowUserAccountMoveLogs = async (~body: postAdminShowUserAccountMoveLogsRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminShowUserAccountMoveLogsResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowUserAccountMoveLogsRequestSchema)
  let response = await fetch(
    ~url="/admin/show-user-account-move-logs",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminShowUserAccountMoveLogsResponseSchema)
}

type postAdminShowUsersRequest = {
  limit: option<int>,
  offset: option<int>,
  sort: option<string>,
  state: option<string>,
  origin: option<string>,
  username: option<string>,
  hostname: option<string>,
}

let postAdminShowUsersRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
    sort: s.field("sort", S.option(S.string)),
    state: s.field("state", S.option(S.string)),
    origin: s.field("origin", S.option(S.string)),
    username: s.field("username", S.option(S.string)),
    hostname: s.field("hostname", S.option(S.string)),
  })

type postAdminShowUsersResponse = array<MisskeyIoComponentSchemas.UserDetailed.t>

let postAdminShowUsersResponseSchema = S.array(MisskeyIoComponentSchemas.UserDetailed.schema)

/**
admin/show-users

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:show-user*
*/
let postAdminShowUsers = async (~body: postAdminShowUsersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminShowUsersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminShowUsersRequestSchema)
  let response = await fetch(
    ~url="/admin/show-users",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminShowUsersResponseSchema)
}

type postAdminSsoCreateRequest = {
  name: option<string>,
  @as("type") type_: string,
  issuer: string,
  audience: option<array<string>>,
  binding: option<string>,
  acsUrl: string,
  signatureAlgorithm: string,
  cipherAlgorithm: option<string>,
  wantAuthnRequestsSigned: option<bool>,
  wantAssertionsSigned: option<bool>,
  wantEmailAddressNormalized: option<bool>,
  useCertificate: bool,
  secret: option<string>,
}

let postAdminSsoCreateRequestSchema = S.object(s => {
    name: s.field("name", S.option(S.string)),
    type_: s.field("type", S.string),
    issuer: s.field("issuer", S.string),
    audience: s.field("audience", S.option(S.array(S.string))),
    binding: s.field("binding", S.option(S.string)),
    acsUrl: s.field("acsUrl", S.string),
    signatureAlgorithm: s.field("signatureAlgorithm", S.string),
    cipherAlgorithm: s.field("cipherAlgorithm", S.option(S.string)),
    wantAuthnRequestsSigned: s.field("wantAuthnRequestsSigned", S.option(S.bool)),
    wantAssertionsSigned: s.field("wantAssertionsSigned", S.option(S.bool)),
    wantEmailAddressNormalized: s.field("wantEmailAddressNormalized", S.option(S.bool)),
    useCertificate: s.field("useCertificate", S.bool),
    secret: s.field("secret", S.option(S.string)),
  })

type postAdminSsoCreateResponse = {
  id: string,
  createdAt: string,
  name: option<string>,
  @as("type") type_: string,
  issuer: string,
  audience: array<string>,
  binding: string,
  acsUrl: string,
  publicKey: string,
  signatureAlgorithm: string,
  cipherAlgorithm: option<string>,
  wantAuthnRequestsSigned: bool,
  wantAssertionsSigned: bool,
  wantEmailAddressNormalized: bool,
}

let postAdminSsoCreateResponseSchema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.nullableAsOption(S.string)),
    type_: s.field("type", S.string),
    issuer: s.field("issuer", S.string),
    audience: s.field("audience", S.array(S.string)),
    binding: s.field("binding", S.string),
    acsUrl: s.field("acsUrl", S.string),
    publicKey: s.field("publicKey", S.string),
    signatureAlgorithm: s.field("signatureAlgorithm", S.string),
    cipherAlgorithm: s.field("cipherAlgorithm", S.option(S.string)),
    wantAuthnRequestsSigned: s.field("wantAuthnRequestsSigned", S.bool),
    wantAssertionsSigned: s.field("wantAssertionsSigned", S.bool),
    wantEmailAddressNormalized: s.field("wantEmailAddressNormalized", S.bool),
  })

/**
admin/sso/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:sso*
*/
let postAdminSsoCreate = async (~body: postAdminSsoCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSsoCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSsoCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/sso/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminSsoCreateResponseSchema)
}

type postAdminSsoDeleteRequest = {
  id: string,
}

let postAdminSsoDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminSsoDeleteResponse = unit

/**
admin/sso/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:sso*
*/
let postAdminSsoDelete = async (~body: postAdminSsoDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSsoDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSsoDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/sso/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminSsoListRequest = {
  limit: option<int>,
  offset: option<int>,
}

let postAdminSsoListRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    offset: s.field("offset", S.option(S.int)),
  })

type postAdminSsoListResponse_1 = {
  id: string,
  createdAt: string,
  name: option<string>,
  @as("type") type_: string,
  issuer: string,
  audience: array<string>,
  binding: string,
  acsUrl: string,
  useCertificate: bool,
  publicKey: string,
  signatureAlgorithm: string,
  cipherAlgorithm: option<string>,
  wantAuthnRequestsSigned: bool,
  wantAssertionsSigned: bool,
  wantEmailAddressNormalized: bool,
}

type postAdminSsoListResponse = array<postAdminSsoListResponse_1>

let postAdminSsoListResponse_1Schema = S.object(s => {
    id: s.field("id", S.string),
    createdAt: s.field("createdAt", S.string),
    name: s.field("name", S.nullableAsOption(S.string)),
    type_: s.field("type", S.string),
    issuer: s.field("issuer", S.string),
    audience: s.field("audience", S.array(S.string)),
    binding: s.field("binding", S.string),
    acsUrl: s.field("acsUrl", S.string),
    useCertificate: s.field("useCertificate", S.bool),
    publicKey: s.field("publicKey", S.string),
    signatureAlgorithm: s.field("signatureAlgorithm", S.string),
    cipherAlgorithm: s.field("cipherAlgorithm", S.option(S.string)),
    wantAuthnRequestsSigned: s.field("wantAuthnRequestsSigned", S.bool),
    wantAssertionsSigned: s.field("wantAssertionsSigned", S.bool),
    wantEmailAddressNormalized: s.field("wantEmailAddressNormalized", S.bool),
  })

let postAdminSsoListResponseSchema = S.array(postAdminSsoListResponse_1Schema)

/**
admin/sso/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:sso*
*/
let postAdminSsoList = async (~body: postAdminSsoListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSsoListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSsoListRequestSchema)
  let response = await fetch(
    ~url="/admin/sso/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminSsoListResponseSchema)
}

type postAdminSsoUpdateRequest = {
  id: string,
  name: option<string>,
  issuer: option<string>,
  audience: option<array<string>>,
  binding: option<string>,
  acsUrl: option<string>,
  signatureAlgorithm: option<string>,
  cipherAlgorithm: option<string>,
  wantAuthnRequestsSigned: option<bool>,
  wantAssertionsSigned: option<bool>,
  wantEmailAddressNormalized: option<bool>,
  regenerateCertificate: option<bool>,
  secret: option<string>,
}

let postAdminSsoUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    name: s.field("name", S.option(S.string)),
    issuer: s.field("issuer", S.option(S.string)),
    audience: s.field("audience", S.option(S.array(S.string))),
    binding: s.field("binding", S.option(S.string)),
    acsUrl: s.field("acsUrl", S.option(S.string)),
    signatureAlgorithm: s.field("signatureAlgorithm", S.option(S.string)),
    cipherAlgorithm: s.field("cipherAlgorithm", S.option(S.string)),
    wantAuthnRequestsSigned: s.field("wantAuthnRequestsSigned", S.option(S.bool)),
    wantAssertionsSigned: s.field("wantAssertionsSigned", S.option(S.bool)),
    wantEmailAddressNormalized: s.field("wantEmailAddressNormalized", S.option(S.bool)),
    regenerateCertificate: s.field("regenerateCertificate", S.option(S.bool)),
    secret: s.field("secret", S.option(S.string)),
  })

type postAdminSsoUpdateResponse = unit

/**
admin/sso/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:sso*
*/
let postAdminSsoUpdate = async (~body: postAdminSsoUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSsoUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSsoUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/sso/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminSuspendUserRequest = {
  userId: string,
}

let postAdminSuspendUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminSuspendUserResponse = unit

/**
admin/suspend-user

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:suspend-user*
*/
let postAdminSuspendUser = async (~body: postAdminSuspendUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSuspendUserResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSuspendUserRequestSchema)
  let response = await fetch(
    ~url="/admin/suspend-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminSystemWebhookCreateRequest = {
  isActive: bool,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
}

let postAdminSystemWebhookCreateRequestSchema = S.object(s => {
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string->S.min(1)->S.max(1024)),
    secret: s.field("secret", S.string->S.min(1)->S.max(1024)),
  })

type postAdminSystemWebhookCreateResponse = MisskeyIoComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookCreateResponseSchema = MisskeyIoComponentSchemas.SystemWebhook.schema

/**
admin/system-webhook/create

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
*/
let postAdminSystemWebhookCreate = async (~body: postAdminSystemWebhookCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSystemWebhookCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookCreateRequestSchema)
  let response = await fetch(
    ~url="/admin/system-webhook/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminSystemWebhookCreateResponseSchema)
}

type postAdminSystemWebhookDeleteRequest = {
  id: string,
}

let postAdminSystemWebhookDeleteRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminSystemWebhookDeleteResponse = unit

/**
admin/system-webhook/delete

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
*/
let postAdminSystemWebhookDelete = async (~body: postAdminSystemWebhookDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSystemWebhookDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookDeleteRequestSchema)
  let response = await fetch(
    ~url="/admin/system-webhook/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminSystemWebhookListRequest = {
  isActive: option<bool>,
  on: option<array<string>>,
}

let postAdminSystemWebhookListRequestSchema = S.object(s => {
    isActive: s.field("isActive", S.option(S.bool)),
    on: s.field("on", S.option(S.array(S.string))),
  })

type postAdminSystemWebhookListResponse = array<MisskeyIoComponentSchemas.SystemWebhook.t>

let postAdminSystemWebhookListResponseSchema = S.array(MisskeyIoComponentSchemas.SystemWebhook.schema)

/**
admin/system-webhook/list

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
*/
let postAdminSystemWebhookList = async (~body: postAdminSystemWebhookListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSystemWebhookListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookListRequestSchema)
  let response = await fetch(
    ~url="/admin/system-webhook/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminSystemWebhookListResponseSchema)
}

type postAdminSystemWebhookShowRequest = {
  id: string,
}

let postAdminSystemWebhookShowRequestSchema = S.object(s => {
    id: s.field("id", S.string),
  })

type postAdminSystemWebhookShowResponse = MisskeyIoComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookShowResponseSchema = MisskeyIoComponentSchemas.SystemWebhook.schema

/**
admin/system-webhook/show

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
*/
let postAdminSystemWebhookShow = async (~body: postAdminSystemWebhookShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSystemWebhookShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookShowRequestSchema)
  let response = await fetch(
    ~url="/admin/system-webhook/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminSystemWebhookShowResponseSchema)
}

type postAdminSystemWebhookUpdateRequest = {
  id: string,
  isActive: bool,
  name: string,
  on: array<string>,
  url: string,
  secret: string,
}

let postAdminSystemWebhookUpdateRequestSchema = S.object(s => {
    id: s.field("id", S.string),
    isActive: s.field("isActive", S.bool),
    name: s.field("name", S.string->S.min(1)->S.max(255)),
    on: s.field("on", S.array(S.string)),
    url: s.field("url", S.string->S.min(1)->S.max(1024)),
    secret: s.field("secret", S.string->S.min(1)->S.max(1024)),
  })

type postAdminSystemWebhookUpdateResponse = MisskeyIoComponentSchemas.SystemWebhook.t

let postAdminSystemWebhookUpdateResponseSchema = MisskeyIoComponentSchemas.SystemWebhook.schema

/**
admin/system-webhook/update

No description provided.

**Internal Endpoint**: This endpoint is an API for the misskey mainframe and is not intended for use by third parties.
**Credential required**: *Yes* / **Permission**: *write:admin:system-webhook*
*/
let postAdminSystemWebhookUpdate = async (~body: postAdminSystemWebhookUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminSystemWebhookUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminSystemWebhookUpdateRequestSchema)
  let response = await fetch(
    ~url="/admin/system-webhook/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminSystemWebhookUpdateResponseSchema)
}

type postAdminUnsetUserAvatarRequest = {
  userId: string,
}

let postAdminUnsetUserAvatarRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminUnsetUserAvatarResponse = unit

/**
admin/unset-user-avatar

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:user-avatar*
*/
let postAdminUnsetUserAvatar = async (~body: postAdminUnsetUserAvatarRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminUnsetUserAvatarResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUnsetUserAvatarRequestSchema)
  let response = await fetch(
    ~url="/admin/unset-user-avatar",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminUnsetUserBannerRequest = {
  userId: string,
}

let postAdminUnsetUserBannerRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminUnsetUserBannerResponse = unit

/**
admin/unset-user-banner

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:user-banner*
*/
let postAdminUnsetUserBanner = async (~body: postAdminUnsetUserBannerRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminUnsetUserBannerResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUnsetUserBannerRequestSchema)
  let response = await fetch(
    ~url="/admin/unset-user-banner",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminUnsetUserMutualLinkRequest = {
  userId: string,
  itemId: string,
}

let postAdminUnsetUserMutualLinkRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    itemId: s.field("itemId", S.string),
  })

type postAdminUnsetUserMutualLinkResponse = unit

/**
admin/unset-user-mutual-link

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:user-mutual-link*
*/
let postAdminUnsetUserMutualLink = async (~body: postAdminUnsetUserMutualLinkRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminUnsetUserMutualLinkResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUnsetUserMutualLinkRequestSchema)
  let response = await fetch(
    ~url="/admin/unset-user-mutual-link",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminUnsuspendUserRequest = {
  userId: string,
}

let postAdminUnsuspendUserRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
  })

type postAdminUnsuspendUserResponse = unit

/**
admin/unsuspend-user

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:unsuspend-user*
*/
let postAdminUnsuspendUser = async (~body: postAdminUnsuspendUserRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminUnsuspendUserResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUnsuspendUserRequestSchema)
  let response = await fetch(
    ~url="/admin/unsuspend-user",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminUpdateAbuseUserReportRequest = {
  reportId: string,
  moderationNote: option<string>,
}

let postAdminUpdateAbuseUserReportRequestSchema = S.object(s => {
    reportId: s.field("reportId", S.string),
    moderationNote: s.field("moderationNote", S.option(S.string)),
  })

type postAdminUpdateAbuseUserReportResponse = unit

/**
admin/update-abuse-user-report

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:resolve-abuse-user-report*
*/
let postAdminUpdateAbuseUserReport = async (~body: postAdminUpdateAbuseUserReportRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminUpdateAbuseUserReportResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateAbuseUserReportRequestSchema)
  let response = await fetch(
    ~url="/admin/update-abuse-user-report",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminUpdateMetaRequest = {
  disableRegistration: option<bool>,
  pinnedUsers: option<JSON.t>,
  hiddenTags: option<JSON.t>,
  blockedHosts: option<JSON.t>,
  sensitiveWords: option<JSON.t>,
  blockedRemoteCustomEmojis: option<JSON.t>,
  prohibitedWords: option<JSON.t>,
  themeColor: option<string>,
  mascotImageUrl: option<string>,
  bannerUrl: option<string>,
  serverErrorImageUrl: option<string>,
  infoImageUrl: option<string>,
  notFoundImageUrl: option<string>,
  iconUrl: option<string>,
  @as("app192IconUrl") app192iconUrl: option<string>,
  @as("app512IconUrl") app512iconUrl: option<string>,
  backgroundImageUrl: option<string>,
  logoImageUrl: option<string>,
  name: option<string>,
  shortName: option<string>,
  description: option<string>,
  defaultLightTheme: option<string>,
  defaultDarkTheme: option<string>,
  cacheRemoteFiles: option<bool>,
  cacheRemoteSensitiveFiles: option<bool>,
  emailRequiredForSignup: option<bool>,
  enableHcaptcha: option<bool>,
  hcaptchaSiteKey: option<string>,
  hcaptchaSecretKey: option<string>,
  enableMcaptcha: option<bool>,
  mcaptchaSiteKey: option<string>,
  mcaptchaInstanceUrl: option<string>,
  mcaptchaSecretKey: option<string>,
  enableRecaptcha: option<bool>,
  recaptchaSiteKey: option<string>,
  recaptchaSecretKey: option<string>,
  enableTurnstile: option<bool>,
  turnstileSiteKey: option<string>,
  turnstileSecretKey: option<string>,
  googleAnalyticsId: option<string>,
  sensitiveMediaDetection: option<string>,
  sensitiveMediaDetectionSensitivity: option<string>,
  setSensitiveFlagAutomatically: option<bool>,
  enableSensitiveMediaDetectionForVideos: option<bool>,
  maintainerName: option<string>,
  maintainerEmail: option<string>,
  langs: option<array<string>>,
  dimensions: option<int>,
  deeplAuthKey: option<string>,
  deeplIsPro: option<bool>,
  enableEmail: option<bool>,
  email: option<string>,
  smtpSecure: option<bool>,
  smtpHost: option<string>,
  smtpPort: option<int>,
  smtpUser: option<string>,
  smtpPass: option<string>,
  enableServiceWorker: option<bool>,
  swPublicKey: option<string>,
  swPrivateKey: option<string>,
  tosUrl: option<string>,
  repositoryUrl: option<string>,
  feedbackUrl: option<string>,
  impressumUrl: option<string>,
  privacyPolicyUrl: option<string>,
  useObjectStorage: option<bool>,
  objectStorageBaseUrl: option<string>,
  objectStorageBucket: option<string>,
  objectStoragePrefix: option<string>,
  objectStorageEndpoint: option<string>,
  objectStorageRegion: option<string>,
  objectStoragePort: option<int>,
  objectStorageAccessKey: option<string>,
  objectStorageSecretKey: option<string>,
  @as("objectStorageUseSSL") objectStorageUseSsl: option<bool>,
  objectStorageUseProxy: option<bool>,
  objectStorageSetPublicRead: option<bool>,
  @as("objectStorageS3ForcePathStyle") objectStorageS3forcePathStyle: option<bool>,
  enableIpLogging: option<bool>,
  enableActiveEmailValidation: option<bool>,
  enableVerifymailApi: option<bool>,
  verifymailAuthKey: option<string>,
  enableTruemailApi: option<bool>,
  truemailInstance: option<string>,
  truemailAuthKey: option<string>,
  enableChartsForRemoteUser: option<bool>,
  enableChartsForFederatedInstances: option<bool>,
  enableServerMachineStats: option<bool>,
  enableIdenticonGeneration: option<bool>,
  serverRules: option<array<string>>,
  bannedEmailDomains: option<array<string>>,
  preservedUsernames: option<array<string>>,
  manifestJsonOverride: option<string>,
  enableFanoutTimeline: option<bool>,
  enableFanoutTimelineDbFallback: option<bool>,
  perLocalUserUserTimelineCacheMax: option<int>,
  perRemoteUserUserTimelineCacheMax: option<int>,
  perUserHomeTimelineCacheMax: option<int>,
  perUserListTimelineCacheMax: option<int>,
  notesPerOneAd: option<int>,
  silencedHosts: option<JSON.t>,
  sensitiveMediaHosts: option<JSON.t>,
  wellKnownWebsites: option<JSON.t>,
  urlPreviewDenyList: option<JSON.t>,
  featuredGameChannels: option<JSON.t>,
  summalyProxy: option<string>,
  urlPreviewEnabled: option<bool>,
  urlPreviewTimeout: option<int>,
  urlPreviewMaximumContentLength: option<int>,
  urlPreviewRequireContentLength: option<bool>,
  urlPreviewUserAgent: option<string>,
  urlPreviewSummaryProxyUrl: option<string>,
  prohibitedWordsForNameOfUser: option<JSON.t>,
  federation: option<string>,
  federationHosts: option<array<string>>,
}

let postAdminUpdateMetaRequestSchema = S.object(s => {
    disableRegistration: s.field("disableRegistration", S.option(S.bool)),
    pinnedUsers: s.field("pinnedUsers", S.option(S.json)),
    hiddenTags: s.field("hiddenTags", S.option(S.json)),
    blockedHosts: s.field("blockedHosts", S.option(S.json)),
    sensitiveWords: s.field("sensitiveWords", S.option(S.json)),
    blockedRemoteCustomEmojis: s.field("blockedRemoteCustomEmojis", S.option(S.json)),
    prohibitedWords: s.field("prohibitedWords", S.option(S.json)),
    themeColor: s.field("themeColor", S.option(S.string->S.pattern(/^#[0-9a-fA-F]{6}$/))),
    mascotImageUrl: s.field("mascotImageUrl", S.option(S.string)),
    bannerUrl: s.field("bannerUrl", S.option(S.string)),
    serverErrorImageUrl: s.field("serverErrorImageUrl", S.option(S.string)),
    infoImageUrl: s.field("infoImageUrl", S.option(S.string)),
    notFoundImageUrl: s.field("notFoundImageUrl", S.option(S.string)),
    iconUrl: s.field("iconUrl", S.option(S.string)),
    app192iconUrl: s.field("app192IconUrl", S.option(S.string)),
    app512iconUrl: s.field("app512IconUrl", S.option(S.string)),
    backgroundImageUrl: s.field("backgroundImageUrl", S.option(S.string)),
    logoImageUrl: s.field("logoImageUrl", S.option(S.string)),
    name: s.field("name", S.option(S.string)),
    shortName: s.field("shortName", S.option(S.string)),
    description: s.field("description", S.option(S.string)),
    defaultLightTheme: s.field("defaultLightTheme", S.option(S.string)),
    defaultDarkTheme: s.field("defaultDarkTheme", S.option(S.string)),
    cacheRemoteFiles: s.field("cacheRemoteFiles", S.option(S.bool)),
    cacheRemoteSensitiveFiles: s.field("cacheRemoteSensitiveFiles", S.option(S.bool)),
    emailRequiredForSignup: s.field("emailRequiredForSignup", S.option(S.bool)),
    enableHcaptcha: s.field("enableHcaptcha", S.option(S.bool)),
    hcaptchaSiteKey: s.field("hcaptchaSiteKey", S.option(S.string)),
    hcaptchaSecretKey: s.field("hcaptchaSecretKey", S.option(S.string)),
    enableMcaptcha: s.field("enableMcaptcha", S.option(S.bool)),
    mcaptchaSiteKey: s.field("mcaptchaSiteKey", S.option(S.string)),
    mcaptchaInstanceUrl: s.field("mcaptchaInstanceUrl", S.option(S.string)),
    mcaptchaSecretKey: s.field("mcaptchaSecretKey", S.option(S.string)),
    enableRecaptcha: s.field("enableRecaptcha", S.option(S.bool)),
    recaptchaSiteKey: s.field("recaptchaSiteKey", S.option(S.string)),
    recaptchaSecretKey: s.field("recaptchaSecretKey", S.option(S.string)),
    enableTurnstile: s.field("enableTurnstile", S.option(S.bool)),
    turnstileSiteKey: s.field("turnstileSiteKey", S.option(S.string)),
    turnstileSecretKey: s.field("turnstileSecretKey", S.option(S.string)),
    googleAnalyticsId: s.field("googleAnalyticsId", S.option(S.string)),
    sensitiveMediaDetection: s.field("sensitiveMediaDetection", S.option(S.string)),
    sensitiveMediaDetectionSensitivity: s.field("sensitiveMediaDetectionSensitivity", S.option(S.string)),
    setSensitiveFlagAutomatically: s.field("setSensitiveFlagAutomatically", S.option(S.bool)),
    enableSensitiveMediaDetectionForVideos: s.field("enableSensitiveMediaDetectionForVideos", S.option(S.bool)),
    maintainerName: s.field("maintainerName", S.option(S.string)),
    maintainerEmail: s.field("maintainerEmail", S.option(S.string)),
    langs: s.field("langs", S.option(S.array(S.string))),
    dimensions: s.field("dimensions", S.option(S.int->S.min(1))),
    deeplAuthKey: s.field("deeplAuthKey", S.option(S.string)),
    deeplIsPro: s.field("deeplIsPro", S.option(S.bool)),
    enableEmail: s.field("enableEmail", S.option(S.bool)),
    email: s.field("email", S.option(S.string)),
    smtpSecure: s.field("smtpSecure", S.option(S.bool)),
    smtpHost: s.field("smtpHost", S.option(S.string)),
    smtpPort: s.field("smtpPort", S.option(S.int)),
    smtpUser: s.field("smtpUser", S.option(S.string)),
    smtpPass: s.field("smtpPass", S.option(S.string)),
    enableServiceWorker: s.field("enableServiceWorker", S.option(S.bool)),
    swPublicKey: s.field("swPublicKey", S.option(S.string)),
    swPrivateKey: s.field("swPrivateKey", S.option(S.string)),
    tosUrl: s.field("tosUrl", S.option(S.string)),
    repositoryUrl: s.field("repositoryUrl", S.option(S.string)),
    feedbackUrl: s.field("feedbackUrl", S.option(S.string)),
    impressumUrl: s.field("impressumUrl", S.option(S.string)),
    privacyPolicyUrl: s.field("privacyPolicyUrl", S.option(S.string)),
    useObjectStorage: s.field("useObjectStorage", S.option(S.bool)),
    objectStorageBaseUrl: s.field("objectStorageBaseUrl", S.option(S.string)),
    objectStorageBucket: s.field("objectStorageBucket", S.option(S.string)),
    objectStoragePrefix: s.field("objectStoragePrefix", S.option(S.string->S.pattern(/^[a-zA-Z0-9._-]*$/))),
    objectStorageEndpoint: s.field("objectStorageEndpoint", S.option(S.string)),
    objectStorageRegion: s.field("objectStorageRegion", S.option(S.string)),
    objectStoragePort: s.field("objectStoragePort", S.option(S.int)),
    objectStorageAccessKey: s.field("objectStorageAccessKey", S.option(S.string)),
    objectStorageSecretKey: s.field("objectStorageSecretKey", S.option(S.string)),
    objectStorageUseSsl: s.field("objectStorageUseSSL", S.option(S.bool)),
    objectStorageUseProxy: s.field("objectStorageUseProxy", S.option(S.bool)),
    objectStorageSetPublicRead: s.field("objectStorageSetPublicRead", S.option(S.bool)),
    objectStorageS3forcePathStyle: s.field("objectStorageS3ForcePathStyle", S.option(S.bool)),
    enableIpLogging: s.field("enableIpLogging", S.option(S.bool)),
    enableActiveEmailValidation: s.field("enableActiveEmailValidation", S.option(S.bool)),
    enableVerifymailApi: s.field("enableVerifymailApi", S.option(S.bool)),
    verifymailAuthKey: s.field("verifymailAuthKey", S.option(S.string)),
    enableTruemailApi: s.field("enableTruemailApi", S.option(S.bool)),
    truemailInstance: s.field("truemailInstance", S.option(S.string)),
    truemailAuthKey: s.field("truemailAuthKey", S.option(S.string)),
    enableChartsForRemoteUser: s.field("enableChartsForRemoteUser", S.option(S.bool)),
    enableChartsForFederatedInstances: s.field("enableChartsForFederatedInstances", S.option(S.bool)),
    enableServerMachineStats: s.field("enableServerMachineStats", S.option(S.bool)),
    enableIdenticonGeneration: s.field("enableIdenticonGeneration", S.option(S.bool)),
    serverRules: s.field("serverRules", S.option(S.array(S.string))),
    bannedEmailDomains: s.field("bannedEmailDomains", S.option(S.array(S.string))),
    preservedUsernames: s.field("preservedUsernames", S.option(S.array(S.string))),
    manifestJsonOverride: s.field("manifestJsonOverride", S.option(S.string)),
    enableFanoutTimeline: s.field("enableFanoutTimeline", S.option(S.bool)),
    enableFanoutTimelineDbFallback: s.field("enableFanoutTimelineDbFallback", S.option(S.bool)),
    perLocalUserUserTimelineCacheMax: s.field("perLocalUserUserTimelineCacheMax", S.option(S.int)),
    perRemoteUserUserTimelineCacheMax: s.field("perRemoteUserUserTimelineCacheMax", S.option(S.int)),
    perUserHomeTimelineCacheMax: s.field("perUserHomeTimelineCacheMax", S.option(S.int)),
    perUserListTimelineCacheMax: s.field("perUserListTimelineCacheMax", S.option(S.int)),
    notesPerOneAd: s.field("notesPerOneAd", S.option(S.int)),
    silencedHosts: s.field("silencedHosts", S.option(S.json)),
    sensitiveMediaHosts: s.field("sensitiveMediaHosts", S.option(S.json)),
    wellKnownWebsites: s.field("wellKnownWebsites", S.option(S.json)),
    urlPreviewDenyList: s.field("urlPreviewDenyList", S.option(S.json)),
    featuredGameChannels: s.field("featuredGameChannels", S.option(S.json)),
    summalyProxy: s.field("summalyProxy", S.option(S.string)),
    urlPreviewEnabled: s.field("urlPreviewEnabled", S.option(S.bool)),
    urlPreviewTimeout: s.field("urlPreviewTimeout", S.option(S.int)),
    urlPreviewMaximumContentLength: s.field("urlPreviewMaximumContentLength", S.option(S.int)),
    urlPreviewRequireContentLength: s.field("urlPreviewRequireContentLength", S.option(S.bool)),
    urlPreviewUserAgent: s.field("urlPreviewUserAgent", S.option(S.string)),
    urlPreviewSummaryProxyUrl: s.field("urlPreviewSummaryProxyUrl", S.option(S.string)),
    prohibitedWordsForNameOfUser: s.field("prohibitedWordsForNameOfUser", S.option(S.json)),
    federation: s.field("federation", S.option(S.string)),
    federationHosts: s.field("federationHosts", S.option(S.array(S.string))),
  })

type postAdminUpdateMetaResponse = unit

/**
admin/update-meta

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:meta*
*/
let postAdminUpdateMeta = async (~body: postAdminUpdateMetaRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminUpdateMetaResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateMetaRequestSchema)
  let response = await fetch(
    ~url="/admin/update-meta",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminUpdateProxyAccountRequest = {
  description: option<string>,
}

let postAdminUpdateProxyAccountRequestSchema = S.object(s => {
    description: s.field("description", S.option(S.string->S.min(1)->S.max(1500))),
  })

type postAdminUpdateProxyAccountResponse = MisskeyIoComponentSchemas.UserDetailed.t

let postAdminUpdateProxyAccountResponseSchema = MisskeyIoComponentSchemas.UserDetailed.schema

/**
admin/update-proxy-account

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:account*
*/
let postAdminUpdateProxyAccount = async (~body: postAdminUpdateProxyAccountRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminUpdateProxyAccountResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateProxyAccountRequestSchema)
  let response = await fetch(
    ~url="/admin/update-proxy-account",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postAdminUpdateProxyAccountResponseSchema)
}

type postAdminUpdateUserNameRequest = {
  userId: string,
  name: option<string>,
}

let postAdminUpdateUserNameRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    name: s.field("name", S.option(S.string)),
  })

type postAdminUpdateUserNameResponse = unit

/**
admin/update-user-name

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:user-name*
*/
let postAdminUpdateUserName = async (~body: postAdminUpdateUserNameRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminUpdateUserNameResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateUserNameRequestSchema)
  let response = await fetch(
    ~url="/admin/update-user-name",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postAdminUpdateUserNoteRequest = {
  userId: string,
  text: string,
}

let postAdminUpdateUserNoteRequestSchema = S.object(s => {
    userId: s.field("userId", S.string),
    text: s.field("text", S.string),
  })

type postAdminUpdateUserNoteResponse = unit

/**
admin/update-user-note

No description provided.

**Credential required**: *Yes* / **Permission**: *write:admin:user-note*
*/
let postAdminUpdateUserNote = async (~body: postAdminUpdateUserNoteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postAdminUpdateUserNoteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postAdminUpdateUserNoteRequestSchema)
  let response = await fetch(
    ~url="/admin/update-user-note",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postV2AdminEmojiListRequest_1 = {
  updatedAtFrom: option<string>,
  updatedAtTo: option<string>,
  name: option<string>,
  host: option<string>,
  uri: option<string>,
  publicUrl: option<string>,
  originalUrl: option<string>,
  @as("type") type_: option<string>,
  aliases: option<string>,
  category: option<string>,
  license: option<string>,
  isSensitive: option<bool>,
  localOnly: option<bool>,
  hostType: option<string>,
  roleIds: option<array<string>>,
}

type postV2AdminEmojiListRequest = {
  query: option<postV2AdminEmojiListRequest_1>,
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
  page: option<int>,
  sortKeys: option<array<string>>,
}

let postV2AdminEmojiListRequest_1Schema = S.object(s => {
    updatedAtFrom: s.field("updatedAtFrom", S.option(S.string)),
    updatedAtTo: s.field("updatedAtTo", S.option(S.string)),
    name: s.field("name", S.option(S.string)),
    host: s.field("host", S.option(S.string)),
    uri: s.field("uri", S.option(S.string)),
    publicUrl: s.field("publicUrl", S.option(S.string)),
    originalUrl: s.field("originalUrl", S.option(S.string)),
    type_: s.field("type", S.option(S.string)),
    aliases: s.field("aliases", S.option(S.string)),
    category: s.field("category", S.option(S.string)),
    license: s.field("license", S.option(S.string)),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
    localOnly: s.field("localOnly", S.option(S.bool)),
    hostType: s.field("hostType", S.option(S.string)),
    roleIds: s.field("roleIds", S.option(S.array(S.string))),
  })

let postV2AdminEmojiListRequestSchema = S.object(s => {
    query: s.field("query", S.option(postV2AdminEmojiListRequest_1Schema)),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    page: s.field("page", S.option(S.int)),
    sortKeys: s.field("sortKeys", S.option(S.array(S.string))),
  })

type postV2AdminEmojiListResponse = {
  emojis: array<MisskeyIoComponentSchemas.EmojiDetailedAdmin.t>,
  count: int,
  allCount: int,
  allPages: int,
}

let postV2AdminEmojiListResponseSchema = S.object(s => {
    emojis: s.field("emojis", S.array(MisskeyIoComponentSchemas.EmojiDetailedAdmin.schema)),
    count: s.field("count", S.int),
    allCount: s.field("allCount", S.int),
    allPages: s.field("allPages", S.int),
  })

/**
v2/admin/emoji/list

No description provided.

**Credential required**: *Yes* / **Permission**: *read:admin:emoji*
*/
let postV2AdminEmojiList = async (~body: postV2AdminEmojiListRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postV2AdminEmojiListResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postV2AdminEmojiListRequestSchema)
  let response = await fetch(
    ~url="/v2/admin/emoji/list",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postV2AdminEmojiListResponseSchema)
}
