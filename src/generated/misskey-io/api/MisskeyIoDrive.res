// misskey-io API for drive
// Generated by @f3liz/rescript-autogen-openapi
// DO NOT EDIT - This file is auto-generated

S.enableJson()


type postDriveResponse = {
  capacity: float,
  usage: float,
}

let postDriveResponseSchema = S.object(s => {
    capacity: s.field("capacity", S.float),
    usage: s.field("usage", S.float),
  })

/**
drive

No description provided.

**Credential required**: *Yes* / **Permission**: *read:drive*
*/
let postDrive = async (~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveResponse => {

  let response = await fetch(
    ~url="/drive",
    ~method_="POST",
    ~body=None,
  )
  response->S.parseOrThrow(postDriveResponseSchema)
}

type postDriveFilesRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  folderId: option<string>,
  @as("type") type_: option<string>,
  sort: option<string>,
}

let postDriveFilesRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    folderId: s.field("folderId", S.option(S.string)),
    type_: s.field("type", S.option(S.string->S.pattern(/^[a-zA-Z\/\*-]+$/))),
    sort: s.field("sort", S.option(S.string)),
  })

type postDriveFilesResponse = array<MisskeyIoComponentSchemas.DriveFile.t>

let postDriveFilesResponseSchema = S.array(MisskeyIoComponentSchemas.DriveFile.schema)

/**
drive/files

No description provided.

**Credential required**: *Yes* / **Permission**: *read:drive*
*/
let postDriveFiles = async (~body: postDriveFilesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFilesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesRequestSchema)
  let response = await fetch(
    ~url="/drive/files",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFilesResponseSchema)
}

type postDriveFilesAttachedNotesRequest = {
  sinceId: option<string>,
  untilId: option<string>,
  limit: option<int>,
  fileId: string,
}

let postDriveFilesAttachedNotesRequestSchema = S.object(s => {
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    fileId: s.field("fileId", S.string),
  })

type postDriveFilesAttachedNotesResponse = array<MisskeyIoComponentSchemas.Note.t>

let postDriveFilesAttachedNotesResponseSchema = S.array(MisskeyIoComponentSchemas.Note.schema)

/**
drive/files/attached-notes

Find the notes to which the given file is attached.

**Credential required**: *Yes* / **Permission**: *read:drive*
*/
let postDriveFilesAttachedNotes = async (~body: postDriveFilesAttachedNotesRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFilesAttachedNotesResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesAttachedNotesRequestSchema)
  let response = await fetch(
    ~url="/drive/files/attached-notes",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFilesAttachedNotesResponseSchema)
}

type postDriveFilesCheckExistenceRequest = {
  md5: string,
}

let postDriveFilesCheckExistenceRequestSchema = S.object(s => {
    md5: s.field("md5", S.string),
  })

type postDriveFilesCheckExistenceResponse = bool

let postDriveFilesCheckExistenceResponseSchema = S.bool

/**
drive/files/check-existence

Check if a given file exists.

**Credential required**: *Yes* / **Permission**: *read:drive*
*/
let postDriveFilesCheckExistence = async (~body: postDriveFilesCheckExistenceRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFilesCheckExistenceResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesCheckExistenceRequestSchema)
  let response = await fetch(
    ~url="/drive/files/check-existence",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFilesCheckExistenceResponseSchema)
}

type postDriveFilesCreateRequest = {
  folderId: option<string>,
  name: option<string>,
  comment: option<string>,
  isSensitive: option<bool>,
  force: option<bool>,
  file: string,
}

let postDriveFilesCreateRequestSchema = S.object(s => {
    folderId: s.field("folderId", S.option(S.string)),
    name: s.field("name", S.option(S.string)),
    comment: s.field("comment", S.option(S.string->S.max(512))),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
    force: s.field("force", S.option(S.bool)),
    file: s.field("file", S.string),
  })

type postDriveFilesCreateResponse = MisskeyIoComponentSchemas.DriveFile.t

let postDriveFilesCreateResponseSchema = MisskeyIoComponentSchemas.DriveFile.schema

/**
drive/files/create

Upload a new drive file.

**Credential required**: *Yes* / **Permission**: *write:drive*
*/
let postDriveFilesCreate = async (~body: postDriveFilesCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFilesCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesCreateRequestSchema)
  let response = await fetch(
    ~url="/drive/files/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFilesCreateResponseSchema)
}

type postDriveFilesDeleteRequest = {
  fileId: string,
}

let postDriveFilesDeleteRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
  })

type postDriveFilesDeleteResponse = unit

/**
drive/files/delete

Delete an existing drive file.

**Credential required**: *Yes* / **Permission**: *write:drive*
*/
let postDriveFilesDelete = async (~body: postDriveFilesDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFilesDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesDeleteRequestSchema)
  let response = await fetch(
    ~url="/drive/files/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postDriveFilesFindRequest = {
  name: string,
  folderId: option<string>,
}

let postDriveFilesFindRequestSchema = S.object(s => {
    name: s.field("name", S.string),
    folderId: s.field("folderId", S.option(S.string)),
  })

type postDriveFilesFindResponse = array<MisskeyIoComponentSchemas.DriveFile.t>

let postDriveFilesFindResponseSchema = S.array(MisskeyIoComponentSchemas.DriveFile.schema)

/**
drive/files/find

Search for a drive file by the given parameters.

**Credential required**: *Yes* / **Permission**: *read:drive*
*/
let postDriveFilesFind = async (~body: postDriveFilesFindRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFilesFindResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesFindRequestSchema)
  let response = await fetch(
    ~url="/drive/files/find",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFilesFindResponseSchema)
}

type postDriveFilesFindByHashRequest = {
  md5: string,
}

let postDriveFilesFindByHashRequestSchema = S.object(s => {
    md5: s.field("md5", S.string),
  })

type postDriveFilesFindByHashResponse = array<MisskeyIoComponentSchemas.DriveFile.t>

let postDriveFilesFindByHashResponseSchema = S.array(MisskeyIoComponentSchemas.DriveFile.schema)

/**
drive/files/find-by-hash

Search for a drive file by a hash of the contents.

**Credential required**: *Yes* / **Permission**: *read:drive*
*/
let postDriveFilesFindByHash = async (~body: postDriveFilesFindByHashRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFilesFindByHashResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesFindByHashRequestSchema)
  let response = await fetch(
    ~url="/drive/files/find-by-hash",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFilesFindByHashResponseSchema)
}

type postDriveFilesShowRequest = {
  fileId: option<string>,
  url: option<string>,
}

let postDriveFilesShowRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.option(S.string)),
    url: s.field("url", S.option(S.string)),
  })

type postDriveFilesShowResponse = MisskeyIoComponentSchemas.DriveFile.t

let postDriveFilesShowResponseSchema = MisskeyIoComponentSchemas.DriveFile.schema

/**
drive/files/show

Show the properties of a drive file.

**Credential required**: *Yes* / **Permission**: *read:drive*
*/
let postDriveFilesShow = async (~body: postDriveFilesShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFilesShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesShowRequestSchema)
  let response = await fetch(
    ~url="/drive/files/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFilesShowResponseSchema)
}

type postDriveFilesUpdateRequest = {
  fileId: string,
  folderId: option<string>,
  name: option<string>,
  isSensitive: option<bool>,
  comment: option<string>,
}

let postDriveFilesUpdateRequestSchema = S.object(s => {
    fileId: s.field("fileId", S.string),
    folderId: s.field("folderId", S.option(S.string)),
    name: s.field("name", S.option(S.string)),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
    comment: s.field("comment", S.option(S.string->S.max(512))),
  })

type postDriveFilesUpdateResponse = MisskeyIoComponentSchemas.DriveFile.t

let postDriveFilesUpdateResponseSchema = MisskeyIoComponentSchemas.DriveFile.schema

/**
drive/files/update

Update the properties of a drive file.

**Credential required**: *Yes* / **Permission**: *write:drive*
*/
let postDriveFilesUpdate = async (~body: postDriveFilesUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFilesUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesUpdateRequestSchema)
  let response = await fetch(
    ~url="/drive/files/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFilesUpdateResponseSchema)
}

type postDriveFilesUploadFromUrlRequest = {
  url: string,
  folderId: option<string>,
  isSensitive: option<bool>,
  comment: option<string>,
  marker: option<string>,
  force: option<bool>,
}

let postDriveFilesUploadFromUrlRequestSchema = S.object(s => {
    url: s.field("url", S.string),
    folderId: s.field("folderId", S.option(S.string)),
    isSensitive: s.field("isSensitive", S.option(S.bool)),
    comment: s.field("comment", S.option(S.string->S.max(512))),
    marker: s.field("marker", S.option(S.string)),
    force: s.field("force", S.option(S.bool)),
  })

type postDriveFilesUploadFromUrlResponse = unit

/**
drive/files/upload-from-url

Request the server to download a new drive file from the specified URL.

**Credential required**: *Yes* / **Permission**: *write:drive*
*/
let postDriveFilesUploadFromUrl = async (~body: postDriveFilesUploadFromUrlRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFilesUploadFromUrlResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFilesUploadFromUrlRequestSchema)
  let response = await fetch(
    ~url="/drive/files/upload-from-url",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postDriveFoldersRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  folderId: option<string>,
}

let postDriveFoldersRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    folderId: s.field("folderId", S.option(S.string)),
  })

type postDriveFoldersResponse = array<MisskeyIoComponentSchemas.DriveFolder.t>

let postDriveFoldersResponseSchema = S.array(MisskeyIoComponentSchemas.DriveFolder.schema)

/**
drive/folders

No description provided.

**Credential required**: *Yes* / **Permission**: *read:drive*
*/
let postDriveFolders = async (~body: postDriveFoldersRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFoldersResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersRequestSchema)
  let response = await fetch(
    ~url="/drive/folders",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFoldersResponseSchema)
}

type postDriveFoldersCreateRequest = {
  name: option<string>,
  parentId: option<string>,
}

let postDriveFoldersCreateRequestSchema = S.object(s => {
    name: s.field("name", S.option(S.string->S.max(200))),
    parentId: s.field("parentId", S.option(S.string)),
  })

type postDriveFoldersCreateResponse = MisskeyIoComponentSchemas.DriveFolder.t

let postDriveFoldersCreateResponseSchema = MisskeyIoComponentSchemas.DriveFolder.schema

/**
drive/folders/create

No description provided.

**Credential required**: *Yes* / **Permission**: *write:drive*
*/
let postDriveFoldersCreate = async (~body: postDriveFoldersCreateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFoldersCreateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersCreateRequestSchema)
  let response = await fetch(
    ~url="/drive/folders/create",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFoldersCreateResponseSchema)
}

type postDriveFoldersDeleteRequest = {
  folderId: string,
}

let postDriveFoldersDeleteRequestSchema = S.object(s => {
    folderId: s.field("folderId", S.string),
  })

type postDriveFoldersDeleteResponse = unit

/**
drive/folders/delete

No description provided.

**Credential required**: *Yes* / **Permission**: *write:drive*
*/
let postDriveFoldersDelete = async (~body: postDriveFoldersDeleteRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFoldersDeleteResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersDeleteRequestSchema)
  let response = await fetch(
    ~url="/drive/folders/delete",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  let _ = response
}

type postDriveFoldersFindRequest = {
  name: string,
  parentId: option<string>,
}

let postDriveFoldersFindRequestSchema = S.object(s => {
    name: s.field("name", S.string),
    parentId: s.field("parentId", S.option(S.string)),
  })

type postDriveFoldersFindResponse = array<MisskeyIoComponentSchemas.DriveFolder.t>

let postDriveFoldersFindResponseSchema = S.array(MisskeyIoComponentSchemas.DriveFolder.schema)

/**
drive/folders/find

No description provided.

**Credential required**: *Yes* / **Permission**: *read:drive*
*/
let postDriveFoldersFind = async (~body: postDriveFoldersFindRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFoldersFindResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersFindRequestSchema)
  let response = await fetch(
    ~url="/drive/folders/find",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFoldersFindResponseSchema)
}

type postDriveFoldersShowRequest = {
  folderId: string,
}

let postDriveFoldersShowRequestSchema = S.object(s => {
    folderId: s.field("folderId", S.string),
  })

type postDriveFoldersShowResponse = MisskeyIoComponentSchemas.DriveFolder.t

let postDriveFoldersShowResponseSchema = MisskeyIoComponentSchemas.DriveFolder.schema

/**
drive/folders/show

No description provided.

**Credential required**: *Yes* / **Permission**: *read:drive*
*/
let postDriveFoldersShow = async (~body: postDriveFoldersShowRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFoldersShowResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersShowRequestSchema)
  let response = await fetch(
    ~url="/drive/folders/show",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFoldersShowResponseSchema)
}

type postDriveFoldersUpdateRequest = {
  folderId: string,
  name: option<string>,
  parentId: option<string>,
}

let postDriveFoldersUpdateRequestSchema = S.object(s => {
    folderId: s.field("folderId", S.string),
    name: s.field("name", S.option(S.string->S.max(200))),
    parentId: s.field("parentId", S.option(S.string)),
  })

type postDriveFoldersUpdateResponse = MisskeyIoComponentSchemas.DriveFolder.t

let postDriveFoldersUpdateResponseSchema = MisskeyIoComponentSchemas.DriveFolder.schema

/**
drive/folders/update

No description provided.

**Credential required**: *Yes* / **Permission**: *write:drive*
*/
let postDriveFoldersUpdate = async (~body: postDriveFoldersUpdateRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveFoldersUpdateResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveFoldersUpdateRequestSchema)
  let response = await fetch(
    ~url="/drive/folders/update",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveFoldersUpdateResponseSchema)
}

type postDriveStreamRequest = {
  limit: option<int>,
  sinceId: option<string>,
  untilId: option<string>,
  @as("type") type_: option<string>,
}

let postDriveStreamRequestSchema = S.object(s => {
    limit: s.field("limit", S.option(S.int->S.min(1)->S.max(100))),
    sinceId: s.field("sinceId", S.option(S.string)),
    untilId: s.field("untilId", S.option(S.string)),
    type_: s.field("type", S.option(S.string->S.pattern(/^[a-zA-Z\/\*-]+$/))),
  })

type postDriveStreamResponse = array<MisskeyIoComponentSchemas.DriveFile.t>

let postDriveStreamResponseSchema = S.array(MisskeyIoComponentSchemas.DriveFile.schema)

/**
drive/stream

No description provided.

**Credential required**: *Yes* / **Permission**: *read:drive*
*/
let postDriveStream = async (~body: postDriveStreamRequest, ~fetch: (~url: string, ~method_: string, ~body: option<JSON.t>) => Promise.t<JSON.t>): postDriveStreamResponse => {
  let jsonBody = body->S.reverseConvertToJsonOrThrow(postDriveStreamRequestSchema)
  let response = await fetch(
    ~url="/drive/stream",
    ~method_="POST",
    ~body=Some(jsonBody),
  )
  response->S.parseOrThrow(postDriveStreamResponseSchema)
}
